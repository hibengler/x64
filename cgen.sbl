-title mincod                                           : phase 2 translation from minimal tokens to 64 bit C code
-stitl description

*   Copyright 1987-2012 robert b. k. dewar and mark emmer.
*   Copyright 2012-2017 david shields
*   Copyright 2018 - Hib Engler

*   this file is part of macro spitbol -> lex into C code

*   macro spitbol is free software: you can redistribute it and/or modify
*   it under the terms of the gnu general public license as published by
*   the free software foundation, either version 2 of the license, or
*   (at your option) any later version.

*   macro spitbol is distributed in the hope that it will be useful,
*   but without any warranty; without even the implied warranty of
*   merchantability or fitness for a particular purpose.  see the
*   gnu general public license for more details.

*   you should have received a copy of the gnu general public license
*   along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.


*   this program takes input file in minimal token form and
*   produces C code.
*   So there will probably be two types of c code.  One type will have 
*   the dreaded "if" statement, and gotos all over the place.  The stack will
*   be mitigated and minimized, unless calling an osint function.
*
*   The other method will Queue the function labels that will be void pointers.
*   After a reurn is done, a SUCCESS/FAILURE/OTHER queue will be evaluated and called - gone to for the rest of the work.
*   this means that every label will be it's own function.
*   or a mini "kernel" if you will.
*
*   And heres the idea.
*   alot of kernels will basically be doing the same thing, except going to different labels.
*   that means that they could be consolidated through different parts, and simpleified,
*   so that each queue effectively can be a separate thread, or virtual thread,   where the threads on the computer
*   will swith the context and do the work.
*   That would mean the registers will be contexed per-queue.  Analysis of a block can determine what is going through, to limit the regs, but for the beginning
*   all regs would be through the stack.
*   This then means that things can happen at the same time.
*   Possibly a program can be compiled 100 lines at a time, but will it be fast?
*   on the CPU, yes,  but then for kernels.
*   All the variables can become streams, or something like it, now it could be possible to to thousands of pattern matches at once.
*   Well, thats the idea behind converting the code to C.
*   I want to use the brook idea of multidimensional streams, where the dimensions are determined at run time.
*   It might go that a CPU will reduce the streams,  although brook could do it with a sort, and then test for zero.
*   brook - brook gpu - and probably opencl and other stuff. to be figured out.
*   imagine all commands becoming something like spitbol:
*   [<label>] [[<expression> [?] [pattern] [= expression]] [goto]
*
*   variable assignments could be done multiple ways.  One way is to have a user file system map the elf file dynamically and provide memory maps to the parent data,
*   and have writes to that be locally administered.   There is code for this,  and if it is done right, the virtual memory system can contain the changes to global variables that 
*   are and are not important
*   would need something to contol input/output so that they can be streams instead of a single character stream.  
*   the parent data could be consolidated, with any clas resolved by the line number (thread number) of the input file.
*   there can also be sibling shares, or perhaps storing value, then array of tables (value, thread id in x,y,z) to capture this if it needs to fo to the parent.
*   it could go to parent, or siblings, and siblings should be able to peek and set their own values. the hooks used to turn input and output to external strams could work there
*   Well, you see, it brings snobol4 into a new realm. A realm where the while statement is possibly mapped, the if statement is taboo.
*   in other words, the assembly language goto solves what openCL, and SYCL (and I think Cuda - but got to learn more) do by having a compiler check everything and build everything during runtime.
*   yeah, spitbol can still do that. 
*   cuda can do it. the parent would make a block, with the threads picking what to do. then an array of gotos would be queued for processing - maybe compressed here
*   with a sort.  Cuda would need blocks and threads to be predefined amounts, probably ^2 ish
*   anyways.
*
*   the program obtains the name of the file to be translated from the
*   command line string in host(0).

*   options relating to the processing of comments can be
*   changed by modifying the source.

*   in addition to the minimal token file, the program requires the
*   name of a "machine definition file" that contains code specific
*   to a particular C variant.  note - for now, the assembly language will be printed first as a comment.
*   the C variant will need two passes. Lets see if the original asm does this

*   you may also specify option flags on the command line to control the
*   code generation.  the following flags are processed:
*       compress        generate tabs rather than spaces in output file
*       comments        retain full-line and end-of-line comments

*   the variable arch is set equal to the uppercase name of the machine
*   being processed.  specific tests upon this variable are discouraged, as
*   all machine-dependent code should be placed in the machine-definition
*   file if possible.

*   in addition to the normal minimal register complement, one scratch
*   work register, w0 is defined.
*   see the register map below for specific allocations.

*   this program is based in part on earlier translators for the
*   it is based in part on earlier translators for the dec vax
*   (vms and un*x) written by steve duff and robert goldberg, and the
*   pc-spitbol translator by david shields.

*  to run under spitbol:
*       spitbol -u "<file>:<machine>[:flag:...:flag]" codlinux.spt

*       reads <file>.lex        containing tokenized source code
*       writes <file>.c         with a c goto script
*       also writes <file>.err  with err and erb error messages
*       parts of m.hdr  are prepended and appended to <file>.s
*       also sets flags         to 1 after converting names to upper case
*       also reads <file>.pub   for debug symbols to be declared public

*   example:

*       spitbol -u min:x86_64:compress cgen.spt


*   revision history:

    version = 'v1.00'
* from 1.12 of asm.sno
    rcode = '_rc_'


-eject

*   keyword initialization

    &anchor = 1;    &stlimit = -1;    &trim   = 1;  &dump = 1

*   useful constants

    letters = 'abcdefghijklmnopqrstuvwxyz'
    ucase   = letters
    lcase   = 'abcdefghijklmnopqrstuvwxyz'
    nos     = '0123456789'
    tab     = char(9)

*       sepchar separates fields in input file
        
    sepchar = '|'
		

*   default the parameter string if none present

    fileprefix = "sbl"

*        cfp_b is bytes per word, cfp_c is characters per word
*        these should agree with values used in translator
*  set target-dependent configuration parameters

*        cfp_b is bytes per word, cfp_c is characters per word
*        these should agree with values used in translator
    cfp_b = 8
    cfp_c = 8
    log_cfp_b = '3'
    log_cfp_c = '3'
    op_w = 'q'
    op_c = 'b'

config.done


*   set z_trace to enable instruction by instruction trace
    z_trace = 1
*    z_trace = 0
*   z_limit is maximum number of calls to be generated if non-zero
    z_limit = 000
*   set z_first non-zero to skip first number of instructions that would generate trace
    z_first = 0
*   will set in_executable when in part of program where executable
*   instructions may occur
    z_exec = 0

*   z_suspend is set to temporarily disable the trace.
    z_suspend = 0
*   set in_skip when should not insert trace code, else assembly errors result.
*   start with skip on, turn off when see first start of code.
    z_skip = 1
*   skip_on and skip_off are labels indicating the start and end,
*   respectively, of sections of the code that should not be traced,
*   usually because they contain a loop instruction that won't
*   compile if too much trace code is inserted.
    skip_on = table(50)
    skip_off = table(50)

        define('skip_init(s)on,off')                    :(skip_init.end)

skip_init       s break(':') . on ':' rem . off         :f(return)

    skip_on[on] = 1
    skip_off[off] = 1                                   :(return)

skip_init.end

*   skip_init('start:ini03')
    skip_init('gbcol                                    :gtarr')
*   skip_init('gtn01:gtnvr')
*   skip_init('bpf05:bpf07')
*   skip_init('scv12:scv19')
*   skip_init('exbl1:exbl2')
*   skip_init('exbl5:expan')
*   skip_init('prn17:prn18')
*   skip_init('ini11:ini13')
*   skip_init('oex13:oexp2')
*   skip_init('oex14:oexp6')
*   skip_init('bdfc1:b_efc')
*   skip_init('sar01:sar10')
*   skip_init('srpl5:srpl8')
*   skip_init('pflu1:pflu2')
*   skip_init('prpa4:prpa5')
*   skip_init('prn17:prn18')
*   skip_init('prtvl:prtt1')
*   skip_init('trim4:trim5')
*   skip_init('prnl1:prnl2')
*   skip_init('prti1:prtmi')
*   skip_init('srpl5:srpl8')


	


*   data structures

    data('minarg(i.type,i.text)')
    data('tstmt(t.label,t.opc,t.op1,t.op2,t.op3,t.comment)')

    sectnow = 0

*   ppm_cases gives count of ppm/err statments that must follow call to
*   a procedure

    ppm_cases = table(50)
    
    
* prc_types gives the type of the procedure.  If the type is N we need to do 
* a JMS call instead of JSR call.
* JMS is from the dec Pdp/8 assembly - it stores the return pointer at the routine and
* returning is a jmp i routine. Well, we will store the return pointer in a variable, and then call
* In our case, prc_type - actually will have ppm_cases of return values;

    prc_types = table(50)

*   function definitions

   define('upper(s)') 
	        xUP_LO  =  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
		xLO_UP  =  'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ'

*   crack parses stmt into a stmt data plex and returns it.
*   it fails if there is a syntax error.

    define('crack(line)operands,operand,char')

    define('chktrace()')
*        comregs - map minimal register names to target register names
    define('comregs(line)t,pre,word')

*   error is used to report an error for current statement

    define('error(text)')
    define('fix_current_function(golabel)')
    define('flush()')
    define('genz()')
    define('genaop(stmt)')
    define('genbop(stmt)')
    define('genlab()')
    define('genop(gopc,gop1,gop2,gop3)')
    define('genopl(gopl,gopc,gop1,gop2,gop3)')
    define('genrep(op)l1,l2)')
    define('getarg(iarg,imem)l1,l2,t1,t2,tmem')
    define('ifreg(iarg)')
    define('memmem()t')
    define('c_umemmem()t')
    define('prcent(n)')
    define('prsarg(iarg)l1,l2')
    define('report(num,text)')
    define('tblini(str)pos,cnt,index,val,lastval')
    define('gencode_c(pass,x)a,b,c')
    define('get_c_argument(iarg,imem)a,b,c,l0,l1,l2,t1,t2,tmem')
    define('get_c_character_argument(iarg,imem)a,b,c,l1,l2,t1,t2,tmem')
    define('get_c_assignment(iarg,imem)a,b,c,l1,l2,t1,t2,tmem')
* get_c_assignment handles assigning to constants and variables
    define('get_c_label(iarg,imem)a,b,c,l1,l2,t1,t2,tmem')
    define('ll_filter(x)')
* low level goto fix for calling the error function, since error is a clib standard
* we change the code to ezzor
    define('convert_value_c(x)a,b,c,d)')
    define('convert_value_assignment(x)a,b,c,d)')
* convert_value_assignment also is used for constants and variables
    define('do_current_label()')
    

	p.c_symbol = '&&' | '||' | '>=' | '<=' | '->' | '*=' | any('^|!=+-*/%[]{}().&')
	p.c_sbrk = '\\' | '\"' | "\'"
	&anchor = 0
	p.c_stringchar1 = &alphabet
	p.c_stringchar1 '"' = ''
	p.c_stringchar2 = p.c_sbrk | any(p.c_stringchar1)
	p.c_string = '"' arbno(p.c_stringchar2) '"'
	p.c_comment = '/*' arbno(any(&alphabet)) '*/'
	p.c_charchar1 = &alphabet
	p.c_charchar1 "'" = ""
	p.c_charchar2 =  p.c_sbrk | any(p.c_charchar1)
	p.c_char = "'" p.c_charchar2 "'"
	p.c_label = any('abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ') ( span('abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') | '' )
	p.c_label_with_dot = any('abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ') ( span('.abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') | '' )	
	p.c_s = span(' 	') 
	p.c_n1 = span('0123456789')
	p.c_n2 = span('0123456789') '.' ( span('0123456789') | '' ) ( 'f' | 'l' | 'ul' | 'd' | '' )
	p.c_token = p.c_n2 | p.c_n1 | p.c_string | p.c_comment | p.c_char | p.c_label | p.c_symbol | p.c_s
	p.c_token_with_dot = p.c_n2 | p.c_n1 | p.c_string | p.c_comment | p.c_char | p.c_label_with_dot | p.c_symbol | p.c_s
	&anchor = 1
    

*   outstmt is used to send a target statement to the target code
*   output file outfile

    
    define('outstmt(ostmt)label,opcode,op1,op2,op3,comment,t,stmtout')

    
*   readline is called to return the next non-comment line from
*   the minimal input file (infile <=> lu1).   note that it will
*   not fail on eof, but it will return a minimal end statement

    define('readline()')

     p.comregs = break(letters) . pre span(letters) . word

*   exttab has entry for external procedures

    exttab = table(50)
    external_procedures = exttab

*   labtab records labels in the code section, and their line numbers

    labtab = table(500)
    labels_in_the_code_section = labtab

*   for each statement, code in generated into three
*   arrays of statements:

*   astmts: statements after opcode (()+, etc.)
*   after_opcode_statements
*   bstmts: statements before code (-(), etc)
*   before_code_statements
*   cstmts: generated code proper
*   code_statements

*    astmts = array(20,'')
    after_opcode_statements = array(4000,'')
    astmts = after_opcode_statements
    before_code_statements = array(4000,'')
    bstmts = before_code_stmts
    code_statements = array(4000,'')
    cstmts = code_statements

*   genlabels is count of generated labels (cf. genlab)

    genlabels = 0



*   initialize variables

    labcnt = noutlines = nlines = nstmts = ntarget = nerrors = 0
    lastopc = lastop1 = lastop2 =
    data_lc = 0
    max_exi = 0
    gone_baby_gone = 0
    
    c_definitions = table(1000)
    entry_labels = table(1000)
    

*   initial patterns

*   p.csparse parses tokenized line
    p.csparse = sepchar break(sepchar) . inlabel
.       sepchar break(sepchar) . incode
.       sepchar break(sepchar) . iarg1
.       sepchar break(sepchar) . iarg2
.       sepchar break(sepchar) . iarg3
.       sepchar break(sepchar) . incomment
    sepchar rem . slineno

*   dispatch table
* these are name addresses of labels in getarg.  I bet this does something like :($label) but faster
*

    getargcase = table(27)
    getargcase[1] = .getarg.c.1;   getargcase[2] = .getarg.c.2
    getargcase[3] = .getarg.c.3;   getargcase[4] = .getarg.c.4
    getargcase[5] = .getarg.c.5;   getargcase[6] = .getarg.c.6
    getargcase[7] = .getarg.c.7;   getargcase[8] = .getarg.c.8
    getargcase[9] = .getarg.c.9;   getargcase[10] = .getarg.c.10
    getargcase[11] = .getarg.c.11; getargcase[12] = .getarg.c.12
    getargcase[13] = .getarg.c.13; getargcase[14] = .getarg.c.14
    getargcase[15] = .getarg.c.15; getargcase[16] = .getarg.c.16
    getargcase[17] = .getarg.c.17; getargcase[18] = .getarg.c.18
    getargcase[19] = .getarg.c.19; getargcase[20] = .getarg.c.20
    getargcase[21] = .getarg.c.21; getargcase[22] = .getarg.c.22
    getargcase[23] = .getarg.c.23; getargcase[24] = .getarg.c.24
    getargcase[25] = .getarg.c.25; getargcase[26] = .getarg.c.26
    getargcase[27] = .getarg.c.27

    get_c_argumentcase = table(27)
    get_c_argumentcase[1] = .get_c_argument.c.1;   get_c_argumentcase[2] = .get_c_argument.c.2
    get_c_argumentcase[3] = .get_c_argument.c.3;   get_c_argumentcase[4] = .get_c_argument.c.4
    get_c_argumentcase[5] = .get_c_argument.c.5;   get_c_argumentcase[6] = .get_c_argument.c.6
    get_c_argumentcase[7] = .get_c_argument.c.7;   get_c_argumentcase[8] = .get_c_argument.c.8
    get_c_argumentcase[9] = .get_c_argument.c.9;   get_c_argumentcase[10] = .get_c_argument.c.10
    get_c_argumentcase[11] = .get_c_argument.c.11; get_c_argumentcase[12] = .get_c_argument.c.12
    get_c_argumentcase[13] = .get_c_argument.c.13; get_c_argumentcase[14] = .get_c_argument.c.14
    get_c_argumentcase[15] = .get_c_argument.c.15; get_c_argumentcase[16] = .get_c_argument.c.16
    get_c_argumentcase[17] = .get_c_argument.c.17; get_c_argumentcase[18] = .get_c_argument.c.18
    get_c_argumentcase[19] = .get_c_argument.c.19; get_c_argumentcase[20] = .get_c_argument.c.20
    get_c_argumentcase[21] = .get_c_argument.c.21; get_c_argumentcase[22] = .get_c_argument.c.22
    get_c_argumentcase[23] = .get_c_argument.c.23; get_c_argumentcase[24] = .get_c_argument.c.24
    get_c_argumentcase[25] = .get_c_argument.c.25; get_c_argumentcase[26] = .get_c_argument.c.26
    get_c_argumentcase[27] = .get_c_argument.c.27


    get_c_character_argumentcase = table(27)
    get_c_character_argumentcase[1] = .get_c_character_argument.c.1;   get_c_character_argumentcase[2] = .get_c_character_argument.c.2
    get_c_character_argumentcase[3] = .get_c_character_argument.c.3;   get_c_character_argumentcase[4] = .get_c_character_argument.c.4
    get_c_character_argumentcase[5] = .get_c_character_argument.c.5;   get_c_character_argumentcase[6] = .get_c_character_argument.c.6
    get_c_character_argumentcase[7] = .get_c_character_argument.c.7;   get_c_character_argumentcase[8] = .get_c_character_argument.c.8
    get_c_character_argumentcase[9] = .get_c_character_argument.c.9;   get_c_character_argumentcase[10] = .get_c_character_argument.c.10
    get_c_character_argumentcase[11] = .get_c_character_argument.c.11; get_c_character_argumentcase[12] = .get_c_character_argument.c.12
    get_c_character_argumentcase[13] = .get_c_character_argument.c.13; get_c_character_argumentcase[14] = .get_c_character_argument.c.14
    get_c_character_argumentcase[15] = .get_c_character_argument.c.15; get_c_character_argumentcase[16] = .get_c_character_argument.c.16
    get_c_character_argumentcase[17] = .get_c_character_argument.c.17; get_c_character_argumentcase[18] = .get_c_character_argument.c.18
    get_c_character_argumentcase[19] = .get_c_character_argument.c.19; get_c_character_argumentcase[20] = .get_c_character_argument.c.20
    get_c_character_argumentcase[21] = .get_c_character_argument.c.21; get_c_character_argumentcase[22] = .get_c_character_argument.c.22
    get_c_character_argumentcase[23] = .get_c_character_argument.c.23; get_c_character_argumentcase[24] = .get_c_character_argument.c.24
    get_c_character_argumentcase[25] = .get_c_character_argument.c.25; get_c_character_argumentcase[26] = .get_c_character_argument.c.26
    get_c_character_argumentcase[27] = .get_c_character_argument.c.27


*   pifatal maps minimal opcodes for which no a code allowed
*   to nonzero value. such operations include conditional
*   branches with operand of form (x)+

    pifatal = tblini(
.       'aov[1]beq[1]bne[1]bge[1]bgt[1]bhi[1]ble[1]blo[1]'
.       'blt[1]bne[1]bnz[1]ceq[1]cne[1]mfi[1]nzb[1]zrb[1]')

*        trace not working for mvc (x64)

    is_executable = table(100)
    s =
+       'add adi adr anb aov atn '
+       'bct beq bev bge bgt bhi ble blo blt bne bnz bod '
+       'brn bri bsw btw bze ceq chk chp cmb cmc cmp cne csc '
+       'cos ctb ctw cvd cvm dca dcv eti dvi dvr erb esw etx flc '
+       'ica icp icv ieq ige igt ile ilt ine ino iov itr jmp '
+       'jsr lch lct lcp lcw ldi ldr lei lnf lsh lsx mcb mfi mli mlr '
+       'mnz mov mti mvw mwb ngi eti ngr nzb orb plc prc psc '
+       'req rge rgt rle rlt rmi rne rno rov rsh rsx rti rtn sbi sbr '
+       'sch scp sin sqr ssl sss sti str sub tan trc wtb xob zer '
+       'zgb zrb'

*        don't trace mvc as doing so causes just 'end' to fail. sort out later. (ds 01/09/13)

is_exec.1

    s len(3) . opc ' ' =                                :f(is_exec.2)
    is_executable[opc] = 1                              :(is_exec.1)

is_exec.2

-stitl main program
*   here follows the driver code for the "main" program.

*   loop until program exits via g.end

*   opnext is invoked to initiate processing of the next line from
*   readline.
*   after doing this, opnext branches to the generator routine indicated
*   for this opcode if there is one.
*   the generators all have entry points beginning
*   with "g.", and can be considered a logical extension of the
*   opnext routine.  the generators have the choice of branching back
*   to dsgen to cause the thisstmt plex to be sent to outstmt, or
*   or branching to dsout, in which case the generator must output
*   all needed code itself.

*   the generators are listed in a separate section below.


*   get file name


*  get definition file name following token file name, and flags.

*        fileprefix ? break(';:') . fileprefix len(1) (break(';:') | rem) . target
*+              ((len(1) rem . flags) | '')
*        $replace(target,lcase,ucase) = 1

*  parse and display flags, setting each one's name to non-null value (1).

                                                        :(flgs.skip)
flgs

   flags ? ((len(1) break(';                            :')) . flag len(1)) |
+        ((len(1) rem) . flag) =                        :f(flgs2)
    flag = replace(flag,lcase,ucase)
    output = "  flag                                    : " flag
    $flag = 1                                           :(flgs)

flgs.skip

flgs2

*   various constants

    comment.delim = '//'

*   branchtab maps minimal opcodes 'beq', etc to desired
*   target instruction

    branchtab = table(10)
    branchtab['beq'] = 'be'
    branchtab['bne'] = 'jne'
    branchtab['bgt'] = 'ja'
    branchtab['bge'] = 'jae'
    branchtab['ble'] = 'jbe'
    branchtab['blt'] = 'jb'
    branchtab['blo'] = 'jb'
    branchtab['bhi'] = 'ja'

    branchtab_standard_c = table(10)
    branchtab_standard_c['beq'] = '=='
    branchtab_standard_c['bne'] = '!='
    branchtab_standard_c['bgt'] = '>'
    branchtab_standard_c['bge'] = '>='
    branchtab_standard_c['ble'] = '<='
    branchtab_standard_c['blt'] = '<'
    branchtab_standard_c['blo'] = '<'
    branchtab_standard_c['bhi'] = '>'
    branchtab_standard_c['jew'] = '=='
    
    
    
    
*   optim.tab flags opcodes capable of participating in or optimization
*                in outstmt routine

    optim.tab = table(10)
    optim.tab<"and"> = 1
    optim.tab<"add"> = 1
    optim.tab<"sub"> = 1
    optim.tab<"neg"> = 1
    optim.tab<"or"> = 1
    optim.tab<"xor"> = 1
    optim.tab<"shr"> = 1
    optim.tab<"shl"> = 1
    optim.tab<"inc"> = 1
    optim.tab<"dec"> = 1


*   ismem is table indexed by operand type which is nonzero if
*   operand type implies memory reference.

    ismem = array(30,0)
    ismem<3> = 1; ismem<4> = 1; ismem<5> = 1
    ismem<9> = 1; ismem<10> = 1; ismem<11> = 1
    ismem<12> = 1; ismem<13> = 1; ismem<14> = 1
    ismem<15> = 1

*   regmap maps minimal register name to target machine
*   register/memory-location name.

    regmap = table(30)
    regmap['xl'] = 'xl';  regmap['xt'] = 'xt'
    regmap['xr'] = 'xr';  regmap['xs'] = 'xs'
    regmap['wa'] = 'wa';  regmap['wb'] = 'wb'
    regmap['wc'] = 'wc';  regmap['ia'] = 'ia'
    regmap['cp'] = 'cp'
*        w0 is temp register
    regmap['w0'] = 'w0'
    w0 = regmap['w0']


* C uses better names
    better_register_name = table(30)
    better_register_name['xl'] = 'xl'
    better_register_name['xt'] = 'xt'
    better_register_name['xr'] = 'xr'  
    better_register_name['xs'] = 'xs'
    better_register_name['wa'] = 'wa'  
    better_register_name['wb'] = 'wb'
    better_register_name['wc'] = 'wc'  
    better_register_name['ia'] = 'ia'
    better_register_name['cp'] = 'cp'
*        w0 is temp register
    better_register_name['w0'] = 'w0'
    better_register_name['cp'] = 'cp'
    better_register_name['ra'] = 'ra'
    better_register_name['fl'] = 'fl'
    
    w0 = better_register_name['w0']

*   quick reference:
    reg.wa = regmap['wa']
    reg.cp = regmap['cp']

*   reglow maps register to identify target, so
*   can extract 'l' part.

    reglow = table(4)
    reglow['wa'] = 'wa_l'
    reglow['wb'] = 'wb_l'
    reglow['wc'] = 'wc_l'

*   real_op maps minimal real opcode to machine opcode

    real_op = table(10)
    real_op['adr'] = 'fadd'
    real_op['atn'] = 'fpatan'
    real_op['chp'] = 'frndint'
    real_op['cos'] = 'fcos'
    real_op['dvr'] = 'fdiv'
    real_op['ldr'] = 'fld'
    real_op['mlr'] = 'fmul'
    real_op['ngr'] = 'fchs'
    real_op['sbr'] = 'fsub'
    real_op['sin'] = 'fsin'
    real_op['sqr'] = 'fsqrt'
    real_op['str'] = 'fst'

*   other definitions that are dependent upon things defined in the
*   machine definition file, and cannot be built until after the definition
*   file has been read in.

*   p.outstmt examines output lines for certain types of comment contructions. works for comment only stuff too

    fillc     = (ident(compress) " ",tab)
    p.outstmt = (break(fillc) . label span(fillc)) . leader
+                       comment.delim rem . comment
    p.alltabs = span(tab) rpos(0)

*   strip end of comments if y
    comments = 'y'
    strip_comment = (differ(comments) 'n', 'y')

    filenami = fileprefix '.lex'
    input(.infile,1,filenami)                           :s(inputok)

inputok

    output = '  input lex file                          : ' filenami

*   associate output files.

    filenamo = 'osint/c' fileprefix '.c'
    output(.outfile,2,filenamo)                         :s(outputok)
    output = '  cannot open asm file: ' filenamo        :(end)

outputok

    output = '  output asm file                         : ' filenamo


*  open file for compilation of minimal err and erb messages

    output(.errfile,3, 'c' fileprefix ".err")               :s(err_ok)
    output = "  cannot open error message file: c" fileprefix ".err":(end)
err_ok


*   then copy contents of x64.hdr (if it exists) to outfile
*   stop at line with just 'end' or end of file

    noutlines = noutlines + 1

* we dont use a header for c
	:(nohdr)    
    input(.hdrfile,4,'x64.hdr')                         :f(nohdr)
    havehdr = 1

*         output = '  input header file:  ' hdr  '.hdr'

hdrcopy

    line = hdrfile                                      :f(hdrend)
    ident(line,'end')                                   :s(nohdr)
    outfile = line
    noutlines = noutlines + 1                           :(hdrcopy)

hdrend

     havehdr =

nohdr

*   will have havehdr non-null if more remains to copy out at end.

*   read in pub file if it exists.  this contains a list of symbols to
*   be declared public when encountered.

    pubtab = table(2)
    input(.pubfile,5, 'c' fileprefix ".pub")                :f(nopub)
    pubtab = table(101)

pubcopy

    line = pubfile                                      :f(pubend)
    pubtab[line] = 1                                    :(pubcopy)

pubend

     endfile(5)

nopub

                                                        :(initialize)
initialize							
*    &trace = 20000
*    &ftrace = 1000
*   &profile = 1
    parser_pass = 1
    
    last_labels = array(100,'')
    section_labels = table()
    section_labels[1] = table(1000)
    section_labels[2] = table(1000)
    section_labels[3] = table(1000)
    section_labels[4] = table(1000)
    section_labels[5] = table(1000)
    section_labels[6] = table(1000)
    section_labels[7] = table(1000)
    section_labels[8] = table(1000)
    
    gencode_c(1,'/* generated from ' infile ' into C code */')
    gencode_c(1,'#ifdef GEN_C_CODE')
    gencode_c(1,'#undef GEN_C_CODE')
    gencode_c(1,'// This is because GEN_C_CODE will  trigger code for standard c routines to shim around the v.variable and c.constant fields')
    gencode_c(1,'#endif')
    gencode_c(1,'#include "stdio.h"')
    gencode_c(1,'#include "math.h"')
    gencode_c(1,'#include "port.h"')
    gencode_c(1,'#include "c_64.h"')
    gencode_c(1,'')
    gencode_c(1,'')
    gencode_c(1,'')
    flush()
    

    last_labels.n = 0
    
dsout

opnext
     thisline = readline()

*     genbop(tstmt('//	' thisline,'','','',''))
     gencode_c(-2,'//b ' thisline)
     thisline '{{end'			:s(opnext.2)
opnext.0     

* did_c_code is a flag so we don't output things if it is not our pass to do so
     did_c_code = 0
* ^^^ for debugging, set to a 1     
* did_comment - is similar to get_c_code - it keeps track of when we placed a comment out there
     did_comment = 0
     
     crack(thisline)                                    :f(dsout)
     op_ = incode '_'
     
     
* handle_labels for c code

    

    ident(inlabel)                                      :s(opnext.asm)
    eq(parser_pass,1)						:f(opnext.pass2)
opnext.pass1
    ident(section_labels[sectnow][inlabel],'')	:f(opnext.p1.know_about_it)
    section_labels[sectnow][inlabel] = table()
opnext.p1.know_about_it
    ident(incode)					:s(opnext.p1.add_ext)
    ident(incode,'ent')						:s(opnext.p1.add_ext)
    ident(incode,'prc')						:s(opnext.p1.add_ext)
    :(opnext.p1.gotcode)
    
    
opnext.p1.add_ext
* here we have labels multiple to the same thing
    last_labels[last_labels.n = last_labels.n + 1] = inlabel    
    section_labels[sectnow][inlabel]['type'] = 'extra'

*opnext.p1.know_about_it
        
opnext.p1.gotcode

	eq(sectnow,1)					:s(opnext.asm)
	eq(sectnow,2)					:s(opnext.asm)
	eq(sectnow,3)					:s(opnext.p1_gotsec34567code)
	eq(sectnow,4)					:s(opnext.p1_gotsec34567code)
	eq(sectnow,5)					:s(opnext.p1_gotsec34567code)
	eq(sectnow,6)					:s(opnext.p1_gotsec34567code)
	eq(sectnow,7)					:s(opnext.p1_gotsec34567code)
	eq(sectnow,8)					:s(opnext.asm)
	eq(sectnow,9)					:s(opnext.asm)
	:(opnext.asm)
	
opnext.p1_gotsec34567code
	t0 = 1
opnext.p1_gotsec345loop	
	ge(t0,last_labels.n)		:s(opnext.p1.ready_for_def)
	genbop(tstmt('#define ' last_labels[t0] '	' inlabel,'','','',''))
	t0 = t0 + 1			:(opnext.p1_gotsec345loop)
	
opnext.p1.ready_for_def
	last_labels.n = 0
* ^^^ make the next label clean
	eq(sectnow,5)				:s(opnext.p1.567code)
	eq(sectnow,6)				:s(opnext.p1.567code)
	eq(sectnow,7)				:s(opnext.p1.567code)
	:(opnext.p1.endgotcode);
opnext.p1.567code	
	ident(incode,'ent')			:s(opnext.p1.entry_goofie);
	gencode_c(1,'extern void ' inlabel '();' )
* make_better_name
	:(opnext.p1.endgotcode)
opnext.p1.entry_goofie
	gencode_c(1,'extern void ' inlabel '();' )    	
	:(opnext.p1.endgotcode)
	

opnext.pass2
	ident(incode)					:s(opnext.p2.gotcode)
	ident(incode,'ent')				:s(opnext.p2.gotcode)
	ident(incode,'prc')				:s(opnext.p2.gotcode)
	eq(sectnow,1)					:s(opnext.asm)
	eq(sectnow,2)					:s(opnext.asm)
	eq(sectnow,3)					:s(opnext.asm)
	eq(sectnow,4)					:s(opnext.asm)
	eq(sectnow,5)					:s(opnext.p2_gotsec567code)
	eq(sectnow,6)					:s(opnext.p2_gotsec567code)
	eq(sectnow,7)					:s(opnext.p2_gotsec567code)
	eq(sectnow,8)					:s(opnext.asm)
	eq(sectnow,9)					:s(opnext.asm)
	:(opnext.asm)
	
	
opnext.p2.gotcode
	eq(sectnow,3)					:s(opnext.p2_gotsec3code)
	eq(sectnow,4)					:s(opnext.p2_gotsec3code)
	eq(sectnow,5)					:s(opnext.p2_gotsec567code)
	eq(sectnow,6)					:s(opnext.p2_gotsec567code)
	eq(sectnow,7)					:s(opnext.p2_gotsec567code)
	:(opnext_asm)
	
		
opnext.p2_gotsec3code			
	:(opnext.p2.endgotcode)

opnext.p2_gotsec567code
	fix_current_function(inlabel)			
opnext.p2_gotsec5code.nofinish		
	 ident(incode,'ent')				:s(opnext.p2_gotsec5code.nofinish.entry)	
	gencode_c(-2,'void ' ll_filter(inlabel) '() {' )
	current_function_name = inlabel
	
	genz()
		
	:(opnext.p2.endgotcode)
	
opnext.p2_gotsec5code.nofinish.entry	

	
	gencode_c(-2,'void ' ll_filter(inlabel) '() {' );
	gencode_c(-2,'/* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */');
	
	
	current_function_name = inlabel
		
	genz()
	:(opnext.p2.endgotcode)
		
	
	
opnext.p1.endgotcode
opnext.p2.endgotcode
	
	last_labels.n = 0		:(opnext.asm)
	
	
opnext.asm


*   append ':' after label if in code or data.

*   output label of executable instruction immediately if there is one,
*   as it simplifies later processing, especially for tracing.

    ident(inlabel)                                      :s(opnext.1)
    thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)

*   keep the label as is is not in executable code

    lt(sectnow,5)                                       :s(opnext.1)

*   here if in code, so output label now
*   defer label processing for ent to allow emission of alignment ops for x86.

    ident(incode,'ent')                                 :s(opnext.1)
    outfile = '// ' thislabel
    outlines = outlines + 1
    
*   set lastlabel so can check to avoid emitting duplicate label definitions

    lastlabel = thislabel

*   clear out label info once generated

    label = thislabel =

opnext.1

    thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)
    i1 = prsarg(iarg1)
    i2 = prsarg(iarg2)
    i3 = prsarg(iarg3)
    tcomment = comregs(incomment) '} ' incode ' ' i.text(i1) ' '
.               i.text(i2) ' ' i.text(i3)
    argerrs = 0
                                                        :($('g.' incode))
*   here if bad opcode


* the file is at eof. We can either do another pass, or complete the current one
opnext.2 
	terminal = 'done pass ' parser_pass
	
	eq(parser_pass,2)					:s(opnext.0)


* we have to close and reopen the file
	endfile(1)
	
        input(.infile,1,filenami)  
* reset some simple counters that work with the file
initialize2
	gone_baby_gone = 0
    labcnt = noutlines = nlines = nstmts = ntarget = nerrors = 0
    lastopc = lastop1 = lastop2 =
    data_lc = 0
    max_exi = 0
	prc.count = 0
	prc.finished_count1 = prc.count1
	
    entry_labels_array = convert(entry_labels,'array')  

    ii = 1
elab.loop0
    junk = entry_labels_array[ii,1]		:f(elab.done0)
    ii = ii + 1
    :(elab.loop0)
elab.done0

    entry_levels_array_len = ii - 1

*   This weird code between pass 1 and pass 2 is needed in header files
*   so we flag it for cs_c_to_gen_c_code.sbl
    gencode_c(1,'// BEGIN_ENTRY_DEFINITION ' )
    gencode_c(1,'// entry label c workaround' )        
    gencode_c(1,'// We make a list of the entries and their meaning' )        
    gencode_c(1,'// Then we convert the list into a hash table at runtime just for entries' )        
    gencode_c(1,'#define NUMBER_ELAB_ENTRIES ' entry_levels_array_len )
    gencode_c(1,'#define NUMBER_ELAB_HASH_ENTRIES 16381')
    gencode_c(1,'#define ELAB_HASH_MULTIPLY 92203')
    gencode_c(1,'typedef struct elab_meaning { void (*call_entry)(); char meaning;} elab_meaning;' )
    gencode_c(1,'extern struct elab_meaning elab_meanings[NUMBER_ELAB_ENTRIES];')
    gencode_c(1,'extern struct elab_meaning elab[NUMBER_ELAB_HASH_ENTRIES];' )
    gencode_c(1,'// END_ENTRY_DEFINITION ' )
    
    gencode_c(1,'struct elab_meaning elab_meanings[' entry_levels_array_len '] = {' )
    ii = 1
elab.loop    
    gt(ii,entry_levels_array_len)		:s(elab.done)
    value_a = entry_labels_array[ii,1]
    value_b = entry_labels_array[ii,2]
    gencode_c(1,'     {.call_entry=' value_a ',.meaning=' upper(value_b) '},' )
    ii = ii + 1
    :(elab.loop)
    	
elab.done
    gencode_c(1,' }; /* elab_meanings */' )
    gencode_c(1,'struct elab_meaning elab[NUMBER_ELAB_HASH_ENTRIES];')
      

    sectnow = 0
	parser_pass = parser_pass + 1
	current_routine = ''
	terminal = 'start pass ' parser_pass
	:(opnext)





ds01

    error('bad op-code')                                :(dsout)

*   generate tokens.

ds.typerr

    error('operand type zero')                          :(dsout)
    
    
	    
    
    

-stitl comregs(line)t,pre,word
comregs

    line p.comregs =                                    :f(comregs1)
    word = eq(size(word),2) differ(t = regmap[word]) t
    comregs = comregs pre word                          :(comregs)

comregs1 comregs = comregs line                         :(return)
-stitl crack(line)

*   crack is called to create a stmt plex containing the various parts  of
*  the minimal source statement in line.  for conditional assembly ops,
*  the opcode is the op, and op1 is the symbol.  note that dtc is handled
*   as a special case to assure that the decomposition is correct.

*   crack prints an error and fails if a syntax error occurs.

crack

    nstmts  = nstmts + 1
    op1 = op2 = op3 = typ1 = typ2 = typ3 =
    line    p.csparse                                   :s(return)
*   here on syntax error

    error('source line syntax error')                   :(freturn)
-stitl error(text)
*   this module handles reporting of errors with the offending
*   statement text in thisline.  comments explaining
*   the error are written to the listing (including error chain), and
*   the appropriate counts are updated.

error

    outfile = '* *???* ' thisline
    outfile = '*       ' text
.                 (ident(lasterror),'. last error was line ' lasterror)
    lasterror = noutlines
    noutlines = noutlines + 2
    le(nerrors = nerrors + 1, 10)                       :s(dsout)
    output = 'too many errors, quitting'                :(end)

-stitl genaop(stmt)
genaop

*    after_opcode_statements[after_opcode_statements.n = after_opcode_statements.n + 1] = stmt              :(return)

-stitl genbop(stmt)
genbop
*    before_code_statements[before_code_statements.n = before_code_statements.n + 1] = stmt              :(return)

-stitl genlab()
*   generate unique labels for use in generated code

genlab

    genlab = '_l' lpad(genlabels = genlabels + 1,4,'0') :(return)

-stitl gencode_c(pass,x)
*   generate code
gencode_c 	
	lt(pass,0)		:s(gencode_c_before)	
	
	eq(parser_pass,pass)		:f(return)
	did_c_code = 1
	eq(did_comment,1)		:s(gencode_c_not_firstline)
	did_comment = 1
	ident(incomment)		:s(gencode_c_not_firstline)
	code_statements[code_statements.n = code_statements.n + 1] = 
.               tstmt('',x '				// ' incomment,'','','')
	
	:(return)

gencode_c_not_firstline
	code_statements[code_statements.n = code_statements.n + 1] = 
.               tstmt('',x,'','','')
	:(return)
			
	
gencode_c_before		
	pass = -pass
	
	eq(parser_pass,pass)		:f(return)
	did_c_code = 1

	before_code_statements[before_code_statements.n = before_code_statements.n + 1] = 
.               tstmt('',x,'','','')
	:(return)
 
-stitl genopl(gopl,gopc,gop1,gop2,gop3)
*   generate operation with label

genopl
*    code_statements[code_statements.n = code_statements.n + 1] =
*.               tstmt('//A	' gopl,gopc,gop1,gop2,gop3)         :(return)
	:(return)

-stitl genop(gopc,gop1,gop2,gop3)
*   generate operation with no label

genop

    genopl(,gopc,gop1,gop2,gop3)                        :(return)


-stitl getarg(iarg,imem)

getarg

    tmem = (differ(imem) '', 'm_word ')
    l1 = i.text(iarg)
    l2 = i.type(iarg)
    eq(l2)                                              :f($(getargcase[l2]))
    getarg = l1                                         :(return)

*  int

getarg.c.1

   getarg = l1                                          :(return)

*  dlbl

getarg.c.2

   getarg = l1                                          :(return)

*  wlbl, clbl

getarg.c.3
getarg.c.4

   getarg = tmem '[' l1 ']'                             :(return)

*  elbl, plbl

getarg.c.5
getarg.c.6

   getarg = l1                                          :(return)

*  w,x, map register name

getarg.c.7
getarg.c.8

    getarg = regmap[l1]                                 :(return)


*  (x), register indirect
getarg.c.9

    l1 len(1) len(2) . l2
    l2 = regmap[l2]
    getarg = tmem '[' l2 ']'                            :(return)

*  (x)+, register indirect, post increment
*  use lea reg,[reg+cfp_b] unless reg is esp, since it takes an extra byte.
*  actually, lea reg,[reg+cfp_b] and add reg,cfp_b are both 2 cycles and 3 bytes
*  for all the other regs, and either could be used.

getarg.c.10

    l1 = substr(l1,2,2)
    t1 = regmap[l1]
    getarg = tmem '[' t1 ']'
    (ident(l1,'xs') genaop(tstmt('//ASM	','add',t1,'cfp_b')))   :s(return)
    genaop(tstmt('//ASM	','lea',t1,'[' t1 '+cfp_b]'))           :(return)

*   -(x), register indirect, pre decrement

getarg.c.11

    t1 = regmap[substr(l1,3,2)]
    getarg = tmem '[' t1 ']'
    genbop(tstmt('//ASM	','lea',t1,'[' t1 '-cfp_b]'))           :(return)

*  int(x)
*  dlbl(x)

getarg.c.12
getarg.c.13

    l1 break('(') . t1 '(' len(2) . t2
    getarg = tmem '[(cfp_b*' t1 ')+' regmap[t2] ']'     :(return)

*   name(x), where name is in working section

getarg.c.14
getarg.c.15

    l1 break('(') . t1 '(' len(2) . t2
    getarg = tmem '[' t1 '+'  regmap[t2] ']'            :(return)

*  signed integer

getarg.c.16 getarg = l1                                 :(return)

*  signed real

getarg.c.17 getarg = l1                                 :(return)

*   =dlbl

getarg.c.18

    getarg = substr(l1,2)                               :(return)

*   *dlbl

getarg.c.19

    getarg = 'cfp_b*' substr(l1,2)                      :(return)

*   =name (data section)

getarg.c.20
getarg.c.21

    getarg =  substr(l1,2)                              :(return)

*   =name (program section)

getarg.c.22

    getarg =  substr(l1,2)                              :(return)

*   pnam, eqop

getarg.c.23
getarg.c.24

   getarg = l1                                          :(return)

*  ptyp, text, dtext

getarg.c.25
getarg.c.26
getarg.c.27

   getarg = l1                                          :(return)







-stitl get_c_label(iarg,imem)
get_c_label    	get_c_label = ll_filter(get_c_argument(iarg,imem))	:s(return)f(freturn)

-stitl ll_filter(x)
* couldnt do it in the header because c has warnings and shit
* This is to catch error and switch it to ezzor
* and other things like that


ll_filter
    	ident(x,'error')		:s(l_ohno_error)
	ll_filter = x	:(return)
l_ohno_error
	ll_filter = 'ezzor' :(return)


-stitl get_c_argument(iarg,imem)

get_c_argument
*		t2 = &lastline
*	terminal = 'hi ' t2

    tmem = (differ(imem) '', 'm_word ')
    l1 = i.text(iarg)
    l1 'm_word ' = ''
    l2 = i.type(iarg)
    eq(l2)                                              :f($(get_c_argumentcase[l2]))
    get_c_argument = l1                                         :(get_c_argument_return)

*  int

get_c_argument.c.1

   get_c_argument = l1                                          :(get_c_argument_return)

*  dlbl

get_c_argument.c.2
   get_c_argument =  l1                                          :(get_c_argument_return)

*  wlbl, clbl

get_c_argument.c.3
get_c_argument.c.4

*   get_c_argument = tmem '*((word *)' l1 ')'                             :(get_c_argument_return)
   get_c_argument = tmem  l1                              :(get_c_argument_return)

*  elbl, plbl

get_c_argument.c.5
get_c_argument.c.6

   get_c_argument = l1                                          :(get_c_argument_return)

*  w,x, map register name

get_c_argument.c.7
get_c_argument.c.8

    get_c_argument = regmap[l1]                                 :(get_c_argument_return)


*  (x), register indirect
get_c_argument.c.9

    l1 len(1) len(2) . l2
    l2 = regmap[l2]
    get_c_argument = tmem '*(' l2 '_it.wp)'                            :(get_c_argument_return)

*  (x)+, register indirect, post increment
*  use lea reg,[reg+cfp_b] unless reg is esp, since it takes an extra byte.
*  actually, lea reg,[reg+cfp_b] and add reg,cfp_b are both 2 cycles and 3 bytes
*  for all the other regs, and either could be used.

get_c_argument.c.10

	l0 = l1
    l1 = substr(l0,2,2)
    l1 '('		:f(get_c_argument.c.10_good1)
    l1 = substr(l0,3,2)
get_c_argument.c.10_good1    
    t1 = regmap[l1]		:s(huihu)
huihu    
    get_c_argument = tmem '*(' t1 '_it.wp++)'
    (ident(l1,'xs') genaop(tstmt('//ASM	','add',t1,'CFP_B')))   :s(get_c_argument_return)
    genaop(tstmt('//ASM	','lea',t1,'[' t1 '+CFP_B]'))           :(get_c_argument_return)

*   -(x), register indirect, pre decrement

get_c_argument.c.11

    t1 = regmap[substr(l1,3,2)]
    get_c_argument = tmem '*(--' t1 '_it.wp)'
    genbop(tstmt('//ASM	','lea',t1,'[' t1 '-CFP_B]'))           :(get_c_argument_return)

*  int(x)
*  dlbl(x)

get_c_argument.c.12
get_c_argument.c.13
    l1 break('(') . t1 '(' len(2) . t2
    get_c_argument = tmem '*((word *)(CFP_B*' t1 ' + ' regmap[t2] '))'     :(get_c_argument_return)


*   name(x), where name is in working section

get_c_argument.c.14

    l1 break('(') . t1 '(' len(2) . t2
    get_c_argument = tmem '*((word *)( ((word)&' t1 ') + ' regmap[t2] '))'     :(get_c_argument_return)


get_c_argument.c.15
    l1 break('(') . t1 '(' len(2) . t2
    get_c_argument = tmem '*((word *)( ((word)&' t1 ') + ' regmap[t2] '))'     :(get_c_argument_return)

*  signed integer

get_c_argument.c.16 
	get_c_argument = l1                                 :(get_c_argument_return)

get_c_argument.c.17 
*  signed real
	get_c_argument = '(double)' l1                                 :(get_c_argument_return)


*   =dlbl

get_c_argument.c.18

    get_c_argument =  substr(l1,2)                               :(get_c_argument_return)

*   *dlbl

get_c_argument.c.19

    get_c_argument = 'CFP_B*' substr(l1,2)                      :(get_c_argument_return)

*   =name (data section)

get_c_argument.c.20
get_c_argument.c.21
    get_c_argument =  '(word)(&' substr(l1,2) ')'                             :(get_c_argument_return)

*   =name (program section)

get_c_argument.c.22

    get_c_argument =   '(word)(' substr(l1,2) ')'                              :(get_c_argument_return)

*   pnam, eqop

get_c_argument.c.23
get_c_argument.c.24

   get_c_argument = l1                                          :(get_c_argument_return)

*  ptyp, text, dtext

get_c_argument.c.25
get_c_argument.c.26
get_c_argument.c.27

   get_c_argument = l1                                          :(get_c_argument_return)
    
get_c_argument_return
* fix the #defines and stuff
	get_c_argument 'm_word ' = ''
	get_c_argument = convert_value_c(get_c_argument)

	:(return)




get_c_assignment
	get_c_assignment = convert_value_assignment( get_c_argument(iarg,imem) )	:(return)
	











-stitl get_c_character_argument(iarg,imem)

get_c_character_argument
*		t2 = &lastline
*	terminal = 'hi ' t2

    tmem = (differ(imem) '', 'm_word ')
    l1 = i.text(iarg)
    l1 'm_word ' = ''
    l2 = i.type(iarg)
    eq(l2)                                              :f($(get_c_character_argumentcase[l2]))
    get_c_character_argument = l1                                         :(get_c_character_argument_return)

*  int

get_c_character_argument.c.1

   get_c_character_argument = '( ' l1 ' &0xff)'                                         :(get_c_character_argument_return)

*  dlbl

get_c_character_argument.c.2

   get_c_character_argument =  l1                                          :(get_c_character_argument_return)

*  wlbl, clbl

get_c_character_argument.c.3
get_c_character_argument.c.4

*   get_c_character_argument = tmem '*((word *)' l1 ')'                             :(get_c_character_argument_return)
   get_c_character_argument = tmem  l1                              :(get_c_character_argument_return)

*  elbl, plbl

get_c_character_argument.c.5
get_c_character_argument.c.6

   get_c_character_argument = l1                                          :(get_c_character_argument_return)

*  w,x, map register name

get_c_character_argument.c.7
get_c_character_argument.c.8

    get_c_character_argument = regmap[l1]                                 :(get_c_character_argument_return)


*  (x), register indirect
get_c_character_argument.c.9

    l1 len(1) len(2) . l2
    l2 = regmap[l2]
    get_c_character_argument = tmem '*(' l2 '_it.chp)'                            :(get_c_character_argument_return)

*  (x)+, register indirect, post increment
*  use lea reg,[reg+cfp_b] unless reg is esp, since it takes an extra byte.
*  actually, lea reg,[reg+cfp_b] and add reg,cfp_b are both 2 cycles and 3 bytes
*  for all the other regs, and either could be used.

get_c_character_argument.c.10

    l1 = substr(l1,2,2)
    t1 = regmap[l1]
    get_c_character_argument = tmem '*(' t1 '_it.chp++)'
    (ident(l1,'xs') genaop(tstmt('//ASM	','add',t1,'CFP_B')))   :s(get_c_character_argument_return)
    genaop(tstmt('//ASM	','lea',t1,'[' t1 '+CFP_B]'))           :(get_c_character_argument_return)

*   -(x), register indirect, pre decrement

get_c_character_argument.c.11

    t1 = regmap[substr(l1,3,2)]
    get_c_character_argument = tmem '*(--' t1 '_it.chp)'
    genbop(tstmt('//ASM	','lea',t1,'[' t1 '-CFP_B]'))           :(get_c_character_argument_return)

*  int(x)
*  dlbl(x)

get_c_character_argument.c.12
get_c_character_argument.c.13

    l1 break('(') . t1 '(' len(2) . t2
    get_c_character_argument = tmem '*((char *)(' t1 ' + ' regmap[t2] '))'     :(get_c_character_argument_return)

*   name(x), where name is in working section

get_c_character_argument.c.14
get_c_character_argument.c.15

    l1 break('(') . t1 '(' len(2) . t2
    get_c_character_argument = tmem '*((char *)(&' t1 ' + '  regmap[t2] '))'     :(get_c_character_argument_return)

*  signed integer

get_c_character_argument.c.16 get_c_character_argument = l1                                 :(get_c_character_argument_return)

*  signed real

get_c_character_argument.c.17 get_c_character_argument = '(double)' l1                                 :(get_c_character_argument_return)

*   =dlbl

get_c_character_argument.c.18

    get_c_character_argument =  substr(l1,2)                               :(get_c_character_argument_return)

*   *dlbl

get_c_character_argument.c.19

    get_c_character_argument =  substr(l1,2)                      :(get_c_character_argument_return)

*   =name (data section)

get_c_character_argument.c.20
get_c_character_argument.c.21
    get_c_character_argument =  '(char)(&' substr(l1,2) ')'                             :(get_c_character_argument_return)

*   =name (program section)

get_c_character_argument.c.22

    get_c_character_argument =   '(char)(' substr(l1,2) ')'                              :(get_c_character_argument_return)

*   pnam, eqop

get_c_character_argument.c.23
get_c_character_argument.c.24

   get_c_character_argument = l1                                          :(get_c_character_argument_return)

*  ptyp, text, dtext

get_c_character_argument.c.25
get_c_character_argument.c.26
get_c_character_argument.c.27

   get_c_character_argument = l1                                          :(get_c_character_argument_return)
    
get_c_character_argument_return
* fix the #defines and stuff
	get_c_character_argument 'm_word ' = ''
	get_c_character_argument = convert_value_c(get_c_character_argument)

	:(return)







-stitl memmem()t
memmem

*   memmem is called for those ops for which both operands may be
*   in memory, in which case, we generate code to load second operand
*   to pseudo-register 'w0', and then modify the second argument
*   to reference this register
	memmem_c_savei1 = copy(i1)
	memmem_c_savei2 = copy(i2)
	
    eq(ismem[i.type(i1)])                               :s(return)
    eq(ismem[i.type(i2)])                               :s(return)

*   here if memory-memory case, load second argument

    t = getarg(i2)
    i2 = minarg(8,'w0')
    genop('mov','w0',t)                                 :(return)






-stitl c_umemmem()t
c_umemmem
* undo damage done with memmem for C
* so we can still see the proper assembly and compare

	i1 = memmem_c_savei1 
	i2 = memmem_c_savei2 	
	:(return)



-stitl prcent(n)
prcent prcent = 'prc_+CFP_B*' ( n - 1)                  :(return)



-stitl outstmt(ostmt)label,opcode,op1,op2,op3,comment)
*   this module writes the components of the statement
*   passed in the argument list to the formatted .s file

outstmt 
    label = t.label(ostmt)

*   clear label if definition already emitted

    label = ident(label, lastlabel)

outstmt1

    comment = t.comment(ostmt)

*  ds suppress comments

    comment = tcomment = comments =
                                                        :(outstmt2)
*   attach source comment to first generated instruction

    differ(comment)                                     :s(outstmt2)
    ident(tcomment)                                     :s(outstmt2)
    comment = tcomment; tcomment =
outstmt2

    opcode = t.opc(ostmt)
    op1 = t.op1(ostmt)
    op2 = t.op2(ostmt)
    op3 = t.op3(ostmt)
    differ(compress)                                    :s(outstmt3)
    stmtout = rpad( rpad(label,7) ' ' rpad(opcode,4) ' '
.                 (ident(op1), op1
.                       (ident(op2), ',' op2
.                               (ident(op3), ',' op3))) ,27)
.       (ident(strip_comment,'y'), ' ' (ident(comment), ';') comment)
.                                                       :(outstmt4)
outstmt3

    stmtout = label tab opcode tab
.                 (ident(op1), op1
.                   (ident(op2), ',' op2
.                     (ident(op3), ',' op3)))
.       (ident(strip_comment,'y'), tab (ident(comment), ';') comment)

**      send text to outfile

**

outstmt4

**
**      send text to output file if not null.

*        stmtout = replace(trim(stmtout),'$','_')

    stmtout = trim(stmtout)
    ident(stmtout)                                      :s(return)
    eq(z_trace)                                         :s(outstmt5)

*        here if trace code desired for executable instructions

    chktrace()

outstmt5

    ident(stmtout)                                      :s(return)
    outfile = stmtout
    ntarget = ntarget + 1
    noutlines = noutlines + 1

*   record code labels in table with delimiter removed.
    (ge(sectnow,5) differ(thislabel))                   :f(return)
    label ? break(':') . label                          :f(return)
    labels_in_the_code_section<label> = noutlines                           :(return)








-stitl  chktrace()
chktrace

*                                                :(return)
*        output = 'chktrace:' inlines ':' label ':' stmtout
*        output = differ (label) 'chktrace label:' label ':'
*        turn off skip mode when begin executable code

    clabel = inlabel
    old_z_skip = z_skip
    old_z_exec = z_exec
    old_is_exec = is_exec
    z_skip = ident(inlabel,'s_aaa') 0

*        incode ? any(lcase)                     :s(return)

    uopcode  = replace(incode, lcase,ucase)

*   do not trace bsw (for now)

    ident(uopcode,'bsw')                                :s(return)
    is_exec = is_executable[uopcode]
    z_exec = ne(z_trace)  ident(inlabel, 's_aaa') 1
    z_exec = gt(nlines,2186) 1

*        need to skip certain blocks since otherwise get branches that are too long
*        skip when in code that won't assemble if try to trace
*        this was discovered on a case-by-case basis.

    z_skip  = differ(inlabel) differ(skip_on[inlabel]) 1
    z_skip  = differ(inlabel) differ(skip_off[inlabel]) 0

    ne(z_skip)                                          :s(return)
    eq(z_exec)                                          :s(return)
    eq(is_exec)                                         :s(return)
*        here to emit trace. need to emit trace after label if there is label
        ident(inlabel)                          :s(chktrace.1)
*        only trace at labels since get jumps that are too removed otherwise
*        ident(label)                            :s(return)
*        here to emit trace code when there is label
*        first need to emit label, then fall through

*        stmtout ? break_ws  . label spanws  rem . body  :f(outstmt5)
*        stmtout = tab body
*        outfile = label
*        label =
    ne(in_gcol)                                         :s(return)

chktrace.1

*    genz()
                                                        :(return)
genz
   eq(parser_pass,1)						:s(return)
   lt(sectnow,5)			:s(return)
    z_count = z_count + 1
*    gt(z_first) le(z_count,z_first)                     :s(return)
*    gt(z_limit)  gt(z_count, z_limit)                   :s(return)

* 6969
    incode 'iff'			:s(return)
    incode 'esw'			:s(return)
    incode 'ejc'			:s(return)

*  only trace at label definition
*        ident(thislabel)                        :s(return)



*        always generate trace if at label definition
 
*    z_desc = '"' replace(thisline,'sepchar',' ') '"'
*    gencode_c(-2,tab 'zzzz(' tab z_count ',' nlines ',' z_desc ');' )
                                                        :(return)

-stitl prsarg(iarg)
prsarg

    prsarg = minarg(0)
    iarg break(',') . l1 ',' rem . l2                   :f(return)
    prsarg = minarg(convert(l1,'integer'),l2)           :(return)



-stitl readline()
*   this routine returns the next statement line in the input file
*   to the caller.  it does fail on eof.  if there is no more input,
*   then a minimal end statement is returned.
*   comments are passed through to the output file directly.
*  the failure 


readline
    readline = infile                                   :f(rl02)
    nlines  = nlines + 1
    ident( readline )                                   :s(readline)
    

readline.0

    leq( substr(readline,1,1 ),'*' )                    :s(rl01a)
* added # as a comment for linux reasons    
    leq( substr(readline,1,1 ),'#' )                    :s(rl01a)
* added // as a comment for c,java,javascript reasons    
    leq( substr(readline,1,2 ),'//' )                    :f(rl01)
rl01a    
    z_skip = ident(readline,'*z+') 0                    :s(readline)
    z_skip = ident(readline,'*z-') 1                    :s(readline)

*   only print comment if requested.

    ident(strip_comment,'n')                            :f(readline)
    readline '*' | '#' | '//' = '//'
    outfile = readline
    noutlines = noutlines + 1        

		                      :(readline)

*   here if not a comment line

rl01             
                                       :(return)

*   here on eof

rl02

* we need to check for this in order to handle multiple passes for the C and other parsers
    readline = '		end'
                                                        :(return)
-stitl tblini(str)
*   this routine is called to initialize a table from a string of
*   index/value pairs.

tblini

    pos     = 0

*   count the number of "[" symbols to get an assessment of the table
*   size we need.

tin01

    str     (tab(*pos) '[' break(']') *?(cnt = cnt + 1) @pos)
.                                                       :s(tin01)

*   allocate the table, and then fill it. note that a small memory
*   optimisation is attempted here by trying to re-use the previous
*   value string if it is the same as the present one.

    tblini   = table(cnt)

tin02

    str     (break('[') $ index len(1) break(']') $ val len(1)) =
.                                                       :f(return)
    val     = convert( val,'integer' )
    val     = ident(val,lastval) lastval
    lastval = val
    tblini[index] = val                                 :(tin02)
-stitl generators

ifreg

    ge(i.type(iarg),7) le(i.type(iarg),8)               :f(freturn)s(return)

g.flc

    output = 'flc  not supported ' (end)
    t1 = (eq(cfp_b,cfp_c) reglow[getarg(i1)], getarg(i1))
    t2 = genlab()

*   z_suspend = 1

    genop('cmp',t1,"'A'")
    genop('jb', t2 )
    genop('cmp',t1,"'Z'")
    genop('ja', t2)
    genop('add',t1,'32')
    genopl(t2 '                                         :')

*   z_suspend = 0
	gencode_c(2,'/* upper case folding not done */')
                                                        :(opdone)

g.mov

*   perhaps change mov x,(xr)+ to
*        mov ax,x; stows

*   perhaps do  mov (xl)+,wx as
*        lodsw
*        xchg ax,tx
*   and also mov (xl)+,name as
*        lodsw
*        mov name,w0
*   need to process memory-memory case
*   change 'mov (xs)+,a' to 'pop a'
*   change 'mov a,-(xs)' to 'push a'

    i.src = i2; i.dst = i1
    t.src = i.text(i.src); t.dst = i.text(i.dst)

    memmem()
    ident(t.src,'(xl)+')                                :s(mov.xlp)
    ident(t.src,'(xt)+')                                :s(mov.xtp)
    ident(t.src,'(xs)+')                                :s(mov.xsp)
    ident(t.dst,'(xr)+')                                :s(mov.xrp)
    ident(t.dst,'-(xs)')                                :s(mov.2)
    genop('mov',getarg(i1),getarg(i2))
                                                        :(g.mov.c)
mov.xtp
mov.xlp

    ident(t.dst,'(xr)+') genop('movs_w')                :s(g.mov.c)
    genop('lods_w')
    ident(t.dst,'-(xs)') genop('push','w0')             :s(g.mov.c)
    genop('mov',getarg(i.dst),'w0')                    
     		 :(g.mov.c)

mov.xsp
    ident(t.dst,'(xr)+')                                :s(mov.xsprp)
    genop('pop',getarg(i.dst))                          
    :(g.mov.c)

mov.xsprp genop('pop','w0')
    genop('stos_w')                                
	           :(g.mov.c)

mov.xrp genop('mov','w0',getarg(i.src))

    genop('stos_w')                                 
        :(g.mov.c)

mov.2

    genop('push',getarg(i.src))                          
	    :(g.mov.c)
	    
	    
g.mov.c
* undo the memmem stuff
    c_umemmem()
    i.src = i2; i.dst = i1

    t.src = i.text(i.src); t.dst = i.text(i.dst)
    
    ident(t.src,'(xl)+')                                :s(mov.c.xlp)
    ident(t.src,'(xt)+')                                :s(mov.c.xtp)
    ident(t.src,'(xs)+')                                :s(mov.c.xsp)
    ident(t.src,'(xr)+')                                :s(mov.c.xrp)
* note - in c it is source
g.mov.c2
    ident(t.dst,'-(xs)')                                :s(mov.c.2)
    :(mov.fixed_c2)

g.mov.c3
    ident(t.dst,'-(xs)')                                :s(mov.c.3)
    :(mov.fixed_c3)

mov.c.xsp
    gencode_c(2,get_c_argument(i1) '= C_POP();')
     :(opdone)

mov.c.xrp    
    i.text(i2) = '*(xr_it.wp++)'	    	    :(g.mov.c3)

mov.c.xlp
mov.c.xtp
    i.text(i2) = '*(xl_it.wp++)'	    	    :(g.mov.c3)
    
mov.c.2
	gencode_c(2,'C_PUSH(' get_c_argument(i.src) ');')
	:(opdone)

mov.c.3
	gencode_c(2,'C_PUSH(' i.text(i2) ');')
	:(opdone)
	
mov.fixed_c2
	gencode_c(2,get_c_argument(i.dst) '= ' get_c_argument(i.src) ';')
	:(opdone)	        
    
mov.fixed_c3
	gencode_c(2,get_c_argument(i.dst) '= ' get_c_argument(i.src) ';')
	:(opdone)	        
    
    
*  odd/even tests.  if w reg, use low byte of register.

g.bod

    t1 = getarg(i1)
    t1 = eq(i.type(i1),8) reglow[t1]
    genop('test',t1,'1')
    genop('jne',getarg(i2))                     
    gencode_c(2, 'if ('  get_c_argument(i1) ' & 1)  C_GOTO(' get_c_label(i2) ');' )
    
	            :(opdone)

g.bev

    t1 = getarg(i1)
    t1 = eq(i.type(i1),8) reglow[t1]
    genop('test',t1,'1')
    genop('je',getarg(i2))
    gencode_c(2, 'if (!((' get_c_argument(i1) ') & 1))  C_GOTO(' get_c_label(i2) ');' )
    
                                                        :(opdone)

g.brn

    genop('jmp',getarg(i1))                        
     gencode_c(2, ' C_GOTO(' get_c_label(i1) ');')
     gone_baby_gone = 1
*    and with that, ourr function is fonr
	      :(opdone)

g.bsw

    t1 = getarg(i1)
    t2 = genlab()
    z_suspend = 1
    ident(i.text(i3))                                   :s(g.bsw1)
    genop('cmp',t1,getarg(i2))    
    genop('jge',getarg(i3))
    gencode_c(2, 'if (' get_c_argument(i1) ' - (word)('  get_c_argument(i2) ') >=0 )  {'
+         ' C_GOTO(' get_c_label(i3) ');}' )
    
*  here after default case.

g.bsw1
    genop('jmp', 'm_word [' t2 '+' t1 '*cfp_b]')
    genop('segment .data')
    genopl(t2 '                                         :')
    z_suspend = 0
    gencode_c(2,'extern word ' t2 ' [];' )  
*    gencode_c(2, '{'
*+         ' w0 = ((word *)'  t2 ')[' get_c_argument(i1) '];  w0=w0&0xfffffffffffffff8; C_GOTO(w0_it.callp);}' ) 


    gencode_c(2, '{'
+         ' w0 = ((word *)'  t2 ')[' get_c_argument(i1) '];  C_GOTO(w0_it.callp);}' ) 
    gencode_c(2, '}  /* ' current_function_name ' */')
    gencode_c(2,char(10))
       current_function_name = ''
        gone_baby_gone = 0 
        iff_label_next = t2
    gencode_c(2, 'word  ' t2 ' [] = {' )
        :(opdone)


g.iff
        ident(iff_label_next)                   :s(g.iff2)
    genop('d_word',getarg(i2))
    gencode_c(2, '	(word)('  get_c_assignment(i2) '),' )
	           :(opdone)
	
                               
g.iff2

    genop('d_word',getarg(i2))                     
    gencode_c(2, 'dword xxxl' linen ' = (word)(' get_c_argument(i2) ';')
	 
	           :(opdone)

g.esw
    
    genop('segment .text')                             
    ident(iff_label_next)                   :s(opdone)
     gencode_c(2, '     }; /* bsw list for ' iff_label_next  ' */')
     iff_label_next = ''
      :(opdone)

g.ent

*   entry points are stored in byte before program entry label
*   last arg is optional, in which case no initial 'db' need be
*   issued. we force odd alignment so can distinguish entry point
*   addresses from block addresses (which are always even).

*   note that this address of odd/even is less restrictive than
*   the minimal definition, which defines an even address as being
*   a multiple of cfp_b (4), and an odd address as one that is not
*   a multiple of cfp_b (ends in 1, 2, or 3).  the definition here
*   is a simple odd/even, least significant bit definition.
*   that is, for us, 1 and 3 are odd, 2 and 4 are even.

*   ******* and all of that doesnt work in C
*   entry points are entry points.  we can tell the difference because of a 
*   range check. -- Hib


    current_routine = thislabel
    t1 = i.text(i1)

    
    outfile = '//' tab 'align' tab '2'
	entry_labels[ll_filter(inlabel)] = i.text(i1)
    differ(t1)                                          :s(g.ent.1)
	entry_labels[ll_filter(inlabel)] = 0
    outfile = '//' tab 'nop'
                                                        :(g.ent.2)
g.ent.1

    outfile = '//' tab 'db' tab  t1

g.ent.2

    outlines = outlines + 2
    gencode_c(2,'// this needs to be an entry point - odd or some poo')
    genopl(thislabel)

*   note that want to attach label to last instruction
*        t1 = code_statements[code_statements.n]
*        t.label(t1) = tlabel
*        code_statements[code_statements.n] = t1
*   here to see if want label made public

    thislabel ? rtab(1) . thislabel '                   :'
    (differ(pubtab[thislabel]), differ(debug)) genop('global',thislabel)
    thislabel =                                        

	    
      :(opdone)

g.bri

    genop('jmp',getarg(i1))
    ppp =  i.text(i1)
    ppp2 = ppp
    ppp '(' arbno(any(&alphabet)) . ppp2 ')' = ppp2   :f(g.bri.one_level)
g.bri.two_levels
     gencode_c(2,'w0 = ' ppp2 '_it.wp[0];' )
     gencode_c(2,'C_GOTO(w0_it.callp);' )
     gone_baby_gone = 1
      
	  :(opdone)

g.bri.one_level
     gencode_c(2,'C_GOTO(' ppp2 '_it.callp);' )
     gone_baby_gone = 1
      
	  :(opdone)

	  

g.lei
    t1 = regmap[i.text(i1)]
    genop('movzx',t1,'byte [' t1 '-1]' )              
    gencode_c(2,get_c_argument(i1) ' = find_elab(' get_c_argument(i1) ');    /* get entry code */' )
        :(opdone)

g.jsr

    jsr_proc = getarg(i1)
    genop('call',jsr_proc)
    

*        get count of following ppm statements


    jsr_count = ppm_cases[jsr_proc]
    eq(jsr_count)                                     :s(g.jsr_zero)
    z_suspend = 1
    jsr_calls = jsr_calls +  1
    jsr_label = 'call_' jsr_calls
    jsr_label_norm = jsr_label
    genop('dec','m_word [' rcode ']')
    genop('js',jsr_label_norm)
    z_suspend = 0

*        generate branch around for ppms that will follow
*        take the branch if normal return (eax==0)

g.jsr_zero
	hey_did_a_jsr = jsr_proc
	hey_did_jsr_args = ''
	hey_did_jsr_count = 0
	eq(parser_pass,1)				:s(opdone)
* hey_did_a_jsr is so we can get the next pos
	jsr_count = ppm_cases[jsr_proc]
	eq(jsr_count,0)					:f(opdone)

	ident(prc_types[jsr_proc],'n')			:s(g.jms.zero)
        gencode_c(2,'C_JSR(' jsr_proc ');')
	:(opdone)
	
g.jms.zero
	eq(parser_pass,1)				:s(opdone)
	new_function_to_build = genlab()
	gencode_c(-2,'extern void ' new_function_to_build '();' )
	gencode_c(-2,'C_JMS(' jsr_proc ',P_PRC_' upper(jsr_proc) ',' new_function_to_build ');' )
	section_labels[sectnow][new_function_to_build] = table()
	gone_baby_gone = 1
	fix_current_function(new_function_to_build)
	gencode_c(-2,' ')
	gencode_c(-2,'void ' new_function_to_build '() {' )
	current_function_name = new_function_to_build
	:(opdone)

g.err
g.ppm

*   here with return code in rcode. it is zero for normal return
*   and positive for error return. decrement the value.
*   if it is negative then this is normal return. otherwise,
*   proceed decrementing rcode until it goes negative,and then
*   take the appropriate branch.

    t1 = getarg(i1)
*   branch to next case if rcode code still not negative.

    ident(i.text(i1))				:s(g.err.2)
    ident(incode,'ppm')                                 :s(g.ppm.add)
    count.err =  count.err + 1
    hey_did_jsr_count = hey_did_jsr_count + 1
    hey_did_jsr_args = hey_did_jsr_args ',' '(C_ERR(' convert(i.text(i1),'integer') '))' 
g.err.3    
    jsr_count = jsr_count - 1
    errfile =   i.text(i1) ' ' i.text(i2)
    max.err = gt(t1,max.err) t1
                                                        :(g.ppn_final)


g.err.2

*   a ppm with no arguments, which should never be executed, is
*   translated to err 299,internal logic error: unexpected ppm branch

    t19 = 299
    count.err =  count.err + 1
    errfile =  t19 ' internal logic error                : unexpected ppm branch'
    hey_did_jsr_args = hey_did_jsr_args ',' '(C_ERR(' t19 '))'
    hey_did_jsr_count = hey_did_jsr_count + 1
                                                        :(g.err.3)

g.ppm.add
    jsr_count = jsr_count - 1
    hey_did_jsr_count = hey_did_jsr_count + 1
    hey_did_jsr_args = hey_did_jsr_args ',' 'C_GOTO(' ll_filter(t1) ')'
    z_suspend = eq(jsr_count) 0
g.ppn_final
	
	
			
    eq(jsr_count,0)				:f(opdone)
    ident(prc_types[jsr_proc],'n')                  :s(g.ppn.final_jms)      
    gencode_c(2,'C_JSR_' hey_did_jsr_count '(' hey_did_a_jsr hey_did_jsr_args ');' )
    hey_did_a_jsr = ''
    hey_did_jsr_count = 0
    hey_did_jsr_args = ''
        :(opdone)
	
g.ppn.final_jms
	new_function_to_build = genlab()
	gencode_c(-2,'extern void ' new_function_to_build '();' )
	gencode_c(-2,'C_JMS(' hey_did_a_jsr ',P_PRC_' upper(hey_did_a_jsr) ',' new_function_to_build ');' )
	section_labels[sectnow][new_function_to_build] = table()
	gone_baby_gone = 1
	fix_current_function(new_function_to_build)
	gencode_c(-2,' ')
	gencode_c(-2,'void ' new_function_to_build '() {' )
	current_function_name = new_function_to_build
	gencode_c(2,'C_JMS_HANDLE_' hey_did_jsr_count '(' hey_did_a_jsr hey_did_jsr_args ');' )
    hey_did_a_jsr = ''
    hey_did_jsr_count = 0
    hey_did_jsr_args = ''
        :(opdone)
	

g.prc

*   generate public declaration
*        t1 = thislabel
*        t1 ? rtab(1) . t1 ':'
*        genop()
*        genop('global',t1)
*   nop needed to get labels straight

    prc.args = getarg(i2)
    ppm_cases[thislabel] = i.text(i2)
    max_exi = gt(prc.args,max_exi) prc.args

    prc_types[thislabel] = i.text(i1)
    &anchor = 0
    kkkk = thislabel
    kkkk ':' rpos(0) = ''
    &anchor = 1
    prc_types[kkkk] = i.text(i1)
    
    current_routine = thislabel
    prc.type = i.text(i1)                               :($('g.prc.' prc.type))

g.prc.e
g.prc.r           
    thislabel =
    eq(parser_pass,1)				:s(g.prc.ccode)
                                      :(opdone)

g.prc.n
*   store return address in reserved location
    prc.count = prc.count + 0
    
* define P_PRC_<FUNCT> 
* and P_PRCLEN_<FUNCT>
* note - P_PRCLEN_<FUNCT> is currently unused
    temp_here_label = upper(thislabel)
    &anchor = 0
    temp_here_label ':'  = ''
    &anchor = 1
    gencode_c(1,'#define P_PRC_' temp_here_label ' ' prc.count )
    gencode_c(1,'#define P_PRCLEN_' temp_here_label ' ' i.text(i2) )
    temp_here_label = ''
    
    prc.count = prc.count + 1
    
    thislabel =
    genop('pop', 'm_word [' prcent(nprc.count) ']')
    
g.prc.ccode     
       :(opdone)

g.exi

    t1 = getarg(i1); t2 = prc.type; t3 = i.text(i1)

*   if type r or e, and no exit parameters, just return

    differ(t2,'n') eq(prc.args)     genop('ret')         :s(g.exi_c) 

    t3 = ident(t3) '0'
    genop('mov','m_word [' rcode ']',+t3)
    ident(t2,'n')                                       :s(g.exi.1)
    genop('ret')                                   
g.exi_c
    ident(t2,'n')					:s(g.exi_c1)
    t3 = ident(t3) '0'
    gencode_c(2,'C_EXIT(' t3 ');')
    gone_baby_gone = 1
    	           :(opdone)

g.exi.1

    genop('mov','w0', 'm_word ['  prcent(prc.count) ']' )
    genop('jmp','w0')
    :(g.exi_c)
    
g.exi_c1
	t3 = ident(t3) '0'
* add the constant start 
    temp_here_label = upper(current_routine)
    &anchor = 0
    temp_here_label ':'  = ''
    &anchor = 1

	gencode_c(2,'C_NEXIT(P_PRC_' temp_here_label ',' t3 ');' )
        gone_baby_gone = 1
	 :(opdone)    
    

                                                        :(opdone)
							
							
g.enp   genop()  
	current_routine = ''
                                       :(opdone)

g.erb
    errfile =  i.text(i1) ' ' i.text(i2)
*        set rcode to error code and branch to error handler
    genop('mov', 'm_word [' rcode ']',  +(i.text(i1)))
    genop('jmp','err_')
      gencode_c(2,'C_ERB(' convert(get_c_argument(i1),'integer') ')' )
 	gone_baby_gone = 1
 
                                                        :(opdone)


g.icv

    genop('inc',getarg(i1))                            
    gencode_c(2,'(' get_c_argument(i1) ')++;')
      :(opdone)


g.dcv

    genop('dec',getarg(i1))                  
    gencode_c(2,'(' get_c_argument(i1) ')--;')
               :(opdone)

g.zer

    ident(i.text(i1),'(xr)+') genop('mov','w0','0')
+               genop('stos_w')                         :s(g.zer.c)
    ifreg(i1)                                           :s(g.zer1)
    ident(i.text(i1),'-(xs)')                           :s(g.zer.xs)
    genop('mov','w0','0')
    genop('mov',getarg(i1),'w0')                    
*    gencode_c(2,'C_PUSH(0);');
	    :(g.zer.c)

g.zer1

    t1 = getarg(i1)
    genop('xor',t1,t1)                                
    
        :(g.zer.c)

g.zer.xs

    genop('push','0')                
		                          :(g.zer.c)
					  
					  
g.zer.c					  
 gencode_c(2,get_c_argument(i1) '=0;')
 :(opdone)

g.mnz

    genop('mov',getarg(i1),'xs')                
    gencode_c(2,get_c_argument(i1) ' = 0xffffffffffffffff;' )
	            :(opdone)

g.ssl
g.sss
g.rtn

    genop()                                             :(opdone)

g.add   memmem()

    genop('add',getarg(i1),getarg(i2))                  
    c_umemmem()
    gencode_c(2,get_c_argument(i1) ' += ' get_c_argument(i2) ';' )
    :(opdone)

g.sub   memmem()
    c_umemmem()
    genop('sub',getarg(i1),getarg(i2))                 
    gencode_c(2,get_c_argument(i1) ' -= ' get_c_argument(i2) ';' )
    
     
       :(opdone)

g.ica   genop('add',getarg(i1),'cfp_b')                
    gencode_c(2,get_c_argument(i1) ' += ' 'CFP_B' ';')
  
  :(opdone)

g.dca   genop('sub',getarg(i1),'cfp_b')                 
    gencode_c(2,get_c_argument(i1) ' -= ' 'CFP_B' ';')

	:(opdone)

g.beq
g.bne
g.bgt
g.bge
g.blt
g.ble
g.blo
g.bhi

*   these operators all have two operands, memmem may apply
*   issue target opcode by table lookup.

    memmem()
    t1 = branchtab[incode]
    genop('cmp',getarg(i1),getarg(i2))
    genop(branchtab[incode],getarg(i3))
    c_umemmem()
    gencode_c(2, 'if ((' get_c_argument(i1) 
+ '-'  get_c_argument(i2) ') ' branchtab_standard_c[incode] ' 0) '
+  'C_GOTO(' get_c_label(i3) ');' )
    :(opdone)
    
* gencode_q is more complex. we are not using global variables (or local links)
* in this case we define the parameters coming into the kernel in pass 1
* and would make an after kernel - which might use items in the before kernel, might not
* so the uncompressed method would be to write a second kernel for the goto here
* but we could compress it using variables (v1, v2, etc) again with two passes to see if the data is input, and not output
* then there is the chain.
* if a chain uses WA as input, and that is run from p1, to p2 to p3 to p4, well, we need to carry that chain WA along.
* the same with known variables.  
* best to give the standard variables at first - registers general purpoise in or out.
* or we could have a define_jump that gives us temporaries that can change, or read onlys, or something.
* lets think about how to reduce the size:
* got an array of 1000 possible links in one direction, and 1000 in another direction
* 
* could have multiple kernels being built - one for kernel_base and one for kernel1 and one for kernel2 if they all go together without  a branch.
* but - too complex.
*
* variabes- kernel_name
* also      last_was_branch
* also 	    kernel has loop
*   eq(pass,1)	:f(g.pass2)
* see if it is kernel, then we can loop through
*g.pass1
*   eq(get_c_argument(i3),kernel_name) :s(g.pass1.go)
*   
*   eq(last_was_branch,1) 	:s(no_need_add_last_branch)
*   build_kernel_next(kernel_name,('kernel_name' '_ln_' nlines )
*  that name will
*   kernel_add_branch(getarg(i3)) :(g.pass1_finalize)
*
*g.pass1.go
*   kernel_add_while = 1
*g.pass1.finalize   
*   last_was_branch = 1
*   :(opdone)
*   
*
*g.pass2   
*   eq(get_c_argument(i3),kernel_name) :s(g.pass2.go)
*   last_was_branch = 1
*   gencode_q = 'if (' get_q_argument(i1) branchtab_standard_c[incode] get_q_argument(i2) ') Q_GOTO(' get_q_label(i3) kernel_args_for(get_q_label(i3)) ');'
* later - first c then cuda/gpu crap - it will work, but the queues will be sparse sometimes and might need unsparsine.
* one way is via random number insertions from other queue , etc.
   

                                                       :(opdone)

g.bnz

    ifreg(i1)                                           :s(g.bnz1)
    genop('cmp', getarg(i1) ,'0')
    genop('jnz',getarg(i2))

                                                        :(g.bnz2)
g.bnz1
	
    genop('or',getarg(i1),getarg(i1))
    genop('jnz',getarg(i2))
g.bnz2    
    gencode_c(2, 'if (' get_c_argument(i1) ') C_GOTO(' get_c_label(i2) ');' )
                                                        :(opdone)

g.bze   ifreg(i1)                                       :s(g.bze1)

    genop('cmp', getarg(i1)  ,'0')
    genop('jz',getarg(i2))
                                                        :(g.bze2)
g.bze1

    t1 = getarg(i1)
    genop('or',t1,t1)
    genop('jz',getarg(i2))                             
g.bze2    
    gencode_c(2, 'if ( !( ' get_c_argument(i1) ') ) C_GOTO(' get_c_label(i2) ');' )
 					:(opdone)
 
g.lct

*   if operands differ must emit code

    differ(i.text(i1),i.text(i2))                       :s(g.lct.1)

*   here if operands same. emit no code if no label, else emit null

    ident(thislabel)                                    :s(g.lct.c)
    genop()                                        
	     :(g.lct.c)

g.lct.1

    genop('mov',getarg(i1),getarg(i2))                  
g.lct.c
    gencode_c(2,get_c_argument(i1) '= ' get_c_argument(i2) ';' )
    							:(opdone)
    

g.bct

*   can issue loop if target register is cx.

    t1 = getarg(i1)
    t2 = getarg(i2)
                                                        :(g.bct2)
    ident(t1,better_register_name['wa'])                                      :s(g.bct1)

g.bct2

    genop('dec',t1)
    genop('jnz',t2)              
    
   					:(g.bct.c)

g.bct1

    genop('loop',t2)                                   
g.bct.c
    gencode_c(2, 'if ((--' get_c_argument(i1) '))  C_GOTO(' get_c_label(i2) ');' )
     
       :(opdone)

g.aov

    genop('add',getarg(i2),getarg(i1))
    genop('jc',getarg(i3))
* note - we ignore carry/overflow    
    gencode_c(2,get_c_argument(i2) '+=' get_c_argument(i1) ';' )
                                                        :(opdone)
g.lcp
    genop(op_,getarg(i1))                            
    gencode_c(2,'reg_cp = ' get_c_argument(i1) ';')
    :(opdone)
	
g.lcw
    genop(op_,getarg(i1))                            
    gencode_c(2,  get_c_argument(i1) '  = *((word *)reg_cp);')
    gencode_c(2,'  reg_cp += CFP_B;')
    :(opdone)
    
g.scp

    genop(op_,getarg(i1))                            
    gencode_c(2, get_c_argument(i1) '= reg_cp;' )
    :(opdone)

*   use cp for code pointer.
    genop('mov',reg.cp,getarg(i1))
    gencode_c(2,better_register_name[reg.cp] '=' get_c_argument(i1) ';')
                                                        :(opdone)

    genop('mov',getarg(i1),reg.cp)
    gencode_c(2,get_c_argument(i1) '= ' better_register_name[reg.cp] ';' )
                                                        :(opdone)
*   should be able to get lodsd; xchg eax,getarg(i1)
    genop('mov',getarg(i1),'m_word [' reg.cp ']')
    genop('add',reg.cp,'cfp_b')
    gencode_c(2,get_c_argument(i1) '= (m_word)' better_register_name[reg.cp] ';  '  better_register_name[reg.cp] '+= cfp_b;' ) 

                                                        :(opdone)


g.icp

    genop(op_)                                          
    gencode_c(2,'reg_cp += CFP_B;')
    
    :(opdone)
*    genop('add',reg.cp,'cfp_b')   
*                                                        :(opdone)

g.ldi

    genop('mov','ia',getarg(i1))
    gencode_c(2,'ia = ' get_c_argument(i1) ';' )
    
* yes, this falls in.   well, it did.
                                                        :(opdone)
 

g.sti

    genop('mov',getarg(i1),'ia')                    
    gencode_c(2,get_c_argument(i1) '= ' better_register_name['ia'] ';')
    :(opdone)

g.adi

    genop('add','ia',getarg(i1))                      
    
    gencode_c(2,better_register_name['ia'] '+=' get_c_argument(i1) ';')
      
	  :(opdone)

g.sbi

    genop('sub','ia',getarg(i1))                     
    gencode_c(2,better_register_name['ia'] '-=' get_c_argument(i1) ';')
       :(opdone)
 
g.mli

    genop('imul','ia',getarg(i1))             
    gencode_c(2,better_register_name['ia'] '*=' get_c_argument(i1) ';')
              :(opdone)

g.dvi


    genop('mov','rax','ia')
    genop('cdq')
    genop('idiv',getarg(i1))
    genop('mov','ia','rax')
    gencode_c(2,better_register_name['ia'] '=' better_register_name['ia'] ' / ' get_c_argument(i1) ';')
    
                                                        :(opdone)

g.rmi
    genop('mov','rax','ia')
    genop('cdq')
    genop('idiv',getarg(i1))
    genop('mov','ia','rdx')
    gencode_c(2,better_register_name['ia'] '=' better_register_name['ia'] ' % ' get_c_argument(i1) ';')
                                                        :(opdone)

g.ngi
    genop('neg','ia')                                   
    gencode_c(2,better_register_name['ia'] '= -' better_register_name['ia'] ';')
                                                        :(opdone)
    
    :(opdone)

g.ino
      gencode_c(2, ' C_GOTO(' get_c_label(i1) ');')
     gone_baby_gone = 1
     gencode_c(2,'/*g.ino g.iov is a noop, but could be done like g.aov*/')

			        :(opdone)

g.iov

    genop(op_,getarg(i1))                        
    gencode_c(2,'/*g.ino g.iov is a noop, but could be done like g.aov*/')

	   
		  
			        :(opdone)

g.ieq   jop = 'je'  
	the_test =     branchtab_standard_c['beq']                                    :(op.cmp)
g.ige   jop = 'jge'                              
	the_test =     branchtab_standard_c['bge']                                    :(op.cmp)
g.igt   jop = 'jg'                               
	the_test =     branchtab_standard_c['bgt']                                    :(op.cmp)
g.ile   jop = 'jle'                              
	the_test =     branchtab_standard_c['ble']                                    :(op.cmp)
g.ilt   jop = 'jl'                               
	the_test =     branchtab_standard_c['blt']                                    :(op.cmp)
g.ine   jop = 'jne'                              
	the_test =     branchtab_standard_c['bne']                                    :(op.cmp)
op.cmp

    genop('sti_',w0)
    genop('or',w0,w0)
    genop(jop,getarg(i1))                              
    gencode_c(2,'if (' better_register_name['ia'] ' ' the_test ' 0)  C_GOTO(' get_c_label(i1) ');' ) 
    
    						:(opdone)

*   real operations

g.itr

    genop('call','itr_')                           
    gencode_c(2,better_register_name['ra'] ' =  (double) (' better_register_name['ia'] ');') 
	 
	           :(opdone)

g.rti

    genop('rti_')
    eq(i.type(i1))                                      :f(g.rti.over)
    gencode_c(2,better_register_name['ia'] ' =  ( ' better_register_name['ra'] '_it.d);' )
  :(opdone)
  
  
*   here if label given, branch if real too large
g.rti.over
    genop('jc',getarg(i1))                          
    gencode_c(2,better_register_name['ia'] ' =  ( ' better_register_name['ra'] '_it.d);' )
    
	    :(opdone)

g.ldr
   tempg = '{'  better_register_name['ra'] '_it.d = '  get_c_argument(i1) ';' 
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'
	:(continue_real1  )
g.str
    tempg =   get_c_argument(i1) ' = (' better_register_name['ra'] '_it.d);' 
	:(continue_real1)  
g.adr
    tempg = '{w0 = '  get_c_argument(i1) ';' better_register_name['ra'] '_it.d += w0_it.d;'
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'   
	:(continue_real1  )
   
g.sbr
    tempg = '{w0 = '  get_c_argument(i1) ';' better_register_name['ra'] '_it.d -= w0_it.d;'
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'   
	:(continue_real1  )
g.mlr
    tempg = '{w0 = '  get_c_argument(i1) ';' better_register_name['ra'] '_it.d *=  w0_it.d;'
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'   
	:(continue_real1  )
g.dvr
    tempg = '{w0 = '  get_c_argument(i1) '; if (w0_it.d != 0.0) {' better_register_name['ra'] '_it.d /= w0_it.d;'
+         better_register_name['fl'] '= (!isgoodnum('  better_register_name['ra'] '_it.d));} else {'
+						 better_register_name['fl'] '=1;}}'    
	:(continue_real1  )
continue_real1
    t1 = getarg(i1,'m_word')
    genop('lea','w0',t1)
    genop('call',op_)
    gencode_c(2,tempg)
                                                        :(opdone)
g.ngr
	tempg = '{' better_register_name['ra'] '_it.d = - ' better_register_name['ra'] '_it.d;'
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'   
	:(continue_real2)
g.atn
	tempg = '{' better_register_name['ra'] '_it.d = atan(' better_register_name['ra'] '_it.d);'
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'   
	:(continue_real2)
g.chp
	tempg = '{' better_register_name['ra'] '_it.d = (long)(' better_register_name['ra'] '_it.d);'
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'   
	:(continue_real2)
g.cos
	tempg = '{' better_register_name['ra'] '_it.d = cos(' better_register_name['ra'] '_it.d);'
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'   
	:(continue_real2)
g.etx
	tempg = '{' better_register_name['ra'] '_it.d = exp(' better_register_name['ra'] '_it.d);'
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'   
	:(continue_real2)
g.lnf
	tempg = '{' better_register_name['ra'] '_it.d = log(' better_register_name['ra'] '_it.d);'
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'   
	:(continue_real2)
g.sin
	tempg = '{' better_register_name['ra'] '_it.d = sin(' better_register_name['ra'] '_it.d);'
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'   
	:(continue_real2)
g.sqr
	tempg = '{' better_register_name['ra'] '_it.d = sqrt(' better_register_name['ra'] '_it.d);'
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'   
	:(continue_real2)
g.tan
	tempg = '{' better_register_name['ra']  '_it.d = tan(' better_register_name['ra'] '_it.d);'
+               better_register_name['fl'] '=(!isgoodnum('  better_register_name['ra'] '_it.d));}'   
	:(continue_real2)

continue_real2
    genop('call',op_)
     gencode_c(2,tempg)
     
                                                        :(opdone)

g.rov
    genop(op_,getarg(i1))                               
    gencode_c(2,'if (' better_register_name['fl'] ') C_GOTO('  get_c_label(i1) ');' )
    :(opdone)

g.rno
    genop(op_,getarg(i1))          
    gencode_c(2,'if (' better_register_name['fl'] '==0) C_GOTO('  get_c_label(i1) ');' ) 
    :(opdone)
		     
g.req   jop = 'je'                                 
	the_test =     branchtab_standard_c['beq']      :(g.r1)
g.rne   jop = 'jne'                                     
	the_test =     branchtab_standard_c['bne']                                    :(g.r1)
	:(g.r1)
g.rge   jop = 'jge'                                     
	the_test =     branchtab_standard_c['bge']                                    :(g.r1)
	:(g.r1)
g.rgt   jop = 'jg'                                      
	the_test =     branchtab_standard_c['bgt']                                    :(g.r1)
	:(g.r1)
g.rle   jop = 'jle'                                     
	the_test =     branchtab_standard_c['ble']                                    :(g.r1)
	:(g.r1)
g.rlt   jop = 'jl'
	the_test =     branchtab_standard_c['blt']                                    :(g.r1)
g.r1    genop('call','cpr_')

    genop('mov','al','byte [reg_fl]')
    genop('or','al','al')
    genop(jop,getarg(i1))                            
* maybe should be al
    gencode_c(2,'if (' better_register_name['ra'] '_it.d ' the_test ' 0.0)  C_GOTO(' get_c_label(i1) ');' ) 
    
          :(opdone)

g.plc
g.psc

    ne(cfp_b,cfp_c)                                     :s(g.plc.1)

*   last arg is optional.  if present and a register or constant,
*   use lea instead.

    t1 = getarg(i1)
    t2 = i.type(i2)
    ((ifreg(i2), ge(t2,1) le(t2,2))
+       genop('lea',t1,'[CFP_F+' t1 '+' getarg(i2) ']')):s(plcpsc_done)
    genop('add',t1,'CFP_F')
    eq(i.type(i2))                            
	              :s(plcpsc_done)

*   here if d_offset_(given (in a variable), so add it in.

    genop('add',t1,getarg(i2))                        
                                                     :(plcpsc_done)

g.plc.1

*   here for case where character size is word size
*   last arg is optional.  if present and a register or constant,
*   use lea instead.

    t1 = getarg(i1)
    t2 = i.type(i2)
    ((ifreg(i2), ge(t2,1) le(t2,2))
+       genop('lea',t1,'[CFP_F+' t1 '+'  getarg(i2) ']')):s(plcpsc_done)
    genop('add',t1,'CFP_F')
    eq(i.type(i2))                                      :s(plcpsc_done)

*   here if d_offset_(given (in a variable), so add it in, after converting to byte count
    genop('mov','w0', getarg(i2))
    genop('sal','w0', 'log_cfp_b')

    genop('add',t1,'w0')                                
    :(plcpsc_done)

* now for c
plcpsc_done

    t1 = get_c_argument(i1)
    t2 = i.type(i2)
*    ne(cfp_b,cfp_c)                                     :s(g.plc.1c)
*nonop that branch for now    
    
     ((ifreg(i2), ge(t2,1) le(t2,2)) 
+     gencode_c(2,
+	get_c_argument(i1) '_it.chp += CFP_F + ' get_c_argument(i2) ';' ))     :s(opdone)
    ident(i.text(i2))                                   :s(plcpsc_one_arg)
     gencode_c(2,
+	get_c_argument(i1) '_it.chp += CFP_F + ' get_c_argument(i2) ';' )    :s(opdone)

plcpsc_one_arg
     gencode_c(2,t1 ' += CFP_F;')
     eq(i.type(i2))	:s(opdone)	
     gencode_c(2,t1 ' <<=LOG_CFP_B;' )
     		:s(opdone)
     
    





*   lch requires separate cases for each first operand possibility.

g.lch

    t2 = i.text(i2)
    t1 = getarg(i1)

*   see if predecrement needed.
    leq('-',substr(t2,1,1))                             :f(g.lcg.1)
    t2 break('(') len(1) len(2) . t3
    (eq(cfp_b,cfp_c) genop('dec',regmap[t3]), genop('sub',regmap[t3],'cfp_b'))

g.lcg.1

    t2 break('(') len(1) len(2) . t3
    eq(cfp_b,cfp_c) genop('mov','w0','0')
    eq(cfp_b,cfp_c) genop('mov','al','m_char [' regmap[t3] ']')
    eq(cfp_b,cfp_c) genop('mov',t1,'w0')
    ne(cfp_b,cfp_c) genop('mov',t1,'m_char [' regmap[t3] ']')

*   see if postincrement needed.
    t2 rtab(1) '+'                                      :f(g.lcg.2)
    (eq(cfp_b,cfp_c) genop('inc',regmap[t3]), genop('add',regmap[t3],'cfp_b'))

g.lcg.2                                                 :(g.lch.c)


g.lch.c

    gencode_c(2, get_c_character_argument(i1) ' = '  get_c_character_argument(i2) ';' )
	:(opdone)




g.sch

    t2 = i.text(i2)
    eq(i.type(i1),8)                                    :s(g.scg.w)
    t1 = getarg(i1)
    eq(cfp_b,cfp_w)                                     :f(g.scg.0)
    ident(t2,'(xr)+')                                   :f(g.scg.0)

*   here if can use stos.

    t2 break('(') len(1) len(2) . t3
    eq(cfp_b,cfp_c) genop('mov','al',getarg(i1))
    ne(cfp_b,cfp_c) genop('mov','eax',getarg(i1))
    genop('stos_b')                                     :(g.sch.c)

g.scg.0

    leq('-',substr(t2,1,1))                             :f(g.scg.1)
    t2 break('(') len(1) len(2) . t3
* bug    genop('dec',regmap[t3])
    (eq(cfp_b,cfp_c) genop('dec',regmap[t3]), genop('sub',regmap[t3],'cfp_b'))

g.scg.1

    t2 break('(') len(1) len(2) . t3
    eq(cfp_b,cfp_c) genop('mov','w0',t1,)
    eq(cfp_b,cfp_c) genop('mov','[' regmap[t3] ']','al')
    ne(cfp_b,cfp_c) genop('mov','m_char [' regmap[t3] ']',t1)
*   see if postincrement needed.
    t2 rtab(1) '+'                                      :f(g.scg.2)
    (eq(cfp_b,cfp_c) genop('inc',regmap[t3]), genop('add',regmap[t3],'cfp_b'))

g.scg.2                                                 :(g.sch.c)
g.scg.w

*   here if moving character from work register, convert t1
*   to name of low part.

    t1 = (eq(cfp_b,cfp_c) reglow[getarg(i1)], getarg(i1))

    ident(t2,'(xl)')                                    :s(g.scg.w.xl)
    ident(t2,'-(xl)')                                   :s(g.scg.w.pxl)
    ident(t2,'(xl)+')                                   :s(g.scg.w.xlp)
    ident(t2,'(xr)')                                    :s(g.scg.w.xr)
    ident(t2,'-(xr)')                                   :s(g.scg.w.pxr)
    ident(t2,'(xr)+')                                   :s(g.scg.w.xrp)

g.scg.w.xl

    genop('mov','m_char [xl]',t1)                       :(g.sch.c)

g.scg.w.pxl

    (eq(cfp_b,cfp_c)  genop('dec', 'xl'), genop('sub','xl', 'cfp_b'))
    genop('mov','m_char [xl]',t1)                       
    :(g.sch.c)

g.scg.w.xlp

    genop('mov','m_char [xl]',t1)
    (eq(cfp_b,cfp_c)  genop('inc', 'xl'), genop('add','xl', 'cfp_b'))
                                                        :(g.sch.c)
g.scg.w.xr

    genop('mov','m_char [xr]',t1)                       :(g.sch.c)

g.scg.w.pxr

    (eq(cfp_b,cfp_c)  genop('dec', 'xr'), genop('sub','xr', 'cfp_b'))
    genop('mov','m_char [xr]',t1)                       :(g.sch.c)

g.scg.w.xrp

    (eq(cfp_b,cfp_c) genop('mov','al',t1), genop('mov','eax',t1))
    genop('stos_b')                                     :(g.sch.c)


g.sch.c
    gencode_c(2, get_c_character_argument(i2) ' = '  get_c_character_argument(i1) ';' )

	:(opdone)






* hib
* this is weird code. Effectively it is a nop if the label si set or cleared
* It is set on 
* srvs4  csc  xr               complete store characters
* strm5  csc  xr               complete store characters
* anyways it is a noop

g.csc   ident(thislabel)                                :s(opnext)

    genop()                                             :(opdone)

g.ceq

    memmem()
    genop('cmp',getarg(i1),getarg(i2))
    genop('je',getarg(i3))
    c_umemmem()
    gencode_c(2,'if ((' get_c_argument(i1) ' - '  get_c_argument(i2) ')== 0) ' 
+      'C_GOTO(' get_c_label(i3) ');' )
    
    
                                                        :(opdone)

g.cne   memmem()

    genop('cmp',getarg(i1),getarg(i2))
    genop('jnz',getarg(i3))
    c_umemmem()
    gencode_c(2,'if ((' get_c_argument(i1) ' - '  get_c_argument(i2) ')!= 0) '
+      'C_GOTO(' get_c_label(i3) ');' )
                                                        :(opdone)

g.cmc

    genop('repe','cmps_b')
    genop('mov','xl','0')
    genop('mov','xr','xl')
    t1 = getarg(i1)
    t2 = getarg(i2)
    (ident(t1,t2) genop('jnz',t1))                      :s(g.cmc.c)
    genop('ja',t2)
    genop('jb',t1)                                      :(g.cmc.c)
    
g.cmc.c
	(ident(t1,t2))				:s(g.cmc.different_only)
	
g.cmc.lexical
	gencode_c(2,'C_CMC(xl_it,xr_it,wa_it,' get_c_label(i1) ',' get_c_label(i2) ');')
	:(opdone)
		    
g.cmc.different_only    
	gencode_c(2,'C_CMC_DIFFER(xl_it,xr_it,wa_it,' get_c_label(i1) ');')
	:(opdone)
    

g.trc

    genop('xchg','xl','xr')
    eq(cfp_b,cfp_c) genopl((t1 = genlab()) '            :','movzx','w0','m_char [xr]')
    ne(cfp_b,cfp_c) genopl((t1 = genlab()) '            :','mov','w0','m_char [xr]')
    ne(cfp_b,cfp_c) genop('sal', 'w0', 'log_cfp_b');* convert char value to byte offset
    eq(cfp_b,cfp_c) genop('mov','al','[xl+w0]')
    ne(cfp_b,cfp_c) genop('mov','eax','[xl+w0]')
    genop('stos' op_c)
*        genop('loop',t1)
    genop('dec','wa')
    genop('jnz',t1)
    genop('xor','xl','xl')
    genop('xor','xr','xr')
*    gencode_c(2,'fprintf(stderr,"		trc xl %lx xr %lx blen %lx\n",xl,xr,wa);' )
    gencode_c(2,'while (wa) {' )
*    gencode_c(2,'  fprintf(stderr,"xl from %x to %x %ld left\n",*(xl_it.chp),xr_it.chp[*(xl_it.chp)],wa);' )
    gencode_c(2,'  *(xl_it.chp) = xr_it.chp[*(xl_it.chp)];xl++;wa--;} xr=0; xl=0;' )
                                                        :(opdone)

g.anb   genop('and',getarg(i1),getarg(i2))              
        gencode_c(2,get_c_argument(i1) ' &= ' get_c_argument(i2) ';' )
	:(opdone)

g.orb   genop('or',getarg(i1),getarg(i2))               
        gencode_c(2,get_c_argument(i1) ' |= ' get_c_argument(i2) ';' )
	:(opdone)

g.xob   genop('xor',getarg(i1),getarg(i2))             
        gencode_c(2,get_c_argument(i1) ' ^= ' get_c_argument(i2) ';' )
						 :(opdone)

g.cmb   genop('not',getarg(i1))                       
* I checked - this is a bitwize not in x86_64, so probably is in spitbol
        gencode_c(2,get_c_argument(i1) ' = ~(' get_c_argument(i1) ');' )  
      :(opdone)


g.rsh
    genop('shr',getarg(i1),getarg(i2))                 
    gencode_c(2,get_c_argument(i1) ' >>= ' get_c_argument(i2) ';' )   
 :(opdone)

g.lsh

    genop('shl',getarg(i1),getarg(i2))                  
    gencode_c(2,get_c_argument(i1) ' <<= ' get_c_argument(i2) ';' )
    
    :(opdone)

g.rsx

    error('rsx not supported')

g.lsx

    error('lsx not supported')

g.nzb   ifreg(i1)                                       :s(g.nzb1)

    genop('cmp',getarg(i1),'0')
    genop('jnz',getarg(i2))
                                                        :(g.nzb.c)
g.nzb1

    genop('or',getarg(i1),getarg(i1))
    genop('jnz',getarg(i2))
g.nzb.c    
    gencode_c(2,'if (' get_c_argument(i1) ') C_GOTO(' get_c_label(i2) ');' ) 
                                                        :(opdone)


g.zrb   ifreg(i1)                                       :s(g.zrb1)

    genop('cmp',getarg(i1),'0')
    genop('jz',getarg(i2))
                                                        :(g.zrb.c)
g.zrb1

    genop('or',getarg(i1),getarg(i1))
    genop('jz',getarg(i2))
g.zrb.c
    gencode_c(2,'if (!(' get_c_argument(i1) ')) C_GOTO(' get_c_label(i2) ');' ) 
                                              :(opdone)

* I guess there are no garbage bits
g.zgb

    genop('nop')                                        :(opdone)

* debugging
g.zzz
    genop('zzz',getarg(i1))                             
    gencode_c(2,'{zzz(' get_c_argument(i1) ');}')    
    :(opdone)

g.wtb   genop('sal',getarg(i1),'log_cfp_b')     
	gencode_c(2,get_c_argument(i1) ' <<= LOG_CFP_B;' )      
  	  :(opdone)

* hib - I did a check, and even in 88 source btw is just / CFP_B
*  the code that uses it I think assumes that bytes is a multiple of words in use.
* I converted word explicitly to long long signed, just in case the number was negative.
g.btw   genop('shr',getarg(i1),'log_cfp_b')            
        gencode_c(2,get_c_argument(i1) ' >>= LOG_CFP_B;' )
 	 :(opdone)




g.mti   ident(i.text(i1),'(xs)+')                       :f(g.mti.1)
    genop('pop','w0')
    genop('ldi_','w0')                                  
        gencode_c(2,'ia = C_POP();' )
    
    :(opdone)

g.mti.1

    genop('ldi_',getarg(i1))                          
        gencode_c(2,'ia = (word)(' get_c_argument(i1) ');' )
        :(opdone)

g.mfi

*   last arg is optional
*   compare with cfp$m, branching if result negative

    eq(i.type(i2))                                      :s(g.mfi.1)

*   here if label given, branch if wc not in range (ie, negative)

    genop('sti_','w0')
    genop('or','w0','w0')
    genop('js',getarg(i2))
    gencode_c(2,'if (ia<0) C_GOTO( ' get_c_label(i2) ');' )
    
    

g.mfi.1

    ident(i.text(i1),'-(xs)')                           :s(g.mfi.2)
    genop('sti_',getarg(i1))                            
    gencode_c(2,get_c_argument(i1) ' = ia;' )
    :(opdone)

g.mfi.2

    genop('sti_','w0')
    genop('push','w0')                                 
    gencode_c(2,'C_PUSH(ia);' )    
      :(opdone)

g.ctw

*   assume cfp_c chars per word

    t1 = getarg(i1)
    eq(cfp_b,cfp_c)                                     :s(g.ctw.1)

*   here if one word per character, so just add character count

    genop('add',t1,i.text(i2))
    gencode_c(2,get_c_argument(i1) ' += ' get_c_argument(i2) ';' )
                                                        :(opdone)
g.ctw.1

    genop('add',t1,'(cfp_c-1)+cfp_c*' i.text(i2))
    genop('shr',t1,'log_cfp_c')
    gencode_c(2,get_c_argument(i1) ' = (' get_c_argument(i1) '+(CFP_C-1)+CFP_C* ' get_c_argument(i2) ') >> LOG_CFP_C;' )
                                                        :(opdone)

											
g.ctb

    t1 = getarg(i1)
    eq(cfp_b,cfp_c)                                     :s(g.ctb.1)

*   here if one word per character, so just add character count, then convert to byte count

    genop('add',t1,i.text(i2))
    genop('sal',getarg(i1),'log_cfp_b')                
    
    gencode_c(2,get_c_argument(i1) ' += ' get_c_argument(i2) ';' )    
    gencode_c(2,get_c_argument(i1) ' = ' get_c_argument(i1) '<< LOG_CFP_B;' )    
      :(opdone)

g.ctb.1

    genop('add',t1,'(cfp_b-1)+cfp_b*' i.text(i2))
    genop('and',t1,'-cfp_b')
*    gencode_c(2,get_c_argument(i1) ' += (CFP_B-1)+CFP_B*'  get_c_argument(i2) '-CFP_B;' )
    gencode_c(2,get_c_argument(i1) ' += (CFP_B-1)+CFP_B*'  get_c_argument(i2) ';' )
    gencode_c(2,get_c_argument(i1) ' &= 0xfffffffffffffff8;' )
                                                        :(opdone)
							
							
							
g.cvm   t1 = getarg(i1)

    genop('sti_',w0)
    genop('imul',w0,'10')
    genop('jo',t1)
    genop('sub',regmap['wb'],'ch_d0')
    genop('sub',w0,regmap['wb'])
    genop('ldi_',w0)
    genop('jo',t1)
    gencode_c(2,'w0 = ia;' )
    gencode_c(2,'w0 *= 10;' )
    gencode_c(2,'if ((ia&0x8000000000000000) != (w0 & 0x8000000000000000)) C_GOTO(' get_c_argument(i1) ');' )
    gencode_c(2,'wb = wb - CH_D0; w0 = w0 - wb; ia =w0; /* time 10 ascii */' )
                                                        :(opdone)
							
g.cvd

    genop('cvd_')               
    gencode_c(2,'wa = ia % 10; ia /= 10; wa = -wa + 48; /*cvd*/' )
* from float.c i_cvd   
			                            :(opdone)


g.mvc

*        use word move if character size is word size
*        if charsize is word size, convert character count to byte count for word move

    ne(cfp_b,cfp_c) genop('shl', 'wa', 'log_cfp_b')
    ne(cfp_b,cfp_c)                                     :s(g.mvw)
    t1 = genlab()
    z_suspend = 1
    genop('rep')
    genop('movs_b')
    z_suspend = 0
*    gencode_c(2,'fprintf(stderr,"copy %lx bytes from %lx to %lx\n",wa,xl,xr ); ' )
*    gencode_c(2,'{word www = wa;word indexa=0;do  { fprintf(stderr,"copy %x %lx bytes left %c\n",xl_it.chp[indexa],www,xl_it.chp[indexa]);'
*+     'indexa++; } while (--www);}' )
    gencode_c(2,'do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);' )
                                                        :(opdone)

g.mvw

    z_suspend = 1
    genop('shr','wa','log_cfp_b')
    genop('rep','movs_w')
*    gencode_c(2,'if (wa& 0x07) { fprintf(stderr,"BAD alighnment %lx\n",wa); } ' )
*    gencode_c(2,'fprintf(stderr,"copy %lx b (%lx words) from %lx to %lx\n",wa,(wa>> LOG_CFP_B),xl,xr);' )
*    gencode_c(2,'{word www = wa>>LOG_CFP_B;word indexa=0;do  { fprintf(stderr,"copy %lx %lx words left\n",xl_it.wp[indexa++],www); } while (--www);}' )
    gencode_c(2,'wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);' )
    
    z_suspend = 0
                                                        :(opdone)

g.mwb

    genop('shr','wa','log_cfp_b')
    genop('std')
    genop('lea','xl','[xl-cfp_b]')
    genop('lea','xr','[xr-cfp_b]')
    genrep('movs_w')
    genop('cld')                                        
*    gencode_c(2,'if (wa& 0x07) { fprintf(stderr,"BAD alighnment %lx\n",wa); } ' )
*    gencode_c(2,'fprintf(stderr,"backwards copy %lx b (%lx words) from %lx to %lx\n",wa,(wa>>  LOG_CFP_B),xl,xr);' )
*    gencode_c(2,'{word www = wa>>LOG_CFP_B;word indexa=-1;do  { '
*+    'indexa--;} while (--www);}' ) 
    gencode_c(2,'wa = wa >> LOG_CFP_B; do { *(--xr_it.wp)= *(--xl_it.wp); } while (--wa);' )
    
    :(opdone)



g.mcb

*        use word move if character size is word size

    ne(cfp_b,cfp_c) genop('shl', 'wa', 'log_cfp_b')
*    ne(cfp_b,cfp_c)                                     :s(g.mwb)
    genop('std')
    genop('dec','xl')
    genop('dec','xr')
    genrep('movs_b')
    genop('cld')
*    gencode_c(2,'fprintf(stderr,"backwards copy %lx bytes from %lx to %lx\n",wa,xl,xr );' )
*    gencode_c(2,'{word www = wa;word indexa=-1;do  { fprintf(stderr,"copyb %x %lx bytes left\n",xl_it.chp[indexa--],www; } while (--www);}' )
    gencode_c(2,'do  { *(--xr_it.chp)= *(--xl_it.chp); } while (--wa);' )
                                                        :(opdone)

genrep

*        generate equivalent of rep op loop
    l1 = genlab()
    l2 = genlab()
    genopl(l1 '                                         :')
    genop('or','wa','wa')
    genop('jz',l2)
    genop(op)
    genop('dec','wa')
    genop('jmp',l1)
    genopl(l2 '                                         :')
                                                        :(return)

g.chk

    genop('cmp','xs','lowspmin')
    genop('jb','sec06')
    gencode_c(2,'if(xs<v.lowspmin) { C_GOTO(sec06); } /* stack overflow check */' )
                                                        :(opdone)

decend

*   here at end of dic or dac to see if want label made public

    thislabel ? rtab(1) . thislabel '                   :'
    differ(pubtab[thislabel]) genop('global',thislabel)
                                                        :(opdone)

g.dac
	thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)
    t1 = i.type(i1)
    t2 = "" ;*(le(t1,2) "", le(t1,4) "d_offset_(", le(t1,6) "d_offset_(", "")
    genopl(thislabel,'d_word',t2 i.text(i1))
    
    eq(sectnow,3)			:s(g.dac_const)
    eq(sectnow,4)			:s(g.dac_no_const)
    	:(decend) 
g.dac_const
    current_label = do_current_label()
*    eq(current_label_is_base,1)   :f(g.dac.noext1)
    gencode_c(1,'word ' current_label ';' )

g.dac.noext1
    gencode_c(2,'.' current_label ' 		= ' get_c_assignment(i1) ',' )
g.dac.cdone1    
                                                        :(decend)
g.dac_no_const
    current_label = do_current_label()
*    eq(current_label_is_base,1)   :f(g.dac.noext2)
    gencode_c(1,'word ' current_label ';' )

g.dac.noext2
    gencode_c(2,'.' current_label ' 		= ' get_c_assignment(i1) ',' )
                                                        :(decend)
							
							
							
g.dic

    genopl(thislabel,'d_word',i.text(i1))
	thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)
    t1 = i.type(i1)
    t2 = "" ;*(le(t1,2) "", le(t1,4) "d_offset_(", le(t1,6) "d_offset_(", "")
    genopl(thislabel,'d_word',t2 i.text(i1))
    
    eq(sectnow,3)			:s(g.dic_const)
    eq(sectnow,4)			:s(g.dic_no_const)
    	:(decend) 
g.dic_const
    current_label = do_current_label()
*    eq(current_label_is_base,1)   :f(g.dic.noext1)
    gencode_c(1,'word ' current_label ';' )

g.dic.noext1
    gencode_c(2,'.' current_label ' 		= ' get_c_assignment(i1) ',' )
g.dic.cdone1    
                                                        :(decend)
g.dic_no_const
    current_label = do_current_label()
*    eq(current_label_is_base,1)   :f(g.dic.noext2)
    gencode_c(1,'word ' current_label ';' )

g.dic.noext2
    gencode_c(2,'.' current_label ' 		= ' get_c_assignment(i1) ',' )
                                                        :(decend)

g.drc

    genop('align',8)
    t1 = i.text(i1)
    t1 ? fence "+" = ""
    gopl = '//	'
    genop('double',t1)

*   note that want to attach label to last instruction

    t.label(code_statements[code_statements.n]) = '// ' thislabel
*    thislabel =                                         
	thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)

    
    eq(sectnow,3)			:s(g.drc_const)
    eq(sectnow,4)			:s(g.drc_noconst)
    :(decend)
g.drc_const
    current_label = do_current_label()
*    eq(current_label_is_base,1)   :f(g.drc.noext1)
    gencode_c(1,'double ' current_label ';' )

g.drc.noext1
    gencode_c(2,'.' current_label ' 		= ' get_c_assignment(i1) ',' )
        
    :(decend)
g.drc_noconst
    current_label = do_current_label()
*    eq(current_label_is_base,1)   :f(g.drc.noext2)
    gencode_c(1,'double ' current_label ';' )

g.drc.noext2
    gencode_c(2,'.' current_label ' 		= ' get_c_assignment(i1) ',' )

        
    :(decend)

g.dtc

*   change first and last chars to " (assume / used in source)

    t1 = i.text(i1)
    t1 tab(1) rtab(1) . t2
    t3 = remdr(size(t2),cfp_c)

*         t2 = "'" t2 "'"
*   append nulls to complete last word so constant length is multiple
*   of word word

    dtc_i = 1
    t4 =

g.dtc.1

    t4 = gt(dtc_i, 1) t4 ","
    t4 = t4 "'" substr(t2,dtc_i,1) "'"
    le(dtc_i = dtc_i + 1, size(t2))                     :s(g.dtc.1)

    t4 = ne(t3) t4 dupl(',0',cfp_c - t3)
    genopl(thislabel,'d_char',t4)
                                                        :(g.dtc.ccode)
    
g.dtc.ccode
    dtc_i = 1
    t1 = i.text(i1)
    t1 tab(1) rtab(1) . t2
    t3 = remdr(size(t2),cfp_c)
    t4 = ''
* t8 held const before
    t8 = ''
    eq(sectnow,3)			:s(g.dtc.ccode.1)
    eq(sectnow,4)			:f(decend)
    t8 = ''
    
g.dtc.ccode.1
	t5 = "'" substr(t2,dtc_i,1) "'"
        current_label = do_current_label()
*	eq(current_label_is_base,1)   :f(g.dtc.noext)
	gencode_c(1,"" t8 " char " current_label ';' )
g.dtc.noext	
	gencode_c(2,t8 "." current_label " = " t5 "," )
        le(dtc_i = dtc_i + 1, size(t2))                     :s(g.dtc.ccode.1)
	t6 = 0
g.dtc.ccode.2
	lt(t6,cfp_c - t3)				:f(decend)
        current_label = do_current_label()
	gencode_c(1,"" t8 " char " current_label ';' )
	gencode_c(2,t8 "." current_label " = 0," )
	t6 = t6 + 1	
	:(g.dtc.ccode.2)	
							
g.dbc

    genopl(thislabel,'d_word',getarg(i1))
    		:s(g.dbc_const)
    	:(decend) 
g.dbc_const	   
    t8 = ''
    eq(sectnow,3)                       :s(g.dbc.ccode)
	    eq(sectnow,4)                       :f(decend)
    t8 = ''	    
	    
g.dbc.ccode	    
    current_label = do_current_label()
*    eq(current_label_is_base,1)   :f(g.dbc.noext)
    gencode_c(1,'' t8 'd_word ' current_label ';' )
g.dbc.noext    
    gencode_c(2,t8 '.' current_label ' 		= ' get_c_argument(i1) ',' )
                                                        :(decend)
g.equ

    genopl(thislabel,'equ',i.text(i1))
    eq(parser_pass,1) :f(decend)
* make the definitions    
    c_definitions[thislabel] = table()
    c_definitions[thislabel]['upper_name'] = upper(thislabel)
    c_definitions[thislabel]['value'] = get_c_argument(i1)
    gencode_c(1,'#define ' c_definitions[thislabel]['upper_name'] '	(' c_definitions[thislabel]['value'] ')')
                                                        :(opdone)
g.exp
    
    ppm_cases[thislabel] = i.text(i1)
    genop('extern',thislabel)
     gencode_c(1,'extern void ' thislabel '();')
    thislabel =                                         :(opdone)

g.inp

    ppm_cases[thislabel] = i.text(i2)
    prc.count1 = ident(i.text(i1),'n') prc.count1 + 1
                                           :(opnext)

g.ejc
	gencode_c(2,char(12))
	lt(secnow,5)					:f(opdone)
	gencode_c(1,char(12))				:(opdone)
	
g.inr                                                   

    genop('')
                                                        :(opdone)

g.ttl
    
    genop('')
    gencode_c(2,'/* ' i.text(i1) '*/')
                                                        :(opdone)

g.sec

    genop('')
    fix_current_function('')			
    current_routine = ''
    sectnow = sectnow + 1                               :($("g.sec." sectnow))

*  procedure declaration section

g.sec.1

    genop('segment .text')
    genop('global','sec01')
    genopl('sec01' ':')         
    gencode_c(-2,'/*-------------------------------------------------------------------- sec01 --------*/')
    gencode_c(-2,'// procedure declarations ')
    				 :(opdone)

*   definitions section

g.sec.2

    genop('segment .data')
    genop('global','sec02')
    genopl('sec02' ':')                          
    gencode_c(-2,'/*-------------------------------------------------------------------- sec02 --------*/')
    gencode_c(-2,'// definitions ')
    
	   
		         :(opdone)

*  constants section

g.sec.3

    genop('segment .data')
    genop('global','sec03')
    genopl('sec03' ':')                             
    gencode_c(-2,'/*-------------------------------------------------------------------- sec03 --------*/')
    gencode_c(-2,'// constants ')
    gencode_c(1,'struct spitbol_constants {')
    gencode_c(-2,'const struct spitbol_constants c = {')
    
	    :(opdone)

*  working variables section

g.sec.4

    gencode_c(1,'}; /* struct spitbol_constants */ ')
    gencode_c(-2,'}; /* struct spitbol_constants c */ ')
    genop('global','esec03')
    genopl('esec03' '                                   :')
    gencode_c(-2,'/*-------------------------------------------------------------------- esec03 --------*/')
    gencode_c(-2,'// constants ')
    
    genop('segment .data')
    genop('global','sec04')
    genopl('sec04' ':')                           
    gencode_c(-2,'/*-------------------------------------------------------------------- sec04 --------*/')
    gencode_c(-2,'// working variables ')		      
    gencode_c(1,'struct spitbol_variables {')
    gencode_c(-2,'struct spitbol_variables v = {')
			          :(opdone)

*   here at start of program section.  if any n type procedures,
*   put out entry-word block declaration at end of working storage

g.sec.5

*   emit code to indicate in code section
*   get direction set to up.

    genop('global','esec04')
    genopl('esec04' '                                   :')

*         (gt(prc.count1) genopl('prc$' ':','times', prc.count1 ' dd 0'))

    genop('prc_                                         : times ' prc.count1 ' dd 0')
    
* prc_ for the _u entries - unrecursive
    gencode_c(1,'void (*prc_[' prc.count1 '])();' )
    cc = 0
    gencode_c(-2,'.prc_ = {' )
g.sec5.prcloop
    lt(cc,prc.finished_count1)		:f(g.sec5.prcdone)
    gencode_c(-2,' NULL,')
    cc = cc + 1		:(g.sec5.prcloop)
g.sec5.prcdone    
    gencode_c(-2,' }, /* non recursive call entry points */' )
    cc = ''
    
    
    
    genop('global','lowspmin')
    genopl('lowspmin' '                                 :','d_word','0')
    gencode_c(1,'word lowspmin;')
    gencode_c(-2,'.lowspmin=0,')
    
    genop('global','end_min_data')
    genopl('end_min_data' '                             :')
    gencode_c(1,'word end_min_data;')
    gencode_c(-2,'.end_min_data=0,')
    
    genop('segment .text')
    genop('global','sec05')
    genopl('sec05' ':')                              
    gencode_c(1,'}; /* struct spitbol_variables */ ')
    gencode_c(-2,'}; /* struct spitbol_variables v */ ')
    gencode_c(-2,'/*-------------------------------------------------------------------- esec04 --------*/')
    
    gencode_c(-2,'/*-------------------------------------------------------------------- sec05 --------*/')
    gencode_c(-2,'// Main code ')		      
    gencode_c(1,'extern void sec05();')
    gencode_c(-2,'void sec05() {')
    current_function_name = 'sec05'
    genz()
       
	     :(opdone)

*   stack overflow section.  output exi__n tail code

g.sec.6

    genop('global','sec06')
    genopl('sec06'  '                                   :', 'nop')
    gencode_c(-2,'/*-------------------------------------------------------------------- sec06 --------*/')
    gencode_c(-2,'// stack overflow ')		      
    gencode_c(1,'extern void sec06();')
    gencode_c(-2,'void sec06() {')
    current_function_name = 'sec06'
    genz()
                                                        :(opdone)

*   error section.  produce code to receive erb's

g.sec.7

    genop('global','sec07')
    gencode_c(-2,'/*-------------------------------------------------------------------- sec07 --------*/')
    gencode_c(-2,'// errors ')		      
    genopl('sec07' '                                    :')
    gencode_c(1,'extern void sec07();')
    gencode_c(1,'#define err_ sec07')
    gencode_c(-2,'void sec07() {')
    current_function_name = 'sec07'
    genz()
    
    flush()
    
*   error section.  produce code to receive erb's

*        allow for some extra cases in case of max.err bad estimate
    n1 = max.err + 8
    output = '  max.err ' max.err
    genopl('err_                                        :','xchg',reg.wa,'m_word [' rcode ']')
                                                        :(opdone)


opdone

    flush()                                             :(opnext)

*   here to emit before_code_statements, code_statements, after_opcode_statements. attach input label and
*   comment to first instruction generated.

flush
* dont flush anything if C didnt do anything
    eq(did_c_code,1)							:f(opdone.6)
* flush it    
    eq(after_opcode_statements.n) eq(before_code_statements.n) eq(code_statements.n)              :f(opdone1)

*   here if some statements to emit, so output single 'null' statement to get label
*   and comment field right.

    label = thislabel =
    outstmt(tstmt())                                    :(opdone.6)

opdone1

    eq(before_code_statements.n)                                        :s(opdone.2)
    i = 1

opdone.1

    outstmt(before_code_statements[i])
    le(i = i + 1, before_code_statements.n)                             :s(opdone.1)

opdone.2

    eq(code_statements.n)                                        :s(opdone.4)
    i = 1

opdone.3

    outstmt(code_statements[i])
    le(i = i + 1, code_statements.n)                             :s(opdone.3)

opdone.4        eq(after_opcode_statements.n)                            :s(opdone.6)

    i = 1
    ident(pifatal[incode])                              :s(opdone.5)
*   here if post incrementing code not allowed
    error('post increment not allowed for op ' incode)

opdone.5

    outstmt(after_opcode_statements[i])
    le(i = i + 1, after_opcode_statements.n)                             :s(opdone.5)

opdone.6

    after_opcode_statements.n = before_code_statements.n = code_statements.n =                    :(return)

flush_end

report

    output = lpad(num,10) '  ' text                
    gencode_c(2,'/* done withflush*/')
         :(return)


g.end


* if we are pass 2 and this is the end - close the last function 
        eq(parser_pass,1) :s(opnext.noendfunction)
	fix_current_function('')			
        flush()

opnext.noendfunction	
* ok done compiling

    &dump = 0
    ident(havehdr)                                      :s(g.end.2)

*   here to copy remaining part from hdr file

g.end.1

    line = hdrfile                                      :f(g.end.2)
    ntarget = ntarget + 1
    noutlines = noutlines + 1
    outfile = line                                      :(g.end.1)

g.end.2

*   here at end of code generation.

    endfile(1)
    endfile(2)
    endfile(3)
    report(nlines,          'lines read')
    report(nstmts,          'statements processed')
    report(ntarget,         'target code lines produced')
    report(&stcount,        'spitbol statements executed')
    report(max.err,         'maximum err/erb number')
    report(prc.count1,      'prc count')
    output  = '  ' gt(prc.count,prc.count1)
.         '  differing counts for n-procedures          :'
.         ' inp ' prc.count1 ' prc ' prc.count
    differ(nerrors) report(nerrors,'errors detected')

    errfile = '* ' max.err ' maximum err/erb number'
    errfile  = '* ' prc.count ' prc count'
.               differ(lasterror) '  the last error was in line ' lasterror

    &code   = ne(nerrors) 2001
    report(collect(), 'free words')
                                                   :(end)


convert_value_c
	a = &anchor
	&anchor = 1
	b = x
	c = ''
	d = ''
cvl1 
	ident(b,'')		:s(cvd1)
	b p.c_token . c = '' 	:f(cvnon)
	c p.c_label 		:f(cvad)
	differ(section_labels[3][c]) :s(cv_constant)
	differ(section_labels[4][c]) :s(cv_variable)
	ident(c_definitions[c],'') :s(cvad)
	c = c_definitions[c]['upper_name'] :f(cvad)
	:(cvad)
cvnon   terminal = 'huh [' b '] '
	b any(1) . c = ''
	:(cvad)
cv_constant
	c = 'c.' c
	:(cvad)
cv_variable
	c = 'v.' c
	:(cvad)
	
cvad	d = d c
	:(cvl1)
cvd1	&anchor = a
	convert_value_c = d
	x arbno(any(&alphabet)) 'int_r'	:f(return)
	terminal = x '	->	' d
	:(return)

							
														
																		
* made to handle assignments fo void *() functions and asddresses of other constants or variables
convert_value_assignment
	a = &anchor
	&anchor = 1
	b = x
	c = ''
	d = ''
cval1 
	ident(b,'')		:s(cvad1)
	b p.c_token_with_dot . c = '' 	:f(cvanon)
	c p.c_label_with_dot 		:f(cvaad)
	ident(c,'double')	:s(cvaad)
	cprime = c
	cprime ( any('abcdefghijklmnopqrstuvwxyz') '.' ) = ''
	ident(section_labels[5][cprime])  :f(cva_procedure)
*	ident(c_definitions[c],'') :f(cvaad)
*	c = c_definitions[c]['upper_name'] :s(cva_constant)
	ident(section_labels[3][cprime]) :f(cva_constant)
	ident(section_labels[4][cprime]) :f(cva_variable)
	:(cvaad)
cva_constant
	c = '(word)(&' c ')'	:(cvaad)
cva_variable
	c = '(word)(&' c ')'	:(cvaad)
cva_procedure
	c = '(word)(' c ')'	:(cvaad)
cvanon   terminal = 'huh [' b '] '
	b any(1) . c = ''

cvaad	d = d c
	:(cval1)
cvad1	&anchor = a
	convert_value_assignment = d
	:(return)
												
			
							
upper   upper   =  replace(s, xUP_LO, xLO_UP)      :(return)
							

do_current_label
		
    ident(position_label,'')    		:s(better_set_it_now)
    ident(thislabel,position_label)		:s(do_current_label.use_what_we_got)
    ident(thislabel,'')				:s(do_current_label.use_what_we_got)
better_set_it_now    
    current_label_is_base = 1
    position_label = thislabel
    position_sequence = 0
    do_current_label = position_label
    do_current_label arbno(any(&alphabet)) . frrrff ':'  = frrrff
    	:(return)
do_current_label.use_what_we_got
	current_label_is_base = 0
	position_sequence = position_sequence + 1
	do_current_label = position_label '__pos__' position_sequence
    do_current_label arbno(any(&alphabet)) . frrrff ':'  = frrrff
	:(return)    





fix_current_function
	ge(sectnow,5)					:f(return)
	ident(current_function_name)			:s(return)	
        eq(gone_baby_gone,1)				:s(fc.skip_goto)
	ident(golabel)					:s(fc.skip_goto)
	gencode_c(-2,'C_GOTO(' ll_filter(golabel) ');' )
fc.skip_goto
	gencode_c(-2,'} /* ' current_function_name ' */')
	gencode_c(-2,char(10))
	current_function_name = ''
	gone_baby_gone = 0
	:(return)


end
