

-title mincod                                           : phase 2 translation from minimal tokens to 80386 code
-stitl description

*   Copyright 1987-2012 robert b. k. dewar and mark emmer.
*   Copyright 2012-2017 david shields

*   this file is part of macro spitbol.

*   macro spitbol is free software: you can redistribute it and/or modify
*   it under the terms of the gnu general public license as published by
*   the free software foundation, either version 2 of the license, or
*   (at your option) any later version.

*   macro spitbol is distributed in the hope that it will be useful,
*   but without any warranty; without even the implied warranty of
*   merchantability or fitness for a particular purpose.  see the
*   gnu general public license for more details.

*   you should have received a copy of the gnu general public license
*   along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.


*   this program takes input file in minimal token form and
*   produces assembly code for intel x64 processor.
*   the program obtains the name of the file to be translated from the
*   command line string in host(0).

*   options relating to the processing of comments can be
*   changed by modifying the source.

*   in addition to the minimal token file, the program requires the
*   name of a "machine definition file" that contains code specific
*   to a particular 80386 assembler.

*   you may also specify option flags on the command line to control the
*   code generation.  the following flags are processed:
*       compress        generate tabs rather than spaces in output file
*       comments        retain full-line and end-of-line comments

*   the variable arch is set equal to the uppercase name of the machine
*   being processed.  specific tests upon this variable are discouraged, as
*   all machine-dependent code should be placed in the machine-definition
*   file if possible.

*   in addition to the normal minimal register complement, one scratch
*   work register, w0 is defined.
*   see the register map below for specific allocations.

*   this program is based in part on earlier translators for the
*   it is based in part on earlier translators for the dec vax
*   (vms and un*x) written by steve duff and robert goldberg, and the
*   pc-spitbol translator by david shields.

*  to run under spitbol:
*       spitbol -u "<file>:<machine>[:flag:...:flag]" codlinux.spt

*       reads <file>.lex        containing tokenized source code
*       writes <file>.s         with 80386 assembly code
*       also writes <file>.err  with err and erb error messages
*       parts of m.hdr  are prepended and appended to <file>.s
*       also sets flags         to 1 after converting names to upper case
*       also reads <file>.pub   for debug symbols to be declared public

*   example:

*       spitbol -u v37:dos:compress codlinux.spt


*   revision history:

    version = 'v1.12'
    rcode = '_rc_'


-eject

*   keyword initialization

    &anchor = 1;    &stlimit = 10000000;    &trim   = 1;  &dump = 1

*   useful constants

    letters = 'abcdefghijklmnopqrstuvwxyz'
    ucase   = letters
    lcase   = 'abcdefghijklmnopqrstuvwxyz'
    nos     = '0123456789'
    tab     = char(9)


*   default the parameter string if none present

    fileprefix = "s"

*        cfp_b is bytes per word, cfp_c is characters per word
*        these should agree with values used in translator
*  set target-dependent configuration parameters

*        cfp_b is bytes per word, cfp_c is characters per word
*        these should agree with values used in translator
    cfp_b = 8
    cfp_c = 8
    log_cfp_b = '3'
    log_cfp_c = '3'
    op_w = 'q'
    op_c = 'b'

config.done


*   set z_trace to enable instruction by instruction trace
    z_trace = 1
    z_trace = 0
*   z_limit is maximum number of calls to be generated if non-zero
    z_limit = 000
*   set z_first non-zero to skip first number of instructions that would generate trace
    z_first = 0
*   will set in_executable when in part of program where executable
*   instructions may occur
    z_exec = 0

*   z_suspend is set to temporarily disable the trace.
    z_suspend = 0
*   set in_skip when should not insert trace code, else assembly errors result.
*   start with skip on, turn off when see first start of code.
    z_skip = 1
*   skip_on and skip_off are labels indicating the start and end,
*   respectively, of sections of the code that should not be traced,
*   usually because they contain a loop instruction that won't
*   compile if too much trace code is inserted.
    skip_on = table(50)
    skip_off = table(50)

        define('skip_init(s)on,off')                    :(skip_init.end)

skip_init       s break(':') . on ':' rem . off         :f(return)

    skip_on[on] = 1
    skip_off[off] = 1                                   :(return)

skip_init.end

*   skip_init('start:ini03')
    skip_init('gbcol                                    :gtarr')
*   skip_init('gtn01:gtnvr')
*   skip_init('bpf05:bpf07')
*   skip_init('scv12:scv19')
*   skip_init('exbl1:exbl2')
*   skip_init('exbl5:expan')
*   skip_init('prn17:prn18')
*   skip_init('ini11:ini13')
*   skip_init('oex13:oexp2')
*   skip_init('oex14:oexp6')
*   skip_init('bdfc1:b_efc')
*   skip_init('sar01:sar10')
*   skip_init('srpl5:srpl8')
*   skip_init('pflu1:pflu2')
*   skip_init('prpa4:prpa5')
*   skip_init('prn17:prn18')
*   skip_init('prtvl:prtt1')
*   skip_init('trim4:trim5')
*   skip_init('prnl1:prnl2')
*   skip_init('prti1:prtmi')
*   skip_init('srpl5:srpl8')



*   data structures

    data('minarg(i.type,i.text)')
    data('tstmt(t.label,t.opc,t.op1,t.op2,t.op3,t.comment,t.other)')

    sectnow = 0

*   ppm_cases gives count of ppm/err statments that must follow call to
*   a procedure

    ppm_cases = table(50,,0)


*   function definitions

*   crack parses stmt into a stmt data plex and returns it.
*   it fails if there is a syntax error.

    define('crack(line)operands,operand,char')

    define('chktrace()')
*        comregs - map minimal register names to target register names
    define('comregs(line)t,pre,word')

*   error is used to report an error for current statement

    define('error(text)')
    define('flush()')
    define('genz()')
    define('genaop(stmt)')
    define('genbop(stmt)')
    define('genlab()')
    define('genop(gopc,gop1,gop2,gop3,other)')
    define('genopl(gopl,gopc,gop1,gop2,gop3,other)')
    define('genrep(op)l1,l2)')
    define('getarg(iarg,imem)l1,l2,t1,t2,tmem')
    define('ifreg(iarg)')
    define('memmem()t')
    define('prcent(n)')
    define('prsarg(iarg)l1,l2')
    define('report(num,text)')
    define('tblini(str)pos,cnt,index,val,lastval')

*   outstmt is used to send a target statement to the target code
*   output file outfile

    define('outstmt(ostmt)label,opcode,op1,op2,op3,comment,t,stmtout,other')

*   readline is called to return the next non-comment line from
*   the minimal input file (infile <=> lu1).   note that it will
*   not fail on eof, but it will return a minimal end statement

    define('readline()')

     p.comregs = break(letters) . pre span(letters) . word

*   exttab has entry for external procedures

    exttab = table(50)

*   labtab records labels in the code section, and their line numbers

    labtab = table(500)

*   for each statement, code in generated into three
*   arrays of statements:

*   astmts: statements after opcode (()+, etc.)
*   bstmts: statements before code (-(), etc)
*   cstmts: generated code proper

    astmts = array(20,'')
    bstmts = array(10,'')
    cstmts = array(20,'')

*   genlabels is count of generated labels (cf. genlab)

    genlabels = 0


*   initialize variables

    labcnt = noutlines = nlines = nstmts = ntarget = nerrors = 0
    lastopc = lastop1 = lastop2 =
    data_lc = 0
    max_exi = 0

*   initial patterns

*   p.csparse parses tokenized line
    p.csparse = '{' break('{') . inlabel
.       '{' break('{') . incode
.       '{' break('{') . iarg1
.       '{' break('{') . iarg2
.       '{' break('{') . iarg3
.       '{' break('{') . incomment
    '{' rem . slineno

*   dispatch table

    getargcase = table(27)
    getargcase[1] = .getarg.c.1;   getargcase[2] = .getarg.c.2
    getargcase[3] = .getarg.c.3;   getargcase[4] = .getarg.c.4
    getargcase[5] = .getarg.c.5;   getargcase[6] = .getarg.c.6
    getargcase[7] = .getarg.c.7;   getargcase[8] = .getarg.c.8
    getargcase[9] = .getarg.c.9;   getargcase[10] = .getarg.c.10
    getargcase[11] = .getarg.c.11; getargcase[12] = .getarg.c.12
    getargcase[13] = .getarg.c.13; getargcase[14] = .getarg.c.14
    getargcase[15] = .getarg.c.15; getargcase[16] = .getarg.c.16
    getargcase[17] = .getarg.c.17; getargcase[18] = .getarg.c.18
    getargcase[19] = .getarg.c.19; getargcase[20] = .getarg.c.20
    getargcase[21] = .getarg.c.21; getargcase[22] = .getarg.c.22
    getargcase[23] = .getarg.c.23; getargcase[24] = .getarg.c.24
    getargcase[25] = .getarg.c.25; getargcase[26] = .getarg.c.26
    getargcase[27] = .getarg.c.27


*   pifatal maps minimal opcodes for which no a code allowed
*   to nonzero value. such operations include conditional
*   branches with operand of form (x)+

    pifatal = tblini(
.       'aov[1]beq[1]bne[1]bge[1]bgt[1]bhi[1]ble[1]blo[1]'
.       'blt[1]bne[1]bnz[1]ceq[1]cne[1]mfi[1]nzb[1]zrb[1]')

*        trace not working for mvc (x64)

    is_executable = table(100)
    s =
+       'add adi adr anb aov atn '
+       'bct beq bev bge bgt bhi ble blo blt bne bnz bod '
+       'brn bri bsw btw bze ceq chk chp cmb cmc cmp cne csc '
+       'cos ctb ctw cvd cvm dca dcv eti dvi dvr erb esw etx flc '
+       'ica icp icv ieq ige igt ile ilt ine ino iov itr jmp '
+       'jsr lch lct lcp lcw ldi ldr lei lnf lsh lsx mcb mfi mli mlr '
+       'mnz mov mti mvw mwb ngi eti ngr nzb orb plc prc psc '
+       'req rge rgt rle rlt rmi rne rno rov rsh rsx rti rtn sbi sbr '
+       'sch scp sin sqr ssl sss sti str sub tan trc wtb xob zer '
+       'zgb zrb'

*        don't trace mvc as doing so causes just 'end' to fail. sort out later. (ds 01/09/13)

is_exec.1

    s len(3) . opc ' ' =                                :f(is_exec.2)
    is_executable[opc] = 1                              :(is_exec.1)

is_exec.2

-stitl main program
*   here follows the driver code for the "main" program.


*   loop until program exits via g.end

*   opnext is invoked to initiate processing of the next line from
*   readline.
*   after doing this, opnext branches to the generator routine indicated
*   for this opcode if there is one.
*   the generators all have entry points beginning
*   with "g.", and can be considered a logical extension of the
*   opnext routine.  the generators have the choice of branching back
*   to dsgen to cause the thisstmt plex to be sent to outstmt, or
*   or branching to dsout, in which case the generator must output
*   all needed code itself.

*   the generators are listed in a separate section below.


*   get file name


*  get definition file name following token file name, and flags.

*        fileprefix ? break(';:') . fileprefix len(1) (break(';:') | rem) . target
*+              ((len(1) rem . flags) | '')
*        $replace(target,lcase,ucase) = 1

*  parse and display flags, setting each one's name to non-null value (1).

                                                        :(flgs.skip)
flgs

   flags ? ((len(1) break(';                            :')) . flag len(1)) |
+        ((len(1) rem) . flag) =                        :f(flgs2)
    flag = replace(flag,lcase,ucase)
    output = "  flag                                    : " flag
    $flag = 1                                           :(flgs)

flgs.skip

flgs2

*   various constants

    comment.delim = '//'

*   branchtab maps minimal opcodes 'beq', etc to desired
*   target instruction

    branchtab = table(10)
    branchtab['beq'] = 'je'
    branchtab['bne'] = 'jne'
    branchtab['bgt'] = 'ja'
    branchtab['bge'] = 'jae'
    branchtab['ble'] = 'jbe'
    branchtab['blt'] = 'jb'
    branchtab['blo'] = 'jb'
    branchtab['bhi'] = 'ja'

*   optim.tab flags opcodes capable of participating in or optimization
*                in outstmt routine

    optim.tab = table(10)
    optim.tab<"and"> = 1
    optim.tab<"add"> = 1
    optim.tab<"sub"> = 1
    optim.tab<"neg"> = 1
    optim.tab<"or"> = 1
    optim.tab<"xor"> = 1
    optim.tab<"shr"> = 1
    optim.tab<"shl"> = 1
    optim.tab<"inc"> = 1
    optim.tab<"dec"> = 1


*   ismem is table indexed by operand type which is nonzero if
*   operand type implies memory reference.

    ismem = array(30,0)
    ismem<3> = 1; ismem<4> = 1; ismem<5> = 1
    ismem<9> = 1; ismem<10> = 1; ismem<11> = 1
    ismem<12> = 1; ismem<13> = 1; ismem<14> = 1
    ismem<15> = 1

*   regmap maps minimal register name to target machine
*   register/memory-location name.

    regmap = table(30)
    regmap['xl'] = 'xl';  regmap['xt'] = 'xt'
    regmap['xr'] = 'xr';  regmap['xs'] = 'xs'
    regmap['wa'] = 'wa';  regmap['wb'] = 'wb'
    regmap['wc'] = 'wc';  regmap['ia'] = 'ia'
    regmap['cp'] = 'cp'
*        w0 is temp register
    regmap['w0'] = 'w0'
    w0 = regmap['w0']

*   quick reference:
    reg.wa = regmap['wa']
    reg.cp = regmap['cp']

*   reglow maps register to identify target, so
*   can extract 'l' part.

    reglow = table(4)
    reglow['wa'] = 'wa_l'
    reglow['wb'] = 'wb_l'
    reglow['wc'] = 'wc_l'

*   real_op maps minimal real opcode to machine opcode

    real_op = table(10)
    real_op['adr'] = 'fadd'
    real_op['atn'] = 'fpatan'
    real_op['chp'] = 'frndint'
    real_op['cos'] = 'fcos'
    real_op['dvr'] = 'fdiv'
    real_op['ldr'] = 'fld'
    real_op['mlr'] = 'fmul'
    real_op['ngr'] = 'fchs'
    real_op['sbr'] = 'fsub'
    real_op['sin'] = 'fsin'
    real_op['sqr'] = 'fsqrt'
    real_op['str'] = 'fst'

*   other definitions that are dependent upon things defined in the
*   machine definition file, and cannot be built until after the definition
*   file has been read in.

*   p.outstmt examines output lines for certain types of comment contructions

    fillc     = (ident(compress) " ",tab)
    p.outstmt = (break(fillc) . label span(fillc)) . leader
+                       comment.delim rem . comment
    p.alltabs = span(tab) rpos(0)

*   strip end of comments if y

    strip_comment = (differ(comments) 'n', 'y')

    filenami = fileprefix '.lex'
    input(.infile,1,filenami)                           :s(inputok)

inputok

    output = '  input lex file                          : ' filenami

*   associate output files.

    filenamo = fileprefix '.c'
    output(.outfile,2,filenamo)                         :s(outputok)
    output = '  cannot open c file: ' filenamo        :(end)

outputok

    output = '  output c file                         : ' filenamo


*  open file for compilation of minimal err and erb messages

    output(.errfile,3, fileprefix ".err")               :s(err_ok)
    output = "  cannot open error message file: " fileprefix ".err":(end)
err_ok


*   then copy contents of c.hdr (if it exists) to outfile
*   stop at line with just 'end' or end of file

    noutlines = noutlines + 1

    input(.hdrfile,4,'c.hdr')                         :f(nohdr)
    havehdr = 1

*         output = '  input header file:  ' hdr  '.hdr'

hdrcopy

    line = hdrfile                                      :f(hdrend)
    ident(line,'end')                                   :s(nohdr)
    outfile = line
    noutlines = noutlines + 1                           :(hdrcopy)

hdrend

     havehdr =

nohdr

*   will have havehdr non-null if more remains to copy out at end.

*   read in pub file if it exists.  this contains a list of symbols to
*   be declared public when encountered.

    pubtab = table(2)
    input(.pubfile,5, fileprefix ".pub")                :f(nopub)
    pubtab = table(101)

pubcopy

    line = pubfile                                      :f(pubend)
    pubtab[line] = 1                                    :(pubcopy)

pubend

     endfile(5)

nopub

                                                        :(dsout)
    &trace = 2000
    &ftrace = 1000
*   &profile = 1

dsout

opnext

     thisline = readline()
     crack(thisline)                                    :f(dsout)
     op_ = incode '_'

*   append ':' after label if in code or data.

*   output label of executable instruction immediately if there is one,
*   as it simplifies later processing, especially for tracing.

    ident(inlabel)                                      :s(opnext.1)
    thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)

*   keep the label as is is not in executable code

    lt(sectnow,5)                                       :s(opnext.1)

*   here if in code, so output label now
*   defer label processing for ent to allow emission of alignment ops for x86.

    ident(incode,'ent')                                 :s(opnext.1)
    outfile = thislabel
    outlines = outlines + 1

*   set lastlabel so can check to avoid emitting duplicate label definitions

    lastlabel = thislabel

*   clear out label info once generated

    label = thislabel =

opnext.1

    thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)
    i1 = prsarg(iarg1)
    i2 = prsarg(iarg2)
    i3 = prsarg(iarg3)
    tcomment = comregs(incomment) '} ' incode ' ' i.text(i1) ' '
.               i.text(i2) ' ' i.text(i3)
    argerrs = 0
                                                        :($('g.' incode))
*   here if bad opcode

ds01

    error('bad op-code')                                :(dsout)

*   generate tokens.

ds.typerr

    error('operand type zero')                          :(dsout)

-stitl comregs(line)t,pre,word
comregs

    line p.comregs =                                    :f(comregs1)
    word = eq(size(word),2) differ(t = regmap[word]) t
    comregs = comregs pre word                          :(comregs)

comregs1 comregs = comregs line                         :(return)
-stitl crack(line)

*   crack is called to create a stmt plex containing the various parts  of
*  the minimal source statement in line.  for conditional assembly ops,
*  the opcode is the op, and op1 is the symbol.  note that dtc is handled
*   as a special case to assure that the decomposition is correct.

*   crack prints an error and fails if a syntax error occurs.

crack

    nstmts  = nstmts + 1
    op1 = op2 = op3 = typ1 = typ2 = typ3 =
    line    p.csparse                                   :s(return)
*   here on syntax error

    error('source line syntax error')                   :(freturn)
-stitl error(text)
*   this module handles reporting of errors with the offending
*   statement text in thisline.  comments explaining
*   the error are written to the listing (including error chain), and
*   the appropriate counts are updated.

error

    outfile = '* *???* ' thisline
    outfile = '*       ' text
.                 (ident(lasterror),'. last error was line ' lasterror)
    lasterror = noutlines
    noutlines = noutlines + 2
    le(nerrors = nerrors + 1, 10)                       :s(dsout)
    output = 'too many errors, quitting'                :(end)

-stitl genaop(stmt)
genaop

    astmts[astmts.n = astmts.n + 1] = stmt              :(return)

-stitl genbop(stmt)
genbop

    bstmts[bstmts.n = bstmts.n + 1] = stmt              :(return)

-stitl genlab()
*   generate unique labels for use in generated code

genlab

    genlab = '_l' lpad(genlabels = genlabels + 1,4,'0') :(return)

-stitl genopl(gopl,gopc,gop1,gop2,gop3,other)
*   generate operation with label

genopl
	ident(other,'') :s(sdsdds)
	terminal = other
sdsdds	
    cstmts[cstmts.n = cstmts.n + 1] =
.               tstmt(gopl,gopc,gop1,gop2,gop3,other)         :(return)

-stitl genop(gopc,gop1,gop2,gop3,other)
*   generate operation with no label

genop

    genopl(,gopc,gop1,gop2,gop3,other)                        :(return)


-stitl getarg(iarg,imem)

getarg

    tmem = (differ(imem) '', 'm_word ')
    l1 = i.text(iarg)
    l2 = i.type(iarg)
    eq(l2)                                              :f($(getargcase[l2]))
    getarg = l1                                         :(return)

*  int

getarg.c.1

   getarg = l1                                          :(return)

*  dlbl

getarg.c.2

   getarg = l1                                          :(return)

*  wlbl, clbl

getarg.c.3
getarg.c.4

   getarg = tmem '[' l1 ']'                             :(return)

*  elbl, plbl

getarg.c.5
getarg.c.6

   getarg = l1                                          :(return)

*  w,x, map register name

getarg.c.7
getarg.c.8

    getarg = regmap[l1]                                 :(return)


*  (x), register indirect
getarg.c.9

    l1 len(1) len(2) . l2
    l2 = regmap[l2]
    getarg = tmem '[' l2 ']'                            :(return)

*  (x)+, register indirect, post increment
*  use lea reg,[reg+cfp_b] unless reg is esp, since it takes an extra byte.
*  actually, lea reg,[reg+cfp_b] and add reg,cfp_b are both 2 cycles and 3 bytes
*  for all the other regs, and either could be used.

getarg.c.10

    l1 = substr(l1,2,2)
    t1 = regmap[l1]
    getarg = tmem '[' t1 ']'
    (ident(l1,'xs') genaop(tstmt(,'add',t1,'cfp_b','')))   :s(return)
    genaop(tstmt(,'lea',t1,'[' t1 '+cfp_b],',''))           :(return)

*   -(x), register indirect, pre decrement

getarg.c.11

    t1 = regmap[substr(l1,3,2)]
    getarg = tmem '[' t1 ']'
    genbop(tstmt(,'lea',t1,'[' t1 '-cfp_b]',''))           :(return)

*  int(x)
*  dlbl(x)

getarg.c.12
getarg.c.13

    l1 break('(') . t1 '(' len(2) . t2
    getarg = tmem '[(cfp_b*' t1 ')+' regmap[t2] ']'     :(return)

*   name(x), where name is in working section

getarg.c.14
getarg.c.15

    l1 break('(') . t1 '(' len(2) . t2
    getarg = tmem '[' t1 '+'  regmap[t2] ']'            :(return)

*  signed integer

getarg.c.16 getarg = l1                                 :(return)

*  signed real

getarg.c.17 getarg = l1                                 :(return)

*   =dlbl

getarg.c.18

    getarg = substr(l1,2)                               :(return)

*   *dlbl

getarg.c.19

    getarg = 'cfp_b*' substr(l1,2)                      :(return)

*   =name (data section)

getarg.c.20
getarg.c.21

    getarg =  substr(l1,2)                              :(return)

*   =name (program section)

getarg.c.22

    getarg =  substr(l1,2)                              :(return)

*   pnam, eqop

getarg.c.23
getarg.c.24

   getarg = l1                                          :(return)

*  ptyp, text, dtext

getarg.c.25
getarg.c.26
getarg.c.27

   getarg = l1                                          :(return)

-stitl memmem()t
memmem

*   memmem is called for those ops for which both operands may be
*   in memory, in which case, we generate code to load second operand
*   to pseudo-register 'w0', and then modify the second argument
*   to reference this register

    eq(ismem[i.type(i1)])                               :s(return)
    eq(ismem[i.type(i2)])                               :s(return)

*   here if memory-memory case, load second argument

    t = getarg(i2)
    i2 = minarg(8,'w0')
    genop('mov','w0',t)                                 :(return)

-stitl prcent(n)
prcent prcent = 'prc_+cfp_b*' ( n - 1)                  :(return)

-stitl outstmt(ostmt)label,opcode,op1,op2,op3,comment,other)
*   this module writes the components of the statement
*   passed in the argument list to the formatted .s file

outstmt label = t.label(ostmt)

*   clear label if definition already emitted

    label = ident(label, lastlabel)

outstmt1

    comment = t.comment(ostmt)

*  ds suppress comments

    comment = tcomment = comments =
                                                        :(outstmt2)
*   attach source comment to first generated instruction

    differ(comment)                                     :s(outstmt2)
    ident(tcomment)                                     :s(outstmt2)
    comment = tcomment; tcomment =
outstmt2

    opcode = t.opc(ostmt)
    op1 = t.op1(ostmt)
    op2 = t.op2(ostmt)
    op3 = t.op3(ostmt)
    other = t.other(ostmt)
    ident(other,'')	:s(rrrr)
    terminal = 'qqq' other
rrrr
    l2 = ''
    ident(label,'')	:s(l2_is_ok)
    l2 = ': '
l2_is_ok
    paren_opcode1 = ''
    paren_opcode2 = ''
    ident(opcode,'') :s(paren_is_ok)
    paren_opcode1 = '('
    paren_opcode2 = ')'
paren_is_ok    
    ident(other,'')	:f(outstmtoth)
    differ(compress)                                    :s(outstmt3)
    stmtout = label l2 ' ' opcode paren_opcode1
.                 (ident(op1), op1
.                       (ident(op2), ',' op2
.                               (ident(op3), ',' op3)))  paren_opcode2
.       (ident(strip_comment,'y'), ' ' (ident(comment), '//') comment)
.                                                       :(outstmt4)
outstmt3

    stmtout = label l2 tab opcode tab
.                 (ident(op1), op1
.                   (ident(op2), ',' op2
.                     (ident(op3), ',' op3)))
.       (ident(strip_comment,'y'), tab (ident(comment), '//') comment)

**      send text to outfile

**

outstmt4

**
**      send text to output file if not null.

*        stmtout = replace(trim(stmtout),'$','_')

    stmtout = trim(stmtout)
    ident(stmtout)                                      :s(return)
    eq(z_trace)                                         :s(outstmt5)

*        here if trace code desired for executable instructions

    chktrace()

outstmt5

    ident(stmtout)                                      :s(return)
    outfile = stmtout
    ntarget = ntarget + 1
    noutlines = noutlines + 1

*   record code labels in table with delimiter removed.
    (ge(sectnow,5) differ(thislabel))                   :f(return)
    label ? break(':') . label                          :f(return)
    labtab<label> = noutlines                           :(return)

outstmtoth
	terminal = 'qqq' other
	stmtout =   other (ident(strip_comment,'y'), tab (ident(comment), '//') comment)
	:(outstmt4)


-stitl  chktrace()
chktrace

*                                                :(return)
*        output = 'chktrace:' inlines ':' label ':' stmtout
*        output = differ (label) 'chktrace label:' label ':'
*        turn off skip mode when begin executable code

    clabel = inlabel
    old_z_skip = z_skip
    old_z_exec = z_exec
    old_is_exec = is_exec
    z_skip = ident(inlabel,'s_aaa') 0

*        incode ? any(lcase)                     :s(return)

    uopcode  = replace(incode, lcase,ucase)

*   do not trace bsw (for now)

    ident(uopcode,'bsw')                                :s(return)
    is_exec = is_executable[uopcode]
    z_exec = ne(z_trace)  ident(inlabel, 's_aaa') 1
    z_exec = gt(nlines,2186) 1

*        need to skip certain blocks since otherwise get branches that are too long
*        skip when in code that won't assemble if try to trace
*        this was discovered on a case-by-case basis.

    z_skip  = differ(inlabel) differ(skip_on[inlabel]) 1
    z_skip  = differ(inlabel) differ(skip_off[inlabel]) 0

    ne(z_skip)                                          :s(return)
    eq(z_exec)                                          :s(return)
    eq(is_exec)                                         :s(return)
*        here to emit trace. need to emit trace after label if there is label
*        ident(inlabel)                          :s(chktrace.1)
*        only trace at labels since get jumps that are too removed otherwise
*        ident(label)                            :s(return)
*        here to emit trace code when there is label
*        first need to emit label, then fall through

*        stmtout ? break_ws  . label spanws  rem . body  :f(outstmt5)
*        stmtout = tab body
*        outfile = label
*        label =
    ne(in_gcol)                                         :s(return)

chktrace.1

    genz()
                                                        :(return)
genz

*        no trace if trace has been suspended
*        output = ne(z_suspend) 'z_suspend ' thisline

    ne(z_suspend)                                       :s(return)

*  only trace at label definition
*        ident(thislabel)                        :s(return)

    z_count = z_count + 1
    gt(z_first) le(z_count,z_first)                     :s(return)
    gt(z_limit)  gt(z_count, z_limit)                   :s(return)

*        always generate trace if at label definition

    z_desc = '"' replace(thisline,'{',' ') '"'
    outfile = tab 'zzz' tab z_count ',' nlines ',' z_desc
    outlines = outlines + 1
                                                        :(return)

-stitl prsarg(iarg)
prsarg

    prsarg = minarg(0)
    iarg break(',') . l1 ',' rem . l2                   :f(return)
    prsarg = minarg(convert(l1,'integer'),l2)           :(return)

-stitl readline()
*   this routine returns the next statement line in the input file
*   to the caller.  it never fails.  if there is no more input,
*   then a minimal end statement is returned.
*   comments are passed through to the output file directly.


readline

    readline = infile                                   :f(rl02)
    nlines  = nlines + 1
    ident( readline )                                   :s(readline)

readline.0

    leq( substr(readline,1,1 ),'*' )                    :f(rl01)
    z_skip = ident(readline,'*z+') 0                    :s(readline)
    z_skip = ident(readline,'*z-') 1                    :s(readline)

*  force skip of full line comments
                                                        :(readline)
*   only print comment if requested.

    ident(strip_comment,'n')                            :f(readline)
    readline len(1) = ';'
    outfile = readline
    noutlines = noutlines + 1                           :(readline)

*   here if not a comment line

rl01                                                    :(return)

*   here on eof

rl02

    readline = '       end'
                                                        :(rl01)
-stitl tblini(str)
*   this routine is called to initialize a table from a string of
*   index/value pairs.

tblini

    pos     = 0

*   count the number of "[" symbols to get an assessment of the table
*   size we need.

tin01

    str     (tab(*pos) '[' break(']') *?(cnt = cnt + 1) @pos)
.                                                       :s(tin01)

*   allocate the table, and then fill it. note that a small memory
*   optimisation is attempted here by trying to re-use the previous
*   value string if it is the same as the present one.

    tblini   = table(cnt)

tin02

    str     (break('[') $ index len(1) break(']') $ val len(1)) =
.                                                       :f(return)
    val     = convert( val,'integer' )
    val     = ident(val,lastval) lastval
    lastval = val
    tblini[index] = val                                 :(tin02)
-stitl generators

ifreg

    ge(i.type(iarg),7) le(i.type(iarg),8)               :f(freturn)s(return)

g.flc

    output = 'flc  not supported ' (end)
    t1 = (eq(cfp_b,cfp_c) reglow[getarg(i1)], getarg(i1))
    t2 = genlab()

*   z_suspend = 1

    genop('cmp',t1,"'A'")
    genop('jb', t2 )
    genop('cmp',t1,"'Z'")
    genop('ja', t2)
    genop('add',t1,'32')
    genopl(t2 '                                         :')

*   z_suspend = 0
                                                        :(opdone)

g.mov

*   perhaps change mov x,(xr)+ to
*        mov ax,x; stows

*   perhaps do  mov (xl)+,wx as
*        lodsw
*        xchg ax,tx
*   and also mov (xl)+,name as
*        lodsw
*        mov name,w0
*   need to process memory-memory case
*   change 'mov (xs)+,a' to 'pop a'
*   change 'mov a,-(xs)' to 'push a'

    i.src = i2; i.dst = i1
    t.src = i.text(i.src); t.dst = i.text(i.dst)
    ident(t.src,'(xl)+')                                :s(mov.xlp)
    ident(t.src,'(xt)+')                                :s(mov.xtp)
    ident(t.src,'(xs)+')                                :s(mov.xsp)
    ident(t.dst,'(xr)+')                                :s(mov.xrp)
    ident(t.dst,'-(xs)')                                :s(mov.2)
    memmem()
    genop('mov',getarg(i1),getarg(i2))
                                                        :(opdone)
mov.xtp
mov.xlp

    ident(t.dst,'(xr)+') genop('movs_w')                :s(opdone)
    genop('lods_w')
    ident(t.dst,'-(xs)') genop('push','w0')             :s(opdone)
    genop('mov',getarg(i.dst),'w0')                     :(opdone)

mov.xsp

    ident(t.dst,'(xr)+')                                :s(mov.xsprp)
    genop('pop',getarg(i.dst))                          :(opdone)

mov.xsprp genop('pop','w0')

    genop('stos_w')                                     :(opdone)

mov.xrp genop('mov','w0',getarg(i.src))

    genop('stos_w')                                     :(opdone)

mov.2

    genop('push',getarg(i.src))                         :(opdone)

*  odd/even tests.  if w reg, use low byte of register.

g.bod

    t1 = getarg(i1)
    t1 = eq(i.type(i1),8) reglow[t1]
    genop('test',t1,'1')
    genop('jne',getarg(i2))                             :(opdone)

g.bev

    t1 = getarg(i1)
    t1 = eq(i.type(i1),8) reglow[t1]
    genop('test',t1,'1')
    genop('je',getarg(i2))
                                                        :(opdone)

g.brn

    genop('jmp',getarg(i1))                             :(opdone)

g.bsw

    t1 = getarg(i1)
    t2 = genlab()
    z_suspend = 1
    ident(i.text(i3))                                   :s(g.bsw1)
    genop('cmp',t1,getarg(i2))
    genop('jge',getarg(i3))

*  here after default case.

g.bsw1

    genop('jmp', 'm_word [' t2 '+' t1 '*cfp_b]')
    genop('segment .data')
    genopl(t2 '                                         :')
    z_suspend = 0
                                                        :(opdone)

g.iff

    genop('d_word',getarg(i2))                          :(opdone)

g.esw

    genop('segment .text')                              :(opdone)

g.ent

*   entry points are stored in byte before program entry label
*   last arg is optional, in which case no initial 'db' need be
*   issued. we force odd alignment so can distinguish entry point
*   addresses from block addresses (which are always even).

*   note that this address of odd/even is less restrictive than
*   the minimal definition, which defines an even address as being
*   a multiple of cfp_b (4), and an odd address as one that is not
*   a multiple of cfp_b (ends in 1, 2, or 3).  the definition here
*   is a simple odd/even, least significant bit definition.
*   that is, for us, 1 and 3 are odd, 2 and 4 are even.


    t1 = i.text(i1)
    outfile = tab 'align' tab '2'
    differ(t1)                                          :s(g.ent.1)
    outfile = tab 'nop'
                                                        :(g.ent.2)
g.ent.1

    outfile = tab 'db' tab  t1

g.ent.2

    outlines = outlines + 2
    genopl(thislabel)

*   note that want to attach label to last instruction
*        t1 = cstmts[cstmts.n]
*        t.label(t1) = tlabel
*        cstmts[cstmts.n] = t1
*   here to see if want label made public

    thislabel ? rtab(1) . thislabel '                   :'
    (differ(pubtab[thislabel]), differ(debug)) genop('global',thislabel)
    thislabel =                                         :(opdone)

g.bri

    genop('jmp',getarg(i1))                             :(opdone)

g.lei

    t1 = regmap[i.text(i1)]
    genop('movzx',t1,'byte [' t1 '-1]' )                :(opdone)

g.jsr

    jsr_proc = getarg(i1)
    genop('call',jsr_proc)

*        get count of following ppm statements

    jsr_count = ppm_cases[jsr_proc]
    eq(jsr_count)                                       :s(opdone)
    z_suspend = 1
    jsr_calls = jsr_calls +  1
    jsr_label = 'call_' jsr_calls
    jsr_label_norm = jsr_label
    genop('dec','m_word [' rcode ']')
    genop('js',jsr_label_norm)
    z_suspend = 0

*        generate branch around for ppms that will follow
*        take the branch if normal return (eax==0)
                                                        :(opdone)

g.err
g.ppm

*   here with return code in rcode. it is zero for normal return
*   and positive for error return. decrement the value.
*   if it is negative then this is normal return. otherwise,
*   proceed decrementing rcode until it goes negative,and then
*   take the appropriate branch.

    t1 = getarg(i1)

*   branch to next case if rcode code still not negative.

    ident(incode,'ppm')                                 :s(g.ppm.loop)
    count.err =  count.err + 1
    errfile =   i.text(i1) ' ' i.text(i2)
    max.err = gt(t1,max.err) t1
                                                        :(g.ppm.loop)

g.ppm.loop.next

    genopl(lab_next '                                   :')
    jsr_count = jsr_count - 1
    z_suspend = eq(jsr_count) 0
    eq(jsr_count) genopl(jsr_label_norm ':')            :(opdone)

g.ppm.loop

    lab_next = genlab()
    genop('dec','m_word [' rcode ']')
    genop('jns',lab_next)
    ident(incode,'ppm')                                 :s(g.ppm.loop.ppm)

*   here if error exit via exi. set rcode to exit code and jump
*   to error handler with error code in rcode

g.ppm.loop.err

    genop('mov','m_word [' rcode ']', +t1)
    genop('jmp','err_')
                                                        :(g.ppm.loop.next)
g.ppm.loop.ppm

*        check each ppm case and take branch if appropriate
    ident(i.text(i1))                                   :s(g.ppm.2)
    count.ppm = count.ppm + 1
    genop('jmp',    getarg(i1))
                                                        :(g.ppm.loop.next)

g.ppm.2

*   a ppm with no arguments, which should never be executed, is
*   translated to err 299,internal logic error: unexpected ppm branch

    t1 = 299
    errfile =  t1 ' internal logic error                : unexpected ppm branch'
                                                        :(g.ppm.loop.err)

g.prc

*   generate public declaration
*        t1 = thislabel
*        t1 ? rtab(1) . t1 ':'
*        genop()
*        genop('global',t1)
*   nop needed to get labels straight

    prc.args = getarg(i2)
    ppm_cases[thislabel] = i.text(i2)
    thislabel =
    max_exi = gt(prc.args,max_exi) prc.args
    prc.type = i.text(i1)                               :($('g.prc.' prc.type))

g.prc.e
g.prc.r                                                 :(opdone)

g.prc.n

*   store return address in reserved location
    prc.count = prc.count + 1
    genop('pop', 'm_word [' prcent(prc.count) ']')      :(opdone)

g.exi

    t1 = getarg(i1); t2 = prc.type; t3 = i.text(i1)

*   if type r or e, and no exit parameters, just return

    differ(t2,'n') eq(prc.args)     genop('ret')        :s(opdone)
    t3 = ident(t3) '0'
    genop('mov','m_word [' rcode ']',+t3)
    ident(t2,'n')                                       :s(g.exi.1)
    genop('ret')                                        :(opdone)

g.exi.1

    genop('mov','w0', 'm_word ['  prcent(prc.count) ']' )
    genop('jmp','w0')
                                                        :(opdone)
g.enp   genop()                                         :(opdone)

g.erb
    errfile =  i.text(i1) ' ' i.text(i2)
*        set rcode to error code and branch to error handler
    genop('mov', 'm_word [' rcode ']',  +(i.text(i1)))
    genop('jmp','err_')
                                                        :(opdone)


g.icv

    genop('inc',getarg(i1))                             :(opdone)

g.dcv

    genop('dec',getarg(i1))                             :(opdone)

g.zer

    ident(i.text(i1),'(xr)+') genop('mov','w0','0')
+               genop('stos_w')                         :s(opdone)
    ifreg(i1)                                           :s(g.zer1)
    ident(i.text(i1),'-(xs)')                           :s(g.zer.xs)
    genop('mov','w0','0')
    genop('mov',getarg(i1),'w0')                        :(opdone)

g.zer1

    t1 = getarg(i1)
    genop('xor',t1,t1)                                  :(opdone)

g.zer.xs

    genop('push','0')                                   :(opdone)

g.mnz

    genop('mov',getarg(i1),'xs')                        :(opdone)

g.ssl
g.sss
g.rtn

    genop()                                             :(opdone)

g.add   memmem()

    genop('add',getarg(i1),getarg(i2))                  :(opdone)

g.sub   memmem()

    genop('sub',getarg(i1),getarg(i2))                  :(opdone)

g.ica   genop('add',getarg(i1),'cfp_b')                 :(opdone)

g.dca   genop('sub',getarg(i1),'cfp_b')                 :(opdone)

g.beq
g.bne
g.bgt
g.bge
g.blt
g.ble
g.blo
g.bhi

*   these operators all have two operands, memmem may apply
*   issue target opcode by table lookup.

    memmem()
    t1 = branchtab[incode]
    genop('cmp',getarg(i1),getarg(i2))
    genop(branchtab[incode],getarg(i3))
.                                                       :(opdone)

g.bnz

    ifreg(i1)                                           :s(g.bnz1)
    genop('cmp', getarg(i1) ,'0')
    genop('jnz',getarg(i2))
                                                        :(opdone)
g.bnz1

    genop('or',getarg(i1),getarg(i1))
    genop('jnz',getarg(i2))
                                                        :(opdone)

g.bze   ifreg(i1)                                       :s(g.bze1)

    genop('cmp', getarg(i1)  ,'0')
    genop('jz',getarg(i2))
                                                        :(opdone)
g.bze1

    t1 = getarg(i1)
    genop('or',t1,t1)
    genop('jz',getarg(i2))                              :(opdone)

g.lct

*   if operands differ must emit code

    differ(i.text(i1),i.text(i2))                       :s(g.lct.1)

*   here if operands same. emit no code if no label, else emit null

    ident(thislabel)                                    :s(opnext)
    genop()                                             :(opdone)

g.lct.1

    genop('mov',getarg(i1),getarg(i2))                  :(opdone)

g.bct

*   can issue loop if target register is cx.

    t1 = getarg(i1)
    t2 = getarg(i2)
                                                        :(g.bct2)
    ident(t1,'wa')                                      :s(g.bct1)

g.bct2

    genop('dec',t1)
    genop('jnz',t2)                                     :(opdone)

g.bct1

    genop('loop',t2)                                    :(opdone)

g.aov

    genop('add',getarg(i2),getarg(i1))
    genop('jc',getarg(i3))
                                                        :(opdone)
g.lcp
g.lcw
g.scp

    genop(op_,getarg(i1))                               :(opdone)

*   use cp for code pointer.
    genop('mov',reg.cp,getarg(i1))
                                                        :(opdone)

    genop('mov',getarg(i1),reg.cp)
                                                        :(opdone)
*   should be able to get lodsd; xchg eax,getarg(i1)
    genop('mov',getarg(i1),'m_word [' reg.cp ']')
    genop('add',reg.cp,'cfp_b')

                                                        :(opdone)


g.icp

    genop(op_)                                          :(opdone)
    genop('add',reg.cp,'cfp_b')
                                                        :(opdone)
g.ldi

    genop('mov','ia',getarg(i1))


g.sti

    genop('mov',getarg(i1),'ia')                        :(opdone)

g.adi

    genop('add','ia',getarg(i1))                        :(opdone)

g.sbi

    genop('sub','ia',getarg(i1))                        :(opdone)

g.mli

    genop('imul','ia',getarg(i1))                       :(opdone)

g.dvi


    genop('mov','rax','ia')
    genop('cdq')
    genop('idiv',getarg(i1))
    genop('mov','ia','rax')
                                                        :(opdone)

g.rmi
    genop('mov','rax','ia')
    genop('cdq')
    genop('idiv',getarg(i1))
    genop('mov','ia','rdx')
                                                        :(opdone)

g.ngi
    genop('neg','ia')                                   :(opdone)

g.ino
g.iov

    genop(op_,getarg(i1))                               :(opdone)


g.ieq   jop = 'je'                                      :(op.cmp)
g.ige   jop = 'jge'                                     :(op.cmp)
g.igt   jop = 'jg'                                      :(op.cmp)
g.ile   jop = 'jle'                                     :(op.cmp)
g.ilt   jop = 'jl'                                      :(op.cmp)
g.ine   jop = 'jne'                                     :(op.cmp)
op.cmp

    genop('sti_',w0)
    genop('or',w0,w0)
    genop(jop,getarg(i1))                               :(opdone)

*   real operations

g.itr

    genop('call','itr_')                                :(opdone)

g.rti

    genop('rti_')
    eq(i.type(i1))                                      :s(opdone)

*   here if label given, branch if real too large

    genop('jc',getarg(i1))                              :(opdone)

g.ldr
g.str
g.adr
g.sbr
g.mlr
g.dvr

    t1 = getarg(i1,'m_word')
    genop('lea','w0',t1)
    genop('call',op_)
                                                        :(opdone)
g.ngr
g.atn
g.chp
g.cos
g.etx
g.lnf
g.sin
g.sqr
g.tan

    genop('call',op_)
                                                        :(opdone)

g.rov
g.rno

    genop(op_,getarg(i1))                               :(opdone)

g.req   jop = 'je'                                      :(g.r1)
g.rne   jop = 'jne'                                     :(g.r1)
g.rge   jop = 'jge'                                     :(g.r1)
g.rgt   jop = 'jg'                                      :(g.r1)
g.rle   jop = 'jle'                                     :(g.r1)
g.rlt   jop = 'jl'
g.r1    genop('call','cpr_')

    genop('mov','al','byte [reg_fl]')
    genop('or','al','al')
    genop(jop,getarg(i1))                               :(opdone)

g.plc
g.psc

    ne(cfp_b,cfp_c)                                     :s(g.plc.1)

*   last arg is optional.  if present and a register or constant,
*   use lea instead.

    t1 = getarg(i1)
    t2 = i.type(i2)
    ((ifreg(i2), ge(t2,1) le(t2,2))
+       genop('lea',t1,'[cfp_f+' t1 '+' getarg(i2) ']')):s(opdone)
    genop('add',t1,'cfp_f')
    eq(i.type(i2))                                      :s(opdone)

*   here if d_offset_(given (in a variable), so add it in.

    genop('add',t1,getarg(i2))                          :(opdone)

g.plc.1

*   here for case where character size if word size
*   last arg is optional.  if present and a register or constant,
*   use lea instead.

    t1 = getarg(i1)
    t2 = i.type(i2)
    ((ifreg(i2), ge(t2,1) le(t2,2))
+       genop('lea',t1,'[cfp_f+' t1 '+' 'cfp_b*' getarg(i2) ']')):s(opdone)
    genop('add',t1,'cfp_f')
    eq(i.type(i2))                                      :s(opdone)

*   here if d_offset_(given (in a variable), so add it in, after converting to byte count
    genop('mov','w0', getarg(i2))
    genop('sal','w0', 'log_cfp_b')

    genop('add',t1,'w0')                                :(opdone)

*   lch requires separate cases for each first operand possibility.

g.lch

    t2 = i.text(i2)
    t1 = getarg(i1)

*   see if predecrement needed.
    leq('-',substr(t2,1,1))                             :f(g.lcg.1)
    t2 break('(') len(1) len(2) . t3
    (eq(cfp_b,cfp_c) genop('dec',regmap[t3]), genop('sub',regmap[t3],'cfp_b'))

g.lcg.1

    t2 break('(') len(1) len(2) . t3
    eq(cfp_b,cfp_c) genop('mov','w0','0')
    eq(cfp_b,cfp_c) genop('mov','al','m_char [' regmap[t3] ']')
    eq(cfp_b,cfp_c) genop('mov',t1,'w0')

    ne(cfp_b,cfp_c) genop('mov',t1,'m_char [' regmap[t3] ']')

*   see if postincrement needed.
    t2 rtab(1) '+'                                      :f(g.lcg.2)
    (eq(cfp_b,cfp_c) genop('inc',regmap[t3]), genop('add',regmap[t3],'cfp_b'))

g.lcg.2                                                 :(opdone)

g.sch

    t2 = i.text(i2)
    eq(i.type(i1),8)                                    :s(g.scg.w)
    t1 = getarg(i1)
    eq(cfp_b,cfp_w)                                     :f(g.scg.0)
    ident(t2,'(xr)+')                                   :f(g.scg.0)

*   here if can use stos.

    eq(cfp_b,cfp_c) genop('mov','al',getarg(i1))
    ne(cfp_b,cfp_c) genop('mov','eax',getarg(i1))
    genop('stos_b')                                     :(opdone)

g.scg.0

    leq('-',substr(t2,1,1))                             :f(g.scg.1)
    t2 break('(') len(1) len(2) . t3
    genop('dec',regmap[t3])
    (eq(cfp_b,cfp_c) genop('dec',regmap[t3]), genop('sub',regmap[t3],'cfp_b'))
g.scg.1

    t2 break('(') len(1) len(2) . t3
    eq(cfp_b,cfp_c) genop('mov','w0',t1,)
    eq(cfp_b,cfp_c) genop('mov','[' regmap[t3] ']','al')
    ne(cfp_b,cfp_c) genop('mov','m_char [' regmap[t3] ']',t1)
*   see if postincrement needed.
    t2 rtab(1) '+'                                      :f(g.scg.2)
    (eq(cfp_b,cfp_c) genop('inc',regmap[t3]), genop('add',regmap[t3],'cfp_b'))

g.scg.2                                                 :(opdone)
g.scg.w

*   here if moving character from work register, convert t1
*   to name of low part.

    t1 = (eq(cfp_b,cfp_c) reglow[getarg(i1)], getarg(i1))

    ident(t2,'(xl)')                                    :s(g.scg.w.xl)
    ident(t2,'-(xl)')                                   :s(g.scg.w.pxl)
    ident(t2,'(xl)+')                                   :s(g.scg.w.xlp)
    ident(t2,'(xr)')                                    :s(g.scg.w.xr)
    ident(t2,'-(xr)')                                   :s(g.scg.w.pxr)
    ident(t2,'(xr)+')                                   :s(g.scg.w.xrp)

g.scg.w.xl

    genop('mov','m_char [xl]',t1)                       :(opdone)

g.scg.w.pxl

    (eq(cfp_b,cfp_c)  genop('dec', 'xl'), genop('sub','xl', 'cfp_b'))
    genop('mov','m_char [xl]',t1)                       :(opdone)

g.scg.w.xlp

    genop('mov','m_char [xl]',t1)
    (eq(cfp_b,cfp_c)  genop('inc', 'xl'), genop('add','xl', 'cfp_b'))
                                                        :(opdone)
g.scg.w.xr

    genop('mov','m_char [xr]',t1)                       :(opdone)

g.scg.w.pxr

    (eq(cfp_b,cfp_c)  genop('dec', 'xr'), genop('sub','xr', 'cfp_b'))
    genop('mov','m_char [xr]',t1)                       :(opdone)

g.scg.w.xrp

    (eq(cfp_b,cfp_c) genop('mov','al',t1), genop('mov','eax',t1))
    genop('stos_b')                                     :(opdone)

g.csc   ident(thislabel)                                :s(opnext)

    genop()                                             :(opdone)

g.ceq

    memmem()
    genop('cmp',getarg(i1),getarg(i2))
    genop('je',getarg(i3))
                                                        :(opdone)

g.cne   memmem()

    genop('cmp',getarg(i1),getarg(i2))
    genop('jnz',getarg(i3))
                                                        :(opdone)

g.cmc

    genop('repe','cmps_b')
    genop('mov','xl','0')
    genop('mov','xr','xl')
    t1 = getarg(i1)
    t2 = getarg(i2)
    (ident(t1,t2) genop('jnz',t1))                      :s(opdone)
    genop('ja',t2)
    genop('jb',t1)                                      :(opdone)

g.trc

    genop('xchg','xl','xr')
    eq(cfp_b,cfp_c) genopl((t1 = genlab()) '            :','movzx','w0','m_char [xr]')
    ne(cfp_b,cfp_c) genopl((t1 = genlab()) '            :','mov','w0','m_char [xr]')
    ne(cfp_b,cfp_c) genop('sal', 'w0', 'log_cfp_b');* convert char value to byte offset
    eq(cfp_b,cfp_c) genop('mov','al','[xl+w0]')
    ne(cfp_b,cfp_c) genop('mov','eax','[xl+w0]')
    genop('stos' op_c)
*        genop('loop',t1)
    genop('dec','wa')
    genop('jnz',t1)
    genop('xor','xl','xl')
    genop('xor','xr','xr')
                                                        :(opdone)

g.anb   genop('and',getarg(i1),getarg(i2))              :(opdone)

g.orb   genop('or',getarg(i1),getarg(i2))               :(opdone)

g.xob   genop('xor',getarg(i1),getarg(i2))              :(opdone)

g.cmb   genop('not',getarg(i1))                         :(opdone)


g.rsh

    genop('shr',getarg(i1),getarg(i2))                  :(opdone)

g.lsh

    genop('shl',getarg(i1),getarg(i2))                  :(opdone)

g.rsx

    error('rsx not supported')

g.lsx

    error('lsx not supported')

g.nzb   ifreg(i1)                                       :s(g.nzb1)

    genop('cmp',getarg(i1),'0')
    genop('jnz',getarg(i2))
                                                        :(opdone)
g.nzb1

    genop('or',getarg(i1),getarg(i1))
    genop('jnz',getarg(i2))
                                                        :(opdone)

g.zrb   ifreg(i1)                                       :s(g.zrb1)

    genop('cmp',getarg(i1),'0')
    genop('jz',getarg(i2))
                                                        :(opdone)
g.zrb1

    genop('or',getarg(i1),getarg(i1))
    genop('jz',getarg(i2))
                                                        :(opdone)

g.zgb

    genop('nop')                                        :(opdone)

g.zzz

    genop('zzz',getarg(i1))                             :(opdone)

g.wtb   genop('sal',getarg(i1),'log_cfp_b')             :(opdone)

g.btw   genop('shr',getarg(i1),'log_cfp_b')             :(opdone)


g.mti   ident(i.text(i1),'(xs)+')                       :f(g.mti.1)

    genop('pop','w0')
    genop('ldi_','w0')                                  :(opdone)

g.mti.1

    genop('ldi_',getarg(i1))                            :(opdone)

g.mfi

*   last arg is optional
*   compare with cfp$m, branching if result negative

    eq(i.type(i2))                                      :s(g.mfi.1)

*   here if label given, branch if wc not in range (ie, negative)

    genop('sti_','w0')
    genop('or','w0','w0')
    genop('js',getarg(i2))

g.mfi.1

    ident(i.text(i1),'-(xs)')                           :s(g.mfi.2)
    genop('sti_',getarg(i1))                            :(opdone)

g.mfi.2

    genop('sti_','w0')
    genop('push','w0')                                  :(opdone)

g.ctw

*   assume cfp_c chars per word

    t1 = getarg(i1)
    eq(cfp_b,cfp_c)                                     :s(g.ctw.1)

*   here if one word per character, so just add character count

    genop('add',t1,i.text(i2))
                                                        :(opdone)
g.ctw.1

    genop('add',t1,'(cfp_c-1)+cfp_c*' i.text(i2))
    genop('shr',t1,'log_cfp_c')
                                                        :(opdone)
g.ctb

    t1 = getarg(i1)
    eq(cfp_b,cfp_c)                                     :s(g.ctb.1)

*   here if one word per character, so just add character count, then convert to byte count

    genop('add',t1,i.text(i2))
    genop('sal',getarg(i1),'log_cfp_b')                 :(opdone)

g.ctb.1

    genop('add',t1,'(cfp_b-1)+cfp_b*' i.text(i2))
    genop('and',t1,'-cfp_b')
                                                        :(opdone)
g.cvm   t1 = getarg(i1)

    genop('sti_',w0)
    genop('imul',w0,'10')
    genop('jo',t1)
    genop('sub',regmap['wb'],'ch_d0')
    genop('sub',w0,regmap['wb'])
    genop('ldi_',w0)
    genop('jo',t1)
                                                        :(opdone)
g.cvd

    genop('cvd_')                                       :(opdone)

g.mvc

*        use word move if character size is word size
*        if charsize is word size, convert character count to byte count for word move

    ne(cfp_b,cfp_c) genop('shl', 'wa', 'log_cfp_b')
    ne(cfp_b,cfp_c)                                     :s(g.mvw)
    t1 = genlab()
    z_suspend = 1
    genop('rep')
    genop('movs_b')
    z_suspend = 0
                                                        :(opdone)

g.mvw

    z_suspend = 1
    genop('shr','wa','log_cfp_b')
    genop('rep','movs_w')
    z_suspend = 0
                                                        :(opdone)

g.mwb

    genop('shr','wa','log_cfp_b')
    genop('std')
    genop('lea','xl','[xl-cfp_b]')
    genop('lea','xr','[xr-cfp_b]')
    genrep('movs_w')
    genop('cld')                                        :(opdone)

    genop('std')
    genop('shr','wa','log_cfp_b')
    genop('rep')
    genop('movs_w')
    genop('ctd')
                                                        :(opdone)

g.mcb

*        use word move if character size is word size

    ne(cfp_b,cfp_c) genop('shl', 'wa', 'log_cfp_b')
    ne(cfp_b,cfp_c)                                     :s(g.mwb)
    genop('std')
    genop('dec','xl')
    genop('dec','xr')
    genrep('movs_b')
    genop('cld')
                                                        :(opdone)
    genop('std')
    genop('rep')
    genop('movs_b')
    genop('cld')
                                                        :(opdone)
genrep

*        generate equivalent of rep op loop
    l1 = genlab()
    l2 = genlab()
    genopl(l1 '                                         :')
    genop('or','wa','wa')
    genop('jz',l2)
    genop(op)
    genop('dec','wa')
    genop('jmp',l1)
    genopl(l2 '                                         :')
                                                        :(return)

g.chk

    genop('cmp','xs','lowspmin')
    genop('jb','sec06')
                                                        :(opdone)

decend

*   here at end of dic or dac to see if want label made public

    thislabel ? rtab(1) . thislabel '                   :'
    differ(pubtab[thislabel]) genop('global',thislabel)
                                                        :(opdone)

g.dac

    t1 = i.type(i1)
    t2 = "" ;*(le(t1,2) "", le(t1,4) "d_offset_(", le(t1,6) "d_offset_(", "")
    genopl(thislabel,'d_word',t2 i.text(i1))
                                                        :(decend)
g.dic

    genopl(thislabel,'d_word',i.text(i1))
                                                        :(decend)

g.drc

    genop('align',8)
    t1 = i.text(i1)
    t1 ? fence "+" = ""
    genop('d_real',t1)

*   note that want to attach label to last instruction

    t.label(cstmts[cstmts.n]) = thislabel
    thislabel =                                         :(opdone)

g.dtc

*   change first and last chars to " (assume / used in source)

    t1 = i.text(i1)
    t1 tab(1) rtab(1) . t2
    t3 = remdr(size(t2),cfp_c)

*         t2 = "'" t2 "'"
*   append nulls to complete last word so constant length is multiple
*   of word word

    dtc_i = 1
    t4 =

g.dtc.1

    t4 = gt(dtc_i, 1) t4 ","
    t4 = t4 "'" substr(t2,dtc_i,1) "'"
    le(dtc_i = dtc_i + 1, size(t2))                     :s(g.dtc.1)

    t4 = ne(t3) t4 dupl(',0',cfp_c - t3)
    genopl(thislabel,'d_char',t4)
                                                        :(opdone)
g.dbc

    genopl(thislabel,'d_word',getarg(i1))
                                                        :(opdone)
g.equ

*    genopl(thislabel,'equ',i.text(i1))
    genopl(,,,,,'#define ' thislabel ' (' i.text(i1) ')')
                                                        :(opdone)
g.exp

    ppm_cases[thislabel] = i.text(i1)
    genop('extern',thislabel)
    thislabel =                                         :(opdone)

g.inp

    ppm_cases[thislabel] = i.text(i2)
    prc.count1 = ident(i.text(i1),'n') prc.count1 + 1
+                                                       :(opnext)

g.ejc
g.inr                                                   :(opnext)
g.ttl

    genop('')
                                                        :(opdone)


g.sec

    genop('')
    sectnow = sectnow + 1                               :($("g.sec." sectnow))

*  procedure declaration section

g.sec.1

    genop('segment .text')
    genop('global','sec01')
    genopl('sec01' ':')                                 :(opdone)

*   definitions section

g.sec.2

    genop('segment .data')
    genop('global','sec02')
    genopl('sec02' ':')                                 :(opdone)

*  constants section

g.sec.3

    genop('segment .data')
    genop('global','sec03')
    genopl('sec03' ':')                                 :(opdone)

*  working variables section

g.sec.4

    genop('global','esec03')
    genopl('esec03' '                                   :')
    genop('segment .data')
    genop('global','sec04')
    genopl('sec04' ':')                                 :(opdone)

*   here at start of program section.  if any n type procedures,
*   put out entry-word block declaration at end of working storage

g.sec.5

*   emit code to indicate in code section
*   get direction set to up.

    genop('global','esec04')
    genopl('esec04' '                                   :')

*         (gt(prc.count1) genopl('prc$' ':','times', prc.count1 ' dd 0'))

    genop('prc_                                         : times ' prc.count1 ' dd 0')
    genop('global','lowspmin')
    genopl('lowspmin' '                                 :','d_word','0')
    genop('global','end_min_data')
    genopl('end_min_data' '                             :')
    genop('segment .text')
    genop('global','sec05')
    genopl('sec05' ':')                                 :(opdone)

*   stack overflow section.  output exi__n tail code

g.sec.6

    genop('global','sec06')
    genopl('sec06'  '                                   :', 'nop')
                                                        :(opdone)

*   error section.  produce code to receive erb's

g.sec.7

    genop('global','sec07')
    genopl('sec07' '                                    :')
    flush()
*   error section.  produce code to receive erb's

*        allow for some extra cases in case of max.err bad estimate
    n1 = max.err + 8
    output = '  max.err ' max.err
    genopl('err_                                        :','xchg',reg.wa,'m_word [' rcode ']')
                                                        :(opdone)


opdone

    flush()                                             :(opnext)

*   here to emit bstmts, cstmts, astmts. attach input label and
*   comment to first instruction generated.

flush

    eq(astmts.n) eq(bstmts.n) eq(cstmts.n)              :f(opdone1)

*   here if some statements to emit, so output single 'null' statement to get label
*   and comment field right.

    label = thislabel =
    outstmt(tstmt())                                    :(opdone.6)

opdone1

    eq(bstmts.n)                                        :s(opdone.2)
    i = 1

opdone.1

    outstmt(bstmts[i])
    le(i = i + 1, bstmts.n)                             :s(opdone.1)

opdone.2

    eq(cstmts.n)                                        :s(opdone.4)
    i = 1

opdone.3

    outstmt(cstmts[i])
    le(i = i + 1, cstmts.n)                             :s(opdone.3)

opdone.4        eq(astmts.n)                            :s(opdone.6)

    i = 1
    ident(pifatal[incode])                              :s(opdone.5)
*   here if post incrementing code not allowed
    error('post increment not allowed for op ' incode)

opdone.5

    outstmt(astmts[i])
    le(i = i + 1, astmts.n)                             :s(opdone.5)

opdone.6

    astmts.n = bstmts.n = cstmts.n =                    :(return)

flush_end

report

    output = lpad(num,10) '  ' text                     :(return)


g.end

    &dump = 0
    ident(havehdr)                                      :s(g.end.2)

*   here to copy remaining part from hdr file

g.end.1

    line = hdrfile                                      :f(g.end.2)
    ntarget = ntarget + 1
    noutlines = noutlines + 1
    outfile = line                                      :(g.end.1)

g.end.2

*   here at end of code generation.

    endfile(1)
    endfile(2)
    endfile(3)
    report(nlines,          'lines read')
    report(nstmts,          'statements processed')
    report(ntarget,         'target code lines produced')
    report(&stcount,        'spitbol statements executed')
    report(max.err,         'maximum err/erb number')
    report(prc.count1,      'prc count')
    output  = '  ' gt(prc.count,prc.count1)
.         '  differing counts for n-procedures          :'
.         ' inp ' prc.count1 ' prc ' prc.count
    differ(nerrors) report(nerrors,'errors detected')

    errfile = '* ' max.err ' maximum err/erb number'
    errfile  = '* ' prc.count ' prc count'
.               differ(lasterror) '  the last error was in line ' lasterror

    &code   = ne(nerrors) 2001
    report(collect(), 'free words')
                                                        :(end)
end
