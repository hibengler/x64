        /* generated from ||ttl|27,l i c e n s e -- software license for this program||||1 into C code */
        #ifdef GEN_C_CODE
        #undef GEN_C_CODE
        // This is because GEN_C_CODE will  trigger code for standard c routines to shim around the v.variable and c.constant fields
        #endif
        #include "stdio.h"
        #include "math.h"
        #include "port.h"
        #include "c_64.h"
//     copyright 1983-2012 robert b. k. dewar
//     copyright 2012-2015 david shields
//     this file is part of macro spitbol.
//     macro spitbol is free software: you can redistribute it and/or modify
//     it under the terms of the gnu general public license as published by
//     the free software foundation, either version 2 of the license, or
//     (at your option) any later version.
//     macro spitbol is distributed in the hope that it will be useful,
//     but without any warranty; without even the implied warranty of
//     merchantability or fitness for a particular purpose.  see the
//     gnu general public license for more details.
//     you should have received a copy of the gnu general public license
//     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.
//      m a c r o   s p i t b o l     v e r s i o n   13.01
//      ---------------------------------------------------
//      date of release  -  january 2013
//      macro spitbol is maintained by
//           dr. david shields
//           260 garth rd apt 3h4
//           scarsdale, ny 10583
//      e-mail - thedaveshields at gmail dot com
//      version 3.7 was maintained by
//           mark emmer
//           catspaw, inc.
//           p.o. box 1123
//           salida, colorado 81021
//           u.s.a
//      e-mail - marke at snobol4 dot com
//      versions 2.6 through 3.4 were maintained by
//           dr. a. p. mccann (deceased)
//           department of computer studies
//           university of leeds
//           leeds ls2 9jt
//           england.
//      from 1979 through early 1983 a number of fixes and
//      enhancements were made by steve duff and robert goldberg.
        
//      r e v i s i o n   h i s t o r y
//      -------------------------------
//      version 13.01 (january 2013, david shields)
//      this version has the same functionality as the previous release, but with
//      many internal code changes.
//      support for x86-64 has been added, but is not currently working.
//      the description of the minimal language formerly found here as comments
//      is now to be found in the file minimal-reference-manual.html
//      version 3.8 (june 2012, david shields)
//      --------------------------------------
//	       this version is very close to v3.7, with the same functionality.
//              the source is now maintained using git, so going forward
//              the detailed revision history will be recorded in the git
//              commit logs, not in this file.
//      version 3.6a to 3.7 (november 1, 1991, mark b. emmer)
//      -----------------------------------------------------
//
//      bugs fixed
//      ----------
//
//      b3.701  add btkwv and refined test at cdgvl+9 to prevent
//              variable names alphabet, lcase, ucase from being
//              pre-evaluated because of their associated
//              constant keywords.  the code
//                 alphabet = "abc"; output = size(alphabet)
//              returned zero because of pre-evaluation.
//      b3.702  delay binding to function block of fourth
//              argument to trace function.  this permits the
//              trace function to be invoked before the 4th
//              argument function is defined.  accomplished by
//              storing a vrblk pointer in trfnc, and fetching
//              its vrfnc entry later, in trxeq.
//      b3.703  references to keywords with constant pattern
//              values (&arb, &bal, etc.) did not work.  a wtb
//              instruction had been omitted at acs14+2.
//      b3.704  if a program employed the code function to
//              redefine a label that was the entry location of
//              a user-defined function, the function would
//              continue to jump to its old function body.  pfcod
//              in pfblk was pointing directly to the target code
//              block, instead of doing so indirectly through the
//              vrblk for the entry label.
//      b3.705  the test that required a label to be defined
//              before it could be used as the entry of a user-
//              defined function has been removed.  functions
//              may be defined even if the label is yet
//              undefined.
//      b3.706  after a compilation error in the code function,
//              the eval function produces spurrious errors.  the
//              code offset cwcof was not being reset to the
//              beginning of code block.  add line at err04+1 to
//              accomplish this reset.
//      b3.707  inconsistant tests with mxlen corrected.  several
//              places were testing with bge instead of bgt,
//              resulting in such anomalies as the statement
//                 &maxlngth = &maxlngth
//              failing.  since mxlen is guaranteed to be
//              strictly less than dnamb, it is permissible to
//              create objects of size mxlen.  bge changed to
//              bgt at locations
//                 s$arr+14, sar07+8, alobf+3, asg14+8, gtar6+10.
//      b3.708  exit(command string) was not loading ptr to fcb
//              chain into wb.  corrected at sext1.
//      b3.709  change patst to return non-string error for null
//              argument.  previously, break(), any(), etc., were
//              succeeding, contrary to the language definition.
//      b3.710  convert function with null second argument
//              crashed system by calling flstg with wa=0.  added
//              test at s$cnv, moved error 74 to separate erb at
//              scv29.
//      b3.711  leq(,) crashed system.  lcomp did not obey
//              minimal assumption that cmc opcode will always
//              be called with wa .gt. 0.  added test at lcmp1.
//      b3.712  modified line at sdf07+4 to use register wa
//              instead of wb.  this corrects problem of define
//              function with local variable list that begins
//              with comma-  define("f(x),l1,l2")
//      b3.713  erroneous plc on uninitialised r$cim in listr.
//      b3.714  erroneous call to flstg possible with null string
//              at sdat1.
//      b3.715  when copy function used with table argument, fix
//              problem at cop07.  when copying first teblk on a
//              chain, the pseudo-previous block pointer in xr
//              is pushed on the stack prior to calling alloc.
//              this is not a valid block pointer, as it points
//              within the tbblk.  if the subsequent alloc
//              invokes gbcol, the heap becomes scrambled.
//              recoded to save pointer to start of block, plus
//              offset in wb.
//      b3.716  at iop01, if gtvar triggered garbage collection
//              via alost, trap block in wc was not collected.
//              save wc on stack to make it collectable across
//              gtvar call.
//      b3.717  at asg10, allow case of variable with more than
//              one trblk, as happens with the following stmt -
//              output(.output, .output, filename).
//      b3.718  at senf1, trblk chain search was reloading chain
//              head, causing infinite loop if the desired trblk
//              was not the first on chain.  system crashed with
//              trace(.v1) output(.v2,.v1,file).
//      b3.719  prototype strings (define, load, data, etc.) were
//              allowing blank characters, producing bogus
//              variable names.
//      b3.720  the fact that iofcb destroyed register wc was not
//              documented.  b$efc conversion of file argument
//              never worked because wc and xt were destroyed by
//              call to iofcb.
//      b3.721  ioput left a trblk attached to filearg1 if sysio
//              failed.  subsequent use of this filearg1 variable
//              in another i/o call would crash system.
//      b3.722  add chk at evlp1 to catch recursive pattern error.
//      b3.723  allow -line to work properly within code function
//              by setting cmpln directly in cnc44.  if file name
//              absent, decrement scnpt to rescan terminator.
//      b3.724  when mxlen exceeds start of dynamic memory, round
//              it up to multiple of word size prior to storing
//              in dnamb at ini06.
//      b3.725  provide right padding of zero characters to any
//              string returned by an external function.
//      b3.726  reset flptr at bpf17 for undefined function
//              when evalx is evaluating an expression.
//      b3.727  modify code after read5 for outer nesting of
//              an execute-time compile of -include statement.
//              create a substring of remainder of original
//              code function argument string and return as
//              result of readr function
//      b3.728  the definition of the aov opcode is corrected.
//              formerly the definition specified that the branch
//              was to be taken if the result of the addition
//              exceeded cfp$m, implying a test for overflow
//              from signed addition.
//              however, address arithmetic must be unsigned to
//              allow for systems where the high order address
//              bit is set.  therefore, the test must be for
//              carry out of the high order bit, if the result
//              would exceed cfp$l.
//      b3.729  a label trace on the entry label for a function
//              was undetected, resulting in a transfer to
//              b$trt and subsequent crash.  see bpf08 for fix.
//      b3.730  pop first argument to substr if it is a buffer.
//      b3.731  pattern replacement with buffer subject returned
//              null string instead of new subject value.
//              changed to behave as if subject was a string.
//      b3.732  if convert function was called with a buffer
//              first argument and "buffer" second argument,
//              it would convert the buffer to a string, and
//              then back to a buffer.  this has be corrected
//              to simply return the first argument as the
//              function result.
//      b3.733  detect external function returning a null string
//              unconverted result at bef12, and jump to exnul.
//      b3.734  fix problem at ins04 when inserting zero length
//              string into buffer.  defend against invoking
//              mvc with a zero value in wa, which will cause
//              some implementations to wrap the counter.
//      b3.735  add overflow test for cos and sin to detect
//              out-of-range argument.
//      b3.736  fixed problem introduced with b3.727 not
//              restoring r$cim, scnpt and scnil after creating
//              substring.
//      b3.737  fixed tfind to place default value in newly
//              allocated teblk.
//      b3.738  added bl$p0 to p$nth entry point.  the expression
//              datatype(convert("","pattern")) would crash when
//              the dtype function uses the non-existant type
//              word preceding p$nth.
//      b3.739  bug at gtn35 in the case of overflow during cvm.
//              wb can be destroyed by cvm on some platforms.
//      b3.740  protect scontinue from usage in other than error
//              320 case.
//      b3.741  protect continue from usage following error
//              evaluating complex failure goto.
//
//
//      changes
//      -------
//
//      c3.701  add .culk conditional to include &lcase, &ucase.
//      c3.702  add -line nn "filename" control card.
//      c3.703  move .cnld conditional up in routine dffnc to
//              omit all tests for b$efc.
//      c3.704  add conditional .cicc to ignore unrecognized
//              control cards.
//      c3.705  add conditional .cnsc to omit string to numeric
//              conversion in sort.  the presence of this
//              conversion mode produces a sort result that is
//              dependent upon the order of input data.
//              for example, given input data "2", 5, "10",
//              string comparison yields "10" lt "2", but string
//              to integer conversion yields "2" lt 5 lt "10".
//      c3.706  add seventh return from syshs that allows callee
//              to return a string pointer and length.  this is
//              done to eliminate the need for the caller to have
//              an scblk big enough to accommodate long strings.
//      c3.707  add eighth return from syshs to force copy of
//              block pointed to by xr.
//      c3.708  made -copy a synonym for -include.
//      c3.709  add conditional .cbyt for statistics displayed
//              in bytes rather than words.
//      c3.710  dump null valued variables when dump = 3.  core
//              dump produced for dump = 4.
//      c3.711  restrict minimum value to which keyword maxlngth
//              can be set to 1,024 via new variable mnlen.
//      c3.712  add conditional symbol .cmth for extended math
//              functions- atan, chop, cos, exp, ln, sin, sqrt,
//              tan.  x**y and remdr(x,y) are extended to include
//              reals.
//      c3.713  add bit to syspp to set -print upon entry
//      c3.714  add conditional .csfn to track source file name
//              associated with each code block.
//      c3.715  add conditional .cinc for -include control card
//              feature.  the format of the card is
//                 -include "filename"
//              include control cards may be used during both the
//              initial compile and execute-time compile.  the
//              filename is saved in a table, and redundant
//              includes of that file are ignored.
//      c3.716  add conditional .csln to include source line
//              number in code blocks.  release current ccblk
//              after initial compile.
//      c3.717  changed rilen to 258 (from 120) to provide
//              uniform input line length when reading from
//              terminal or input.
//      c3.718  add additional exit to iofcb to distinguish
//              argument not convertable to string and argument
//              file not open.
//      c3.719  add fourth and fifth arguments to host function.
//      c3.720  add &compare keyword to control string
//              comparisons.
//      c3.721  setup pfdmp at iniy0 in case osint forced
//              &profile non-zero.
//      c3.722  add conditional symbol .caex to include up arrow
//              as synonym for exponentiation.
//      c3.723  add conditional .ccmc and external function syscm
//              to provide string comparison using collation
//              sequence other than strict ordering of character
//              codes (international compares).
//      c3.724  add conditional .cpol and external function syspl
//              to provide interactive control of spitbol
//              execution.
//      c3.725  add conditional symbol .cera and external
//              function sysea to provide advice of compilation
//              and runtime errors to osint.
//      c3.726  add cmpln, rdcln, rdnln to track source line
//              number.
//      c3.727  converted error messages to upper/lower case.
//      c3.728  add conditional .cgbc to external routine sysgc.
//              called at the start and end of garbage collection
//              to perform any needed notification to operating
//              system or user.
//      c3.729  modified last line of s$set from exnul to exint
//              so seek can return final file position after
//              seek.
//      c3.730  place mov xr,(xs) at s$rmd+4 to allow real second
//              arg to remdr.
//      c3.731  remove redundant bge xr,=cfp$u,scn07 at scn06+4
//      c3.732  change definition of cmc and trc such that only
//              xl must be cleared after operation.  note, this
//              change was subsequently voided.  cmc and trc must
//              clear both xl and xr, because utility routines
//              may preserve xl or xr on the stack, and the stack
//              is collectable by gbcol.
//      c3.733  remove most branches to exits and exixr.
//              instead, jump directly to next code word.
//      c3.734  add error 260 for array too large in gtarr.
//      c3.735  add conditional .cs32 to initialize stlim to
//              2147483647.
//      c3.736  add second argument to exit function, allowing
//              user to specify file name of load module being
//              written.  if omitted, osint will provide a
//              default name.
//      c3.737  add conditional .cspr to include spare locations
//              in working area.  these may be used in later bug
//              fixes without changing the size of the working
//              storage and obsoleting modules created by exit().
//              subsuently removed in c3.767.
//      c3.738  add r$cts to remember last string used to build
//              bit column in patst.
//      c3.739  change flstg to type e procedure instead of r.
//      c3.740  standardize on big-endian systems.  at the
//              implementors choice, the zgb opcode can also
//              perform a byte swap if necessary to achieve big-
//              endian byte ordering.  this is done so that
//              systems with similar word lengths will produce
//              the same hash code for strings, and hence the
//              same ordering for table entries.  the hashs
//              procedure has an additional zgb added to reorder
//              the length word.
//      c3.741  add conditional .csou to cause assignments to
//              output and terminal variables to be processed
//              through calls to sysou rather than through
//              listing buffer.  done to eliminate short record
//              lengths enforced by buffer size.  a code of 0 or
//              1 is passed to sysou instead of an fcblk.
//      c3.742  increased iniln, inils, rilen to 1024.
//      c3.743  add bit to syspp to set noerrors mode.
//      c3.744  add .ccmk conditional to include keyword compare
//              even if syscm is not being included.  done to
//              provide identical data regions in systems that
//              implement syscm and those which do not, so that
//              save files can be exchanged in the next release.
//      c3.745  add wc return parameter to sysil to allow
//              interface to inform spitbol if file about to be
//              read is a binary file.  if so, no blank trimming
//              occurs.
//      c3.746  fold load function argument types to upper case.
//      c3.747  add .cexp conditional to have sysex pop its
//              arguments.
//      c3.748  in stopr, do not attempt to display file name and
//              line number if stopping because of stack overflow
//              during garbage collection.  pointers to file name
//              table and code block are wrong.
//      c3.749  add bit to syspp to set case folding mode.
//      c3.750  add additional return from sysld if insufficient
//              memory to load/call external function.
//      c3.751  add additional returns from sysex if insufficient
//              memory or bad argument type.
//      c3.752  ignore leading and trailing blanks in arguments
//              within prototype strings to clear, data, define
//              and load.
//      c3.753  test for fatal error at err04 and abort if so.
//              force termination on stack overflow by setting
//              errft to 4 in stack overflow section.
//      c3.754  recode copy loop at srt14 to exchange usage of
//              registers xl and xr.  this permits use of the
//              mvw order instead of the explicit loop coding
//              previously employed.
//      c3.755  add .ceng conditional to include routines needed
//              by text processing engine. add routines enevs and
//              engts for use by engine or debugger.  copy xr to
//              xl around call to syspl to allow syspl to
//              trigger garbage collection.
//      c3.756  add &file, &lastfile, &line, &lastline keywords.
//              for now, line and lastline are maintained in the
//              same manner as stno and lastno, which adds over-
//              head to the statement initialization code.  a
//              possible change is to create a stmln procedure
//              that maps statement numbers to line numbers.
//              one simple strategy would be to sweep code blocks
//              in memory looking for the statement number and
//              extracting the line number from that code block.
//              such a procedure would also allow line numbers
//              (and file names) to be added to statement profile
//              reports.
//      c3.757  change sort to fail instead of producing error
//              message if argument table is null.  change sorta
//              to return failure.  add another return to gtarr
//              to distinguish null table from bad argument.
//      c3.758  create procedure prtmm to display memory usage
//              statistics, and call it when producing end-of-
//              run stats.
//      c3.759  add label scontinue to allow setexit to resume
//              execution exactly where it was interrupted.
//      c3.760  add snobol4 backspace function and conditional
//              .cbsp.
//      c3.761  add additional arguments to sysgc to assist
//              virtual memory managers.
//      c3.762  the method of converting a table to an array has
//              been revised.  previously, table elements were
//              copied to the result array in the order they were
//              encountered along the various hash chains.  this
//              appeared to the user as a random ordering.  how-
//              ever, spitbol/370 as well as sil snobol4 ordered
//              array elements according to their time of entry
//              into the table.  user programs that relied upon
//              this behavior malfunctioned when ported to macro
//              spitbol.
//              to remedy this, the conversion is performed in
//              three steps:
//              1. convert table to an array placing the address
//                 of each teblk in the array instead of the key
//                 and value.
//              2. sort the array of addresses.  this orders ele-
//                 ments by time of creation (ascending address).
//              3. scan the array, replacing addresses with the
//                 key and value from the referenced teblk.
//              the affected portions of the program are at s$cnv
//              and in gtarr, which now accepts an additional
//              argument specifying whether to place key/values
//              in the array or teblk addresses.
//      c3.763  if case-folding is active, fold the function name
//              provided to the load() function before passing it
//              to sysld.
//      c3.764  add sediment algorithm to garbage collector,
//              conditioned on .csed.
//      c3.765  add optimization to discard null statements and
//              statements which just have a constant subject
//              (see code at cmp12).
//      c3.766  rearranged order of initial objects in static
//              memory so that hash table is the last of the four
//              object created by initialization code.  this is
//              done so that the print buffer, gts work area, and
//              &alphabet keywords do not need to be saved in
//              any save file created by osint.  added routine to
//              initialize these structures.
//      c3.767  removed .cspr conditional and spare locations.
//      c3.768  added .crel conditional and extensive routines
//              (reloc et. al.) to perform relocation of data
//              in working section, static region, and dynamic
//              region after reload of a saved memory image.
//              routines relaj, relcr, and reloc are invoked
//              by osint after reloading a save file.
//              it is now possible to reload such an image even
//              if the spitbol compiler and its data structures
//              are reloaded to other addresses.  the working
//              section has been extensively rearranged to
//              accommodate the reloc procedure.
//      c3.769  zero r$ccb (interim ccblk ptr) in collect,
//              convert, eval, and exit functions to release
//              unneeded ccblk memory.
//      c3.770  add exit(4) and exit(-4) to allow execution to
//              continue after writing save file or load module.
//              revised sysxi interface to detect continuation
//              after performance of exit(4) or exit(-4) action.
//      c3.771  change filnm to preserve registers.
//      c3.772  addition of .cncr and syscr (real to string
//              system routine option).
//      c3.773  modified replace function to optimize usage
//              when second argument is &alphabet.  in this case,
//              the third argument can be used as the translate
//              table directly.
//      c3.774  modified conditionals for buffers and reals so
//              that their respective block codes are always
//              present, even if these data types are conditioned
//              out.  this provides consistent block code
//              numbering for external functions.
//      c3.775  modified alobf to test string length against
//              kvmxl instead of mxlen.  also, alobf was testing
//              total size of bfblk, instead of just string len.
//      c3.776  move utility routines source up to lie between
//              predefined snobol functions (s$xxx) routines and
//              utility procedures.  this was done to assist
//              translation on platforms such as apple macintosh
//              that use 15-bit offsets to store error exits (ppm
//              branches).  offsets to labels like exfal were
//              just too far away.  similarly, functions tfind,
//              tmake, and vmake are located out of alphabetic
//              order to satisfy the macintosh's limited range
//              for subroutine calls.  move built-in labels
//              beyond the block and pattern routines to get it
//              within 32k of the error routines.
//      c3.777  at scn46, allow colon, right paren and right
//              bracket to terminate = operator with default
//              null operand.
//      c3.778  added .ctet conditional for table entry trace.
//      c3.779  introduce cfp$l, the largest unsigned value
//              that may be stored in a one-word integer.  this
//              is done to accommodate machines where memory
//              addresses have the high-order address bit set.
//      c3.780  perform replace in place if first arg is buffer.
//      c3.781  perform reverse in place if first arg is buffer.
//      c3.782  change sysou to accept buffer as well as string
//              to be output.  change code at asg11 to prevent
//              conversion of buffer to string.
//      c3.783  optimize pos and rpos when it is the first node
//              of a pattern and has either an integer or simple
//              expression variable argument.  if unanchored mode
//              and the cursor is zero, it is advanced directly
//              to the desired cursor position.
//      c3.784  perform trim function in place if arg is buffer.
//      c3.785  add gtstb procedure to get a string or buffer
//              argument for replace, reverse, size, trim, etc.
//      c3.786  change leq, lgt, etc. to perform comparisons
//              without converting buffer arguments to strings.
//              this is done by changing lcomp to accept buffer
//              argument(s).  this also affects sort function,
//              which will compare two buffers as strings.
//      c3.787  change gtnum to use characters in buffer without
//              conversion to a string.  this implies that acomp
//              will perform arithmetic comparisons of buffers
//              without converting to strings first.
//      c3.788  perform comparisons of strings and buffers in
//              sortc.
//      c3.789  change insbf to allow insertion of a buffer into
//              a buffer without first converting it to a string.
//              note that this only works when the two buffers
//              are not the same.
//      c3.790  documentation change:  note that all of the block
//              move opcodes should have wa .gt. 0.  not all
//              implementations avoid moving objects when wa is
//              zero.
//      c3.791  change ident to provide buffer/buffer and
//              buffer/string comparisons, to accommodate users
//              who perform ident(buf) to check for null string
//              in buffer.
//      c3.792  added fullscan keyword initialized to one.  user
//              may set to any non-zero value, will receive an
//              error message if attempts to set to zero, since
//              quickscan mode is not supported.
//      c3.793  rewrote statement startup code at stmgo to only
//              perform checking of profiling, stcount tracing,
//              and statement counting if necessary.
//      c3.794  add additional exit to sysfc and ioput to signal
//              that i/o channel (fcblk) is already in use.
//              added error message numbers 289 and 290.
//      c3.795  added optional integer argument to date function
//              to specify format of date string returned by
//              sysdt.
//
//
//      version 3.6 to 3.6a (oct 83)
//      ---------------------------
//
//      changes
//      -------
//
//      c3.617  add .cnlf. if defined, then arguments to external
//              functions may be declared to have type file.
//              such arguments must have been used as second
//              arg to input() or output() and a pointer to the
//              fcb is passed to the external function.
//
//
//      version 3.5 to 3.6 (jun 83)
//      ---------------------------
//
//      codes used to identify authors are (sgd) for duff,
//      (reg) for  goldberg, and (lds) for shields.
//
//      bugs fixed
//      ----------
//      b3.601  (sgd) to fix multiple trap block problem in asign
//      b3.602  (sgd) patch in gtarr to fix null convert.
//      b3.603  (sgd) inserted missing wtb after sysmm calls.
//      b3.604  (sgd) use string length in hashs.
//      b3.605  (sgd) fixed serious parser problem
//              relating to (x y) on line being viewed as pattern
//              match.  fixed by addition of new cmtyp value
//              c$cnp (concatenation - not pattern match).
//      b3.606  (sgd) fixed exit(n) respecification code
//              to properly observe header semantics on return.
//      b3.607  (sgd) bypass prtpg call at initialization
//              following compilation if no output generated.
//              this prevents output files consisting of the
//              headers and a few blank lines when there is no
//              source listing and no compilation stats.
//              also fix timsx initialization in same code.
//      b3.608  (sgd) b$efc code did not check for
//              unconverted result returning null string.
//      b3.609  (sgd) load pfvbl field in retrn for
//              return tracing. this was causing bug on return
//              traces that tried to access the variable name.
//      b3.610  (sgd) fixed problem relating to compilation of
//              goto fields containing small integers
//              (in const sec).
//      b3.611  (reg) prevent clear() from clobbering protected
//              variables at label sclr5.
//      b3.612  (reg) fixed gtexp from accepting trailing
//              semicolon or colon. this is not a legal way
//              to end an expression.
//      b3.613  (reg) fixed difficulties with listings during
//              execution when no listing generated during
//              compilation. -list to code() caused bomb.
//              fix is to reset r$ttl and r$stl to nulls not 0
//              after compilation.
//              (listr and listt expect nulls)
//              when listing and statistics routed to different
//              file than execution output, error message is sent
//              to execution output (and gets separated from
//              ... in statement ... msg). labo1 calls sysax and
//              stopr does not call sysax if entered from labo1.
//      b3.614  (lds) fix misuse of wc just after asg10.
//      b3.615  (lds) add comment pointing out suspicious code
//              after tfn02
//      b3.616  (lds) fix inconsistent declaration of sorth.
//      b3.617  (lds) insert missing conditional tests on cnbf.
//      b3.618  (lds) fix some violations of minimal language
//              that had slipped past some translators.
//      b3.619  (lds) correct error introduced in fixing b3.614.
        
//      changes
//      -------
//
//
//      c3.601  (sgd) addition of .cnci and sysci (int to string
//              system routine option)
//      c3.602  (reg) changed iniln and and inils to 258
//      c3.603  (sgd) merged in profiler patches, repaired code.
//      c3.604  (sgd) added buffer type and symbol cnbf
//      c3.605  (sgd) added char function.  char(n) returns nth
//              character of host machine character set.
//      c3.606  (reg) added cfp$u to ease translation on smaller
//              systems - conditional .cucf
//      c3.607  (reg) added lower case support, conditional .culc
//      c3.608  (reg) added set i/o function, conditional .cust
//      c3.609  (reg) conditionalized page eject after call to
//              sysbx and added another before call to sysbx,
//              so that, if desired by the implementor,
//              standard output will reflect assignments made
//              by executing program only.
//              conditional .cuej controls - if defined then
//              eject is before call to sysbx.
//      c3.610  (lds) introduce .ctmd to support systm that
//              reports elapsed time in deciseconds instead of
//              milliseconds.
//      c3.611  (lds)  provide place for .def or .und for each
//              conditional  option, so that settings can be
//              changed without changing line numbers.
//              current settings are for 808x translation.
//      c3.612  (lds) obey (new) restriction that operand in
//              conditional branch instruction cannot have form
//              (x)+ in order to simplify translations for which
//              postincrement not readily available.
//      c3.613  (reg,lds) add op
//                    flc wreg
//              that folds character in wreg to upper case.
//              this op is used only if .culc is defined.
//              this change also involves addition of keyword
//              &case which when nonzero (the initial setting)
//              causes the case folding just described to be
//              done.
//      c3.614  (lds) add option .cs16 to permit initialization
//              of statement limit values to 32767 for 16 bit
//              machines.
//      c3.615  (lds) permit return point and entry point
//              addresses to be distinguished by their parity
//              instead of by lying within a certain range
//              of values.  introduce conditional symbols
//              .crpp  return points have odd parity
//              .cepp  entry points have odd parity
//      c3.616  (lds) introduce new minimal opcodes to branch
//              according to parity,
//                bev  opn,plbl  branch if address even
//                bod  opn,plbl  branch if address odd
//              an address is even if it is a multiple of cfp$b.
        
//      documentation revisions
//      -----------------------
//
//      d3.601  (lds) bring minimal machine description up to
//              date
//
        
//      version 3.4 to 3.5 (feb 79)
//      ---------------------------
//
//
//      bugs fixed
//      ----------
//
//      b3.401  prtst should be declared as an r type procedure.
//      b3.402  timing error if spitbol fails in dump.
//      b3.403  error in handling omitted args of operators.
//      b3.404  too many lines put on first page of listing.
//      b3.405  leading unary operator in eval erroneously needed
//              preceding blank.
//      b3.406  identifying name in dump of array or table values
//              was omitted.
//      b3.407  eval unable to return a deferred expression.
//      b3.408  illegal if setexit code branches to return.
//      b3.409  illegal on detaching input, output, terminal.
//
//      changes
//      -------
//
//      c3.401  -sequ and -nose control cards removed.
//      c3.402  option provided to suppress system identification
//              on listing.
//      c3.403  description of sysbx slightly revised.
//      c3.404  permissible to modify scblk length before taking
//              error returns from sysin, sysrd, sysri.
//      c3.405  conditional .cnld may be defined to omit load().
//      c3.406  conditional .cnex may be defined to omit exit().
//      c3.407  table now accepts a third argument specifying
//              default initial lookup value.
//      c3.408  routines sort, rsort for sorting arrays and table
//              introduced. specification is as in sitbol.
//              routines may be omitted by defining .cnsr .
//      c3.409  error in code(), eval() call now causes statement
//              failure but errtext keyword is still set.
//      c3.410  arg to code() may contain embedded control cards
//              and comment delimited by a semicolon.
//
//      documentation revisions
//      -----------------------
//
//      d3.401  purpose of restriction 2 in minimal section -6-
//              (operations on char values), erroneously stated
//              to be for cmc, rather than for ceq, cne.
//              descriptions of above opcodes revised.
//      d3.402  description of ent clarified.
//      d3.403  descriptions of several opcodes revised to remove
//              technically invalid literals e.g. =0 , *1.
//      d3.405  restricted use of letter z in minimal clarified.
//      d3.406  divide by zero explicitly mentioned in relation
//              to overflow setting.
        
//      version 3.3 to 3.4 (oct 78)
//      ---------------------------
//
//
//      bugs fixed
//      ----------
//
//      b3.301  illegal for erroneous eval() arg.
//      b3.302  address arithmetic overflow in alloc and alocs.
//      b3.303  -eject and -space ignored -nolist option.
//      b3.304  erroneous argument scan in load().
//      b3.305  erroneous plc on uninitialised r$cim in nexts.
//      b3.306  ldi used instead of mti after prv07.
//      b3.307  misuse of rmi at erra2.
//      b3.308  misuse of mti in hashs.
//      b3.309  bug in -sequ card sequence number checking.
//      b3.310  stack overflow error message not always printed.
//      b3.311  corrupt prototype print for traced arrays.
//      b3.312  pattern first arg in dupl caused error.
//      b3.313  omitted csc in s$rpd, erroneous csc in convert.
//      b3.314  misplaced btw in exbld.
//      b3.315  incorrect code in hashs.
//      b3.316  failure of load to scan integer arg.
//      b3.317  table access with negative integer arg. failed.
//      b3.318  error in returning result of loaded function.
//      b3.319  =e$srs used after ini01 instead of *e$srs.
//      b3.320  err used instead of erb after systu
//      b3.321  label could start with disallowed character.
//      b3.322  continue after setexit had bad heuristic.
        
//
//
//      changes
//      -------
//
//      c3.301  sysax and .csax introduced - see sysax
//              in procedures section.
//      c3.302  variable mxlen introduced. contains the maximum
//              size of a spitbol object and is not changeable
//              after initialisation. may be defaulted or set
//              explicitly by sysmx.
//      c3.303  syshs returns revised - see syshs.
//      c3.304  new minimal opcode aov to fix b3.302.
//      c3.305  inhibit stlimit check if stlimit made negative.
//      c3.306  cfp$m is required to be of form 2**n - 1.
//      c3.307  dupl made to conform to sil snobol4 standard.
//      c3.308  lch and sch actions more closely defined.
//      c3.309  batch initialisation code omitted if conditional
//              assembly symbol .cnbt (no batch) defined.
//      c3.310  (wa) contains argument count in sysex call.
//      c3.311  sysfc  may request allocation of static fcblk.
//      c3.312  if ia,wc overlap, restriction put on dumping/
//              restoring these registers.
//      c3.313  new listing option intermediate between compact
//              and extended provided (see syspp).
//      c3.314  revision of sysxi interface to permit options for
//              load module standard o/p file (see sysxi,syspp).
//      c3.315  last arg of substr may be omitted - treated
//              as remainder of string.
        
//      version 3.2 to 3.3 (jan 78)
//      ---------------------------
//
//      bugs fixed
//      ----------
//
//      b3.201  array reference and external function load
//              routines illegally accessed information
//              beyond the stack front.
//              similar fault in unanchored pattern matching.
//      b3.202  dump(1) produced dump(2) type output.
//      b3.203  wtb conversion omitted in code following
//              ini01, ini02, exbld.
//      b3.204  incorrect fail return from tfind in arref.
//      b3.205  endfile did not detach i/o associated variables.
//      b3.206  -space with omitted arg. failed
//      b3.207  looped if dump keyword non-zero after stack
//              overflow in garbage collect failure.
//      b3.208  failure in reading numbers with trailing blanks.
//
//      changes
//      -------
//
//      the extensive changes made here mostly result from a
//      snobol4 implementors meeting held at new york university
//      in august 1977. they are aimed at
//           (1) having spitbol conform to certain snobol4
//           language standards  and
//           (2) producing a stable definition of minimal by
//           carrying out a few essential revisions in the light
//           of experience in its use.
//
//      changes to spitbol
//      ------------------
//
//      c3.201  default values for keywords trim and anchor are
//              zero. on systems where records are customarily
//              handled without traling blanks, there is no
//              obligation to supply such blanks.
//      c3.202  default value of -inxx control card is -in72.
        
//      c3.203  the second argument of input and output is
//              permitted to be an integer as in snobol4.
//              in addition input(), output() now give a snobol4
//              statement failure if sysio uses the file not
//              found return.
//              the third argument has a recommended format and
//              to override its default delimiter (,) a
//              conditional assembly symbol, .ciod, is used.
//              interfaces to sysef,sysej,syfc,sysio,sysrw
//              are revised.
//              wc may now be used to return from sysio, a max
//              record length.
//      c3.204  a new configuration parameter cfp$f (scblk offset
//              is introduced. cfp$u is removed.
//      c3.205  implementation and version identification is
//              required - see sysid.
//      c3.206  routine sysmx returns the maximum length of
//              spitbol objects (strings arrays etc).  this
//              information is not now needed at time of entry to
//              spitbol and hence wc should be zero on entry.
//      c3.207  a conditional parameter .cnra permits assembly
//              of a more compact version with no real
//              arithmetic code.
//      c3.208  terminal is a new pre-associated variable
//              capable of performing input and output to an
//              online terminal.
//              sysri is a new routine used in the implementation
//              of this. see also syspp.
//      c3.209  the environment parameters e$--- are now
//              provided by the minimal translator using the
//              revised   equ  *   format (see c3.229 and start
//              of spitbol definitions section - some reordering
//              of symbols has occurred).
//      c3.210  the interface of sysxi has been slightly revised.
//              unavailability of i/o channels after exit(1),
//              exit(-1) is documented together with additional
//              error return usage for sysin,sysou,syspr,sysrd.
//      c3.211  spitbol error codes have been frozen - see c3.230
//      c3.212  the utility routines arref etc. are now
//              introduced by rtn statements.
//      c3.213  sysrl (record length for std input file) is
//              removed. since implementation of a general -inxxx
//              control card and an ability to specify max record
//              length using the third argument of input, sysrl
//              has become redundant.
//      c3.214  sysej and sysxi are now passed a chain linking
//              all fcblks in use.
//      c3.215  a special ending code in sysej is used when
//              attempts to use standard output channel fail.
//      c3.216  restriction c3.233 observed so simplifying
//              optimised translation of ent with omitted val.
        
//
//      changes to minimal
//      ------------------
//
//      c3.220  minimal opcodes dec, dim, inc, and bmp
//              are withdrawn and replaced by the more consistent
//              set dca, dcv, ica, icv.
//      c3.221  chs has been replaced by the more generally
//              useful zgb (still likely to be a no-op for most
//              implementations however).
//      c3.222  the set of character comparisons has been
//              reduced to ceq and cne to ease implementation
//              problems.
//      c3.223  opcode irz is removed and dvi, rmi orders are
//              redefined to conform to more common usage.
//      c3.224  new opcodes ssl and sss are defined. their use
//              permits return links for n type procedures to be
//              placed on a local stack if desired.
//      c3.225  opcode mnz complements zer. it moves a non-zero
//              flag to its destination.
//      c3.226  for some machines it is preferable for the stack
//              to build up rather than down. to permit this
//              without need for massive changes in minimal and
//              recoding of existing programs, a scheme has been
//              devised in which an additional register name, xt,
//              is used as a synonym for xl when this register
//              is involved in stack manipulation- see section 4.
//      c3.227  section 0 of a minimal program is renamed the
//              procedure section. it now contains, in addition
//              to exp, specifications of internal procedures
//              and routines by means of the inp and inr opcodes.
//      c3.228  the literal operand formats =int and *int have
//              been withdrawn. =dlbl and *dlbl must be used in
//              their stead.
//      c3.229  the format
//              label  equ  *nn
//              used to specify values supplied by the minimal
//              translator for char. codes etc. is replaced by
//              label  equ  *
//              where the order in which the definitions are
//              supplied by the translator should match the
//              order of occurrence in the definitions section.
//      c3.230  the format of err,erb opcodes is changed to
//              require a numeric operand.
//      c3.231  the rtn opcode is used to introduce routines
//              (which are quite distinct from procedures).
//      c3.232  conditional assembly directives may be nested.
//      c3.233  minor restriction placed on the omission of
//              val with the ent opcode.
        
//      version 3.1 to 3.2 (aug 77)
//      ---------------------------
//
//      bugs fixed
//      ----------
//
//      b3.101  astonishing this was unnoticed for three years.
//              bad code for snobol4 integer divide, /, gave
//              wrong result for operands of opposite signs.
//              implementations have either wrongly translated
//              dvi and got correct result or correctly
//              translated dvi and got wrong result - leeds had
//              one of each. see also c3.106.
//              test program no. 1 now extended to check /
//              more thoroughly.
//      b3.102  garbage collection bug in scane
//
//      changes
//      -------
//
//      c3.101  option to use additional characters ch$ht,ch$vt
//              (horizontal and vertical tab) with same syntactic
//              significance as ch$bl (blank).
//      c3.102  option to use a set of shifted case alphabetic
//              characters ch$$a ... ch$$$.
//      c3.103  conditional assembly features are introduced into
//              minimal on account of the above.
//              see minimal documentation section for details
//              of above changes.
//      c3.104  lch and sch may use an x register first
//              operand as alternative to a w register.
//      c3.105  spitbol statement numbers in the listing may
//              optionally be padded to 6 or 8 chars instead of 5
//              by defining conditional assembly symbols
//              .csn6 or .csn8 .
//      c3.106  to fix bug 3.101. at moderate cost,
//              opcode irz (branch if integer divide remainder
//              zero) introduced.
//      c3.107  to handle possible machine dependency in string
//              hashing, chs (complete hashing of string) opcode
//              is introduced. probably a no-op on most machines
//              - not on the dec10.
//      c3.108  procedures patin,tfind,trace have been
//              modified to conform to the minimal standard
//              call and return regime.
//      c3.109  sysfc interface revised slightly to permit
//              osint to return a pointer to a privately
//              allocated fcblk which spitbol will return on
//              subsequent i/o - see sysfc doc.
//      c3.110  to remove inconsistencies in calling sequences,
//              all sys routines having access to a possible
//              fcblk have fcblk ptr or zero in reg. wa on entry.
//              change affects sysef, sysen, sysil, sysin,
//              sysou, sysrw.
//      c3.111  syspp bit allocated to provide
//               -noexec option on entry to spitbol.
        
//
//      documentation revisions
//      -----------------------
//
//      d3.101  need to preserve registers in syspi, syspr,
//              sysrd calls was overstated.
        
//      version 3.0 to 3.1 (mar 77)
//      ---------------------------
//
//      bugs fixed
//      ----------
//
//      b3.001  replace() could fail during pre-evaluation.
//              spitbol now signals an error for null or
//              unequally long 2nd and 3rd arguments.
//      b3.002  negative second arguments to dupl, lpad, rpad
//              caused spitbol to signal an error. now causes
//              return of null string or first arg respectively.
//      b3.003  brn-s used instead of ppm-s in s$sub.
//      b3.004  err used instead of erb after cmp30.
//      b3.005  b$pfc, s$cnv, s$def, arith and arref kept
//              information illegally above the stack top.
//      b3.006  pre-evaluation of constant parts of
//              complex gotos was erroneous.
//      b3.007  incorrect handling of labels compiled by code().
//      b3.008  the single use of trc (in s$rpl) was not in
//              accord with its definition. some translations of
//              trc may need revision now that the use
//              has been brought into line with definition.
//
//      changes
//      -------
//
//      a debate on a few weaknesses in minimal design has
//      been resolved by introducing 4 new opcodes.
//
//      c3.001  new minimal opcodes bmp and dim introduced
//              to augment inc and dec which are applicable
//              only to addresses.
//      c3.002  the opcode szc (store zero characters) had
//              a restricted applicability. it has been
//              replaced by the more general zer (zeroise).
//      c3.003  fcblks may be optionally allocated as xrblk-s or
//              xnblk-s  - see sysfc for vital information.
//      c3.004  control card processing has been recoded.
//              -inxxx allows specification of standard input
//              file record lengths other than 72 or 80, see also
//              sysrl. -sequ is ignored unless -in80 is in effect
//      c3.005  to enable efficient buffering of chars on
//              machines without char. handling orders, the
//              csc (complete store characters) instruction
//              is introduced. current implementations can
//              translate it as a no-op if it is of no benefit.
//      c3.006  integers 0,1,2 are treated specially.
//              icblks in static are used instead of
//              allocating space in dynamic.
        
//
//      version 2.7 (june 76) to 3.0 (jan 77)
//      -------------------------------------
//
//      bugs fixed
//      ----------
//
//      b2.701  goes illegal if timed out during processing of
//              dump() call.
//      b2.702  goes illegal if spitbol error detected in args of
//              code() or eval(). bug fixed so that user now gets
//              a spitbol error report (trappable by setexit)
//              before statement failure.
//      b2.703  goes illegal in some circumstances when
//              multiple compilation errors occur in a statement
//      b2.704  goes illegal if garbage collector runs out of
//              stack space.
//      b2.705  control card processing incorrect for cdc 6400.
//      b2.706  incorrect handling of multiple occurrences of
//              chars in replace 2nd and 3rd args.
//      b2.707  stack overflow in pre-evaluation of replace in
//              cdc 6400 version.
//      b2.708  an explicit call of sysmw was coded in s$dat
//              instead of the mvw opcode.
//      b2.709  call of garbage collector whilst dumping
//              caused havoc.
//      b2.710  size restriction on spitbol objects (size must be
//              numerically less than lowest dynamic address)
//              was not enforced, with potential for catastrophe.
//      b2.711  deferred expressions involving alternation or
//              negation were incorrectly translated.
//      b2.712  listing of a compilation error at the end of a
//              long line could cause compiler to go illegal.
//      b2.713  incorrect -nofail code with success goto.
        
//
//
//      changes
//      -------
//
//      (it is not anticipated that major revisions on this
//      scale will be frequent).
//
//      c2.701  default value of anchor keyword is set to 1. this
//              conflicts with snobol4 practice but is a
//              preferable default for most applications.
//      c2.702  if errtype is out of range the string in keyword
//              errtext is printed as the error message.
//      c2.703  if stlimit is exceeded, up to 10 more statements
//              may be obeyed to permit setexit trap to gain
//              control.
//      c2.704  the concept of an interactive channel is
//              introduced for implementations where an online
//              terminal may be used for spitbol. the standard
//              print file may be specified as interactive in
//              which case shorter title lines are output.
//              alternatively copies of compilation and
//              execution errors only may be sent to this channel
//      c2.705  printing of compilation statistics may be
//              suppressed.
//      c2.706  printing of execution statistics may be
//              suppressed.
//      c2.707  extended or compact listing format may be
//              selected.
//      c2.708  an initial -nolist option may be specified
//              before compilation starts.
//      c2.709  to specify choices implied by c2.704 to c2.708
//              syspp interface is revised and syspi is defined.
//      c2.710  compilation and execution time statistics
//              messages have been shortened.
//      c2.711  the exit function as in sitbol is introduced
//              to permit saving load modules - see sysxi, s$ext.
//      c2.712  diagnostic routines sysgb and sysgd have been
//              removed. they were useful in the early debugging
//              days but have fallen into disuse now.
//      c2.713  szc may have an operand of type opn instead of
//              type opw
//      c2.714  input/output association interface has been
//              revised. sysif,sysof have been consolidated into
//              the new system routine, sysio, and the
//              specification of sysfc has been slightly changed.
//      c2.715  configuration parameter mxlen has been withdrawn
//              and the maximum size of a spitbol object which
//              was formerly fixed at spitbol compile time by
//              reference to it may now be specified as a run
//              time option by placing a value in wc before entry
//              to spitbol. (see comment on dynamic area in
//              basic information section).
//      c2.716  a function, host, is introduced which yields
//              information about the host machine - see syshs
//              and s$hst.
        
//
//      documentation revisions
//      -----------------------
//
//      d2.701  the description of mvc has been revised to
//              reflect the fact that some spitbol code sequences
//              rely on mvc not destroying wb. minor changes
//              have been made to mwb and mvw descriptions to
//              emphasise similarities in the implicit loops of
//              these orders.
//      d2.702  descriptions of dvi and rmi have been clarified.
//      d2.703  implementation of rsx,lsx,ceq,cge,cgt,chi,clo,clt
//              is optional at present since they are currently
//              unused. their use in later versions is not
//              excluded.
//      d2.704  impossibility of using stack for return links of
//              n type procedures is emphasised.
//      d2.705  notation (xl),(wc) etc in language description is
//              clarified.
//      d2.706  documentation of sysfc, sysio has been improved.
//      d2.707  opcode descriptions are cross referenced from
//              the alphabetical opcode list.
//      d2.708  general description of compiler has been moved to
//              the start of the compiler proper.
//      d2.709  definitions of environment parameters have been
//              put near the front of the definitions section.
        
        
//      general structure
//      -----------------
//      this program is a translator for a version of the snobol4
//      programming language. language details are contained in
//      the manual macro spitbol by dewar and mccann, technical
//      report 90, university of leeds 1976.
//      the implementation is discussed in dewar and mccann,
//      macro spitbol - a snobol4 compiler, software practice and
//      experience, 7, 95-113, 1977.
//      the language is as implemented by the btl translator
//      (griswold, poage and polonsky, prentice hall, 1971)
//      with the following principal exceptions.
//      1)   redefinition of standard system functions and
//           operators is not permitted.
//      2)   the value function is not provided.
//      3)   access tracing is provided in addition to the
//           other standard trace modes.
//      4)   the keyword stfcount is not provided.
//      5)   the keyword fullscan is not provided and all pattern
//           matching takes place in fullscan mode (i.e. with no
//           heuristics applied).
//      6)   a series of expressions separated by commas may
//           be grouped within parentheses to provide a selection
//           capability. the semantics are that the selection
//           assumes the value of the first expression within it
//           which succeeds as they are evaluated from the left.
//           if no expression succeeds the entire statement fails
//      7)   an explicit pattern matching operator is provided.
//           this is the binary query (see gimpel sigplan oct 74)
//      8)   the assignment operator is introduced as in the
//           gimpel reference.
//      9)   the exit function is provided for generating load
//           modules - cf. gimpels sitbol.
//      the method used in this program is to translate the
//      source code into an internal pseudo-code (see following
//      section). an interpretor is then used to execute this
//      generated pseudo-code. the nature of the snobol4 language
//      is such that the latter task is much more complex than
//      the actual translation phase. accordingly, nearly all the
//      code in the program section is concerned with the actual
//      execution of the snobol4 program.
        
//      interpretive code format
//      ------------------------
//      the interpretive pseudo-code consists of a series of
//      address pointers. the exact format of the code is
//      described in connection with the cdblk format. the
//      purpose of this section is to give general insight into
//      the interpretive approach involved.
//      the basic form of the code is related to reverse polish.
//      in other words, the operands precede the operators which
//      are zero address operators. there are some exceptions to
//      these rules, notably the unary not operator and the
//      selection construction which clearly require advance
//      knowledge of the operator involved.
//      the operands are moved to the top of the main stack and
//      the operators are applied to the top stack entries. like
//      other versions of spitbol, this processor depends on
//      knowing whether operands are required by name or by value
//      and moves the appropriate object to the stack. thus no
//      name/value checks are included in the operator circuits.
//      the actual pointers in the code point to a block whose
//      first word is the address of the interpretor routine
//      to be executed for the code word.
//      in the case of operators, the pointer is to a word which
//      contains the address of the operator to be executed. in
//      the case of operands such as constants, the pointer is to
//      the operand itself. accordingly, all operands contain
//      a field which points to the routine to load the value of
//      the operand onto the stack. in the case of a variable,
//      there are three such pointers. one to load the value,
//      one to store the value and a third to jump to the label.
//      the handling of failure returns deserves special comment.
//      the location flptr contains the pointer to the location
//      on the main stack which contains the failure return
//      which is in the form of a byte offset in the current
//      code block (cdblk or exblk). when a failure occurs, the
//      stack is popped as indicated by the setting of flptr and
//      control is passed to the appropriate location in the
//      current code block with the stack pointer pointing to the
//      failure offset on the stack and flptr unchanged.
        
//      internal data representations
//      -----------------------------
//      representation of values
//      a value is represented by a pointer to a block which
//      describes the type and particulars of the data value.
//      in general, a variable is a location containing such a
//      pointer (although in the case of trace associations this
//      is modified, see description of trblk).
//      the following is a list of possible datatypes showing the
//      type of block used to hold the value. the details of
//      each block format are given later.
//      datatype              block type
//      --------              ----------
//      array                 arblk or vcblk
//      code                  cdblk
//      expression            exblk or seblk
//      integer               icblk
//      name                  nmblk
//      pattern               p0blk or p1blk or p2blk
//      real                  rcblk
//      string                scblk
//      table                 tbblk
//      program datatype      pdblk
        
//      representation of variables
//      ---------------------------
//      during the course of evaluating expressions, it is
//      necessary to generate names of variables (for example
//      on the left side of a binary equals operator). these are
//      not to be confused with objects of datatype name which
//      are in fact values.
//      from a logical point of view, such names could be simply
//      represented by a pointer to the appropriate value cell.
//      however in the case of arrays and program defined
//      datatypes, this would violate the rule that there must be
//      no pointers into the middle of a block in dynamic store.
//      accordingly, a name is always represented by a base and
//      offset. the base points to the start of the block
//      containing the variable value and the offset is the
//      offset within this block in bytes. thus the address
//      of the actual variable is determined by adding the base
//      and offset values.
//      the following are the instances of variables represented
//      in this manner.
//      1)   natural variable base is ptr to vrblk
//                            offset is *vrval
//      2)   table element    base is ptr to teblk
//                            offset is *teval
//      3)   array element    base is ptr to arblk
//                            offset is offset to element
//      4)   vector element   base is ptr to vcblk
//                            offset is offset to element
//      5)   prog def dtp     base is ptr to pdblk
//                            offset is offset to field value
//      in addition there are two cases of objects which are
//      like variables but cannot be handled in this manner.
//      these are called pseudo-variables and are represented
//      with a special base pointer as follows=
//      expression variable   ptr to evblk (see evblk)
//      keyword variable      ptr to kvblk (see kvblk)
//      pseudo-variables are handled as special cases by the
//      access procedure (acess) and the assignment procedure
//      (asign). see these two procedures for details.
        
//      organization of data area
//      -------------------------
//      the data area is divided into two regions.
//      static area
//      the static area builds up from the bottom and contains
//      data areas which are allocated dynamically but are never
//      deleted or moved around. the macro-program itself
//      uses the static area for the following.
//      1)   all variable blocks (vrblk).
//      2)   the hash table for variable blocks.
//      3)   miscellaneous buffers and work areas (see program
//           initialization section).
//      in addition, the system procedures may use this area for
//      input/output buffers, external functions etc. space in
//      the static region is allocated by calling procedure alost
//      the following global variables define the current
//      location and size of the static area.
//      statb                 address of start of static area
//      state                 address+1 of last word in area.
//      the minimum size of static is given approximately by
//           12 + *e_hnb + *e_sts + space for alphabet string
//           and standard print buffer.
        
//      dynamic area
//      the dynamic area is built upwards in memory after the
//      static region. data in this area must all be in standard
//      block formats so that it can be processed by the garbage
//      collector (procedure gbcol). gbcol compacts blocks down
//      in this region as required by space exhaustion and can
//      also move all blocks up to allow for expansion of the
//      static region.
//      with the exception of tables and arrays, no spitbol
//      object once built in dynamic memory is ever subsequently
//      modified. observing this rule necessitates a copying
//      action during string and pattern concatenation.
//      garbage collection is fundamental to the allocation of
//      space for values. spitbol uses a very efficient garbage
//      collector which insists that pointers into dynamic store
//      should be identifiable without use of bit tables,
//      marker bits etc. to satisfy this requirement, dynamic
//      memory must not start at too low an address and lengths
//      of arrays, tables, strings, code and expression blocks
//      may not exceed the numerical value of the lowest dynamic
//      address.
//      to avoid either penalizing users with modest
//      requirements or restricting those with greater needs on
//      host systems where dynamic memory is allocated in low
//      addresses, the minimum dynamic address may be specified
//      sufficiently high to permit arbitrarily large spitbol
//      objects to be created (with the possibility in extreme
//      cases of wasting large amounts of memory below the
//      start address). this minimum value is made available
//      in variable mxlen by a system routine, sysmx.
//      alternatively sysmx may indicate that a
//      default may be used in which dynamic is placed
//      at the lowest possible address following static.
//      the following global work cells define the location and
//      length of the dynamic area.
//      dnamb                 start of dynamic area
//      dnamp                 next available location
//      dname                 last available location + 1
//      dnamb is always higher than state since the alost
//      procedure maintains some expansion space above state.
//      *** dnamb must never be permitted to have a value less
//      than that in mxlen ***
//      space in the dynamic region is allocated by the alloc
//      procedure. the dynamic region may be used by system
//      procedures provided that all the rules are obeyed.
//      some of the rules are subtle so it is preferable for
//      osint to manage its own memory needs. spitbol procs
//      obey rules to ensure that no action can cause a garbage
//      collection except at such times as contents of xl, xr
//      and the stack are +clean+ (see comment before utility
//      procedures and in gbcol for more detail). note
//      that calls of alost may cause garbage collection (shift
//      of memory to free space). spitbol procs which call
//      system routines assume that they cannot precipitate
//      collection and this must be respected.
        
//      register usage
//      --------------
//      (cp)                  code pointer register. used to
//                            hold a pointer to the current
//                            location in the interpretive pseudo
//                            code (i.e. ptr into a cdblk).
//      (xl,xr)               general index registers. usually
//                            used to hold pointers to blocks in
//                            dynamic storage. an important
//                            restriction is that the value in
//                            xl must be collectable for
//                            a garbage collect call. a value
//                            is collectable if it either points
//                            outside the dynamic area, or if it
//                            points to the start of a block in
//                            the dynamic area.
//      (xs)                  stack pointer. used to point to
//                            the stack front. the stack may
//                            build up or down and is used
//                            to stack subroutine return points
//                            and other recursively saved data.
//      (xt)                  an alternative name for xl during
//                            its use in accessing stacked items.
//      (wa,wb,wc)            general work registers. cannot be
//                            used for indexing, but may hold
//                            various types of data.
//      (ia)                  used for all signed integer
//                            arithmetic, both that used by the
//                            translator and that arising from
//                            use of snobol4 arithmetic operators
//      (ra)                  real accumulator. used for all
//                            floating point arithmetic.
        
//      spitbol conditional assembly symbols
//      ------------------------------------
//      in the spitbol translator, the following conditional
//      assembly symbols are referred to. to incorporate the
//      features referred to, the minimal source should be
//      prefaced by suitable conditional assembly symbol
//      definitions.
//      in all cases it is permissible to default the definitions
//      in which case the additional features will be omitted
//      from the target code.
//      .caex                 define to allow up arrow for expon.
//      .caht                 define to include horizontal tab
//      .casl                 define to include 26 shifted lettrs
//      .cavt                 define to include vertical tab
//      .cbyt                 define for statistics in bytes
//      .ccmc                 define to include syscm function
//      .ccmk                 define to include compare keyword
//      .cepp                 define if entrys have odd parity
//      .cera                 define to include sysea function
//      .cexp                 define if spitbol pops sysex args
//      .cgbc                 define to include sysgc function
//      .cicc                 define to ignore bad control cards
//      .cinc                 define to add -include control card
//      .ciod                 define to not use default delimiter
//                              in processing 3rd arg of input()
//                              and output()
//      .cmth                 define to include math functions
//      .cnbf                 define to omit buffer extension
//      .cnbt                 define to omit batch initialisation
//      .cnci                 define to enable sysci routine
//      .cncr                 define to enable syscr routine
//      .cnex                 define to omit exit() code.
//      .cnld                 define to omit load() code.
//      .cnlf                 define to add file type for load()
//      .cnpf                 define to omit profile stuff
//      .cnra                 define to omit all real arithmetic
//      .cnsc                 define to no numeric-string compare
//      .cnsr                 define to omit sort, rsort
//      .cpol                 define if interface polling desired
//      .crel                 define to include reloc routines
//      .crpp                 define if returns have odd parity
//      .cs16                 define to initialize stlim to 32767
//      .cs32                 define to init stlim to 2147483647
//                            omit to take default of 50000
//      .csax                 define if sysax is to be called
//      .csed                 define to use sediment in gbcol
//      .csfn                 define to track source file names
//      .csln                 define if line number in code block
//      .csou                 define if output, terminal to sysou
//      .ctet                 define to table entry trace wanted
//      .ctmd                 define if systm unit is decisecond
//      .cucf                 define to include cfp_u
//      .cuej                 define to suppress needless ejects
//      .culk                 define to include &l/ucase keywords
//      .culc                 define to include &case (lc names)
//                            if cucl defined, must support
//                            minimal op flc wreg that folds
//                            argument to lower case
//      .cust                 define to include set() code
//                            conditional options
//                            since .undef not allowed if symbol
//                            not defined, a full comment line
//                            indicates symbol initially not
//                            defined.
//	The following options are enabled for the linux implementationss.
// copyright 1987-2012 robert b. k. dewar and mark emmer.
//
// copyright 2012-2015 david shields
//
// this file is part of macro spitbol.
//
//     macro spitbol is free software: you can redistribute it and/or modify
//     it under the terms of the gnu general public license as published by
//     the free software foundation, either version 2 of the license, or
//     (at your option) any later version.
//
//     macro spitbol is distributed in the hope that it will be useful,
//     but without any warranty; without even the implied warranty of
//     merchantability or fitness for a particular purpose.  see the
//     gnu general public license for more details.
//
//     you should have received a copy of the gnu general public license
//     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.
//
//      spitbol conditional assembly symbols for use by token.spt
//      ---------------------------------------------------------
//
//      this file of conditional symbols will override the conditional
//      definitions contained in the spitbol minimal file.   in addition,
//      lines beginning with ">" are treated as spitbol statements and
//      immediately executed.
//
//      in the spitbol translator, the following conditional
//      assembly symbols are referred to. to incorporate the
//      features referred to, the minimal source should be
//      prefaced by suitable conditional assembly symbol
//      definitions.
//      in all cases it is permissible to default the definitions
//      in which case the additional features will be omitted
//      from the target code.
//
//
//                            conditional options
//                            since .undef not allowed if symbol not
//                            defined, a full comment line indicates
//                            symbol initially not defined.
//
//	The following options are set for the linux implementations
//      .caex                 define to allow up arrow for exponentiation
//      .cavt                 define to include vertical tab
//      .ccmc                 define to include syscm function
//      .ceng                 define to include engine features
//      .cnci                 define to enable sysci routine
//      .cncr                 define to enable syscr routine
//      .cnex                 define to omit exit() code.
//      .cnld                 define to omit load() code.
//      .cnpf                 define to omit profile stuff
//def   .cnra                 define to omit all real arithmetic
//      .cnsr                 define to omit sort, rsort
//      .crpp                 define if return points have odd parity
//      .cs16                 define to initialize stlim to 32767
//      .culc                 define to include &case (lc names)
//      .cust                 define to include set() code
//      .cusr                 define to have set() use real values
//                             (must also #define setreal 1 in systype.h)
//
//      force definition of .ccmk if .ccmc is defined
//      this section starts with descriptions of the operating
//      system dependent procedures which are used by the spitbol
//      translator. all such procedures have five letter names
//      beginning with sys. they are listed in alphabetical
//      order.
//      all procedures have a  specification consisting of a
//      model call, preceded by a possibly empty list of register
//      contents giving parameters available to the procedure and
//      followed by a possibly empty list of register contents
//      required on return from the call or which may have had
//      their contents destroyed. only those registers explicitly
//      mentioned in the list after the call may have their
//      values changed.
//      the segment of code providing the external procedures is
//      conveniently referred to as osint (operating system
//      interface). the sysxx procedures it contains provide
//      facilities not usually available as primitives in
//      assembly languages. for particular target machines,
//      implementors may choose for some minimal opcodes which
//      do not have reasonably direct translations, to use calls
//      of additional procedures which they provide in osint.
//      e.g. mwb or trc might be translated as jsr sysmb,
//      jsr systc in some implementations.
//      in the descriptions, reference is made to --blk
//      formats (-- = a pair of letters). see the spitbol
//      definitions section for detailed descriptions of all
//      such block formats except fcblk for which sysfc should
//      be consulted.
//      section 0 contains inp,inr specifications of internal
//      procedures,routines. this gives a single pass translator
//      information making it easy to generate alternative calls
//      in the translation of jsr-s for procedures of different
//      types if this proves necessary.
        
//      sysax -- after execution
        extern void sysax();				// define external entry point
//      if the conditional assembly symbol .csax is defined,
//      this routine is called immediately after execution and
//      before printing of execution statistics or dump output.
//      purpose of call is for implementor to determine and
//      if the call is not required it will be omitted if .csax
//      is undefined. in this case sysax need not be coded.
//      jsr  sysax            call after execution
        
//      sysbs -- backspace file
        extern void sysbs();				// define external entry point
//      sysbs is used to implement the snobol4 function backspace
//      if the conditional assembly symbol .cbsp is defined.
//      the meaning is system dependent.  in general, backspace
//      repositions the file one record closer to the beginning
//      of file, such that a subsequent read or write will
//      operate on the previous record.
//      (wa)                  ptr to fcblk or zero
//      (xr)                  backspace argument (scblk ptr)
//      jsr  sysbs            call to backspace
//      ppm  loc              return here if file does not exist
//      ppm  loc              return here if backspace not allowed
//      ppm  loc              return here if i/o error
//      (wa,wb)               destroyed
//      the second error return is used for files for which
//      backspace is not permitted. for example, it may be expected
//      files on character devices are in this category.
        
//      sysbx -- before execution
        extern void sysbx();				// define external entry point
//      called after initial spitbol compilation and before
//      commencing execution in case osint needs
//      to assign files or perform other necessary services.
//      osint may also choose to send a message to online
//      terminal (if any) indicating that execution is starting.
//      jsr  sysbx            call before execution starts
        
//      sysdc -- date check
        extern void sysdc();				// define external entry point
//      sysdc is called to check that the expiry date for a trial
//      version of spitbol is unexpired.
//      jsr  sysdc            call to check date
//      return only if date is ok
        
//      sysdm  -- dump core
        extern void sysdm();				// define external entry point
//      sysdm is called by a spitbol program call of dump(n) with
//      n ge 4.  its purpose is to provide a core dump.
//      n could hold an encoding of the start adrs for dump and
//      amount to be dumped e.g.  n = 256*a + s , s = start adrs
//      in kilowords,  a = kilowords to dump
//      (xr)                  parameter n of call dump(n)
//      jsr  sysdm            call to enter routine
        
//      sysdt -- get current date
        extern void sysdt();				// define external entry point
//      sysdt is used to obtain the current date. the date is
//      returned as a character string in any format appropriate
//      to the operating system in use. it may also contain the
//      current time of day. sysdt is used to implement the
//      snobol4 function date().
//      (xr)                  parameter n of call date(n)
//      jsr  sysdt            call to get date
//      (xl)                  pointer to block containing date
//      the format of the block is like an scblk except that
//      the first word need not be set. the result is copied
//      into spitbol dynamic memory on return.
        
//      sysea -- inform osint of compilation and runtime errors
        extern void sysea();				// define external entry point
//      provides means for interface to take special actions on
//      errors
//      (wa)                  error code
//      (wb)                  line number
//      (wc)                  column number
//      (xr)                  system stage
//      (xl)                  file name (scblk)
//      jsr  sysea            call to sysea function
//      ppm  loc              suppress printing of error message
//      (xr)                  message to print (scblk) or 0
//      sysea may not return if interface chooses to retain
//      control.  closing files via the fcb chain will be the
//      responsibility of the interface.
//      all registers preserved
        
//      sysef -- eject file
        extern void sysef();				// define external entry point
//      sysef is used to write a page eject to a named file. it
//      may only be used for files where this concept makes
//      sense. note that sysef is not normally used for the
//      standard output file (see sysep).
//      (wa)                  ptr to fcblk or zero
//      (xr)                  eject argument (scblk ptr)
//      jsr  sysef            call to eject file
//      ppm  loc              return here if file does not exist
//      ppm  loc              return here if inappropriate file
//      ppm  loc              return here if i/o error
        
//      sysej -- end of job
        extern void sysej();				// define external entry point
//      sysej is called once at the end of execution to
//      terminate the run. the significance of the abend and
//      code values is system dependent. in general, the code
//      value should be made available for testing, and the
//      abend value should cause some post-mortem action such as
//      a dump. note that sysej does not return to its caller.
//      see sysxi for details of fcblk chain
//      (wa)                  value of abend keyword
//      (wb)                  value of code keyword
//      (xl)                  o or ptr to head of fcblk chain
//      jsr  sysej            call to end job
//      the following special values are used as codes in (wb)
//      999  execution suppressed
//      998  standard output file full or unavailable in a sysxi
//           load module. in these cases (wa) contains the number
//           of the statement causing premature termination.
        
//      sysem -- get error message text
        extern void sysem();				// define external entry point
//      sysem is used to obtain the text of err, erb calls in the
//      source program given the error code number. it is allowed
//      to return a null string if this facility is unavailable.
//      (wa)                  error code number
//      jsr  sysem            call to get text
//      (xr)                  text of message
//      the returned value is a pointer to a block in scblk
//      format except that the first word need not be set. the
//      string is copied into dynamic memory on return.
//      if the null string is returned either because sysem does
//      not provide error message texts or because wa is out of
//      range, spitbol will print the string stored in errtext
//      keyword.
        
//      sysen -- endfile
        extern void sysen();				// define external entry point
//      sysen is used to implement the snobol4 function endfile.
//      the meaning is system dependent. in general, endfile
//      implies that no further i/o operations will be performed,
//      but does not guarantee this to be the case. the file
//      should be closed after the call, a subsequent read
//      or write may reopen the file at the start or it may be
//      necessary to reopen the file via sysio.
//      (wa)                  ptr to fcblk or zero
//      (xr)                  endfile argument (scblk ptr)
//      jsr  sysen            call to endfile
//      ppm  loc              return here if file does not exist
//      ppm  loc              return here if endfile not allowed
//      ppm  loc              return here if i/o error
//      (wa,wb)               destroyed
//      the second error return is used for files for which
//      endfile is not permitted. for example, it may be expected
//      that the standard input and output files are in this
//      category.
        
//      sysep -- eject printer page
        extern void sysep();				// define external entry point
//      sysep is called to perform a page eject on the standard
//      printer output file (corresponding to syspr output).
//      jsr  sysep            call to eject printer output
        
//      sysex -- call external function
        extern void sysex();				// define external entry point
//      sysex is called to pass control to an external function
//      previously loaded with a call to sysld.
//      (xs)                  pointer to arguments on stack
//      (xl)                  pointer to control block (efblk)
//      (wa)                  number of arguments on stack
//      jsr  sysex            call to pass control to function
//      ppm  loc              return here if function call fails
//      ppm  loc              return here if insufficient memory
//      ppm  loc              return here if bad argument type
//      (xr)                  result returned
//      the arguments are stored on the stack with
//      the last argument at 0(xs). on return, xs
//      is popped past the arguments.
//      the form of the arguments as passed is that used in the
//      spitbol translator (see definitions and data structures
//      section). the control block format is also described
//      (under efblk) in this section.
//      there are two ways of returning a result.
//      1)   return a pointer to a block in dynamic storage. this
//           block must be in exactly correct format, including
//           the first word. only functions written with intimate
//           knowledge of the system will return in this way.
//      2)   string, integer and real results may be returned by
//           pointing to a pseudo-block outside dynamic memory.
//           this block is in icblk, rcblk or scblk format except
//           that the first word will be overwritten
//           by a type word on return and so need not
//           be correctly set. such a result is
//           copied into main storage before proceeding.
//           unconverted results may similarly be returned in a
//           pseudo-block which is in correct format including
//           type word recognisable by garbage collector since
//           block is copied into dynamic memory.
        
//      sysfc -- file control block routine
        extern void sysfc();				// define external entry point
//      see also sysio
//      input and output have 3 arguments referred to as shown
//           input(variable name,file arg1,file arg2)
//           output(variable name,file arg1,file arg2)
//      file arg1 may be an integer or string used to identify
//      an i/o channel. it is converted to a string for checking.
//      the exact significance of file arg2
//      is not rigorously prescribed but to improve portability,
//      the scheme described in the spitbol user manual
//      should be adopted when possible. the preferred form is
//      a string _f_,r_r_,c_c_,i_i_,...,z_z_  where
//      _f_ is an optional file name which is placed first.
//       remaining items may be omitted or included in any order.
//      _r_ is maximum record length
//      _c_ is a carriage control character or character string
//      _i_ is some form of channel identification used in the
//         absence of _f_ to associate the variable
//         with a file allocated dynamically by jcl commands at
//         spitbol load time.
//      ,...,z_z_ are additional fields.
//      if , (comma) cannot be used as a delimiter, .ciod
//      should be defined to introduce by conditional assembly
//      another delimiter (see
//        iodel  equ  *
//      early in definitions section).
//      sysfc is called when a variable is input or output
//      associated to check file arg1 and file arg2 and
//      to  report whether an fcblk (file control
//      block) is necessary and if so what size it should be.
//      this makes it possible for spitbol rather than osint to
//      allocate such a block in dynamic memory if required
//      or alternatively in static memory.
//      the significance of an fcblk , if one is requested, is
//      entirely up to the system interface. the only restriction
//      is that if the fcblk should appear to lie in dynamic
//      memory, pointers to it should be proper pointers to
//      the start of a recognisable and garbage collectable
//      block (this condition will be met if sysfc requests
//      spitbol to provide an fcblk).
//      an option is provided for osint to return a pointer in
//      xl to an fcblk which it privately allocated. this ptr
//      will be made available when i/o occurs later.
//      private fcblks may have arbitrary contents and spitbol
//      stores nothing in them.
        
//      the requested size for an fcblk in dynamic memory
//      should allow a 2 word overhead for block type and
//      length fields. information subsequently stored in the
//      remaining words may be arbitrary if an xnblk (external
//      non-relocatable block) is requested. if the request is
//      for an xrblk (external relocatable block) the
//      contents of words should be collectable (i.e. any
//      apparent pointers into dynamic should be genuine block
//      pointers). these restrictions do not apply if an fcblk
//      is allocated outside dynamic or is not allocated at all.
//      if an fcblk is requested, its fields will be initialised
//      to zero before entry to sysio with the exception of
//      words 0 and 1 in which the block type and length
//      fields are placed for fcblks in dynamic memory only.
//      for the possible use of sysej and sysxi, if fcblks
//      are used, a chain is built so that they may all be
//      found - see sysxi for details.
//      if both file arg1 and file arg2 are null, calls of sysfc
//      and sysio are omitted.
//      if file arg1 is null (standard input/output file), sysfc
//      is called to check non-null file arg2 but any request
//      for an fcblk will be ignored, since spitbol handles the
//      standard files specially and cannot readily keep fcblk
//      pointers for them.
//      filearg1 is type checked by spitbol so further checking
//      may be unneccessary in many implementations.
//      file arg2 is passed so that sysfc may analyse and
//      check it. however to assist in this, spitbol also passes
//      on the stack the components of this argument with
//      file name, _f_ (otherwise null) extracted and stacked
//      first.
//      the other fields, if any, are extracted as substrings,
//      pointers to them are stacked and a count of all items
//      stacked is placed in wc. if an fcblk was earlier
//      allocated and pointed to via file arg1, sysfc is also
//      passed a pointer to this fcblk.
//      (xl)                  file arg1 scblk ptr (2nd arg)
//      (xr)                  filearg2 (3rd arg) or null
//      -(xs)...-(xs)         scblks for _f_,_r_,_c_,...
//      (wc)                  no. of stacked scblks above
//      (wa)                  existing file arg1 fcblk ptr or 0
//      (wb)                  0/3 for input/output assocn
//      jsr  sysfc            call to check need for fcblk
//      ppm  loc              invalid file argument
//      ppm  loc              fcblk already in use
//      (xs)                  popped (wc) times
//      (wa non zero)         byte size of requested fcblk
//      (wa=0,xl non zero)    private fcblk ptr in xl
//      (wa=xl=0)             no fcblk wanted, no private fcblk
//      (wc)                  0/1/2 request alloc of xrblk/xnblk
//                            /static block for use as fcblk
//      (wb)                  destroyed
        
//      sysgc -- inform interface of garbage collections
        extern void sysgc();				// define external entry point
//      provides means for interface to take special actions
//      prior to and after a garbage collection.
//      possible usages-
//      1. provide visible screen icon of garbage collection
//         in progress
//      2. inform virtual memory manager to ignore page access
//         patterns during garbage collection.  such accesses
//         typically destroy the page working set accumulated
//         by the program.
//      3. inform virtual memory manager that contents of memory
//         freed by garbage collection can be discarded.
//      (xr)                  non-zero if beginning gc
//                            =0 if completing gc
//      (wa)                  dnamb=start of dynamic area
//      (wb)                  dnamp=next available location
//      (wc)                  dname=last available location + 1
//      jsr  sysgc            call to sysgc function
//      all registers preserved
        
//      syshs -- give access to host computer features
        extern void syshs();				// define external entry point
//      provides means for implementing special features
//      on different host computers. the only defined entry is
//      that where all arguments are null in which case syshs
//      returns an scblk containing name of computer,
//      name of operating system and name of site separated by
//      colons. the scblk need not have a correct first field
//      as this is supplied on copying string to dynamic memory.
//      spitbol does no argument checking but does provide a
//      single error return for arguments checked as erroneous
//      by osint. it also provides a single execution error
//      return. if these are inadequate, use may be made of the
//      minimal error section direct as described in minimal
//      documentation, section 10.
//      several non-error returns are provided. the first
//      corresponds to the defined entry or, for implementation
//      defined entries, any string may be returned. the others
//      permit respectively,  return a null result, return with a
//      result to be stacked which is pointed at by xr, and a
//      return causing spitbol statement failure. if a returned
//      result is in dynamic memory it must obey garbage
//      collector rules. the only results copied on return
//      are strings returned via ppm loc3 return.
//      (wa)                  argument 1
//      (xl)                  argument 2
//      (xr)                  argument 3
//      (wb)                  argument 4
//      (wc)                  argument 5
//      jsr  syshs            call to get host information
//      ppm  loc1             erroneous arg
//      ppm  loc2             execution error
//      ppm  loc3             scblk ptr in xl or 0 if unavailable
//      ppm  loc4             return a null result
//      ppm  loc5             return result in xr
//      ppm  loc6             cause statement failure
//      ppm  loc7             return string at xl, length wa
//      ppm  loc8             return copy of result in xr
        
//      sysid -- return system identification
        extern void sysid();				// define external entry point
//      this routine should return strings to head the standard
//      printer output. the first string will be appended to
//      a heading line of the form
//           macro spitbol version v.v
//      supplied by spitbol itself. v.v are digits giving the
//      major version number and generally at least a minor
//      version number relating to osint should be supplied to
//      give say
//           macro spitbol version v.v(m.m)
//      the second string should identify at least the machine
//      and operating system.  preferably it should include
//      the date and time of the run.
//      optionally the strings may include site name of the
//      the implementor and/or machine on which run takes place,
//      unique site or copy number and other information as
//      appropriate without making it so long as to be a
//      nuisance to users.
//      the first words of the scblks pointed at need not be
//      correctly set.
//      jsr  sysid            call for system identification
//      (xr)                  scblk ptr for addition to header
//      (xl)                  scblk ptr for second header
        
//      sysif -- switch to new include file
        extern void sysif();				// define external entry point
//      sysif is used for include file processing, both to inform
//      the interface when a new include file is desired, and
//      when the end of file of an include file has been reached
//      and it is desired to return to reading from the previous
//      nested file.
//      it is the responsibility of sysif to remember the file
//      access path to the present input file before switching to
//      the new include file.
//      (xl)                  ptr to scblk or zero
//      (xr)                  ptr to vacant scblk of length cswin
//                            (xr not used if xl is zero)
//      jsr  sysif            call to change files
//      ppm  loc              unable to open file
//      (xr)                  scblk with full path name of file
//                            (xr not used if input xl is zero)
//      register xl points to an scblk containing the name of the
//      include file to which the interface should switch.  data
//      is fetched from the file upon the next call to sysrd.
//      sysif may have the ability to search multiple libraries
//      for the include file named in (xl).  it is therefore
//      required that the full path name of the file where the
//      file was finally located be returned in (xr).  it is this
//      name that is recorded along with the source statements,
//      and will accompany subsequent error messages.
//      register xl is zero to mark conclusion of use of an
//      include file.
        
//      sysil -- get input record length
        extern void sysil();				// define external entry point
//      sysil is used to get the length of the next input record
//      from a file previously input associated with a sysio
//      call. the length returned is used to establish a buffer
//      for a subsequent sysin call.  sysil also indicates to the
//      caller if this is a binary or text file.
//      (wa)                  ptr to fcblk or zero
//      jsr  sysil            call to get record length
//      (wa)                  length or zero if file closed
//      (wc)                  zero if binary, non-zero if text
//      no harm is done if the value returned is too long since
//      unused space will be reclaimed after the sysin call.
//      note that it is the sysil call (not the sysio call) which
//      causes the file to be opened as required for the first
//      record input from the file.
        
//      sysin -- read input record
        extern void sysin();				// define external entry point
//      sysin is used to read a record from the file which was
//      referenced in a prior call to sysil (i.e. these calls
//      always occur in pairs). the buffer provided is an
//      scblk for a string of length set from the sysil call.
//      if the actual length read is less than this, the length
//      field of the scblk must be modified before returning
//      unless buffer is right padded with zeroes.
//      it is also permissible to take any of the alternative
//      returns after scblk length has been modified.
//      (wa)                  ptr to fcblk or zero
//      (xr)                  pointer to buffer (scblk ptr)
//      jsr  sysin            call to read record
//      ppm  loc              endfile or no i/p file after sysxi
//      ppm  loc              return here if i/o error
//      ppm  loc              return here if record format error
//      (wa,wb,wc)            destroyed
        
//      sysio -- input/output file association
        extern void sysio();				// define external entry point
//      see also sysfc.
//      sysio is called in response to a snobol4 input or output
//      function call except when file arg1 and file arg2
//      are both null.
//      its call always follows immediately after a call
//      of sysfc. if sysfc requested allocation
//      of an fcblk, its address will be in wa.
//      for input files, non-zero values of _r_ should be
//      copied to wc for use in allocating input buffers. if _r_
//      is defaulted or not implemented, wc should be zeroised.
//      once a file has been opened, subsequent input(),output()
//      calls in which the second argument is identical with that
//      in a previous call, merely associate the additional
//      variable name (first argument) to the file and do not
//      result in re-opening the file.
//      in subsequent associated accesses to the file a pointer
//      to any fcblk allocated will be made available.
//      (xl)                  file arg1 scblk ptr (2nd arg)
//      (xr)                  file arg2 scblk ptr (3rd arg)
//      (wa)                  fcblk ptr (0 if none)
//      (wb)                  0 for input, 3 for output
//      jsr  sysio            call to associate file
//      ppm  loc              return here if file does not exist
//      ppm  loc              return if input/output not allowed
//      (xl)                  fcblk pointer (0 if none)
//      (wc)                  0 (for default) or max record lngth
//      (wa,wb)               destroyed
//      the second error return is used if the file named exists
//      but input/output from the file is not allowed. for
//      example, the standard output file may be in this category
//      as regards input association.
        
//      sysld -- load external function
        extern void sysld();				// define external entry point
//      sysld is called in response to the use of the snobol4
//      load function. the named function is loaded (whatever
//      this means), and a pointer is returned. the pointer will
//      be used on subsequent calls to the function (see sysex).
//      (xr)                  pointer to function name (scblk)
//      (xl)                  pointer to library name (scblk)
//      jsr  sysld            call to load function
//      ppm  loc              return here if func does not exist
//      ppm  loc              return here if i/o error
//      ppm  loc              return here if insufficient memory
//      (xr)                  pointer to loaded code
//      the significance of the pointer returned is up to the
//      system interface routine. the only restriction is that
//      if the pointer is within dynamic storage, it must be
//      a proper block pointer.
        
//      sysmm -- get more memory
        extern void sysmm();				// define external entry point
//      sysmm is called in an attempt to allocate more dynamic
//      memory. this memory must be allocated contiguously with
//      the current dynamic data area.
//      the amount allocated is up to the system to decide. any
//      value is acceptable including zero if allocation is
//      impossible.
//      jsr  sysmm            call to get more memory
//      (xr)                  number of additional words obtained
        
//      sysmx -- supply mxlen
        extern void sysmx();				// define external entry point
//      because of the method of garbage collection, no spitbol
//      object is allowed to occupy more bytes of memory than
//      the integer giving the lowest address of dynamic
//      (garbage collectable) memory. mxlen is the name used to
//      refer to this maximum length of an object and for most
//      users of most implementations, provided dynamic memory
//      starts at an address of at least a few thousand words,
//      there is no problem.
//      if the default starting address is less than say 10000 or
//      20000, then a load time option should be provided where a
//      user can request that he be able to create larger
//      objects. this routine informs spitbol of this request if
//      any. the value returned is either an integer
//      representing the desired value of mxlen (and hence the
//      minimum dynamic store address which may result in
//      non-use of some store) or zero if a default is acceptable
//      in which mxlen is set to the lowest address allocated
//      to dynamic store before compilation starts.
//      if a non-zero value is returned, this is used for keyword
//      maxlngth. otherwise the initial low address of dynamic
//      memory is used for this keyword.
//      jsr  sysmx            call to get mxlen
//      (wa)                  either mxlen or 0 for default
        
//      sysou -- output record
        extern void sysou();				// define external entry point
//      sysou is used to write a record to a file previously
//      associated with a sysio call.
//      (wa)                  ptr to fcblk
//                            or 0 for terminal or 1 for output
//      (xr)                  record to be written (scblk)
//      jsr  sysou            call to output record
//      ppm  loc              file full or no file after sysxi
//      ppm  loc              return here if i/o error
//      (wa,wb,wc)            destroyed
//      note that it is the sysou call (not the sysio call) which
//      causes the file to be opened as required for the first
//      record output to the file.
        
//      syspi -- print on interactive channel
        extern void syspi();				// define external entry point
//      if spitbol is run from an online terminal, osint can
//      request that messages such as copies of compilation
//      errors be sent to the terminal (see syspp). if relevant
//      reply was made by syspp then syspi is called to send such
//      messages to the interactive channel.
//      syspi is also used for sending output to the terminal
//      through the special variable name, terminal.
//      (xr)                  ptr to line buffer (scblk)
//      (wa)                  line length
//      jsr  syspi            call to print line
//      ppm  loc              failure return
//      (wa,wb)               destroyed
        
//      syspl -- provide interactive control of spitbol
        extern void syspl();				// define external entry point
//      provides means for interface to take special actions,
//      such as interrupting execution, breakpointing, stepping,
//      and expression evaluation.  these last three options are
//      not presently implemented by the code calling syspl.
//      (wa)                  opcode as follows-
//                            =0 poll to allow osint to interrupt
//                            =1 breakpoint hit
//                            =2 completion of statement stepping
//                            =3 expression evaluation result
//      (wb)                  statement number
//      r_fcb                 o or ptr to head of fcblk chain
//      jsr  syspl            call to syspl function
//      ppm  loc              user interruption
//      ppm  loc              step one statement
//      ppm  loc              evaluate expression
//      ---                   resume execution
//                            (wa) = new polling interval
        
//      syspp -- obtain print parameters
        extern void syspp();				// define external entry point
//      syspp is called once during compilation to obtain
//      parameters required for correct printed output format
//      and to select other options. it may also be called again
//      after sysxi when a load module is resumed. in this
//      case the value returned in wa may be less than or equal
//      to that returned in initial call but may not be
//      greater.
//      the information returned is -
//      1.   line length in chars for standard print file
//      2.   no of lines/page. 0 is preferable for a non-paged
//           device (e.g. online terminal) in which case listing
//           page throws are suppressed and page headers
//           resulting from -title,-stitl lines are kept short.
//      3.   an initial -nolist option to suppress listing unless
//           the program contains an explicit -list.
//      4.   options to suppress listing of compilation and/or
//           execution stats (useful for established programs) -
//           combined with 3. gives possibility of listing
//           file never being opened.
//      5.   option to have copies of errors sent to an
//           interactive channel in addition to standard printer.
//      6.   option to keep page headers short (e.g. if listing
//           to an online terminal).
//      7.   an option to choose extended or compact listing
//           format. in the former a page eject and in the latter
//           a few line feeds precede the printing of each
//           of-- listing, compilation statistics, execution
//           output and execution statistics.
//      8.   an option to suppress execution as though a
//           -noexecute card were supplied.
//      9.   an option to request that name /terminal/  be pre-
//           associated to an online terminal via syspi and sysri
//      10.  an intermediate (standard) listing option requiring
//           that page ejects occur in source listings. redundant
//           if extended option chosen but partially extends
//           compact option.
//      11.  option to suppress sysid identification.
//      jsr  syspp            call to get print parameters
//      (wa)                  print line length in chars
//      (wb)                  number of lines/page
//      (wc)                  bits value ...mlkjihgfedcba where
//                            a = 1 to send error copy to int.ch.
//                            b = 1 means std printer is int. ch.
//                            c = 1 for -nolist option
//                            d = 1 to suppress compiln. stats
//                            e = 1 to suppress execn. stats
//                            f = 1/0 for extnded/compact listing
//                            g = 1 for -noexecute
//                            h = 1 pre-associate /terminal/
//                            i = 1 for standard listing option.
//                            j = 1 suppresses listing header
//                            k = 1 for -print
//                            l = 1 for -noerrors
        
//      syspr -- print line on standard output file
        extern void syspr();				// define external entry point
//      syspr is used to print a single line on the standard
//      output file.
//      (xr)                  pointer to line buffer (scblk)
//      (wa)                  line length
//      jsr  syspr            call to print line
//      ppm  loc              too much o/p or no file after sysxi
//      (wa,wb)               destroyed
//      the buffer pointed to is the length obtained from the
//      syspp call and is filled out with trailing blanks. the
//      value in wa is the actual line length which may be less
//      than the maximum line length possible. there is no space
//      control associated with the line, all lines are printed
//      single spaced. note that null lines (wa=0) are possible
//      in which case a blank line is to be printed.
//      the error exit is used for systems which limit the amount
//      of printed output. if possible, printing should be
//      permitted after this condition has been signalled once to
//      allow for dump and other diagnostic information.
//      assuming this to be possible, spitbol may make more syspr
//      calls. if the error return occurs another time, execution
//      is terminated by a call of sysej with ending code 998.
        
//      sysrd -- read record from standard input file
        extern void sysrd();				// define external entry point
//      sysrd is used to read a record from the standard input
//      file. the buffer provided is an scblk for a string the
//      length of which in characters is given in wc, this
//      corresponding to the maximum length of string which
//      spitbol is prepared to receive. at compile time it
//      corresponds to xxx in the most recent -inxxx card
//      (default 72) and at execution time to the most recent
//      ,r_r_ (record length) in the third arg of an input()
//      statement for the standard input file (default 80).
//      if fewer than (wc) characters are read, the length
//      field of the scblk must be adjusted before returning
//      unless the buffer is right padded with zeroes.
//      it is also permissible to take the alternative return
//      after such an adjustment has been made.
//      spitbol may continue to make calls after an endfile
//      return so this routine should be prepared to make
//      repeated endfile returns.
//      (xr)                  pointer to buffer (scblk ptr)
//      (wc)                  length of buffer in characters
//      jsr  sysrd            call to read line
//      ppm  loc              endfile or no i/p file after sysxi
//                            or input file name change.  if
//                            the former, scblk length is zero.
//                            if input file name change, length
//                            is non-zero. caller should re-issue
//                            sysrd to obtain input record.
//      (wa,wb,wc)            destroyed
        
//      sysri -- read record from interactive channel
        extern void sysri();				// define external entry point
//      reads a record from online terminal for spitbol variable,
//      terminal. if online terminal is unavailable then code the
//      endfile return only.
//      the buffer provided is of length 258 characters. sysri
//      should replace the count in the second word of the scblk
//      by the actual character count unless buffer is right
//      padded with zeroes.
//      it is also permissible to take the alternative
//      return after adjusting the count.
//      the end of file return may be used if this makes
//      sense on the target machine (e.g. if there is an
//      eof character.)
//      (xr)                  ptr to 258 char buffer (scblk ptr)
//      jsr  sysri            call to read line from terminal
//      ppm  loc              end of file return
//      (wa,wb,wc)            may be destroyed
        
//      sysrw -- rewind file
        extern void sysrw();				// define external entry point
//      sysrw is used to rewind a file i.e. reposition the file
//      at the start before the first record. the file should be
//      closed and the next read or write call will open the
//      file at the start.
//      (wa)                  ptr to fcblk or zero
//      (xr)                  rewind arg (scblk ptr)
//      jsr  sysrw            call to rewind file
//      ppm  loc              return here if file does not exist
//      ppm  loc              return here if rewind not allowed
//      ppm  loc              return here if i/o error
        
//      systm -- get execution time so far
        extern void systm();				// define external entry point
//      systm is used to obtain the amount of execution time
//      used so far since spitbol was given control. the units
//      are described as microseconds in the spitbol output, but
//      the exact meaning is system dependent. where appropriate,
//      this value should relate to processor rather than clock
//      timing values.
//      if the symbol .ctmd is defined, the units are described
//      as deciseconds (0.1 second).
//      jsr  systm            call to get timer value
//      (ia)                  time so far in micliseconds
//                            (deciseconds if .ctmd defined)
        
//      systt -- trace toggle
        extern void systt();				// define external entry point
//      called by spitbol function trace() with no args to
//      toggle the system trace switch.  this permits tracing of
//      labels in spitbol code to be turned on or off.
//      jsr  systt            call to toggle trace switch
        
//      sysul -- unload external function
        extern void sysul();				// define external entry point
//      sysul is used to unload a function previously
//      loaded with a call to sysld.
//      (xr)                  ptr to control block (efblk)
//      jsr  sysul            call to unload function
//      the function cannot be called following a sysul call
//      until another sysld call is made for the same function.
//      the efblk contains the function code pointer and also a
//      pointer to the vrblk containing the function name (see
//      definitions and data structures section).
        
//      sysxi -- exit to produce load module
        extern void sysxi();				// define external entry point
//      when sysxi is called, xl contains either a string pointer
//      or zero. in the former case, the string gives the
//      character name of a program. the intention is that
//      spitbol execution should be terminated forthwith and
//      the named program loaded and executed. this type of chain
//      execution is very system dependent and implementors may
//      choose to omit it or find it impossible to provide.
//      if (xl) is zero,ia contains one of the following integers
//      -1, -2, -3, -4
//           create if possible a load module containing only the
//           impure area of memory which needs to be loaded with
//           a compatible pure segment for subsequent executions.
//           version numbers to check compatibility should be
//           kept in both segments and checked on loading.
//           to assist with this check, (xr) on entry is a
//           pointer to an scblk containing the spitbol major
//           version number v.v (see sysid).  the file thus
//           created is called a save file.
//      0    if possible, return control to job control
//           command level. the effect if available will be
//           system dependent.
//      +1, +2, +3, +4
//           create if possible a load module from all of
//           memory. it should be possible to load and execute
//           this module directly.
//      in the case of saved load modules, the status of open
//      files is not preserved and implementors may choose to
//      offer means of attaching files before execution of load
//      modules starts or leave it to the user to include
//      suitable input(), output() calls in his program.
//      sysxi should make a note that no i/o channels,
//      including standard files, have files attached so that
//      calls of sysin, sysou, syspr, sysrd should fail unless
//      new associations are made for the load module.
//      at least in the case of the standard output file, it is
//      recommended that either the user be required to attach
//      a file or that a default file is attached, since the
//      problem of error messages generated by the load module
//      is otherwise severe. as a last resort, if spitbol
//      attempts to write to the standard output file and gets a
//      reply indicating that such ouput is unacceptable it stops
//      by using an entry to sysej with ending code 998.
//      as described below, passing of some arguments makes it
//      clear that load module will use a standard output file.
//      if use is made of fcblks for i/o association, spitbol
//      builds a chain so that those in use may be found in sysxi
//      and sysej. the nodes are 4 words long. third word
//      contains link to next node or 0, fourth word contains
//      fcblk pointer.
        
//      sysxi (continued)
//      (xl)                  zero or scblk ptr to first argument
//      (xr)                  ptr to v.v scblk
//      (ia)                  signed integer argument
//      (wa)                  scblk ptr to second argument
//      (wb)                  0 or ptr to head of fcblk chain
//      jsr  sysxi            call to exit
//      ppm  loc              requested action not possible
//      ppm  loc              action caused irrecoverable error
//      (wb,wc,ia,xr,xl,cp)   should be preserved over call
//      (wa)                  0 in all cases except sucessful
//                            performance of exit(4) or exit(-4),
//                            in which case 1 should be returned.
//      loading and running the load module or returning from
//      jcl command level causes execution to resume at the point
//      after the error returns which follow the call of sysxi.
//      the value passed as exit argument is used to indicate
//      options required on resumption of load module.
//      +1 or -1 require that on resumption, sysid and syspp be
//      called and a heading printed on the standard output file.
//      +2 or -2 indicate that syspp will be called but not sysid
//      and no heading will be put on standard output file.
//      above options have the obvious implication that a
//      standard o/p file must be provided for the load module.
//      +3, +4, -3 or -4 indicate calls of neither sysid nor
//      syspp and no heading will be placed on standard output
//      file.
//      +4 or -4 indicate that execution is to continue after
//      creation of the save file or load module, although all
//      files will be closed by the sysxi action.  this permits
//      the user to checkpoint long-running programs while
//      continuing execution.
//      no return from sysxi is possible if another program
//      is loaded and entered.
        
//      introduce the internal procedures.
        
        
//      introduce the internal routines
//      this section contains all symbol definitions and also
//      pictures of all data structures used in the system.
//      definitions of machine parameters
//      the minimal translator should supply appropriate values
//      for the particular target machine for all the
//      equ  *
//      definitions given at the start of this section.
//      note that even if conditional assembly is used to omit
//      some feature (e.g. real arithmetic) a full set of cfp_-
//      values must be supplied. use dummy values if genuine
//      ones are not needed.
        #define CFP_A	(256)				// number of characters in alphabet
        #define CFP_B	(8)				// bytes/word addressing factor
        #define CFP_C	(8)				// number of characters per word
        #define CFP_F	(16)				// offset in bytes to chars in
//                            scblk. see scblk format.
        #define CFP_I	(1)				// number of words in integer constant
        #define CFP_M	(9223372036854775807)				// max positive integer in one word
        #define CFP_N	(64)				// number of bits in one word
//      the following definitions require the supply of either
//      a single parameter if real arithmetic is omitted or
//      three parameters if real arithmetic is included.
        #define CFP_R	(1)				// number of words in real constant
        #define CFP_S	(9)				// number of sig digs for real output
        #define CFP_X	(3)				// max digits in real exponent
        #define MXDGS	(CFP_S+CFP_X)				// max digits in real number
//      max space for real (for +0.e+) needs five more places
        #define NSTMX	(MXDGS+5)				// max space for real
//      the following definition for cfp_u supplies a realistic
//      upper bound on the size of the alphabet.  cfp_u is used
//      to save space in the scane bsw-iff-esw table and to ease
//      translation storage requirements.
        #define CFP_U	(128)				// realistic upper bound on alphabet
        
//      environment parameters
//      the spitbol program is essentially independent of
//      the definitions of these parameters. however, the
//      efficiency of the system may be affected. consequently,
//      these parameters may require tuning for a given version
//      the values given in comments have been successfully used.
//      e_srs is the number of words to reserve at the end of
//      storage for end of run processing. it should be
//      set as small as possible without causing memory overflow
//      in critical situations (e.g. memory overflow termination)
//      and should thus reserve sufficient space at least for
//      an scblk containing say 30 characters.
        #define E_SRS	(100)				// 30 words
//      e_sts is the number of words grabbed in a chunk when
//      storage is allocated in the static region. the minimum
//      permitted value is 256/cfp_b. larger values will lead
//      to increased efficiency at the cost of wasting memory.
        #define E_STS	(1000)				// 500 words
//      e_cbs is the size of code block allocated initially and
//      the expansion increment if overflow occurs. if this value
//      is too small or too large, excessive garbage collections
//      will occur during compilation and memory may be lost
//      in the case of a too large value.
        #define E_CBS	(500)				// 500 words
//      e_hnb is the number of bucket headers in the variable
//      hash table. it should always be odd. larger values will
//      speed up compilation and indirect references at the
//      expense of additional storage for the hash table itself.
        #define E_HNB	(257)				// 127 bucket headers
//      e_hnw is the maximum number of words of a string
//      name which participate in the string hash algorithm.
//      larger values give a better hash at the expense of taking
//      longer to compute the hash. there is some optimal value.
        #define E_HNW	(3)				// 6 words
//      e_fsp.  if the amount of free space left after a garbage
//      collection is small compared to the total amount of space
//      in use garbage collector thrashing is likely to occur as
//      this space is used up.  e_fsp is a measure of the
//      minimum percentage of dynamic memory left as free space
//      before the system routine sysmm is called to try to
//      obtain more memory.
        #define E_FSP	(15)				// 15 percent
//      e_sed.  if the amount of free space left in the sediment
//      after a garbage collection is a significant fraction of
//      the new sediment size, the sediment is marked for
//      collection on the next call to the garbage collector.
        #define E_SED	(25)				// 25 percent
        
//      definitions of codes for letters
        #define CH_LA	(97)				// letter a
        #define CH_LB	(98)				// letter b
        #define CH_LC	(99)				// letter c
        #define CH_LD	(100)				// letter d
        #define CH_LE	(101)				// letter e
        #define CH_LF	(102)				// letter f
        #define CH_LG	(103)				// letter g
        #define CH_LH	(104)				// letter h
        #define CH_LI	(105)				// letter i
        #define CH_LJ	(106)				// letter j
        #define CH_LK	(107)				// letter k
        #define CH_LL	(108)				// letter l
        #define CH_LM	(109)				// letter m
        #define CH_LN	(110)				// letter n
        #define CH_LO	(111)				// letter o
        #define CH_LP	(112)				// letter p
        #define CH_LQ	(113)				// letter q
        #define CH_LR	(114)				// letter r
        #define CH_LS	(115)				// letter s
        #define CH_LT	(116)				// letter t
        #define CH_LU	(117)				// letter u
        #define CH_LV	(118)				// letter v
        #define CH_LW	(119)				// letter w
        #define CH_LX	(120)				// letter x
        #define CH_LY	(121)				// letter y
        #define CH_L_	(122)				// letter z
//      definitions of codes for digits
        #define CH_D0	(48)				// digit 0
        #define CH_D1	(49)				// digit 1
        #define CH_D2	(50)				// digit 2
        #define CH_D3	(51)				// digit 3
        #define CH_D4	(52)				// digit 4
        #define CH_D5	(53)				// digit 5
        #define CH_D6	(54)				// digit 6
        #define CH_D7	(55)				// digit 7
        #define CH_D8	(56)				// digit 8
        #define CH_D9	(57)				// digit 9
        
//      definitions of codes for special characters
//      the names of these characters are related to their
//      original representation in the ebcdic set corresponding
//      to the description in standard snobol4 manuals and texts.
        #define CH_AM	(38)				// keyword operator (ampersand)
        #define CH_AS	(42)				// multiplication symbol (asterisk)
        #define CH_AT	(64)				// cursor position operator (at)
        #define CH_BB	(60)				// left array bracket (less than)
        #define CH_BL	(32)				// blank
        #define CH_BR	(124)				// alternation operator (vertical bar)
        #define CH_CL	(58)				// goto symbol (colon)
        #define CH_CM	(44)				// comma
        #define CH_DL	(36)				// indirection operator (dollar)
        #define CH_DT	(46)				// name operator (dot)
        #define CH_DQ	(34)				// double quote
        #define CH_EQ	(61)				// equal sign
        #define CH_EX	(33)				// exponentiation operator (exclm)
        #define CH_MN	(45)				// minus sign / hyphen
        #define CH_NM	(35)				// number sign
        #define CH_NT	(126)				// negation operator (not)
        #define CH_PC	(94)				// percent
        #define CH_PL	(43)				// plus sign
        #define CH_PP	(40)				// left parenthesis
        #define CH_RB	(62)				// right array bracket (grtr than)
        #define CH_RP	(41)				// right parenthesis
        #define CH_QU	(63)				// interrogation operator (question)
        #define CH_SL	(47)				// slash
        #define CH_SM	(59)				// semicolon
        #define CH_SQ	(39)				// single quote
        #define CH_U_	(95)				// special identifier char (underline)
        #define CH_OB	(91)				// opening bracket
        #define CH_CB	(93)				// closing bracket
        
//      remaining chars are optional additions to the standards.
//      tab characters - syntactically equivalent to blank
        #define CH_HT	(9)				// horizontal tab
//      upper case or shifted case alphabetic chars
        #define CH_UA	(65)				// shifted a
        #define CH_UB	(66)				// shifted b
        #define CH_UC	(67)				// shifted c
        #define CH_UD	(68)				// shifted d
        #define CH_UE	(69)				// shifted e
        #define CH_UF	(70)				// shifted f
        #define CH_UG	(71)				// shifted g
        #define CH_UH	(72)				// shifted h
        #define CH_UI	(73)				// shifted i
        #define CH_UJ	(74)				// shifted j
        #define CH_UK	(75)				// shifted k
        #define CH_UL	(76)				// shifted l
        #define CH_UM	(77)				// shifted m
        #define CH_UN	(78)				// shifted n
        #define CH_UO	(79)				// shifted o
        #define CH_UP	(80)				// shifted p
        #define CH_UQ	(81)				// shifted q
        #define CH_UR	(82)				// shifted r
        #define CH_US	(83)				// shifted s
        #define CH_UT	(84)				// shifted t
        #define CH_UU	(85)				// shifted u
        #define CH_UV	(86)				// shifted v
        #define CH_UW	(87)				// shifted w
        #define CH_UX	(88)				// shifted x
        #define CH_UY	(89)				// shifted y
        #define CH_UZ	(90)				// shifted z
//      if a delimiter other than ch_cm must be used in
//      the third argument of input(),output() then .ciod should
//      be defined and a parameter supplied for iodel.
        #define IODEL	(32)
        
//      data block formats and definitions
//      the following sections describe the detailed format of
//      all possible data blocks in static and dynamic memory.
//      every block has a name of the form xxblk where xx is a
//      unique two character identifier. the first word of every
//      block must contain a pointer to a program location in the
//      interpretor which is immediately preceded by an address
//      constant containing the value bl_xx where xx is the block
//      identifier. this provides a uniform mechanism for
//      distinguishing between the various block types.
//      in some cases, the contents of the first word is constant
//      for a given block type and merely serves as a pointer
//      to the identifying address constant. however, in other
//      cases there are several possibilities for the first
//      word in which case each of the several program entry
//      points must be preceded by the appropriate constant.
//      in each block, some of the fields are relocatable. this
//      means that they may contain a pointer to another block
//      in the dynamic area. (to be more precise, if they contain
//      a pointer within the dynamic area, then it is a pointer
//      to a block). such fields must be modified by the garbage
//      collector (procedure gbcol) whenever blocks are compacted
//      in the dynamic region. the garbage collector (actually
//      procedure gbcpf) requires that all such relocatable
//      fields in a block must be contiguous.
        
//      the description format uses the following scheme.
//      1)   block title and two character identifier
//      2)   description of basic use of block and indication
//           of circumstances under which it is constructed.
//      3)   picture of the block format. in these pictures low
//           memory addresses are at the top of the page. fixed
//           length fields are surrounded by i (letter i). fields
//           which are fixed length but whose length is dependent
//           on a configuration parameter are surrounded by *
//           (asterisk). variable length fields are surrounded
//           by / (slash).
//      4)   definition of symbolic offsets to fields in
//           block and of the size of the block if fixed length
//           or of the size of the fixed length fields if the
//           block is variable length.
//           note that some routines such as gbcpf assume
//           certain offsets are equal. the definitions
//           given here enforce this.  make changes to
//           them only with due care.
//      definitions of common offsets
        #define OFFS1	(1)
        #define OFFS2	(2)
        #define OFFS3	(3)
//      5)   detailed comments on the significance and formats
//           of the various fields.
//      the order is alphabetical by identification code.
        
//      definitions of block codes
//      this table provides a unique identification code for
//      each separate block type. the first word of a block in
//      the dynamic area always contains the address of a program
//      entry point. the block code is used as the entry point id
//      the order of these codes dictates the order of the table
//      used by the datatype function (scnmt in the constant sec)
//      block codes for accessible datatypes
//      note that real and buffer types are always included, even
//      if they are conditionally excluded elsewhere.  this main-
//      tains block type codes across all versions of spitbol,
//      providing consistancy for external functions.  but note
//      that the bcblk is out of alphabetic order, placed at the
//      end of the list so as not to change the block type
//      ordering in use in existing external functions.
        #define BL_AR	(0)				// arblk     array
        #define BL_CD	(BL_AR+1)				// cdblk     code
        #define BL_EX	(BL_CD+1)				// exblk     expression
        #define BL_IC	(BL_EX+1)				// icblk     integer
        #define BL_NM	(BL_IC+1)				// nmblk     name
        #define BL_P0	(BL_NM+1)				// p0blk     pattern
        #define BL_P1	(BL_P0+1)				// p1blk     pattern
        #define BL_P2	(BL_P1+1)				// p2blk     pattern
        #define BL_RC	(BL_P2+1)				// rcblk     real
        #define BL_SC	(BL_RC+1)				// scblk     string
        #define BL_SE	(BL_SC+1)				// seblk     expression
        #define BL_TB	(BL_SE+1)				// tbblk     table
        #define BL_VC	(BL_TB+1)				// vcblk     array
        #define BL_XN	(BL_VC+1)				// xnblk     external
        #define BL_XR	(BL_XN+1)				// xrblk     external
        #define BL_BC	(BL_XR+1)				// bcblk     buffer
        #define BL_PD	(BL_BC+1)				// pdblk     program defined datatype
        #define BL__D	(BL_PD+1)				// number of block codes for data
//      other block codes
        #define BL_TR	(BL_PD+1)				// trblk
        #define BL_BF	(BL_TR+1)				// bfblk
        #define BL_CC	(BL_BF+1)				// ccblk
        #define BL_CM	(BL_CC+1)				// cmblk
        #define BL_CT	(BL_CM+1)				// ctblk
        #define BL_DF	(BL_CT+1)				// dfblk
        #define BL_EF	(BL_DF+1)				// efblk
        #define BL_EV	(BL_EF+1)				// evblk
        #define BL_FF	(BL_EV+1)				// ffblk
        #define BL_KV	(BL_FF+1)				// kvblk
        #define BL_PF	(BL_KV+1)				// pfblk
        #define BL_TE	(BL_PF+1)				// teblk
        #define BL__I	(0)				// default identification code
        #define BL__T	(BL_TR+1)				// code for data or trace block
        #define BL___	(BL_TE+1)				// number of block codes
        
//      field references
//      references to the fields of data blocks are symbolic
//      (i.e. use the symbolic offsets) with the following
//      exceptions.
//      1)   references to the first word are usually not
//           symbolic since they use the (x) operand format.
//      2)   the code which constructs a block is often not
//           symbolic and should be changed if the corresponding
//           block format is modified.
//      3)   the plc and psc instructions imply an offset
//           corresponding to the definition of cfp_f.
//      4)   there are non-symbolic references (easily changed)
//           in the garbage collector (procedures gbcpf, blkln).
//      5)   the fields idval, fargs appear in several blocks
//           and any changes must be made in parallel to all
//           blocks containing the fields. the actual references
//           to these fields are symbolic with the above
//           listed exceptions.
//      6)   several spots in the code assume that the
//           definitions of the fields vrval, teval, trnxt are
//           the same (these are sections of code which search
//           out along a trblk chain from a variable).
//      7)   references to the fields of an array block in the
//           array reference routine arref are non-symbolic.
//      apart from the exceptions listed, references are symbolic
//      as far as possible and modifying the order or number
//      of fields will not require changes.
        
//      common fields for function blocks
//      blocks which represent callable functions have two
//      common fields at the start of the block as follows.
//           +------------------------------------+
//           i                fcode               i
//           +------------------------------------+
//           i                fargs               i
//           +------------------------------------+
//           /                                    /
//           /       rest of function block       /
//           /                                    /
//           +------------------------------------+
        #define FCODE	(0)				// pointer to code for function
        #define FARGS	(1)				// number of arguments
//      fcode is a pointer to the location in the interpretor
//      program which processes this type of function call.
//      fargs is the expected number of arguments. the actual
//      number of arguments is adjusted to this amount by
//      deleting extra arguments or supplying trailing nulls
//      for missing ones before transferring though fcode.
//      a value of 999 may be used in this field to indicate a
//      variable number of arguments (see svblk field svnar).
//      the block types which follow this scheme are.
//      ffblk                 field function
//      dfblk                 datatype function
//      pfblk                 program defined function
//      efblk                 external loaded function
        
//      identification field
//      id   field
//      certain program accessible objects (those which contain
//      other data values and can be copied) are given a unique
//      identification number (see exsid). this id value is an
//      address integer value which is always stored in word two.
        #define IDVAL	(1)				// id value field
//      the blocks containing an idval field are.
//      arblk                 array
//      pdblk                 program defined datatype
//      tbblk                 table
//      vcblk                 vector block (array)
//      note that a zero idval means that the block is only
//      half built and should not be dumped (see dumpr).
        
//      array block (arblk)
//      an array block represents an array value other than one
//      with one dimension whose lower bound is one (see vcblk).
//      an arblk is built with a call to the functions convert
//      (s_cnv) or array (s_arr).
//           +------------------------------------+
//           i                artyp               i
//           +------------------------------------+
//           i                idval               i
//           +------------------------------------+
//           i                arlen               i
//           +------------------------------------+
//           i                arofs               i
//           +------------------------------------+
//           i                arndm               i
//           +------------------------------------+
//           *                arlbd               *
//           +------------------------------------+
//           *                ardim               *
//           +------------------------------------+
//           *                                    *
//           * above 2 flds repeated for each dim *
//           *                                    *
//           +------------------------------------+
//           i                arpro               i
//           +------------------------------------+
//           /                                    /
//           /                arvls               /
//           /                                    /
//           +------------------------------------+
        
//      array block (continued)
        #define ARTYP	(0)				// pointer to dummy routine b_art
        #define ARLEN	(IDVAL+1)				// length of arblk in bytes
        #define AROFS	(ARLEN+1)				// offset in arblk to arpro field
        #define ARNDM	(AROFS+1)				// number of dimensions
        #define ARLBD	(ARNDM+1)				// low bound (first subscript)
        #define ARDIM	(ARLBD+CFP_I)				// dimension (first subscript)
        #define ARLB2	(ARDIM+CFP_I)				// low bound (second subscript)
        #define ARDM2	(ARLB2+CFP_I)				// dimension (second subscript)
        #define ARPRO	(ARDIM+CFP_I)				// array prototype (one dimension)
        #define ARVLS	(ARPRO+1)				// start of values (one dimension)
        #define ARPR2	(ARDM2+CFP_I)				// array prototype (two dimensions)
        #define ARVL2	(ARPR2+1)				// start of values (two dimensions)
        #define ARSI_	(ARLBD)				// number of standard fields in block
        #define ARDMS	(ARLB2-ARLBD)				// size of info for one set of bounds
//      the bounds and dimension fields are signed integer
//      values and each occupy cfp_i words in the arblk.
//      the length of an arblk in bytes may not exceed mxlen.
//      this is required to keep name offsets garbage collectable
//      the actual values are arranged in row-wise order and
//      can contain a data pointer or a pointer to a trblk.
        
//      code construction block (ccblk)
//      at any one moment there is at most one ccblk into
//      which the compiler is currently storing code (cdwrd).
//           +------------------------------------+
//           i                cctyp               i
//           +------------------------------------+
//           i                cclen               i
//           +------------------------------------+
//           i                ccsln               i
//           +------------------------------------+
//           i                ccuse               i
//           +------------------------------------+
//           /                                    /
//           /                cccod               /
//           /                                    /
//           +------------------------------------+
        #define CCTYP	(0)				// pointer to dummy routine b_cct
        #define CCLEN	(CCTYP+1)				// length of ccblk in bytes
        #define CCSLN	(CCLEN+1)				// source line number
        #define CCUSE	(CCSLN+1)				// offset past last used word (bytes)
        #define CCCOD	(CCUSE+1)				// start of generated code in block
//      the reason that the ccblk is a separate block type from
//      the usual cdblk is that the garbage collector must
//      only process those fields which have been set (see gbcpf)
        
//      code block (cdblk)
//      a code block is built for each statement compiled during
//      the initial compilation or by subsequent calls to code.
//           +------------------------------------+
//           i                cdjmp               i
//           +------------------------------------+
//           i                cdstm               i
//           +------------------------------------+
//           i                cdsln               i
//           +------------------------------------+
//           i                cdlen               i
//           +------------------------------------+
//           i                cdfal               i
//           +------------------------------------+
//           /                                    /
//           /                cdcod               /
//           /                                    /
//           +------------------------------------+
        #define CDJMP	(0)				// ptr to routine to execute statement
        #define CDSTM	(CDJMP+1)				// statement number
        #define CDSLN	(CDSTM+1)				// source line number
        #define CDLEN	(CDSLN+1)				// length of cdblk in bytes
        #define CDFAL	(CDLEN+1)				// failure exit (see below)
        #define CDCOD	(CDFAL+1)				// executable pseudo-code
        #define CDSI_	(CDCOD)				// number of standard fields in cdblk
//      cdstm is the statement number of the current statement.
//      cdjmp, cdfal are set as follows.
//      1)   if the failure exit is the next statement
//           cdjmp = b_cds
//           cdfal = ptr to cdblk for next statement
//      2)   if the failure exit is a simple label name
//           cdjmp = b_cds
//           cdfal is a ptr to the vrtra field of the vrblk
//      3)   if there is no failure exit (-nofail mode)
//           cdjmp = b_cds
//           cdfal = o_unf
//      4)   if the failure exit is complex or direct
//           cdjmp = b_cdc
//           cdfal is the offset to the o_gof word
        
//      code block (continued)
//      cdcod is the start of the actual code. first we describe
//      the code generated for an expression. in an expression,
//      elements are fetched by name or by value. for example,
//      the binary equal operator fetches its left argument
//      by name and its right argument by value. these two
//      cases generate quite different code and are described
//      separately. first we consider the code by value case.
//      generation of code by value for expressions elements.
//      expression            pointer to exblk or seblk
//      integer constant      pointer to icblk
//      null constant         pointer to nulls
//      pattern               (resulting from preevaluation)
//                            =o_lpt
//                            pointer to p0blk,p1blk or p2blk
//      real constant         pointer to rcblk
//      string constant       pointer to scblk
//      variable              pointer to vrget field of vrblk
//      addition              value code for left operand
//                            value code for right operand
//                            =o_add
//      affirmation           value code for operand
//                            =o_aff
//      alternation           value code for left operand
//                            value code for right operand
//                            =o_alt
//      array reference       (case of one subscript)
//                            value code for array operand
//                            value code for subscript operand
//                            =o_aov
//                            (case of more than one subscript)
//                            value code for array operand
//                            value code for first subscript
//                            value code for second subscript
//                            ...
//                            value code for last subscript
//                            =o_amv
//                            number of subscripts
        
//      code block (continued)
//      assignment            (to natural variable)
//                            value code for right operand
//                            pointer to vrsto field of vrblk
//                            (to any other variable)
//                            name code for left operand
//                            value code for right operand
//                            =o_ass
//      compile error         =o_cer
//      complementation       value code for operand
//                            =o_com
//      concatenation         (case of pred func left operand)
//                            value code for left operand
//                            =o_pop
//                            value code for right operand
//                            (all other cases)
//                            value code for left operand
//                            value code for right operand
//                            =o_cnc
//      cursor assignment     name code for operand
//                            =o_cas
//      division              value code for left operand
//                            value code for right operand
//                            =o_dvd
//      exponentiation        value code for left operand
//                            value code for right operand
//                            =o_exp
//      function call         (case of call to system function)
//                            value code for first argument
//                            value code for second argument
//                            ...
//                            value code for last argument
//                            pointer to svfnc field of svblk
        
//      code block (continued)
//      function call         (case of non-system function 1 arg)
//                            value code for argument
//                            =o_fns
//                            pointer to vrblk for function
//                            (non-system function, gt 1 arg)
//                            value code for first argument
//                            value code for second argument
//                            ...
//                            value code for last argument
//                            =o_fnc
//                            number of arguments
//                            pointer to vrblk for function
//      immediate assignment  value code for left operand
//                            name code for right operand
//                            =o_ima
//      indirection           value code for operand
//                            =o_inv
//      interrogation         value code for operand
//                            =o_int
//      keyword reference     name code for operand
//                            =o_kwv
//      multiplication        value code for left operand
//                            value code for right operand
//                            =o_mlt
//      name reference        (natural variable case)
//                            pointer to nmblk for name
//                            (all other cases)
//                            name code for operand
//                            =o_nam
//      negation              =o_nta
//                            cdblk offset of o_ntc word
//                            value code for operand
//                            =o_ntb
//                            =o_ntc
        
//      code block (continued)
//      pattern assignment    value code for left operand
//                            name code for right operand
//                            =o_pas
//      pattern match         value code for left operand
//                            value code for right operand
//                            =o_pmv
//      pattern replacement   name code for subject
//                            value code for pattern
//                            =o_pmn
//                            value code for replacement
//                            =o_rpl
//      selection             (for first alternative)
//                            =o_sla
//                            cdblk offset to next o_slc word
//                            value code for first alternative
//                            =o_slb
//                            cdblk offset past alternatives
//                            (for subsequent alternatives)
//                            =o_slc
//                            cdblk offset to next o_slc,o_sld
//                            value code for alternative
//                            =o_slb
//                            offset in cdblk past alternatives
//                            (for last alternative)
//                            =o_sld
//                            value code for last alternative
//      subtraction           value code for left operand
//                            value code for right operand
//                            =o_sub
        
//      code block (continued)
//      generation of code by name for expression elements.
//      variable              =o_lvn
//                            pointer to vrblk
//      expression            (case of *natural variable)
//                            =o_lvn
//                            pointer to vrblk
//                            (all other cases)
//                            =o_lex
//                            pointer to exblk
//      array reference       (case of one subscript)
//                            value code for array operand
//                            value code for subscript operand
//                            =o_aon
//                            (case of more than one subscript)
//                            value code for array operand
//                            value code for first subscript
//                            value code for second subscript
//                            ...
//                            value code for last subscript
//                            =o_amn
//                            number of subscripts
//      compile error         =o_cer
//      function call         (same code as for value call)
//                            =o_fne
//      indirection           value code for operand
//                            =o_inn
//      keyword reference     name code for operand
//                            =o_kwn
//      any other operand is an error in a name position
//      note that in this description, =o_xxx refers to the
//      generation of a word containing the address of another
//      word which contains the entry point address o_xxx.
        
//      code block (continued)
//      now we consider the overall structure of the code block
//      for a statement with possible goto fields.
//      first comes the code for the statement body.
//      the statement body is an expression to be evaluated
//      by value although the value is not actually required.
//      normal value code is generated for the body of the
//      statement except in the case of a pattern match by
//      value, in which case the following is generated.
//                            value code for left operand
//                            value code for right operand
//                            =o_pms
//      next we have the code for the success goto. there are
//      several cases as follows.
//      1)   no success goto  ptr to cdblk for next statement
//      2)   simple label     ptr to vrtra field of vrblk
//      3)   complex goto     (code by name for goto operand)
//                            =o_goc
//      4)   direct goto      (code by value for goto operand)
//                            =o_god
//      following this we generate code for the failure goto if
//      it is direct or if it is complex, simple failure gotos
//      having been handled by an appropriate setting of the
//      cdfal field of the cdblk. the generated code is one
//      of the following.
//      1)   complex fgoto    =o_fif
//                            =o_gof
//                            name code for goto operand
//                            =o_goc
//      2)   direct fgoto     =o_fif
//                            =o_gof
//                            value code for goto operand
//                            =o_god
//      an optimization occurs if the success and failure gotos
//      are identical and either complex or direct. in this case,
//      no code is generated for the success goto and control
//      is allowed to fall into the failure goto on success.
        
//      compiler block (cmblk)
//      a compiler block (cmblk) is built by expan to represent
//      one node of a tree structured expression representation.
//           +------------------------------------+
//           i                cmidn               i
//           +------------------------------------+
//           i                cmlen               i
//           +------------------------------------+
//           i                cmtyp               i
//           +------------------------------------+
//           i                cmopn               i
//           +------------------------------------+
//           /           cmvls or cmrop           /
//           /                                    /
//           /                cmlop               /
//           /                                    /
//           +------------------------------------+
        #define CMIDN	(0)				// pointer to dummy routine b_cmt
        #define CMLEN	(CMIDN+1)				// length of cmblk in bytes
        #define CMTYP	(CMLEN+1)				// type (c_xxx, see list below)
        #define CMOPN	(CMTYP+1)				// operand pointer (see below)
        #define CMVLS	(CMOPN+1)				// operand value pointers (see below)
        #define CMROP	(CMVLS)				// right (only) operator operand
        #define CMLOP	(CMVLS+1)				// left operator operand
        #define CMSI_	(CMVLS)				// number of standard fields in cmblk
        #define CMUS_	(CMSI_+1)				// size of unary operator cmblk
        #define CMBS_	(CMSI_+2)				// size of binary operator cmblk
        #define CMAR1	(CMVLS+1)				// array subscript pointers
//      the cmopn and cmvls fields are set as follows
//      array reference       cmopn = ptr to array operand
//                            cmvls = ptrs to subscript operands
//      function call         cmopn = ptr to vrblk for function
//                            cmvls = ptrs to argument operands
//      selection             cmopn = zero
//                            cmvls = ptrs to alternate operands
//      unary operator        cmopn = ptr to operator dvblk
//                            cmrop = ptr to operand
//      binary operator       cmopn = ptr to operator dvblk
//                            cmrop = ptr to right operand
//                            cmlop = ptr to left operand
        
//      cmtyp is set to indicate the type of expression element
//      as shown by the following table of definitions.
        #define C_ARR	(0)				// array reference
        #define C_FNC	(C_ARR+1)				// function call
        #define C_DEF	(C_FNC+1)				// deferred expression (unary *)
        #define C_IND	(C_DEF+1)				// indirection (unary _)
        #define C_KEY	(C_IND+1)				// keyword reference (unary ampersand)
        #define C_UBO	(C_KEY+1)				// undefined binary operator
        #define C_UUO	(C_UBO+1)				// undefined unary operator
        #define C_UO_	(C_UUO+1)				// test value (=c_uuo+1=c_ubo+2)
        #define C__NM	(C_UUO+1)				// number of codes for name operands
//      the remaining types indicate expression elements which
//      can only be evaluated by value (not by name).
        #define C_BVL	(C_UUO+1)				// binary op with value operands
        #define C_UVL	(C_BVL+1)				// unary operator with value operand
        #define C_ALT	(C_UVL+1)				// alternation (binary bar)
        #define C_CNC	(C_ALT+1)				// concatenation
        #define C_CNP	(C_CNC+1)				// concatenation, not pattern match
        #define C_UNM	(C_CNP+1)				// unary op with name operand
        #define C_BVN	(C_UNM+1)				// binary op (operands by value, name)
        #define C_ASS	(C_BVN+1)				// assignment
        #define C_INT	(C_ASS+1)				// interrogation
        #define C_NEG	(C_INT+1)				// negation (unary not)
        #define C_SEL	(C_NEG+1)				// selection
        #define C_PMT	(C_SEL+1)				// pattern match
        #define C_PR_	(C_BVN)				// last preevaluable code
        #define C__NV	(C_PMT+1)				// number of different cmblk types
        
//      character table block (ctblk)
//      a character table block is used to hold logical character
//      tables for use with any,notany,span,break,breakx
//      patterns. each character table can be used to store
//      cfp_n distinct tables as bit columns. a bit column
//      allocated for each argument of more than one character
//      in length to one of the above listed pattern primitives.
//           +------------------------------------+
//           i                cttyp               i
//           +------------------------------------+
//           *                                    *
//           *                                    *
//           *                ctchs               *
//           *                                    *
//           *                                    *
//           +------------------------------------+
        #define CTTYP	(0)				// pointer to dummy routine b_ctt
        #define CTCHS	(CTTYP+1)				// start of character table words
        #define CTSI_	(CTCHS+CFP_A)				// number of words in ctblk
//      ctchs is cfp_a words long and consists of a one word
//      bit string value for each possible character in the
//      internal alphabet. each of the cfp_n possible bits in
//      a bitstring is used to form a column of bit indicators.
//      a bit is set on if the character is in the table and off
//      if the character is not present.
        
//      datatype function block (dfblk)
//      a datatype function is used to control the construction
//      of a program defined datatype object. a call to the
//      system function data builds a dfblk for the datatype name
//      note that these blocks are built in static because pdblk
//      length is got from dflen field.  if dfblk was in dynamic
//      store this would cause trouble during pass two of garbage
//      collection.  scblk referred to by dfnam field is also put
//      in static so that there are no reloc. fields. this cuts
//      garbage collection task appreciably for pdblks which are
//      likely to be present in large numbers.
//           +------------------------------------+
//           i                fcode               i
//           +------------------------------------+
//           i                fargs               i
//           +------------------------------------+
//           i                dflen               i
//           +------------------------------------+
//           i                dfpdl               i
//           +------------------------------------+
//           i                dfnam               i
//           +------------------------------------+
//           /                                    /
//           /                dffld               /
//           /                                    /
//           +------------------------------------+
        #define DFLEN	(FARGS+1)				// length of dfblk in bytes
        #define DFPDL	(DFLEN+1)				// length of corresponding pdblk
        #define DFNAM	(DFPDL+1)				// pointer to scblk for datatype name
        #define DFFLD	(DFNAM+1)				// start of vrblk ptrs for field names
        #define DFFLB	(DFFLD-1)				// offset behind dffld for field func
        #define DFSI_	(DFFLD)				// number of standard fields in dfblk
//      the fcode field points to the routine b_dfc
//      fargs (the number of arguments) is the number of fields.
        
//      dope vector block (dvblk)
//      a dope vector is assembled for each possible operator in
//      the snobol4 language as part of the constant section.
//           +------------------------------------+
//           i                dvopn               i
//           +------------------------------------+
//           i                dvtyp               i
//           +------------------------------------+
//           i                dvlpr               i
//           +------------------------------------+
//           i                dvrpr               i
//           +------------------------------------+
        #define DVOPN	(0)				// entry address (ptr to o_xxx)
        #define DVTYP	(DVOPN+1)				// type code (c_xxx, see cmblk)
        #define DVLPR	(DVTYP+1)				// left precedence (llxxx, see below)
        #define DVRPR	(DVLPR+1)				// right precedence (rrxxx, see below)
        #define DVUS_	(DVLPR+1)				// size of unary operator dv
        #define DVBS_	(DVRPR+1)				// size of binary operator dv
        #define DVUBS	(DVUS_+DVBS_)				// size of unop + binop (see scane)
//      the contents of the dvtyp field is copied into the cmtyp
//      field of the cmblk for the operator if it is used.
//      the cmopn field of an operator cmblk points to the dvblk
//      itself, providing the required entry address pointer ptr.
//      for normally undefined operators, the dvopn (and cmopn)
//      fields contain a word offset from r_uba of the function
//      block pointer for the operator (instead of o_xxx ptr).
//      for certain special operators, the dvopn field is not
//      required at all and is assembled as zero.
//      the left precedence is used in comparing an operator to
//      the left of some other operator. it therefore governs the
//      precedence of the operator towards its right operand.
//      the right precedence is used in comparing an operator to
//      the right of some other operator. it therefore governs
//      the precedence of the operator towards its left operand.
//      higher precedence values correspond to a tighter binding
//      capability. thus we have the left precedence lower
//      (higher) than the right precedence for right (left)
//      associative binary operators.
//      the left precedence of unary operators is set to an
//      arbitrary high value. the right value is not required and
//      consequently the dvrpr field is omitted for unary ops.
        
//      table of operator precedence values
        #define RRASS	(10)				// right     equal
        #define LLASS	(00)				// left      equal
        #define RRPMT	(20)				// right     question mark
        #define LLPMT	(30)				// left      question mark
        #define RRAMP	(40)				// right     ampersand
        #define LLAMP	(50)				// left      ampersand
        #define RRALT	(70)				// right     vertical bar
        #define LLALT	(60)				// left      vertical bar
        #define RRCNC	(90)				// right     blank
        #define LLCNC	(80)				// left      blank
        #define RRATS	(110)				// right     at
        #define LLATS	(100)				// left      at
        #define RRPLM	(120)				// right     plus, minus
        #define LLPLM	(130)				// left      plus, minus
        #define RRNUM	(140)				// right     number
        #define LLNUM	(150)				// left      number
        #define RRDVD	(160)				// right     slash
        #define LLDVD	(170)				// left      slash
        #define RRMLT	(180)				// right     asterisk
        #define LLMLT	(190)				// left      asterisk
        #define RRPCT	(200)				// right     percent
        #define LLPCT	(210)				// left      percent
        #define RREXP	(230)				// right     exclamation
        #define LLEXP	(220)				// left      exclamation
        #define RRDLD	(240)				// right     dollar, dot
        #define LLDLD	(250)				// left      dollar, dot
        #define RRNOT	(270)				// right     not
        #define LLNOT	(260)				// left      not
        #define LLUNO	(999)				// left      all unary operators
//      precedences are the same as in btl snobol4 with the
//      following exceptions.
//      1)   binary question mark is lowered and made left assoc-
//           iative to reflect its new use for pattern matching.
//      2)   alternation and concatenation are made right
//           associative for greater efficiency in pattern
//           construction and matching respectively. this change
//           is transparent to the snobol4 programmer.
//      3)   the equal sign has been added as a low precedence
//           operator which is right associative to reflect its
//           more general usage in this version of snobol4.
        
//      external function block (efblk)
//      an external function block is used to control the calling
//      of an external function. it is built by a call to load.
//           +------------------------------------+
//           i                fcode               i
//           +------------------------------------+
//           i                fargs               i
//           +------------------------------------+
//           i                eflen               i
//           +------------------------------------+
//           i                efuse               i
//           +------------------------------------+
//           i                efcod               i
//           +------------------------------------+
//           i                efvar               i
//           +------------------------------------+
//           i                efrsl               i
//           +------------------------------------+
//           /                                    /
//           /                eftar               /
//           /                                    /
//           +------------------------------------+
        #define EFLEN	(FARGS+1)				// length of efblk in bytes
        #define EFUSE	(EFLEN+1)				// use count (for opsyn)
        #define EFCOD	(EFUSE+1)				// ptr to code (from sysld)
        #define EFVAR	(EFCOD+1)				// ptr to associated vrblk
        #define EFRSL	(EFVAR+1)				// result type (see below)
        #define EFTAR	(EFRSL+1)				// argument types (see below)
        #define EFSI_	(EFTAR)				// number of standard fields in efblk
//      the fcode field points to the routine b_efc.
//      efuse is used to keep track of multiple use when opsyn
//      is employed. the function is automatically unloaded
//      when there are no more references to the function.
//      efrsl and eftar are type codes as follows.
//           0                type is unconverted
//           1                type is string
//           2                type is integer
//           3                type is real
//           4                type is file
        
//      expression variable block (evblk)
//      in this version of spitbol, an expression can be used in
//      any position which would normally expect a name (for
//      example on the left side of equals or as the right
//      argument of binary dot). this corresponds to the creation
//      of a pseudo-variable which is represented by a pointer to
//      an expression variable block as follows.
//           +------------------------------------+
//           i                evtyp               i
//           +------------------------------------+
//           i                evexp               i
//           +------------------------------------+
//           i                evvar               i
//           +------------------------------------+
        #define EVTYP	(0)				// pointer to dummy routine b_evt
        #define EVEXP	(EVTYP+1)				// pointer to exblk for expression
        #define EVVAR	(EVEXP+1)				// pointer to trbev dummy trblk
        #define EVSI_	(EVVAR+1)				// size of evblk
//      the name of an expression variable is represented by a
//      base pointer to the evblk and an offset of evvar. this
//      value appears to be trapped by the dummy trbev block.
//      note that there is no need to allow for the case of an
//      expression variable which references an seblk since a
//      variable which is of the form *var is equivalent to var.
        
//      expression block (exblk)
//      an expression block is built for each expression
//      referenced in a program or created by eval or convert
//      during execution of a program.
//           +------------------------------------+
//           i                extyp               i
//           +------------------------------------+
//           i                exstm               i
//           +------------------------------------+
//           i                exsln               i
//           +------------------------------------+
//           i                exlen               i
//           +------------------------------------+
//           i                exflc               i
//           +------------------------------------+
//           /                                    /
//           /                excod               /
//           /                                    /
//           +------------------------------------+
        #define EXTYP	(0)				// ptr to routine b_exl to load expr
        #define EXSTM	(CDSTM)				// stores stmnt no. during evaluation
        #define EXSLN	(EXSTM+1)				// stores line no. during evaluation
        #define EXLEN	(EXSLN+1)				// length of exblk in bytes
        #define EXFLC	(EXLEN+1)				// failure code (=o_fex)
        #define EXCOD	(EXFLC+1)				// pseudo-code for expression
        #define EXSI_	(EXCOD)				// number of standard fields in exblk
//      there are two cases for excod depending on whether the
//      expression can be evaluated by name (see description
//      of cdblk for details of code for expressions).
//      if the expression can be evaluated by name we have.
//                            (code for expr by name)
//                            =o_rnm
//      if the expression can only be evaluated by value.
//                            (code for expr by value)
//                            =o_rvl
        
//      field function block (ffblk)
//      a field function block is used to control the selection
//      of a field from a program defined datatype block.
//      a call to data creates an ffblk for each field.
//           +------------------------------------+
//           i                fcode               i
//           +------------------------------------+
//           i                fargs               i
//           +------------------------------------+
//           i                ffdfp               i
//           +------------------------------------+
//           i                ffnxt               i
//           +------------------------------------+
//           i                ffofs               i
//           +------------------------------------+
        #define FFDFP	(FARGS+1)				// pointer to associated dfblk
        #define FFNXT	(FFDFP+1)				// ptr to next ffblk on chain or zero
        #define FFOFS	(FFNXT+1)				// offset (bytes) to field in pdblk
        #define FFSI_	(FFOFS+1)				// size of ffblk in words
//      the fcode field points to the routine b_ffc.
//      fargs always contains one.
//      ffdfp is used to verify that the correct program defined
//      datatype is being accessed by this call.
//      ffdfp is non-reloc. because dfblk is in static
//      ffofs is used to select the appropriate field. note that
//      it is an actual offset (not a field number)
//      ffnxt is used to point to the next ffblk of the same name
//      in the case where there are several fields of the same
//      name for different datatypes. zero marks the end of chain
        
//      integer constant block (icblk)
//      an icblk is created for every integer referenced or
//      created by a program. note however that certain internal
//      integer values are stored as addresses (e.g. the length
//      field in a string constant block)
//           +------------------------------------+
//           i                icget               i
//           +------------------------------------+
//           *                icval               *
//           +------------------------------------+
        #define ICGET	(0)				// ptr to routine b_icl to load int
        #define ICVAL	(ICGET+1)				// integer value
        #define ICSI_	(ICVAL+CFP_I)				// size of icblk
//      the length of the icval field is cfp_i.
        
//      keyword variable block (kvblk)
//      a kvblk is used to represent a keyword pseudo-variable.
//      a kvblk is built for each keyword reference (kwnam).
//           +------------------------------------+
//           i                kvtyp               i
//           +------------------------------------+
//           i                kvvar               i
//           +------------------------------------+
//           i                kvnum               i
//           +------------------------------------+
        #define KVTYP	(0)				// pointer to dummy routine b_kvt
        #define KVVAR	(KVTYP+1)				// pointer to dummy block trbkv
        #define KVNUM	(KVVAR+1)				// keyword number
        #define KVSI_	(KVNUM+1)				// size of kvblk
//      the name of a keyword variable is represented by a
//      base pointer to the kvblk and an offset of kvvar. the
//      value appears to be trapped by the pointer to trbkv.
        
//      name block (nmblk)
//      a name block is used wherever a name must be stored as
//      a value following use of the unary dot operator.
//           +------------------------------------+
//           i                nmtyp               i
//           +------------------------------------+
//           i                nmbas               i
//           +------------------------------------+
//           i                nmofs               i
//           +------------------------------------+
        #define NMTYP	(0)				// ptr to routine b_nml to load name
        #define NMBAS	(NMTYP+1)				// base pointer for variable
        #define NMOFS	(NMBAS+1)				// offset for variable
        #define NMSI_	(NMOFS+1)				// size of nmblk
//      the actual field representing the contents of the name
//      is found nmofs bytes past the address in nmbas.
//      the name is split into base and offset form to avoid
//      creation of a pointer into the middle of a block which
//      could not be handled properly by the garbage collector.
//      a name may be built for any variable (see section on
//      representations of variables) this includes the
//      cases of pseudo-variables.
        
//      pattern block, no parameters (p0blk)
//      a p0blk is used to represent pattern nodes which do
//      not require the use of any parameter values.
//           +------------------------------------+
//           i                pcode               i
//           +------------------------------------+
//           i                pthen               i
//           +------------------------------------+
        #define PCODE	(0)				// ptr to match routine (p_xxx)
        #define PTHEN	(PCODE+1)				// pointer to subsequent node
        #define PASI_	(PTHEN+1)				// size of p0blk
//      pthen points to the pattern block for the subsequent
//      node to be matched. this is a pointer to the pattern
//      block ndnth if there is no subsequent (end of pattern)
//      pcode is a pointer to the match routine for the node.
        
//      pattern block (one parameter)
//      a p1blk is used to represent pattern nodes which
//      require one parameter value.
//           +------------------------------------+
//           i                pcode               i
//           +------------------------------------+
//           i                pthen               i
//           +------------------------------------+
//           i                parm1               i
//           +------------------------------------+
        #define PARM1	(PTHEN+1)				// first parameter value
        #define PBSI_	(PARM1+1)				// size of p1blk in words
//      see p0blk for definitions of pcode, pthen
//      parm1 contains a parameter value used in matching the
//      node. for example, in a len pattern, it is the integer
//      argument to len. the details of the use of the parameter
//      field are included in the description of the individual
//      match routines. parm1 is always an address pointer which
//      is processed by the garbage collector.
        
//      pattern block (two parameters)
//      a p2blk is used to represent pattern nodes which
//      require two parameter values.
//           +------------------------------------+
//           i                pcode               i
//           +------------------------------------+
//           i                pthen               i
//           +------------------------------------+
//           i                parm1               i
//           +------------------------------------+
//           i                parm2               i
//           +------------------------------------+
        #define PARM2	(PARM1+1)				// second parameter value
        #define PCSI_	(PARM2+1)				// size of p2blk in words
//      see p1blk for definitions of pcode, pthen, parm1
//      parm2 is a parameter which performs the same sort of
//      function as parm1 (see description of p1blk).
//      parm2 is a non-relocatable field and is not
//      processed by the garbage collector. accordingly, it may
//      not contain a pointer to a block in dynamic memory.
        
//      program-defined datatype block
//      a pdblk represents the data item formed by a call to a
//      datatype function as defined by the system function data.
//           +------------------------------------+
//           i                pdtyp               i
//           +------------------------------------+
//           i                idval               i
//           +------------------------------------+
//           i                pddfp               i
//           +------------------------------------+
//           /                                    /
//           /                pdfld               /
//           /                                    /
//           +------------------------------------+
        #define PDTYP	(0)				// ptr to dummy routine b_pdt
        #define PDDFP	(IDVAL+1)				// ptr to associated dfblk
        #define PDFLD	(PDDFP+1)				// start of field value pointers
        #define PDFOF	(DFFLD-PDFLD)				// difference in offset to field ptrs
        #define PDSI_	(PDFLD)				// size of standard fields in pdblk
        #define PDDFS	(DFSI_-PDSI_)				// difference in dfblk, pdblk sizes
//      the pddfp pointer may be used to determine the datatype
//      and the names of the fields if required. the dfblk also
//      contains the length of the pdblk in bytes (field dfpdl).
//      pddfp is non-reloc. because dfblk is in static
//      pdfld values are stored in order from left to right.
//      they contain values or pointers to trblk chains.
        
//      program defined function block (pfblk)
//      a pfblk is created for each call to the define function
//      and a pointer to the pfblk placed in the proper vrblk.
//           +------------------------------------+
//           i                fcode               i
//           +------------------------------------+
//           i                fargs               i
//           +------------------------------------+
//           i                pflen               i
//           +------------------------------------+
//           i                pfvbl               i
//           +------------------------------------+
//           i                pfnlo               i
//           +------------------------------------+
//           i                pfcod               i
//           +------------------------------------+
//           i                pfctr               i
//           +------------------------------------+
//           i                pfrtr               i
//           +------------------------------------+
//           /                                    /
//           /                pfarg               /
//           /                                    /
//           +------------------------------------+
        #define PFLEN	(FARGS+1)				// length of pfblk in bytes
        #define PFVBL	(PFLEN+1)				// pointer to vrblk for function name
        #define PFNLO	(PFVBL+1)				// number of locals
        #define PFCOD	(PFNLO+1)				// ptr to vrblk for entry label
        #define PFCTR	(PFCOD+1)				// trblk ptr if call traced else 0
        #define PFRTR	(PFCTR+1)				// trblk ptr if return traced else 0
        #define PFARG	(PFRTR+1)				// vrblk ptrs for arguments and locals
        #define PFAGB	(PFARG-1)				// offset behind pfarg for arg, local
        #define PFSI_	(PFARG)				// number of standard fields in pfblk
//      the fcode field points to the routine b_pfc.
//      pfarg is stored in the following order.
//           arguments (left to right)
//           locals (left to right)
        
//      real constant block (rcblk)
//      an rcblk is created for every real referenced or
//      created by a program.
//           +------------------------------------+
//           i                rcget               i
//           +------------------------------------+
//           *                rcval               *
//           +------------------------------------+
        #define RCGET	(0)				// ptr to routine b_rcl to load real
        #define RCVAL	(RCGET+1)				// real value
        #define RCSI_	(RCVAL+CFP_R)				// size of rcblk
//      the length of the rcval field is cfp_r.
        
//      string constant block (scblk)
//      an scblk is built for every string referenced or created
//      by a program.
//           +------------------------------------+
//           i                scget               i
//           +------------------------------------+
//           i                sclen               i
//           +------------------------------------+
//           /                                    /
//           /                schar               /
//           /                                    /
//           +------------------------------------+
        #define SCGET	(0)				// ptr to routine b_scl to load string
        #define SCLEN	(SCGET+1)				// length of string in characters
        #define SCHAR	(SCLEN+1)				// characters of string
        #define SCSI_	(SCHAR)				// size of standard fields in scblk
//      the characters of the string are stored left justified.
//      the final word is padded on the right with zeros.
//      (i.e. the character whose internal code is zero).
//      the value of sclen may not exceed mxlen. this ensures
//      that character offsets (e.g. the pattern match cursor)
//      can be correctly processed by the garbage collector.
//      note that the offset to the characters of the string
//      is given in bytes by cfp_f and that this value is
//      automatically allowed for in plc, psc.
//      note that for a spitbol scblk, the value of cfp_f
//      is given by cfp_b*schar.
        
//      simple expression block (seblk)
//      an seblk is used to represent an expression of the form
//      *(natural variable). all other expressions are exblks.
//           +------------------------------------+
//           i                setyp               i
//           +------------------------------------+
//           i                sevar               i
//           +------------------------------------+
        #define SETYP	(0)				// ptr to routine b_sel to load expr
        #define SEVAR	(SETYP+1)				// ptr to vrblk for variable
        #define SESI_	(SEVAR+1)				// length of seblk in words
        
//      standard variable block (svblk)
//      an svblk is assembled in the constant section for each
//      variable which satisfies one of the following conditions.
//      1)   it is the name of a system function
//      2)   it has an initial value
//      3)   it has a keyword association
//      4)   it has a standard i/o association
//      6)   it has a standard label association
//      if vrblks are constructed for any of these variables,
//      then the vrsvp field points to the svblk (see vrblk)
//           +------------------------------------+
//           i                svbit               i
//           +------------------------------------+
//           i                svlen               i
//           +------------------------------------+
//           /                svchs               /
//           +------------------------------------+
//           i                svknm               i
//           +------------------------------------+
//           i                svfnc               i
//           +------------------------------------+
//           i                svnar               i
//           +------------------------------------+
//           i                svlbl               i
//           +------------------------------------+
//           i                svval               i
//           +------------------------------------+
        
//      standard variable block (continued)
        #define SVBIT	(0)				// bit string indicating attributes
        #define SVLEN	(1)				// (=sclen) length of name in chars
        #define SVCHS	(2)				// (=schar) characters of name
        #define SVSI_	(2)				// number of standard fields in svblk
        #define SVPRE	(1)				// set if preevaluation permitted
        #define SVFFC	(SVPRE+SVPRE)				// set on if fast call permitted
        #define SVCKW	(SVFFC+SVFFC)				// set on if keyword value constant
        #define SVPRD	(SVCKW+SVCKW)				// set on if predicate function
        #define SVNBT	(4)				// number of bits to right of svknm
        #define SVKNM	(SVPRD+SVPRD)				// set on if keyword association
        #define SVFNC	(SVKNM+SVKNM)				// set on if system function
        #define SVNAR	(SVFNC+SVFNC)				// set on if system function
        #define SVLBL	(SVNAR+SVNAR)				// set on if system label
        #define SVVAL	(SVLBL+SVLBL)				// set on if predefined value
//      note that the last five bits correspond in order
//      to the fields which are present (see procedure gtnvr).
//      the following definitions are used in the svblk table
        #define SVFNF	(SVFNC+SVNAR)				// function with no fast call
        #define SVFNN	(SVFNF+SVFFC)				// function with fast call, no preeval
        #define SVFNP	(SVFNN+SVPRE)				// function allowing preevaluation
        #define SVFPR	(SVFNN+SVPRD)				// predicate function
        #define SVFNK	(SVFNN+SVKNM)				// no preeval func + keyword
        #define SVKWV	(SVKNM+SVVAL)				// keyword + value
        #define SVKWC	(SVCKW+SVKNM)				// keyword with constant value
        #define SVKVC	(SVKWV+SVCKW)				// constant keyword + value
        #define SVKVL	(SVKVC+SVLBL)				// constant keyword + value + label
        #define SVFPK	(SVFNP+SVKVC)				// preeval fcn + const keywd + val
//      the svpre bit allows the compiler to preevaluate a call
//      to the associated system function if all the arguments
//      are themselves constants. functions in this category
//      must have no side effects and must never cause failure.
//      the call may generate an error condition.
//      the svffc bit allows the compiler to generate the special
//      fast call after adjusting the number of arguments. only
//      the item and apply functions fall outside this category.
//      the svckw bit is set if the associated keyword value is
//      a constant, thus allowing preevaluation for a value call.
//      the svprd bit is set on for all predicate functions to
//      enable the special concatenation code optimization.
        
//      svblk (continued)
//      svknm                 keyword number
//           svknm is present only for a standard keyword assoc.
//           it contains a keyword number as defined by the
//           keyword number table given later on.
//      svfnc                 system function pointer
//           svfnc is present only for a system function assoc.
//           it is a pointer to the actual code for the system
//           function. the generated code for a fast call is a
//           pointer to the svfnc field of the svblk for the
//           function. the vrfnc field of the vrblk points to
//           this same field, in which case, it serves as the
//           fcode field for the function call.
//      svnar                 number of function arguments
//           svnar is present only for a system function assoc.
//           it is the number of arguments required for a call
//           to the system function. the compiler uses this
//           value to adjust the number of arguments in a fast
//           call and in the case of a function called through
//           the vrfnc field of the vrblk, the svnar field
//           serves as the fargs field for o_fnc. a special
//           case occurs if this value is set to 999. this is
//           used to indicate that the function has a variable
//           number of arguments and causes o_fnc to pass control
//           without adjusting the argument count. the only
//           predefined functions using this are apply and item.
//      svlbl                 system label pointer
//           svlbl is present only for a standard label assoc.
//           it is a pointer to a system label routine (l_xxx).
//           the vrlbl field of the corresponding vrblk points to
//           the svlbl field of the svblk.
//      svval                 system value pointer
//           svval is present only for a standard value.
//           it is a pointer to the pattern node (ndxxx) which
//           is the standard initial value of the variable.
//           this value is copied to the vrval field of the vrblk
        
//      svblk (continued)
//      keyword number table
//      the following table gives symbolic names for keyword
//      numbers. these values are stored in the svknm field of
//      svblks and in the kvnum field of kvblks. see also
//      procedures asign, acess and kwnam.
//      unprotected keywords with one word integer values
        #define K_ABE	(0)				// abend
        #define K_ANC	(K_ABE+CFP_B)				// anchor
        #define K_COD	(K_ANC+CFP_B)				// code
        #define K_COM	(K_COD+CFP_B)				// compare
        #define K_DMP	(K_COM+CFP_B)				// dump
        #define K_ERL	(K_DMP+CFP_B)				// errlimit
        #define K_ERT	(K_ERL+CFP_B)				// errtype
        #define K_FTR	(K_ERT+CFP_B)				// ftrace
        #define K_FLS	(K_FTR+CFP_B)				// fullscan
        #define K_INP	(K_FLS+CFP_B)				// input
        #define K_MXL	(K_INP+CFP_B)				// maxlength
        #define K_OUP	(K_MXL+CFP_B)				// output
        #define K_PFL	(K_OUP+CFP_B)				// profile
        #define K_TRA	(K_PFL+CFP_B)				// trace
        #define K_TRM	(K_TRA+CFP_B)				// trim
//      protected keywords with one word integer values
        #define K_FNC	(K_TRM+CFP_B)				// fnclevel
        #define K_LST	(K_FNC+CFP_B)				// lastno
        #define K_LLN	(K_LST+CFP_B)				// lastline
        #define K_LIN	(K_LLN+CFP_B)				// line
        #define K_STN	(K_LIN+CFP_B)				// stno
//      keywords with constant pattern values
        #define K_ABO	(K_STN+CFP_B)				// abort
        #define K_ARB	(K_ABO+PASI_)				// arb
        #define K_BAL	(K_ARB+PASI_)				// bal
        #define K_FAL	(K_BAL+PASI_)				// fail
        #define K_FEN	(K_FAL+PASI_)				// fence
        #define K_REM	(K_FEN+PASI_)				// rem
        #define K_SUC	(K_REM+PASI_)				// succeed
        
//      keyword number table (continued)
//      special keywords
        #define K_ALP	(K_SUC+1)				// alphabet
        #define K_RTN	(K_ALP+1)				// rtntype
        #define K_STC	(K_RTN+1)				// stcount
        #define K_ETX	(K_STC+1)				// errtext
        #define K_FIL	(K_ETX+1)				// file
        #define K_LFL	(K_FIL+1)				// lastfile
        #define K_STL	(K_LFL+1)				// stlimit
        #define K_LCS	(K_STL+1)				// lcase
        #define K_UCS	(K_LCS+1)				// ucase
//      relative offsets of special keywords
        #define K__AL	(K_ALP-K_ALP)				// alphabet
        #define K__RT	(K_RTN-K_ALP)				// rtntype
        #define K__SC	(K_STC-K_ALP)				// stcount
        #define K__ET	(K_ETX-K_ALP)				// errtext
        #define K__FL	(K_FIL-K_ALP)				// file
        #define K__LF	(K_LFL-K_ALP)				// lastfile
        #define K__SL	(K_STL-K_ALP)				// stlimit
        #define K__LC	(K_LCS-K_ALP)				// lcase
        #define K__UC	(K_UCS-K_ALP)				// ucase
        #define K__N_	(K__UC+1)				// number of special cases
//      symbols used in asign and acess procedures
        #define K_P__	(K_FNC)				// first protected keyword
        #define K_V__	(K_ABO)				// first keyword with constant value
        #define K_S__	(K_ALP)				// first keyword with special acess
        
//      format of a table block (tbblk)
//      a table block is used to represent a table value.
//      it is built by a call to the table or convert functions.
//           +------------------------------------+
//           i                tbtyp               i
//           +------------------------------------+
//           i                idval               i
//           +------------------------------------+
//           i                tblen               i
//           +------------------------------------+
//           i                tbinv               i
//           +------------------------------------+
//           /                                    /
//           /                tbbuk               /
//           /                                    /
//           +------------------------------------+
        #define TBTYP	(0)				// pointer to dummy routine b_tbt
        #define TBLEN	(OFFS2)				// length of tbblk in bytes
        #define TBINV	(OFFS3)				// default initial lookup value
        #define TBBUK	(TBINV+1)				// start of hash bucket pointers
        #define TBSI_	(TBBUK)				// size of standard fields in tbblk
        #define TBNBK	(11)				// default no. of buckets
//      the table block is a hash table which points to chains
//      of table element blocks representing the elements
//      in the table which hash into the same bucket.
//      tbbuk entries either point to the first teblk on the
//      chain or they point to the tbblk itself to indicate the
//      end of the chain.
        
//      table element block (teblk)
//      a table element is used to represent a single entry in
//      a table (see description of tbblk format for hash table)
//           +------------------------------------+
//           i                tetyp               i
//           +------------------------------------+
//           i                tesub               i
//           +------------------------------------+
//           i                teval               i
//           +------------------------------------+
//           i                tenxt               i
//           +------------------------------------+
        #define TETYP	(0)				// pointer to dummy routine b_tet
        #define TESUB	(TETYP+1)				// subscript value
        #define TEVAL	(TESUB+1)				// (=vrval) table element value
        #define TENXT	(TEVAL+1)				// link to next teblk
//      see s_cnv where relation is assumed with tenxt and tbbuk
        #define TESI_	(TENXT+1)				// size of teblk in words
//      tenxt points to the next teblk on the hash chain from the
//      tbbuk chain for this hash index. at the end of the chain,
//      tenxt points back to the start of the tbblk.
//      teval contains a data pointer or a trblk pointer.
//      tesub contains a data pointer.
        
//      trap block (trblk)
//      a trap block is used to represent a trace or input or
//      output association in response to a call to the trace
//      input or output system functions. see below for details
//           +------------------------------------+
//           i                tridn               i
//           +------------------------------------+
//           i                trtyp               i
//           +------------------------------------+
//           i  trval or trlbl or trnxt or trkvr  i
//           +------------------------------------+
//           i       trtag or trter or trtrf      i
//           +------------------------------------+
//           i            trfnc or trfpt          i
//           +------------------------------------+
        #define TRIDN	(0)				// pointer to dummy routine b_trt
        #define TRTYP	(TRIDN+1)				// trap type code
        #define TRVAL	(TRTYP+1)				// value of trapped variable (=vrval)
        #define TRNXT	(TRVAL)				// ptr to next trblk on trblk chain
        #define TRLBL	(TRVAL)				// ptr to actual label (traced label)
        #define TRKVR	(TRVAL)				// vrblk pointer for keyword trace
        #define TRTAG	(TRVAL+1)				// trace tag
        #define TRTER	(TRTAG)				// ptr to terminal vrblk or null
        #define TRTRF	(TRTAG)				// ptr to trblk holding fcblk ptr
        #define TRFNC	(TRTAG+1)				// trace function vrblk (zero if none)
        #define TRFPT	(TRFNC)				// fcblk ptr for sysio
        #define TRSI_	(TRFNC+1)				// number of words in trblk
        #define TRTIN	(0)				// trace type for input association
        #define TRTAC	(TRTIN+1)				// trace type for access trace
        #define TRTVL	(TRTAC+1)				// trace type for value trace
        #define TRTOU	(TRTVL+1)				// trace type for output association
        #define TRTFC	(TRTOU+1)				// trace type for fcblk identification
        
//      trap block (continued)
//      variable input association
//           the value field of the variable points to a trblk
//           instead of containing the data value. in the case
//           of a natural variable, the vrget and vrsto fields
//           contain =b_vra and =b_vrv to activate the check.
//           trtyp is set to trtin
//           trnxt points to next trblk or trval has variable val
//           trter is a pointer to svblk if association is
//           for input, terminal, else it is null.
//           trtrf points to the trap block which in turn points
//           to an fcblk used for i/o association.
//           trfpt is the fcblk ptr returned by sysio.
//      variable access trace association
//           the value field of the variable points to a trblk
//           instead of containing the data value. in the case
//           of a natural variable, the vrget and vrsto fields
//           contain =b_vra and =b_vrv to activate the check.
//           trtyp is set to trtac
//           trnxt points to next trblk or trval has variable val
//           trtag is the trace tag (0 if none)
//           trfnc is the trace function vrblk ptr (0 if none)
//      variable value trace association
//           the value field of the variable points to a trblk
//           instead of containing the data value. in the case
//           of a natural variable, the vrget and vrsto fields
//           contain =b_vra and =b_vrv to activate the check.
//           trtyp is set to trtvl
//           trnxt points to next trblk or trval has variable val
//           trtag is the trace tag (0 if none)
//           trfnc is the trace function vrblk ptr (0 if none)
        
//      trap block (continued)
//      variable output association
//           the value field of the variable points to a trblk
//           instead of containing the data value. in the case
//           of a natural variable, the vrget and vrsto fields
//           contain =b_vra and =b_vrv to activate the check.
//           trtyp is set to trtou
//           trnxt points to next trblk or trval has variable val
//           trter is a pointer to svblk if association is
//           for output, terminal, else it is null.
//           trtrf points to the trap block which in turn points
//           to an fcblk used for i/o association.
//           trfpt is the fcblk ptr returned by sysio.
//      function call trace
//           the pfctr field of the corresponding pfblk is set
//           to point to a trblk.
//           trtyp is set to trtin
//           trnxt is zero
//           trtag is the trace tag (0 if none)
//           trfnc is the trace function vrblk ptr (0 if none)
//      function return trace
//           the pfrtr field of the corresponding pfblk is set
//           to point to a trblk
//           trtyp is set to trtin
//           trnxt is zero
//           trtag is the trace tag (0 if none)
//           trfnc is the trace function vrblk ptr (0 if none)
//      label trace
//           the vrlbl of the vrblk for the label is
//           changed to point to a trblk and the vrtra field is
//           set to b_vrt to activate the check.
//           trtyp is set to trtin
//           trlbl points to the actual label (cdblk) value
//           trtag is the trace tag (0 if none)
//           trfnc is the trace function vrblk ptr (0 if none)
        
//      trap block (continued)
//      keyword trace
//           keywords which can be traced possess a unique
//           location which is zero if there is no trace and
//           points to a trblk if there is a trace. the locations
//           are as follows.
//           r_ert            errtype
//           r_fnc            fnclevel
//           r_stc            stcount
//           the format of the trblk is as follows.
//           trtyp is set to trtin
//           trkvr is a pointer to the vrblk for the keyword
//           trtag is the trace tag (0 if none)
//           trfnc is the trace function vrblk ptr (0 if none)
//      input/output file arg1 trap block
//           the value field of the variable points to a trblk
//           instead of containing the data value. in the case of
//           a natural variable, the vrget and vrsto fields
//           contain =b_vra and =b_vrv. this trap block is used
//           to hold a pointer to the fcblk which an
//           implementation may request to hold information
//           about a file.
//           trtyp is set to trtfc
//           trnext points to next trblk or trval is variable val
//           trfnm is 0
//           trfpt is the fcblk pointer.
//      note that when multiple traps are set on a variable
//      the order is in ascending value of trtyp field.
//      input association (if present)
//      access trace (if present)
//      value trace (if present)
//      output association (if present)
//      the actual value of the variable is stored in the trval
//      field of the last trblk on the chain.
//      this implementation does not permit trace or i/o
//      associations to any of the pseudo-variables.
        
//      vector block (vcblk)
//      a vcblk is used to represent an array value which has
//      one dimension whose lower bound is one. all other arrays
//      are represented by arblks. a vcblk is created by the
//      system function array (s_arr) when passed an integer arg.
//           +------------------------------------+
//           i                vctyp               i
//           +------------------------------------+
//           i                idval               i
//           +------------------------------------+
//           i                vclen               i
//           +------------------------------------+
//           i                vcvls               i
//           +------------------------------------+
        #define VCTYP	(0)				// pointer to dummy routine b_vct
        #define VCLEN	(OFFS2)				// length of vcblk in bytes
        #define VCVLS	(OFFS3)				// start of vector values
        #define VCSI_	(VCVLS)				// size of standard fields in vcblk
        #define VCVLB	(VCVLS-1)				// offset one word behind vcvls
        #define VCTBD	(TBSI_-VCSI_)				// difference in sizes - see prtvl
//      vcvls are either data pointers or trblk pointers
//      the dimension can be deduced from vclen.
        
//      variable block (vrblk)
//      a variable block is built in the static memory area
//      for every variable referenced or created by a program.
//      the order of fields is assumed in the model vrblk stnvr.
//      note that since these blocks only occur in the static
//      region, it is permissible to point to any word in
//      the block and this is used to provide three distinct
//      access points from the generated code as follows.
//      1)   point to vrget (first word of vrblk) to load the
//           value of the variable onto the main stack.
//      2)   point to vrsto (second word of vrblk) to store the
//           top stack element as the value of the variable.
//      3)   point to vrtra (fourth word of vrblk) to jump to
//           the label associated with the variable name.
//           +------------------------------------+
//           i                vrget               i
//           +------------------------------------+
//           i                vrsto               i
//           +------------------------------------+
//           i                vrval               i
//           +------------------------------------+
//           i                vrtra               i
//           +------------------------------------+
//           i                vrlbl               i
//           +------------------------------------+
//           i                vrfnc               i
//           +------------------------------------+
//           i                vrnxt               i
//           +------------------------------------+
//           i                vrlen               i
//           +------------------------------------+
//           /                                    /
//           /            vrchs = vrsvp           /
//           /                                    /
//           +------------------------------------+
        
//      variable block (continued)
        #define VRGET	(0)				// pointer to routine to load value
        #define VRSTO	(VRGET+1)				// pointer to routine to store value
        #define VRVAL	(VRSTO+1)				// variable value
        #define VRVLO	(VRVAL-VRSTO)				// offset to value from store field
        #define VRTRA	(VRVAL+1)				// pointer to routine to jump to label
        #define VRLBL	(VRTRA+1)				// pointer to code for label
        #define VRLBO	(VRLBL-VRTRA)				// offset to label from transfer field
        #define VRFNC	(VRLBL+1)				// pointer to function block
        #define VRNXT	(VRFNC+1)				// pointer to next vrblk on hash chain
        #define VRLEN	(VRNXT+1)				// length of name (or zero)
        #define VRCHS	(VRLEN+1)				// characters of name (vrlen gt 0)
        #define VRSVP	(VRLEN+1)				// ptr to svblk (vrlen eq 0)
        #define VRSI_	(VRCHS+1)				// number of standard fields in vrblk
        #define VRSOF	(VRLEN-SCLEN)				// offset to dummy scblk for name
        #define VRSVO	(VRSVP-VRSOF)				// pseudo-offset to vrsvp field
//      vrget = b_vrl if not input associated or access traced
//      vrget = b_vra if input associated or access traced
//      vrsto = b_vrs if not output associated or value traced
//      vrsto = b_vrv if output associated or value traced
//      vrsto = b_vre if value is protected pattern value
//      vrval points to the appropriate value unless the
//      variable is i/o/trace associated in which case, vrval
//      points to an appropriate trblk (trap block) chain.
//      vrtra = b_vrg if the label is not traced
//      vrtra = b_vrt if the label is traced
//      vrlbl points to a cdblk if there is a label
//      vrlbl points to the svblk svlbl field for a system label
//      vrlbl points to stndl for an undefined label
//      vrlbl points to a trblk if the label is traced
//      vrfnc points to a ffblk for a field function
//      vrfnc points to a dfblk for a datatype function
//      vrfnc points to a pfblk for a program defined function
//      vrfnc points to a efblk for an external loaded function
//      vrfnc points to svfnc (svblk) for a system function
//      vrfnc points to stndf if the function is undefined
//      vrnxt points to the next vrblk on this chain unless
//      this is the end of the chain in which case it is zero.
//      vrlen is the name length for a non-system variable.
//      vrlen is zero for a system variable.
//      vrchs is the name (ljrz) if vrlen is non-zero.
//      vrsvp is a ptr to the svblk if vrlen is zero.
        
//      format of a non-relocatable external block (xnblk)
//      an xnblk is a block representing an unknown (external)
//      data value. the block contains no pointers to other
//      relocatable blocks. an xnblk is used by external function
//      processing or possibly for system i/o routines etc.
//      the macro-system itself does not use xnblks.
//      this type of block may be used as a file control block.
//      see sysfc,sysin,sysou,s_inp,s_oup for details.
//           +------------------------------------+
//           i                xntyp               i
//           +------------------------------------+
//           i                xnlen               i
//           +------------------------------------+
//           /                                    /
//           /                xndta               /
//           /                                    /
//           +------------------------------------+
        #define XNTYP	(0)				// pointer to dummy routine b_xnt
        #define XNLEN	(XNTYP+1)				// length of xnblk in bytes
        #define XNDTA	(XNLEN+1)				// data words
        #define XNSI_	(XNDTA)				// size of standard fields in xnblk
//      note that the term non-relocatable refers to the contents
//      and not the block itself. an xnblk can be moved around if
//      it is built in the dynamic memory area.
        
//      relocatable external block (xrblk)
//      an xrblk is a block representing an unknown (external)
//      data value. the data area in this block consists only
//      of address values and any addresses pointing into the
//      dynamic memory area must point to the start of other
//      data blocks. see also description of xnblk.
//      this type of block may be used as a file control block.
//      see sysfc,sysin,sysou,s_inp,s_oup for details.
//           +------------------------------------+
//           i                xrtyp               i
//           +------------------------------------+
//           i                xrlen               i
//           +------------------------------------+
//           /                                    /
//           /                xrptr               /
//           /                                    /
//           +------------------------------------+
        #define XRTYP	(0)				// pointer to dummy routine b_xrt
        #define XRLEN	(XRTYP+1)				// length of xrblk in bytes
        #define XRPTR	(XRLEN+1)				// start of address pointers
        #define XRSI_	(XRPTR)				// size of standard fields in xrblk
        
//      s_cnv (convert) function switch constants.  the values
//      are tied to the order of the entries in the svctb table
//      and hence to the branch table in s_cnv.
        #define CNVST	(8)				// max standard type code for convert
        #define CNVRT	(CNVST+1)				// convert code for reals
        #define CNVBT	(CNVRT)				// no buffers - same as real code
        #define CNVTT	(CNVBT+1)				// bsw code for convert
//      input image length
        #define INILN	(1024)				// default image length for compiler
        #define INILS	(1024)				// image length if -sequ in effect
        #define IONMB	(2)				// name base used for iochn in sysio
        #define IONMO	(4)				// name offset used for iochn in sysio
//      minimum value for keyword maxlngth
//      should be larger than iniln
        #define MNLEN	(1024)				// min value allowed keyword maxlngth
        #define MXERN	(329)				// err num inadequate startup memory
//      in general, meaningful mnemonics should be used for
//      offsets. however for small integers used often in
//      literals the following general definitions are provided.
        #define NUM01	(1)
        #define NUM02	(2)
        #define NUM03	(3)
        #define NUM04	(4)
        #define NUM05	(5)
        #define NUM06	(6)
        #define NUM07	(7)
        #define NUM08	(8)
        #define NUM09	(9)
        #define NUM10	(10)
        #define NUM25	(25)
        #define NM320	(320)
        #define NM321	(321)
        #define NINI8	(998)
        #define NINI9	(999)
        #define THSND	(1000)
        
//      numbers of undefined spitbol operators
        #define OPBUN	(5)				// no. of binary undefined ops
        #define OPUUN	(6)				// no of unary undefined ops
//      offsets used in prtsn, prtmi and acess
        #define PRSNF	(13)				// offset used in prtsn
        #define PRTMF	(21)				// offset to col 21 (prtmi)
        #define RILEN	(1024)				// buffer length for sysri
//      codes for stages of processing
        #define STGIC	(0)				// initial compile
        #define STGXC	(STGIC+1)				// execution compile (code)
        #define STGEV	(STGXC+1)				// expression eval during execution
        #define STGXT	(STGEV+1)				// execution time
        #define STGCE	(STGXT+1)				// initial compile after end line
        #define STGXE	(STGCE+1)				// exec. compile after end line
        #define STGND	(STGCE-STGIC)				// difference in stage after end
        #define STGEE	(STGXE+1)				// eval evaluating expression
        #define STGNO	(STGEE+1)				// number of codes
        
//      statement number pad count for listr
        #define STNPD	(8)				// statement no. pad count
//      syntax type codes
//      these codes are returned from the scane procedure.
//      they are spaced 3 apart for the benefit of expan.
        #define T_UOP	(0)				// unary operator
        #define T_LPR	(T_UOP+3)				// left paren
        #define T_LBR	(T_LPR+3)				// left bracket
        #define T_CMA	(T_LBR+3)				// comma
        #define T_FNC	(T_CMA+3)				// function call
        #define T_VAR	(T_FNC+3)				// variable
        #define T_CON	(T_VAR+3)				// constant
        #define T_BOP	(T_CON+3)				// binary operator
        #define T_RPR	(T_BOP+3)				// right paren
        #define T_RBR	(T_RPR+3)				// right bracket
        #define T_COL	(T_RBR+3)				// colon
        #define T_SMC	(T_COL+3)				// semi-colon
//      the following definitions are used only in the goto field
        #define T_FGO	(T_SMC+1)				// failure goto
        #define T_SGO	(T_FGO+1)				// success goto
//      the above codes are grouped so that codes for elements
//      which can legitimately immediately precede a unary
//      operator come first to facilitate operator syntax check.
        #define T_UOK	(T_FNC)				// last code ok before unary operator
        
//      definitions of values for expan jump table
        #define T_UO0	(T_UOP+0)				// unary operator, state zero
        #define T_UO1	(T_UOP+1)				// unary operator, state one
        #define T_UO2	(T_UOP+2)				// unary operator, state two
        #define T_LP0	(T_LPR+0)				// left paren, state zero
        #define T_LP1	(T_LPR+1)				// left paren, state one
        #define T_LP2	(T_LPR+2)				// left paren, state two
        #define T_LB0	(T_LBR+0)				// left bracket, state zero
        #define T_LB1	(T_LBR+1)				// left bracket, state one
        #define T_LB2	(T_LBR+2)				// left bracket, state two
        #define T_CM0	(T_CMA+0)				// comma, state zero
        #define T_CM1	(T_CMA+1)				// comma, state one
        #define T_CM2	(T_CMA+2)				// comma, state two
        #define T_FN0	(T_FNC+0)				// function call, state zero
        #define T_FN1	(T_FNC+1)				// function call, state one
        #define T_FN2	(T_FNC+2)				// function call, state two
        #define T_VA0	(T_VAR+0)				// variable, state zero
        #define T_VA1	(T_VAR+1)				// variable, state one
        #define T_VA2	(T_VAR+2)				// variable, state two
        #define T_CO0	(T_CON+0)				// constant, state zero
        #define T_CO1	(T_CON+1)				// constant, state one
        #define T_CO2	(T_CON+2)				// constant, state two
        #define T_BO0	(T_BOP+0)				// binary operator, state zero
        #define T_BO1	(T_BOP+1)				// binary operator, state one
        #define T_BO2	(T_BOP+2)				// binary operator, state two
        #define T_RP0	(T_RPR+0)				// right paren, state zero
        #define T_RP1	(T_RPR+1)				// right paren, state one
        #define T_RP2	(T_RPR+2)				// right paren, state two
        #define T_RB0	(T_RBR+0)				// right bracket, state zero
        #define T_RB1	(T_RBR+1)				// right bracket, state one
        #define T_RB2	(T_RBR+2)				// right bracket, state two
        #define T_CL0	(T_COL+0)				// colon, state zero
        #define T_CL1	(T_COL+1)				// colon, state one
        #define T_CL2	(T_COL+2)				// colon, state two
        #define T_SM0	(T_SMC+0)				// semicolon, state zero
        #define T_SM1	(T_SMC+1)				// semicolon, state one
        #define T_SM2	(T_SMC+2)				// semicolon, state two
        #define T_NES	(T_SM2+1)				// number of entries in branch table
        
//       definition of offsets used in control card processing
        #define CC_DO	(0)				// -double
        #define CC_CO	(CC_DO+1)				// -compare
        #define CC_DU	(CC_CO+1)				// -dump
        #define CC_CP	(CC_DU+1)				// -copy
        #define CC_EJ	(CC_CP+1)				// -eject
        #define CC_ER	(CC_EJ+1)				// -errors
        #define CC_EX	(CC_ER+1)				// -execute
        #define CC_FA	(CC_EX+1)				// -fail
        #define CC_IN	(CC_FA+1)				// -include
        #define CC_LN	(CC_IN+1)				// -line
        #define CC_LI	(CC_LN+1)				// -list
        #define CC_NR	(CC_LI+1)				// -noerrors
        #define CC_NX	(CC_NR+1)				// -noexecute
        #define CC_NF	(CC_NX+1)				// -nofail
        #define CC_NL	(CC_NF+1)				// -nolist
        #define CC_NO	(CC_NL+1)				// -noopt
        #define CC_NP	(CC_NO+1)				// -noprint
        #define CC_OP	(CC_NP+1)				// -optimise
        #define CC_PR	(CC_OP+1)				// -print
        #define CC_SI	(CC_PR+1)				// -single
        #define CC_SP	(CC_SI+1)				// -space
        #define CC_ST	(CC_SP+1)				// -stitl
        #define CC_TI	(CC_ST+1)				// -title
        #define CC_TR	(CC_TI+1)				// -trace
        #define CC_NC	(CC_TR+1)				// number of control cards
        #define CCNOC	(4)				// no. of chars included in match
        #define CCOFS	(7)				// offset to start of title/subtitle
        #define CCINM	(9)				// max depth of include file nesting
        
//      definitions of stack offsets used in cmpil procedure
//      see description at start of cmpil procedure for details
//      of use of these locations on the stack.
        #define CMSTM	(0)				// tree for statement body
        #define CMSGO	(CMSTM+1)				// tree for success goto
        #define CMFGO	(CMSGO+1)				// tree for fail goto
        #define CMCGO	(CMFGO+1)				// conditional goto flag
        #define CMPCD	(CMCGO+1)				// previous cdblk pointer
        #define CMFFP	(CMPCD+1)				// failure fill in flag for previous
        #define CMFFC	(CMFFP+1)				// failure fill in flag for current
        #define CMSOP	(CMFFC+1)				// success fill in offset for previous
        #define CMSOC	(CMSOP+1)				// success fill in offset for current
        #define CMLBL	(CMSOC+1)				// ptr to vrblk for current label
        #define CMTRA	(CMLBL+1)				// ptr to entry cdblk
        #define CMNEN	(CMTRA+1)				// count of stack entries for cmpil
//      a few constants used by the profiler
        #define PFPD1	(8)				// pad positions ...
        #define PFPD2	(20)				// ... for profile ...
        #define PFPD3	(32)				// ... printout
        #define PF_I2	(CFP_I+CFP_I)				// size of table entry (2 ints)
        
//      definition of limits and adjustments that are built by
//      relcr for use by the routines that relocate pointers
//      after a save file is reloaded.  see reloc etc. for usage.
//      a block of information is built that is used in
//      relocating pointers.  there are rnsi_ instances
//      of a rssi_ word structure.  each instance corresponds
//      to one of the regions that a pointer might point into.
//      each structure takes the form:
//           +------------------------------------+
//           i    address past end of section     i
//           +------------------------------------+
//           i  adjustment from old to new adrs   i
//           +------------------------------------+
//           i    address of start of section     i
//           +------------------------------------+
//      the instances are ordered thusly:
//           +------------------------------------+
//           i           dynamic storage          i
//           +------------------------------------+
//           i           static storage           i
//           +------------------------------------+
//           i       working section globals      i
//           +------------------------------------+
//           i          constant section          i
//           +------------------------------------+
//           i            code section            i
//           +------------------------------------+
//      symbolic names for these locations as offsets from
//      the first entry are provided here.
//      definitions within a section
        #define RLEND	(0)				// end
        #define RLADJ	(RLEND+1)				// adjustment
        #define RLSTR	(RLADJ+1)				// start
        #define RSSI_	(RLSTR+1)				// size of section
        #define RNSI_	(5)				// number of structures
//      overall definitions of all structures
        #define RLDYE	(0)				// dynamic region end
        #define RLDYA	(RLDYE+1)				// dynamic region adjustment
        #define RLDYS	(RLDYA+1)				// dynamic region start
        #define RLSTE	(RLDYS+1)				// static region end
        #define RLSTA	(RLSTE+1)				// static region adjustment
        #define RLSTS	(RLSTA+1)				// static region start
        #define RLWKE	(RLSTS+1)				// working section globals end
        #define RLWKA	(RLWKE+1)				// working section globals adjustment
        #define RLWKS	(RLWKA+1)				// working section globals start
        #define RLCNE	(RLWKS+1)				// constants section end
        #define RLCNA	(RLCNE+1)				// constants section adjustment
        #define RLCNS	(RLCNA+1)				// constants section start
        #define RLCDE	(RLCNS+1)				// code section end
        #define RLCDA	(RLCDE+1)				// code section adjustment
        #define RLCDS	(RLCDA+1)				// code section start
        #define RLSI_	(RLCDS+1)				// number of fields in structure
//      this section consists entirely of assembled constants.
//      all label names are five letters. the order is
//      approximately alphabetical, but in some cases (always
//      documented), constants must be placed in some special
//      order which must not be disturbed.
//      it must also be remembered that there is a requirement
//      for no forward references which also disturbs the
//      alphabetical order in some cases.
        struct spitbol_constants {				// start of constant section
//      start of constant section
        word c_aaa;				// first location of constant section
//      free store percentage (used by alloc)
        word alfsp;				// free store percentage
//      bit constants for general use
        d_word bits0;				// all zero bits
        d_word bits1;				// one bit in low order position
        d_word bits2;				// bit in position 2
        d_word bits3;				// bit in position 3
        d_word bits4;				// bit in position 4
        d_word bits5;				// bit in position 5
        d_word bits6;				// bit in position 6
        d_word bits7;				// bit in position 7
        d_word bits8;				// bit in position 8
        d_word bits9;				// bit in position 9
        d_word bit10;				// bit in position 10
        d_word bit11;				// bit in position 11
        d_word bit12;				// bit in position 12
//bitsm  dbc  cfp_m            mask for max integer
        d_word bitsm;				// mask for max integer (value filled in at runtime)
//      bit constants for svblk (svbit field) tests
        d_word btfnc;				// bit to test for function
        d_word btknm;				// bit to test for keyword number
        d_word btlbl;				// bit to test for label
        d_word btffc;				// bit to test for fast call
        d_word btckw;				// bit to test for constant keyword
        d_word btkwv;				// bits to test for keword with value
        d_word btprd;				// bit to test for predicate function
        d_word btpre;				// bit to test for preevaluation
        d_word btval;				// bit to test for value
        
//      list of names used for control card processing
         char ccnms;
         char ccnms__pos__1;
         char ccnms__pos__2;
         char ccnms__pos__3;
         char ccnms__pos__4;
         char ccnms__pos__5;
         char ccnms__pos__6;
         char ccnms__pos__7;
         char ccnms__pos__8;
         char ccnms__pos__9;
         char ccnms__pos__10;
         char ccnms__pos__11;
         char ccnms__pos__12;
         char ccnms__pos__13;
         char ccnms__pos__14;
         char ccnms__pos__15;
         char ccnms__pos__16;
         char ccnms__pos__17;
         char ccnms__pos__18;
         char ccnms__pos__19;
         char ccnms__pos__20;
         char ccnms__pos__21;
         char ccnms__pos__22;
         char ccnms__pos__23;
         char ccnms__pos__24;
         char ccnms__pos__25;
         char ccnms__pos__26;
         char ccnms__pos__27;
         char ccnms__pos__28;
         char ccnms__pos__29;
         char ccnms__pos__30;
         char ccnms__pos__31;
         char ccnms__pos__32;
         char ccnms__pos__33;
         char ccnms__pos__34;
         char ccnms__pos__35;
         char ccnms__pos__36;
         char ccnms__pos__37;
         char ccnms__pos__38;
         char ccnms__pos__39;
         char ccnms__pos__40;
         char ccnms__pos__41;
         char ccnms__pos__42;
         char ccnms__pos__43;
         char ccnms__pos__44;
         char ccnms__pos__45;
         char ccnms__pos__46;
         char ccnms__pos__47;
         char ccnms__pos__48;
         char ccnms__pos__49;
         char ccnms__pos__50;
         char ccnms__pos__51;
         char ccnms__pos__52;
         char ccnms__pos__53;
         char ccnms__pos__54;
         char ccnms__pos__55;
         char ccnms__pos__56;
         char ccnms__pos__57;
         char ccnms__pos__58;
         char ccnms__pos__59;
         char ccnms__pos__60;
         char ccnms__pos__61;
         char ccnms__pos__62;
         char ccnms__pos__63;
         char ccnms__pos__64;
         char ccnms__pos__65;
         char ccnms__pos__66;
         char ccnms__pos__67;
         char ccnms__pos__68;
         char ccnms__pos__69;
         char ccnms__pos__70;
         char ccnms__pos__71;
         char ccnms__pos__72;
         char ccnms__pos__73;
         char ccnms__pos__74;
         char ccnms__pos__75;
         char ccnms__pos__76;
         char ccnms__pos__77;
         char ccnms__pos__78;
         char ccnms__pos__79;
         char ccnms__pos__80;
         char ccnms__pos__81;
         char ccnms__pos__82;
         char ccnms__pos__83;
         char ccnms__pos__84;
         char ccnms__pos__85;
         char ccnms__pos__86;
         char ccnms__pos__87;
         char ccnms__pos__88;
         char ccnms__pos__89;
         char ccnms__pos__90;
         char ccnms__pos__91;
         char ccnms__pos__92;
         char ccnms__pos__93;
         char ccnms__pos__94;
         char ccnms__pos__95;
         char ccnms__pos__96;
         char ccnms__pos__97;
         char ccnms__pos__98;
         char ccnms__pos__99;
         char ccnms__pos__100;
         char ccnms__pos__101;
         char ccnms__pos__102;
         char ccnms__pos__103;
         char ccnms__pos__104;
         char ccnms__pos__105;
         char ccnms__pos__106;
         char ccnms__pos__107;
         char ccnms__pos__108;
         char ccnms__pos__109;
         char ccnms__pos__110;
         char ccnms__pos__111;
         char ccnms__pos__112;
         char ccnms__pos__113;
         char ccnms__pos__114;
         char ccnms__pos__115;
         char ccnms__pos__116;
         char ccnms__pos__117;
         char ccnms__pos__118;
         char ccnms__pos__119;
         char ccnms__pos__120;
         char ccnms__pos__121;
         char ccnms__pos__122;
         char ccnms__pos__123;
         char ccnms__pos__124;
         char ccnms__pos__125;
         char ccnms__pos__126;
         char ccnms__pos__127;
         char ccnms__pos__128;
         char ccnms__pos__129;
         char ccnms__pos__130;
         char ccnms__pos__131;
         char ccnms__pos__132;
         char ccnms__pos__133;
         char ccnms__pos__134;
         char ccnms__pos__135;
         char ccnms__pos__136;
         char ccnms__pos__137;
         char ccnms__pos__138;
         char ccnms__pos__139;
         char ccnms__pos__140;
         char ccnms__pos__141;
         char ccnms__pos__142;
         char ccnms__pos__143;
         char ccnms__pos__144;
         char ccnms__pos__145;
         char ccnms__pos__146;
         char ccnms__pos__147;
         char ccnms__pos__148;
         char ccnms__pos__149;
         char ccnms__pos__150;
         char ccnms__pos__151;
         char ccnms__pos__152;
         char ccnms__pos__153;
         char ccnms__pos__154;
         char ccnms__pos__155;
         char ccnms__pos__156;
         char ccnms__pos__157;
         char ccnms__pos__158;
         char ccnms__pos__159;
         char ccnms__pos__160;
         char ccnms__pos__161;
         char ccnms__pos__162;
         char ccnms__pos__163;
         char ccnms__pos__164;
         char ccnms__pos__165;
         char ccnms__pos__166;
         char ccnms__pos__167;
         char ccnms__pos__168;
         char ccnms__pos__169;
         char ccnms__pos__170;
         char ccnms__pos__171;
         char ccnms__pos__172;
         char ccnms__pos__173;
         char ccnms__pos__174;
         char ccnms__pos__175;
         char ccnms__pos__176;
         char ccnms__pos__177;
         char ccnms__pos__178;
         char ccnms__pos__179;
         char ccnms__pos__180;
         char ccnms__pos__181;
         char ccnms__pos__182;
         char ccnms__pos__183;
         char ccnms__pos__184;
         char ccnms__pos__185;
         char ccnms__pos__186;
         char ccnms__pos__187;
         char ccnms__pos__188;
         char ccnms__pos__189;
         char ccnms__pos__190;
         char ccnms__pos__191;
//      header messages for dumpr procedure (scblk format)
        word dmhdk;				// dump of keyword values
        word dmhdk__pos__1;
         char dmhdk__pos__2;
         char dmhdk__pos__3;
         char dmhdk__pos__4;
         char dmhdk__pos__5;
         char dmhdk__pos__6;
         char dmhdk__pos__7;
         char dmhdk__pos__8;
         char dmhdk__pos__9;
         char dmhdk__pos__10;
         char dmhdk__pos__11;
         char dmhdk__pos__12;
         char dmhdk__pos__13;
         char dmhdk__pos__14;
         char dmhdk__pos__15;
         char dmhdk__pos__16;
         char dmhdk__pos__17;
         char dmhdk__pos__18;
         char dmhdk__pos__19;
         char dmhdk__pos__20;
         char dmhdk__pos__21;
         char dmhdk__pos__22;
         char dmhdk__pos__23;
         char dmhdk__pos__24;
         char dmhdk__pos__25;
        word dmhdv;				// dump of natural variables
        word dmhdv__pos__1;
         char dmhdv__pos__2;
         char dmhdv__pos__3;
         char dmhdv__pos__4;
         char dmhdv__pos__5;
         char dmhdv__pos__6;
         char dmhdv__pos__7;
         char dmhdv__pos__8;
         char dmhdv__pos__9;
         char dmhdv__pos__10;
         char dmhdv__pos__11;
         char dmhdv__pos__12;
         char dmhdv__pos__13;
         char dmhdv__pos__14;
         char dmhdv__pos__15;
         char dmhdv__pos__16;
         char dmhdv__pos__17;
         char dmhdv__pos__18;
         char dmhdv__pos__19;
         char dmhdv__pos__20;
         char dmhdv__pos__21;
         char dmhdv__pos__22;
         char dmhdv__pos__23;
         char dmhdv__pos__24;
         char dmhdv__pos__25;
         char dmhdv__pos__26;
         char dmhdv__pos__27;
         char dmhdv__pos__28;
         char dmhdv__pos__29;
         char dmhdv__pos__30;
         char dmhdv__pos__31;
         char dmhdv__pos__32;
         char dmhdv__pos__33;
        
//      message text for compilation statistics
        word encm1;
        word encm1__pos__1;
         char encm1__pos__2;
         char encm1__pos__3;
         char encm1__pos__4;
         char encm1__pos__5;
         char encm1__pos__6;
         char encm1__pos__7;
         char encm1__pos__8;
         char encm1__pos__9;
         char encm1__pos__10;
         char encm1__pos__11;
         char encm1__pos__12;
         char encm1__pos__13;
         char encm1__pos__14;
         char encm1__pos__15;
         char encm1__pos__16;
         char encm1__pos__17;
         char encm1__pos__18;
         char encm1__pos__19;
         char encm1__pos__20;
         char encm1__pos__21;
         char encm1__pos__22;
         char encm1__pos__23;
         char encm1__pos__24;
         char encm1__pos__25;
        word encm2;
        word encm2__pos__1;
         char encm2__pos__2;
         char encm2__pos__3;
         char encm2__pos__4;
         char encm2__pos__5;
         char encm2__pos__6;
         char encm2__pos__7;
         char encm2__pos__8;
         char encm2__pos__9;
         char encm2__pos__10;
         char encm2__pos__11;
         char encm2__pos__12;
         char encm2__pos__13;
         char encm2__pos__14;
         char encm2__pos__15;
         char encm2__pos__16;
         char encm2__pos__17;
         char encm2__pos__18;
         char encm2__pos__19;
         char encm2__pos__20;
         char encm2__pos__21;
         char encm2__pos__22;
         char encm2__pos__23;
         char encm2__pos__24;
         char encm2__pos__25;
        word encm3;
        word encm3__pos__1;
         char encm3__pos__2;
         char encm3__pos__3;
         char encm3__pos__4;
         char encm3__pos__5;
         char encm3__pos__6;
         char encm3__pos__7;
         char encm3__pos__8;
         char encm3__pos__9;
         char encm3__pos__10;
         char encm3__pos__11;
         char encm3__pos__12;
         char encm3__pos__13;
         char encm3__pos__14;
         char encm3__pos__15;
         char encm3__pos__16;
         char encm3__pos__17;
        word encm4;
        word encm4__pos__1;
         char encm4__pos__2;
         char encm4__pos__3;
         char encm4__pos__4;
         char encm4__pos__5;
         char encm4__pos__6;
         char encm4__pos__7;
         char encm4__pos__8;
         char encm4__pos__9;
         char encm4__pos__10;
         char encm4__pos__11;
         char encm4__pos__12;
         char encm4__pos__13;
         char encm4__pos__14;
         char encm4__pos__15;
         char encm4__pos__16;
         char encm4__pos__17;
         char encm4__pos__18;
         char encm4__pos__19;
         char encm4__pos__20;
         char encm4__pos__21;
         char encm4__pos__22;
         char encm4__pos__23;
         char encm4__pos__24;
         char encm4__pos__25;
        word encm5;				// execution suppressed
        word encm5__pos__1;
         char encm5__pos__2;
         char encm5__pos__3;
         char encm5__pos__4;
         char encm5__pos__5;
         char encm5__pos__6;
         char encm5__pos__7;
         char encm5__pos__8;
         char encm5__pos__9;
         char encm5__pos__10;
         char encm5__pos__11;
         char encm5__pos__12;
         char encm5__pos__13;
         char encm5__pos__14;
         char encm5__pos__15;
         char encm5__pos__16;
         char encm5__pos__17;
         char encm5__pos__18;
         char encm5__pos__19;
         char encm5__pos__20;
         char encm5__pos__21;
         char encm5__pos__22;
         char encm5__pos__23;
         char encm5__pos__24;
         char encm5__pos__25;
//      string constant for abnormal end
        word endab;
        word endab__pos__1;
         char endab__pos__2;
         char endab__pos__3;
         char endab__pos__4;
         char endab__pos__5;
         char endab__pos__6;
         char endab__pos__7;
         char endab__pos__8;
         char endab__pos__9;
         char endab__pos__10;
         char endab__pos__11;
         char endab__pos__12;
         char endab__pos__13;
         char endab__pos__14;
         char endab__pos__15;
         char endab__pos__16;
         char endab__pos__17;
        
//      memory overflow during initialisation
        word endmo;
        word endml;
         char endml__pos__1;
         char endml__pos__2;
         char endml__pos__3;
         char endml__pos__4;
         char endml__pos__5;
         char endml__pos__6;
         char endml__pos__7;
         char endml__pos__8;
         char endml__pos__9;
         char endml__pos__10;
         char endml__pos__11;
         char endml__pos__12;
         char endml__pos__13;
         char endml__pos__14;
         char endml__pos__15;
         char endml__pos__16;
//      string constant for message issued by l_end
        word endms;
        word endms__pos__1;
         char endms__pos__2;
         char endms__pos__3;
         char endms__pos__4;
         char endms__pos__5;
         char endms__pos__6;
         char endms__pos__7;
         char endms__pos__8;
         char endms__pos__9;
         char endms__pos__10;
         char endms__pos__11;
         char endms__pos__12;
         char endms__pos__13;
         char endms__pos__14;
         char endms__pos__15;
         char endms__pos__16;
         char endms__pos__17;
//      fail message for stack fail section
        word endso;				// stack overflow in garbage collector
        word endso__pos__1;
         char endso__pos__2;
         char endso__pos__3;
         char endso__pos__4;
         char endso__pos__5;
         char endso__pos__6;
         char endso__pos__7;
         char endso__pos__8;
         char endso__pos__9;
         char endso__pos__10;
         char endso__pos__11;
         char endso__pos__12;
         char endso__pos__13;
         char endso__pos__14;
         char endso__pos__15;
         char endso__pos__16;
         char endso__pos__17;
         char endso__pos__18;
         char endso__pos__19;
         char endso__pos__20;
         char endso__pos__21;
         char endso__pos__22;
         char endso__pos__23;
         char endso__pos__24;
         char endso__pos__25;
         char endso__pos__26;
         char endso__pos__27;
         char endso__pos__28;
         char endso__pos__29;
         char endso__pos__30;
         char endso__pos__31;
         char endso__pos__32;
         char endso__pos__33;
         char endso__pos__34;
         char endso__pos__35;
         char endso__pos__36;
         char endso__pos__37;
         char endso__pos__38;
         char endso__pos__39;
         char endso__pos__40;
         char endso__pos__41;
//      string constant for time up
        word endtu;
        word endtu__pos__1;
         char endtu__pos__2;
         char endtu__pos__3;
         char endtu__pos__4;
         char endtu__pos__5;
         char endtu__pos__6;
         char endtu__pos__7;
         char endtu__pos__8;
         char endtu__pos__9;
         char endtu__pos__10;
         char endtu__pos__11;
         char endtu__pos__12;
         char endtu__pos__13;
         char endtu__pos__14;
         char endtu__pos__15;
         char endtu__pos__16;
         char endtu__pos__17;
        
//      string constant for error message (error section)
        word ermms;				// error
        word ermms__pos__1;
         char ermms__pos__2;
         char ermms__pos__3;
         char ermms__pos__4;
         char ermms__pos__5;
         char ermms__pos__6;
         char ermms__pos__7;
         char ermms__pos__8;
         char ermms__pos__9;
        word ermns;				// string / -- /
        word ermns__pos__1;
         char ermns__pos__2;
         char ermns__pos__3;
         char ermns__pos__4;
         char ermns__pos__5;
         char ermns__pos__6;
         char ermns__pos__7;
         char ermns__pos__8;
         char ermns__pos__9;
//      string constant for page numbering
        word lstms;				// page
        word lstms__pos__1;
         char lstms__pos__2;
         char lstms__pos__3;
         char lstms__pos__4;
         char lstms__pos__5;
         char lstms__pos__6;
         char lstms__pos__7;
         char lstms__pos__8;
         char lstms__pos__9;
//      listing header message
        word headr;
        word headr__pos__1;
         char headr__pos__2;
         char headr__pos__3;
         char headr__pos__4;
         char headr__pos__5;
         char headr__pos__6;
         char headr__pos__7;
         char headr__pos__8;
         char headr__pos__9;
         char headr__pos__10;
         char headr__pos__11;
         char headr__pos__12;
         char headr__pos__13;
         char headr__pos__14;
         char headr__pos__15;
         char headr__pos__16;
         char headr__pos__17;
         char headr__pos__18;
         char headr__pos__19;
         char headr__pos__20;
         char headr__pos__21;
         char headr__pos__22;
         char headr__pos__23;
         char headr__pos__24;
         char headr__pos__25;
         char headr__pos__26;
         char headr__pos__27;
         char headr__pos__28;
         char headr__pos__29;
         char headr__pos__30;
         char headr__pos__31;
         char headr__pos__32;
         char headr__pos__33;
        word headv;				// for exit() version no. check
        word headv__pos__1;
         char headv__pos__2;
         char headv__pos__3;
         char headv__pos__4;
         char headv__pos__5;
         char headv__pos__6;
         char headv__pos__7;
         char headv__pos__8;
         char headv__pos__9;
//      free store percentage (used by gbcol)
        word gbsdp;				// sediment percentage
//      integer constants for general use
//      icbld optimisation uses the first three.
        word int_r;
        word intv0;				// 0
        word inton;
        word intv1;				// 1
        word inttw;
        word intv2;				// 2
        word intvt;				// 10
        word intvh;				// 100
        word intth;				// 1000
//      table used in icbld optimisation
        word intab;				// pointer to 0
        word intab__pos__1;				// pointer to 1
        word intab__pos__2;				// pointer to 2
        
//      special pattern nodes. the following pattern nodes
//      consist simply of a pcode pointer, see match routines
//      (p_xxx) for full details of their use and format).
        word ndabb;				// arbno
        word ndabd;				// arbno
        word ndarc;				// arb
        word ndexb;				// expression
        word ndfnb;				// fence()
        word ndfnd;				// fence()
        word ndexc;				// expression
        word ndimb;				// immediate assignment
        word ndimd;				// immediate assignment
        word ndnth;				// pattern end (null pattern)
        word ndpab;				// pattern assignment
        word ndpad;				// pattern assignment
        word nduna;				// anchor point movement
//      keyword constant pattern nodes. the following nodes are
//      used as the values of pattern keywords and the initial
//      values of the corresponding natural variables. all
//      nodes are in p0blk format and the order is tied to the
//      definitions of corresponding k_xxx symbols.
        word ndabo;				// abort
        word ndabo__pos__1;
        word ndarb;				// arb
        word ndarb__pos__1;
        word ndbal;				// bal
        word ndbal__pos__1;
        word ndfal;				// fail
        word ndfal__pos__1;
        word ndfen;				// fence
        word ndfen__pos__1;
        word ndrem;				// rem
        word ndrem__pos__1;
        word ndsuc;				// succeed
        word ndsuc__pos__1;
//      null string. all null values point to this string. the
//      svchs field contains a blank to provide for easy default
//      processing in trace, stoptr, lpad and rpad.
//      nullw contains 10 blanks which ensures an all blank word
//      but for very exceptional machines.
        word nulls;				// null string value
        word nulls__pos__1;				// sclen = 0
         char nullw;
         char nullw__pos__1;
         char nullw__pos__2;
         char nullw__pos__3;
         char nullw__pos__4;
         char nullw__pos__5;
         char nullw__pos__6;
         char nullw__pos__7;
         char nullw__pos__8;
         char nullw__pos__9;
         char nullw__pos__10;
         char nullw__pos__11;
         char nullw__pos__12;
         char nullw__pos__13;
         char nullw__pos__14;
         char nullw__pos__15;
//      constant strings for lcase and ucase keywords
        word lcase;
        word lcase__pos__1;
         char lcase__pos__2;
         char lcase__pos__3;
         char lcase__pos__4;
         char lcase__pos__5;
         char lcase__pos__6;
         char lcase__pos__7;
         char lcase__pos__8;
         char lcase__pos__9;
         char lcase__pos__10;
         char lcase__pos__11;
         char lcase__pos__12;
         char lcase__pos__13;
         char lcase__pos__14;
         char lcase__pos__15;
         char lcase__pos__16;
         char lcase__pos__17;
         char lcase__pos__18;
         char lcase__pos__19;
         char lcase__pos__20;
         char lcase__pos__21;
         char lcase__pos__22;
         char lcase__pos__23;
         char lcase__pos__24;
         char lcase__pos__25;
         char lcase__pos__26;
         char lcase__pos__27;
         char lcase__pos__28;
         char lcase__pos__29;
         char lcase__pos__30;
         char lcase__pos__31;
         char lcase__pos__32;
         char lcase__pos__33;
        word ucase;
        word ucase__pos__1;
         char ucase__pos__2;
         char ucase__pos__3;
         char ucase__pos__4;
         char ucase__pos__5;
         char ucase__pos__6;
         char ucase__pos__7;
         char ucase__pos__8;
         char ucase__pos__9;
         char ucase__pos__10;
         char ucase__pos__11;
         char ucase__pos__12;
         char ucase__pos__13;
         char ucase__pos__14;
         char ucase__pos__15;
         char ucase__pos__16;
         char ucase__pos__17;
         char ucase__pos__18;
         char ucase__pos__19;
         char ucase__pos__20;
         char ucase__pos__21;
         char ucase__pos__22;
         char ucase__pos__23;
         char ucase__pos__24;
         char ucase__pos__25;
         char ucase__pos__26;
         char ucase__pos__27;
         char ucase__pos__28;
         char ucase__pos__29;
         char ucase__pos__30;
         char ucase__pos__31;
         char ucase__pos__32;
         char ucase__pos__33;
        
//      operator dope vectors (see dvblk format)
        word opdvc;				// concatenation
        word opdvc__pos__1;
        word opdvc__pos__2;
        word opdvc__pos__3;
//      opdvs is used when scanning below the top level to
//      insure that the concatenation will not be later
//      mistaken for pattern matching
        word opdvp;				// concatenation - not pattern match
        word opdvp__pos__1;
        word opdvp__pos__2;
        word opdvp__pos__3;
//      note that the order of the remaining entries is tied to
//      the order of the coding in the scane procedure.
        word opdvs;				// assignment
        word opdvs__pos__1;
        word opdvs__pos__2;
        word opdvs__pos__3;
        word opdvs__pos__4;				// unary equal
        word opdvs__pos__5;
        word opdvs__pos__6;
        word opdvs__pos__7;				// pattern match
        word opdvs__pos__8;
        word opdvs__pos__9;
        word opdvs__pos__10;
        word opdvs__pos__11;				// interrogation
        word opdvs__pos__12;
        word opdvs__pos__13;
        word opdvs__pos__14;				// binary ampersand
        word opdvs__pos__15;
        word opdvs__pos__16;
        word opdvs__pos__17;
        word opdvs__pos__18;				// keyword reference
        word opdvs__pos__19;
        word opdvs__pos__20;
        word opdvs__pos__21;				// alternation
        word opdvs__pos__22;
        word opdvs__pos__23;
        word opdvs__pos__24;
        
//      operator dope vectors (continued)
        word opdvs__pos__25;				// unary vertical bar
        word opdvs__pos__26;
        word opdvs__pos__27;
        word opdvs__pos__28;				// binary at
        word opdvs__pos__29;
        word opdvs__pos__30;
        word opdvs__pos__31;
        word opdvs__pos__32;				// cursor assignment
        word opdvs__pos__33;
        word opdvs__pos__34;
        word opdvs__pos__35;				// binary number sign
        word opdvs__pos__36;
        word opdvs__pos__37;
        word opdvs__pos__38;
        word opdvs__pos__39;				// unary number sign
        word opdvs__pos__40;
        word opdvs__pos__41;
        word opdvs__pos__42;				// division
        word opdvs__pos__43;
        word opdvs__pos__44;
        word opdvs__pos__45;
        word opdvs__pos__46;				// unary slash
        word opdvs__pos__47;
        word opdvs__pos__48;
        word opdvs__pos__49;				// multiplication
        word opdvs__pos__50;
        word opdvs__pos__51;
        word opdvs__pos__52;
        
//      operator dope vectors (continued)
        word opdvs__pos__53;				// deferred expression
        word opdvs__pos__54;
        word opdvs__pos__55;
        word opdvs__pos__56;				// binary percent
        word opdvs__pos__57;
        word opdvs__pos__58;
        word opdvs__pos__59;
        word opdvs__pos__60;				// unary percent
        word opdvs__pos__61;
        word opdvs__pos__62;
        word opdvs__pos__63;				// exponentiation
        word opdvs__pos__64;
        word opdvs__pos__65;
        word opdvs__pos__66;
        word opdvs__pos__67;				// unary exclamation
        word opdvs__pos__68;
        word opdvs__pos__69;
        word opdvs__pos__70;				// immediate assignment
        word opdvs__pos__71;
        word opdvs__pos__72;
        word opdvs__pos__73;
        word opdvs__pos__74;				// indirection
        word opdvs__pos__75;
        word opdvs__pos__76;
        word opdvs__pos__77;				// binary not
        word opdvs__pos__78;
        word opdvs__pos__79;
        word opdvs__pos__80;
        word opdvs__pos__81;				// negation
        word opdvs__pos__82;
        word opdvs__pos__83;
        
//      operator dope vectors (continued)
        word opdvs__pos__84;				// subtraction
        word opdvs__pos__85;
        word opdvs__pos__86;
        word opdvs__pos__87;
        word opdvs__pos__88;				// complementation
        word opdvs__pos__89;
        word opdvs__pos__90;
        word opdvs__pos__91;				// addition
        word opdvs__pos__92;
        word opdvs__pos__93;
        word opdvs__pos__94;
        word opdvs__pos__95;				// affirmation
        word opdvs__pos__96;
        word opdvs__pos__97;
        word opdvs__pos__98;				// pattern assignment
        word opdvs__pos__99;
        word opdvs__pos__100;
        word opdvs__pos__101;
        word opdvs__pos__102;				// name reference
        word opdvs__pos__103;
        word opdvs__pos__104;
//      special dvs for goto operators (see procedure scngf)
        word opdvd;				// direct goto
        word opdvd__pos__1;
        word opdvd__pos__2;
        word opdvn;				// complex normal goto
        word opdvn__pos__1;
        word opdvn__pos__2;
        
//      operator entry address pointers, used in code
        word oamn_;				// array ref (multi-subs by value)
        word oamv_;				// array ref (multi-subs by value)
        word oaon_;				// array ref (one sub by name)
        word oaov_;				// array ref (one sub by value)
        word ocer_;				// compilation error
        word ofex_;				// failure in expression evaluation
        word ofif_;				// failure during goto evaluation
        word ofnc_;				// function call (more than one arg)
        word ofne_;				// function name error
        word ofns_;				// function call (single argument)
        word ogof_;				// set goto failure trap
        word oinn_;				// indirection by name
        word okwn_;				// keyword reference by name
        word olex_;				// load expression by name
        word olpt_;				// load pattern
        word olvn_;				// load variable name
        word onta_;				// negation, first entry
        word ontb_;				// negation, second entry
        word ontc_;				// negation, third entry
        word opmn_;				// pattern match by name
        word opms_;				// pattern match (statement)
        word opop_;				// pop top stack item
        word ornm_;				// return name from expression
        word orpl_;				// pattern replacement
        word orvl_;				// return value from expression
        word osla_;				// selection, first entry
        word oslb_;				// selection, second entry
        word oslc_;				// selection, third entry
        word osld_;				// selection, fourth entry
        word ostp_;				// stop execution
        word ounf_;				// unexpected failure
        
//      table of names of undefined binary operators for opsyn
        word opsnb;				// at
        word opsnb__pos__1;				// ampersand
        word opsnb__pos__2;				// number
        word opsnb__pos__3;				// percent
        word opsnb__pos__4;				// not
//      table of names of undefined unary operators for opsyn
        word opnsu;				// vertical bar
        word opnsu__pos__1;				// equal
        word opnsu__pos__2;				// number
        word opnsu__pos__3;				// percent
        word opnsu__pos__4;				// slash
        word opnsu__pos__5;				// exclamation
//      address const containing profile table entry size
        word pfi2a;
//      profiler message strings
        word pfms1;
        word pfms1__pos__1;
         char pfms1__pos__2;
         char pfms1__pos__3;
         char pfms1__pos__4;
         char pfms1__pos__5;
         char pfms1__pos__6;
         char pfms1__pos__7;
         char pfms1__pos__8;
         char pfms1__pos__9;
         char pfms1__pos__10;
         char pfms1__pos__11;
         char pfms1__pos__12;
         char pfms1__pos__13;
         char pfms1__pos__14;
         char pfms1__pos__15;
         char pfms1__pos__16;
         char pfms1__pos__17;
        word pfms2;
        word pfms2__pos__1;
         char pfms2__pos__2;
         char pfms2__pos__3;
         char pfms2__pos__4;
         char pfms2__pos__5;
         char pfms2__pos__6;
         char pfms2__pos__7;
         char pfms2__pos__8;
         char pfms2__pos__9;
         char pfms2__pos__10;
         char pfms2__pos__11;
         char pfms2__pos__12;
         char pfms2__pos__13;
         char pfms2__pos__14;
         char pfms2__pos__15;
         char pfms2__pos__16;
         char pfms2__pos__17;
         char pfms2__pos__18;
         char pfms2__pos__19;
         char pfms2__pos__20;
         char pfms2__pos__21;
         char pfms2__pos__22;
         char pfms2__pos__23;
         char pfms2__pos__24;
         char pfms2__pos__25;
         char pfms2__pos__26;
         char pfms2__pos__27;
         char pfms2__pos__28;
         char pfms2__pos__29;
         char pfms2__pos__30;
         char pfms2__pos__31;
         char pfms2__pos__32;
         char pfms2__pos__33;
         char pfms2__pos__34;
         char pfms2__pos__35;
         char pfms2__pos__36;
         char pfms2__pos__37;
         char pfms2__pos__38;
         char pfms2__pos__39;
         char pfms2__pos__40;
         char pfms2__pos__41;
         char pfms2__pos__42;
         char pfms2__pos__43;
         char pfms2__pos__44;
         char pfms2__pos__45;
         char pfms2__pos__46;
         char pfms2__pos__47;
         char pfms2__pos__48;
         char pfms2__pos__49;
        word pfms3;
        word pfms3__pos__1;
         char pfms3__pos__2;
         char pfms3__pos__3;
         char pfms3__pos__4;
         char pfms3__pos__5;
         char pfms3__pos__6;
         char pfms3__pos__7;
         char pfms3__pos__8;
         char pfms3__pos__9;
         char pfms3__pos__10;
         char pfms3__pos__11;
         char pfms3__pos__12;
         char pfms3__pos__13;
         char pfms3__pos__14;
         char pfms3__pos__15;
         char pfms3__pos__16;
         char pfms3__pos__17;
         char pfms3__pos__18;
         char pfms3__pos__19;
         char pfms3__pos__20;
         char pfms3__pos__21;
         char pfms3__pos__22;
         char pfms3__pos__23;
         char pfms3__pos__24;
         char pfms3__pos__25;
         char pfms3__pos__26;
         char pfms3__pos__27;
         char pfms3__pos__28;
         char pfms3__pos__29;
         char pfms3__pos__30;
         char pfms3__pos__31;
         char pfms3__pos__32;
         char pfms3__pos__33;
         char pfms3__pos__34;
         char pfms3__pos__35;
         char pfms3__pos__36;
         char pfms3__pos__37;
         char pfms3__pos__38;
         char pfms3__pos__39;
         char pfms3__pos__40;
         char pfms3__pos__41;
         char pfms3__pos__42;
         char pfms3__pos__43;
         char pfms3__pos__44;
         char pfms3__pos__45;
         char pfms3__pos__46;
         char pfms3__pos__47;
         char pfms3__pos__48;
         char pfms3__pos__49;
//      real constants for general use. note that the constants
//      starting at reav1 form a powers of ten table (used in
//      gtnum and gtstg)
        double reav0;				// 0.0
        double reap1;				// 0.1
        double reap5;				// 0.5
        double reav1;				// 10**0
        double reavt;				// 10**1
        double reavt__pos__1;				// 10**2
        double reavt__pos__2;				// 10**3
        double reavt__pos__3;				// 10**4
        double reavt__pos__4;				// 10**5
        double reavt__pos__5;				// 10**6
        double reavt__pos__6;				// 10**7
        double reavt__pos__7;				// 10**8
        double reavt__pos__8;				// 10**9
        double reatt;				// 10**10
        
//      string constants (scblk format) for dtype procedure
        word scarr;				// array
        word scarr__pos__1;
         char scarr__pos__2;
         char scarr__pos__3;
         char scarr__pos__4;
         char scarr__pos__5;
         char scarr__pos__6;
         char scarr__pos__7;
         char scarr__pos__8;
         char scarr__pos__9;
        word sccod;				// code
        word sccod__pos__1;
         char sccod__pos__2;
         char sccod__pos__3;
         char sccod__pos__4;
         char sccod__pos__5;
         char sccod__pos__6;
         char sccod__pos__7;
         char sccod__pos__8;
         char sccod__pos__9;
        word scexp;				// expression
        word scexp__pos__1;
         char scexp__pos__2;
         char scexp__pos__3;
         char scexp__pos__4;
         char scexp__pos__5;
         char scexp__pos__6;
         char scexp__pos__7;
         char scexp__pos__8;
         char scexp__pos__9;
         char scexp__pos__10;
         char scexp__pos__11;
         char scexp__pos__12;
         char scexp__pos__13;
         char scexp__pos__14;
         char scexp__pos__15;
         char scexp__pos__16;
         char scexp__pos__17;
        word scext;				// external
        word scext__pos__1;
         char scext__pos__2;
         char scext__pos__3;
         char scext__pos__4;
         char scext__pos__5;
         char scext__pos__6;
         char scext__pos__7;
         char scext__pos__8;
         char scext__pos__9;
         char scext__pos__10;
         char scext__pos__11;
         char scext__pos__12;
         char scext__pos__13;
         char scext__pos__14;
         char scext__pos__15;
         char scext__pos__16;
         char scext__pos__17;
        word scint;				// integer
        word scint__pos__1;
         char scint__pos__2;
         char scint__pos__3;
         char scint__pos__4;
         char scint__pos__5;
         char scint__pos__6;
         char scint__pos__7;
         char scint__pos__8;
         char scint__pos__9;
        word scnam;				// name
        word scnam__pos__1;
         char scnam__pos__2;
         char scnam__pos__3;
         char scnam__pos__4;
         char scnam__pos__5;
         char scnam__pos__6;
         char scnam__pos__7;
         char scnam__pos__8;
         char scnam__pos__9;
        word scnum;				// numeric
        word scnum__pos__1;
         char scnum__pos__2;
         char scnum__pos__3;
         char scnum__pos__4;
         char scnum__pos__5;
         char scnum__pos__6;
         char scnum__pos__7;
         char scnum__pos__8;
         char scnum__pos__9;
        word scpat;				// pattern
        word scpat__pos__1;
         char scpat__pos__2;
         char scpat__pos__3;
         char scpat__pos__4;
         char scpat__pos__5;
         char scpat__pos__6;
         char scpat__pos__7;
         char scpat__pos__8;
         char scpat__pos__9;
        word screa;				// real
        word screa__pos__1;
         char screa__pos__2;
         char screa__pos__3;
         char screa__pos__4;
         char screa__pos__5;
         char screa__pos__6;
         char screa__pos__7;
         char screa__pos__8;
         char screa__pos__9;
        word scstr;				// string
        word scstr__pos__1;
         char scstr__pos__2;
         char scstr__pos__3;
         char scstr__pos__4;
         char scstr__pos__5;
         char scstr__pos__6;
         char scstr__pos__7;
         char scstr__pos__8;
         char scstr__pos__9;
        word sctab;				// table
        word sctab__pos__1;
         char sctab__pos__2;
         char sctab__pos__3;
         char sctab__pos__4;
         char sctab__pos__5;
         char sctab__pos__6;
         char sctab__pos__7;
         char sctab__pos__8;
         char sctab__pos__9;
        word scfil;				// file (for extended load arguments)
        word scfil__pos__1;
         char scfil__pos__2;
         char scfil__pos__3;
         char scfil__pos__4;
         char scfil__pos__5;
         char scfil__pos__6;
         char scfil__pos__7;
         char scfil__pos__8;
         char scfil__pos__9;
        
//      string constants (scblk format) for kvrtn (see retrn)
        word scfrt;				// freturn
        word scfrt__pos__1;
         char scfrt__pos__2;
         char scfrt__pos__3;
         char scfrt__pos__4;
         char scfrt__pos__5;
         char scfrt__pos__6;
         char scfrt__pos__7;
         char scfrt__pos__8;
         char scfrt__pos__9;
        word scnrt;				// nreturn
        word scnrt__pos__1;
         char scnrt__pos__2;
         char scnrt__pos__3;
         char scnrt__pos__4;
         char scnrt__pos__5;
         char scnrt__pos__6;
         char scnrt__pos__7;
         char scnrt__pos__8;
         char scnrt__pos__9;
        word scrtn;				// return
        word scrtn__pos__1;
         char scrtn__pos__2;
         char scrtn__pos__3;
         char scrtn__pos__4;
         char scrtn__pos__5;
         char scrtn__pos__6;
         char scrtn__pos__7;
         char scrtn__pos__8;
         char scrtn__pos__9;
//      datatype name table for dtype procedure. the order of
//      these entries is tied to the b_xxx definitions for blocks
//      note that slots for buffer and real data types are filled
//      even if these data types are conditionalized out of the
//      implementation.  this is done so that the block numbering
//      at bl_ar etc. remains constant in all versions.
        word scnmt;				// arblk     array
        word scnmt__pos__1;				// cdblk     code
        word scnmt__pos__2;				// exblk     expression
        word scnmt__pos__3;				// icblk     integer
        word scnmt__pos__4;				// nmblk     name
        word scnmt__pos__5;				// p0blk     pattern
        word scnmt__pos__6;				// p1blk     pattern
        word scnmt__pos__7;				// p2blk     pattern
        word scnmt__pos__8;				// rcblk     real
        word scnmt__pos__9;				// scblk     string
        word scnmt__pos__10;				// seblk     expression
        word scnmt__pos__11;				// tbblk     table
        word scnmt__pos__12;				// vcblk     array
        word scnmt__pos__13;				// xnblk     external
        word scnmt__pos__14;				// xrblk     external
        word scnmt__pos__15;				// bfblk     no buffer in this version
//      string constant for real zero
        word scre0;
        word scre0__pos__1;
         char scre0__pos__2;
         char scre0__pos__3;
         char scre0__pos__4;
         char scre0__pos__5;
         char scre0__pos__6;
         char scre0__pos__7;
         char scre0__pos__8;
         char scre0__pos__9;
        
//      used to re-initialise kvstl
        word stlim;				// default statement limit
//      dummy function block used for undefined functions
        word stndf;				// ptr to undefined function err call
        word stndf__pos__1;				// dummy fargs count for call circuit
//      dummy code block used for undefined labels
        word stndl;				// code ptr points to undefined lbl
//      dummy operator block used for undefined operators
        word stndo;				// ptr to undefined operator err call
        word stndo__pos__1;				// dummy fargs count for call circuit
//      standard variable block. this block is used to initialize
//      the first seven fields of a newly constructed vrblk.
//      its format is tied to the vrblk definitions (see gtnvr).
        word stnvr;				// vrget
        word stnvr__pos__1;				// vrsto
        word stnvr__pos__2;				// vrval
        word stnvr__pos__3;				// vrtra
        word stnvr__pos__4;				// vrlbl
        word stnvr__pos__5;				// vrfnc
        word stnvr__pos__6;				// vrnxt
        
//      messages used in end of run processing (stopr)
        word stpm1;				// in statement
        word stpm1__pos__1;
         char stpm1__pos__2;
         char stpm1__pos__3;
         char stpm1__pos__4;
         char stpm1__pos__5;
         char stpm1__pos__6;
         char stpm1__pos__7;
         char stpm1__pos__8;
         char stpm1__pos__9;
         char stpm1__pos__10;
         char stpm1__pos__11;
         char stpm1__pos__12;
         char stpm1__pos__13;
         char stpm1__pos__14;
         char stpm1__pos__15;
         char stpm1__pos__16;
         char stpm1__pos__17;
        word stpm2;
        word stpm2__pos__1;
         char stpm2__pos__2;
         char stpm2__pos__3;
         char stpm2__pos__4;
         char stpm2__pos__5;
         char stpm2__pos__6;
         char stpm2__pos__7;
         char stpm2__pos__8;
         char stpm2__pos__9;
         char stpm2__pos__10;
         char stpm2__pos__11;
         char stpm2__pos__12;
         char stpm2__pos__13;
         char stpm2__pos__14;
         char stpm2__pos__15;
         char stpm2__pos__16;
         char stpm2__pos__17;
        word stpm3;
        word stpm3__pos__1;
         char stpm3__pos__2;
         char stpm3__pos__3;
         char stpm3__pos__4;
         char stpm3__pos__5;
         char stpm3__pos__6;
         char stpm3__pos__7;
         char stpm3__pos__8;
         char stpm3__pos__9;
         char stpm3__pos__10;
         char stpm3__pos__11;
         char stpm3__pos__12;
         char stpm3__pos__13;
         char stpm3__pos__14;
         char stpm3__pos__15;
         char stpm3__pos__16;
         char stpm3__pos__17;
         char stpm3__pos__18;
         char stpm3__pos__19;
         char stpm3__pos__20;
         char stpm3__pos__21;
         char stpm3__pos__22;
         char stpm3__pos__23;
         char stpm3__pos__24;
         char stpm3__pos__25;
        word stpm4;				// in line
        word stpm4__pos__1;
         char stpm4__pos__2;
         char stpm4__pos__3;
         char stpm4__pos__4;
         char stpm4__pos__5;
         char stpm4__pos__6;
         char stpm4__pos__7;
         char stpm4__pos__8;
         char stpm4__pos__9;
        word stpm5;
        word stpm5__pos__1;
         char stpm5__pos__2;
         char stpm5__pos__3;
         char stpm5__pos__4;
         char stpm5__pos__5;
         char stpm5__pos__6;
         char stpm5__pos__7;
         char stpm5__pos__8;
         char stpm5__pos__9;
         char stpm5__pos__10;
         char stpm5__pos__11;
         char stpm5__pos__12;
         char stpm5__pos__13;
         char stpm5__pos__14;
         char stpm5__pos__15;
         char stpm5__pos__16;
         char stpm5__pos__17;
        word stpm6;				// in file
        word stpm6__pos__1;
         char stpm6__pos__2;
         char stpm6__pos__3;
         char stpm6__pos__4;
         char stpm6__pos__5;
         char stpm6__pos__6;
         char stpm6__pos__7;
         char stpm6__pos__8;
         char stpm6__pos__9;
        word stpm7;
        word stpm7__pos__1;
         char stpm7__pos__2;
         char stpm7__pos__3;
         char stpm7__pos__4;
         char stpm7__pos__5;
         char stpm7__pos__6;
         char stpm7__pos__7;
         char stpm7__pos__8;
         char stpm7__pos__9;
         char stpm7__pos__10;
         char stpm7__pos__11;
         char stpm7__pos__12;
         char stpm7__pos__13;
         char stpm7__pos__14;
         char stpm7__pos__15;
         char stpm7__pos__16;
         char stpm7__pos__17;
        word stpm8;
        word stpm8__pos__1;
         char stpm8__pos__2;
         char stpm8__pos__3;
         char stpm8__pos__4;
         char stpm8__pos__5;
         char stpm8__pos__6;
         char stpm8__pos__7;
         char stpm8__pos__8;
         char stpm8__pos__9;
         char stpm8__pos__10;
         char stpm8__pos__11;
         char stpm8__pos__12;
         char stpm8__pos__13;
         char stpm8__pos__14;
         char stpm8__pos__15;
         char stpm8__pos__16;
         char stpm8__pos__17;
        word stpm9;
        word stpm9__pos__1;
         char stpm9__pos__2;
         char stpm9__pos__3;
         char stpm9__pos__4;
         char stpm9__pos__5;
         char stpm9__pos__6;
         char stpm9__pos__7;
         char stpm9__pos__8;
         char stpm9__pos__9;
         char stpm9__pos__10;
         char stpm9__pos__11;
         char stpm9__pos__12;
         char stpm9__pos__13;
         char stpm9__pos__14;
         char stpm9__pos__15;
         char stpm9__pos__16;
         char stpm9__pos__17;
//      chars for /tu/ ending code
         char strtu;
         char strtu__pos__1;
         char strtu__pos__2;
         char strtu__pos__3;
         char strtu__pos__4;
         char strtu__pos__5;
         char strtu__pos__6;
         char strtu__pos__7;
//      table used by convert function to check datatype name
//      the entries are ordered to correspond to branch table
//      in s_cnv
        word svctb;				// string
        word svctb__pos__1;				// integer
        word svctb__pos__2;				// name
        word svctb__pos__3;				// pattern
        word svctb__pos__4;				// array
        word svctb__pos__5;				// table
        word svctb__pos__6;				// expression
        word svctb__pos__7;				// code
        word svctb__pos__8;				// numeric
        word svctb__pos__9;				// real
        word svctb__pos__10;				// zero marks end of list
        
//      messages (scblk format) used by trace procedures
        word tmasb;				// asterisks for trace statement no
        word tmasb__pos__1;
         char tmasb__pos__2;
         char tmasb__pos__3;
         char tmasb__pos__4;
         char tmasb__pos__5;
         char tmasb__pos__6;
         char tmasb__pos__7;
         char tmasb__pos__8;
         char tmasb__pos__9;
         char tmasb__pos__10;
         char tmasb__pos__11;
         char tmasb__pos__12;
         char tmasb__pos__13;
         char tmasb__pos__14;
         char tmasb__pos__15;
         char tmasb__pos__16;
         char tmasb__pos__17;
        word tmbeb;				// blank-equal-blank
        word tmbeb__pos__1;
         char tmbeb__pos__2;
         char tmbeb__pos__3;
         char tmbeb__pos__4;
         char tmbeb__pos__5;
         char tmbeb__pos__6;
         char tmbeb__pos__7;
         char tmbeb__pos__8;
         char tmbeb__pos__9;
//      dummy trblk for expression variable
        word trbev;				// dummy trblk
//      dummy trblk for keyword variable
        word trbkv;				// dummy trblk
//      dummy code block to return control to trxeq procedure
        word trxdr;				// block points to return routine
        word trxdc;				// pointer to block
        
//      standard variable blocks
//      see svblk format for full details of the format. the
//      vrblks are ordered by length and within each length the
//      order is alphabetical by name of the variable.
        d_word v_eqf;				// eq
        word v_eqf__pos__1;
         char v_eqf__pos__2;
         char v_eqf__pos__3;
         char v_eqf__pos__4;
         char v_eqf__pos__5;
         char v_eqf__pos__6;
         char v_eqf__pos__7;
         char v_eqf__pos__8;
         char v_eqf__pos__9;
        word v_eqf__pos__10;
        word v_eqf__pos__11;
        d_word v_gef;				// ge
        word v_gef__pos__1;
         char v_gef__pos__2;
         char v_gef__pos__3;
         char v_gef__pos__4;
         char v_gef__pos__5;
         char v_gef__pos__6;
         char v_gef__pos__7;
         char v_gef__pos__8;
         char v_gef__pos__9;
        word v_gef__pos__10;
        word v_gef__pos__11;
        d_word v_gtf;				// gt
        word v_gtf__pos__1;
         char v_gtf__pos__2;
         char v_gtf__pos__3;
         char v_gtf__pos__4;
         char v_gtf__pos__5;
         char v_gtf__pos__6;
         char v_gtf__pos__7;
         char v_gtf__pos__8;
         char v_gtf__pos__9;
        word v_gtf__pos__10;
        word v_gtf__pos__11;
        d_word v_lef;				// le
        word v_lef__pos__1;
         char v_lef__pos__2;
         char v_lef__pos__3;
         char v_lef__pos__4;
         char v_lef__pos__5;
         char v_lef__pos__6;
         char v_lef__pos__7;
         char v_lef__pos__8;
         char v_lef__pos__9;
        word v_lef__pos__10;
        word v_lef__pos__11;
        d_word v_lnf;				// ln
        word v_lnf__pos__1;
         char v_lnf__pos__2;
         char v_lnf__pos__3;
         char v_lnf__pos__4;
         char v_lnf__pos__5;
         char v_lnf__pos__6;
         char v_lnf__pos__7;
         char v_lnf__pos__8;
         char v_lnf__pos__9;
        word v_lnf__pos__10;
        word v_lnf__pos__11;
        d_word v_ltf;				// lt
        word v_ltf__pos__1;
         char v_ltf__pos__2;
         char v_ltf__pos__3;
         char v_ltf__pos__4;
         char v_ltf__pos__5;
         char v_ltf__pos__6;
         char v_ltf__pos__7;
         char v_ltf__pos__8;
         char v_ltf__pos__9;
        word v_ltf__pos__10;
        word v_ltf__pos__11;
        d_word v_nef;				// ne
        word v_nef__pos__1;
         char v_nef__pos__2;
         char v_nef__pos__3;
         char v_nef__pos__4;
         char v_nef__pos__5;
         char v_nef__pos__6;
         char v_nef__pos__7;
         char v_nef__pos__8;
         char v_nef__pos__9;
        word v_nef__pos__10;
        word v_nef__pos__11;
        d_word v_any;				// any
        word v_any__pos__1;
         char v_any__pos__2;
         char v_any__pos__3;
         char v_any__pos__4;
         char v_any__pos__5;
         char v_any__pos__6;
         char v_any__pos__7;
         char v_any__pos__8;
         char v_any__pos__9;
        word v_any__pos__10;
        word v_any__pos__11;
        d_word v_arb;				// arb
        word v_arb__pos__1;
         char v_arb__pos__2;
         char v_arb__pos__3;
         char v_arb__pos__4;
         char v_arb__pos__5;
         char v_arb__pos__6;
         char v_arb__pos__7;
         char v_arb__pos__8;
         char v_arb__pos__9;
        word v_arb__pos__10;
        word v_arb__pos__11;
        
//      standard variable blocks (continued)
        d_word v_arg;				// arg
        word v_arg__pos__1;
         char v_arg__pos__2;
         char v_arg__pos__3;
         char v_arg__pos__4;
         char v_arg__pos__5;
         char v_arg__pos__6;
         char v_arg__pos__7;
         char v_arg__pos__8;
         char v_arg__pos__9;
        word v_arg__pos__10;
        word v_arg__pos__11;
        d_word v_bal;				// bal
        word v_bal__pos__1;
         char v_bal__pos__2;
         char v_bal__pos__3;
         char v_bal__pos__4;
         char v_bal__pos__5;
         char v_bal__pos__6;
         char v_bal__pos__7;
         char v_bal__pos__8;
         char v_bal__pos__9;
        word v_bal__pos__10;
        word v_bal__pos__11;
        d_word v_cos;				// cos
        word v_cos__pos__1;
         char v_cos__pos__2;
         char v_cos__pos__3;
         char v_cos__pos__4;
         char v_cos__pos__5;
         char v_cos__pos__6;
         char v_cos__pos__7;
         char v_cos__pos__8;
         char v_cos__pos__9;
        word v_cos__pos__10;
        word v_cos__pos__11;
        d_word v_end;				// end
        word v_end__pos__1;
         char v_end__pos__2;
         char v_end__pos__3;
         char v_end__pos__4;
         char v_end__pos__5;
         char v_end__pos__6;
         char v_end__pos__7;
         char v_end__pos__8;
         char v_end__pos__9;
        word v_end__pos__10;
        d_word v_exp;				// exp
        word v_exp__pos__1;
         char v_exp__pos__2;
         char v_exp__pos__3;
         char v_exp__pos__4;
         char v_exp__pos__5;
         char v_exp__pos__6;
         char v_exp__pos__7;
         char v_exp__pos__8;
         char v_exp__pos__9;
        word v_exp__pos__10;
        word v_exp__pos__11;
        d_word v_len;				// len
        word v_len__pos__1;
         char v_len__pos__2;
         char v_len__pos__3;
         char v_len__pos__4;
         char v_len__pos__5;
         char v_len__pos__6;
         char v_len__pos__7;
         char v_len__pos__8;
         char v_len__pos__9;
        word v_len__pos__10;
        word v_len__pos__11;
        d_word v_leq;				// leq
        word v_leq__pos__1;
         char v_leq__pos__2;
         char v_leq__pos__3;
         char v_leq__pos__4;
         char v_leq__pos__5;
         char v_leq__pos__6;
         char v_leq__pos__7;
         char v_leq__pos__8;
         char v_leq__pos__9;
        word v_leq__pos__10;
        word v_leq__pos__11;
        d_word v_lge;				// lge
        word v_lge__pos__1;
         char v_lge__pos__2;
         char v_lge__pos__3;
         char v_lge__pos__4;
         char v_lge__pos__5;
         char v_lge__pos__6;
         char v_lge__pos__7;
         char v_lge__pos__8;
         char v_lge__pos__9;
        word v_lge__pos__10;
        word v_lge__pos__11;
        d_word v_lgt;				// lgt
        word v_lgt__pos__1;
         char v_lgt__pos__2;
         char v_lgt__pos__3;
         char v_lgt__pos__4;
         char v_lgt__pos__5;
         char v_lgt__pos__6;
         char v_lgt__pos__7;
         char v_lgt__pos__8;
         char v_lgt__pos__9;
        word v_lgt__pos__10;
        word v_lgt__pos__11;
        d_word v_lle;				// lle
        word v_lle__pos__1;
         char v_lle__pos__2;
         char v_lle__pos__3;
         char v_lle__pos__4;
         char v_lle__pos__5;
         char v_lle__pos__6;
         char v_lle__pos__7;
         char v_lle__pos__8;
         char v_lle__pos__9;
        word v_lle__pos__10;
        word v_lle__pos__11;
        
//      standard variable blocks (continued)
        d_word v_llt;				// llt
        word v_llt__pos__1;
         char v_llt__pos__2;
         char v_llt__pos__3;
         char v_llt__pos__4;
         char v_llt__pos__5;
         char v_llt__pos__6;
         char v_llt__pos__7;
         char v_llt__pos__8;
         char v_llt__pos__9;
        word v_llt__pos__10;
        word v_llt__pos__11;
        d_word v_lne;				// lne
        word v_lne__pos__1;
         char v_lne__pos__2;
         char v_lne__pos__3;
         char v_lne__pos__4;
         char v_lne__pos__5;
         char v_lne__pos__6;
         char v_lne__pos__7;
         char v_lne__pos__8;
         char v_lne__pos__9;
        word v_lne__pos__10;
        word v_lne__pos__11;
        d_word v_pos;				// pos
        word v_pos__pos__1;
         char v_pos__pos__2;
         char v_pos__pos__3;
         char v_pos__pos__4;
         char v_pos__pos__5;
         char v_pos__pos__6;
         char v_pos__pos__7;
         char v_pos__pos__8;
         char v_pos__pos__9;
        word v_pos__pos__10;
        word v_pos__pos__11;
        d_word v_rem;				// rem
        word v_rem__pos__1;
         char v_rem__pos__2;
         char v_rem__pos__3;
         char v_rem__pos__4;
         char v_rem__pos__5;
         char v_rem__pos__6;
         char v_rem__pos__7;
         char v_rem__pos__8;
         char v_rem__pos__9;
        word v_rem__pos__10;
        word v_rem__pos__11;
        d_word v_sin;				// sin
        word v_sin__pos__1;
         char v_sin__pos__2;
         char v_sin__pos__3;
         char v_sin__pos__4;
         char v_sin__pos__5;
         char v_sin__pos__6;
         char v_sin__pos__7;
         char v_sin__pos__8;
         char v_sin__pos__9;
        word v_sin__pos__10;
        word v_sin__pos__11;
        d_word v_tab;				// tab
        word v_tab__pos__1;
         char v_tab__pos__2;
         char v_tab__pos__3;
         char v_tab__pos__4;
         char v_tab__pos__5;
         char v_tab__pos__6;
         char v_tab__pos__7;
         char v_tab__pos__8;
         char v_tab__pos__9;
        word v_tab__pos__10;
        word v_tab__pos__11;
        d_word v_tan;				// tan
        word v_tan__pos__1;
         char v_tan__pos__2;
         char v_tan__pos__3;
         char v_tan__pos__4;
         char v_tan__pos__5;
         char v_tan__pos__6;
         char v_tan__pos__7;
         char v_tan__pos__8;
         char v_tan__pos__9;
        word v_tan__pos__10;
        word v_tan__pos__11;
        d_word v_atn;				// atan
        word v_atn__pos__1;
         char v_atn__pos__2;
         char v_atn__pos__3;
         char v_atn__pos__4;
         char v_atn__pos__5;
         char v_atn__pos__6;
         char v_atn__pos__7;
         char v_atn__pos__8;
         char v_atn__pos__9;
        word v_atn__pos__10;
        word v_atn__pos__11;
        d_word v_chr;				// char
        word v_chr__pos__1;
         char v_chr__pos__2;
         char v_chr__pos__3;
         char v_chr__pos__4;
         char v_chr__pos__5;
         char v_chr__pos__6;
         char v_chr__pos__7;
         char v_chr__pos__8;
         char v_chr__pos__9;
        word v_chr__pos__10;
        word v_chr__pos__11;
        d_word v_chp;				// chop
        word v_chp__pos__1;
         char v_chp__pos__2;
         char v_chp__pos__3;
         char v_chp__pos__4;
         char v_chp__pos__5;
         char v_chp__pos__6;
         char v_chp__pos__7;
         char v_chp__pos__8;
         char v_chp__pos__9;
        word v_chp__pos__10;
        word v_chp__pos__11;
        d_word v_cod;				// code
        word v_cod__pos__1;
         char v_cod__pos__2;
         char v_cod__pos__3;
         char v_cod__pos__4;
         char v_cod__pos__5;
         char v_cod__pos__6;
         char v_cod__pos__7;
         char v_cod__pos__8;
         char v_cod__pos__9;
        word v_cod__pos__10;
        word v_cod__pos__11;
        word v_cod__pos__12;
        d_word v_cop;				// copy
        word v_cop__pos__1;
         char v_cop__pos__2;
         char v_cop__pos__3;
         char v_cop__pos__4;
         char v_cop__pos__5;
         char v_cop__pos__6;
         char v_cop__pos__7;
         char v_cop__pos__8;
         char v_cop__pos__9;
        word v_cop__pos__10;
        word v_cop__pos__11;
        
//      standard variable blocks (continued)
        d_word v_dat;				// data
        word v_dat__pos__1;
         char v_dat__pos__2;
         char v_dat__pos__3;
         char v_dat__pos__4;
         char v_dat__pos__5;
         char v_dat__pos__6;
         char v_dat__pos__7;
         char v_dat__pos__8;
         char v_dat__pos__9;
        word v_dat__pos__10;
        word v_dat__pos__11;
        d_word v_dte;				// date
        word v_dte__pos__1;
         char v_dte__pos__2;
         char v_dte__pos__3;
         char v_dte__pos__4;
         char v_dte__pos__5;
         char v_dte__pos__6;
         char v_dte__pos__7;
         char v_dte__pos__8;
         char v_dte__pos__9;
        word v_dte__pos__10;
        word v_dte__pos__11;
        d_word v_dmp;				// dump
        word v_dmp__pos__1;
         char v_dmp__pos__2;
         char v_dmp__pos__3;
         char v_dmp__pos__4;
         char v_dmp__pos__5;
         char v_dmp__pos__6;
         char v_dmp__pos__7;
         char v_dmp__pos__8;
         char v_dmp__pos__9;
        word v_dmp__pos__10;
        word v_dmp__pos__11;
        word v_dmp__pos__12;
        d_word v_dup;				// dupl
        word v_dup__pos__1;
         char v_dup__pos__2;
         char v_dup__pos__3;
         char v_dup__pos__4;
         char v_dup__pos__5;
         char v_dup__pos__6;
         char v_dup__pos__7;
         char v_dup__pos__8;
         char v_dup__pos__9;
        word v_dup__pos__10;
        word v_dup__pos__11;
        d_word v_evl;				// eval
        word v_evl__pos__1;
         char v_evl__pos__2;
         char v_evl__pos__3;
         char v_evl__pos__4;
         char v_evl__pos__5;
         char v_evl__pos__6;
         char v_evl__pos__7;
         char v_evl__pos__8;
         char v_evl__pos__9;
        word v_evl__pos__10;
        word v_evl__pos__11;
        d_word v_ext;				// exit
        word v_ext__pos__1;
         char v_ext__pos__2;
         char v_ext__pos__3;
         char v_ext__pos__4;
         char v_ext__pos__5;
         char v_ext__pos__6;
         char v_ext__pos__7;
         char v_ext__pos__8;
         char v_ext__pos__9;
        word v_ext__pos__10;
        word v_ext__pos__11;
        d_word v_fal;				// fail
        word v_fal__pos__1;
         char v_fal__pos__2;
         char v_fal__pos__3;
         char v_fal__pos__4;
         char v_fal__pos__5;
         char v_fal__pos__6;
         char v_fal__pos__7;
         char v_fal__pos__8;
         char v_fal__pos__9;
        word v_fal__pos__10;
        word v_fal__pos__11;
        d_word v_fil;				// file
        word v_fil__pos__1;
         char v_fil__pos__2;
         char v_fil__pos__3;
         char v_fil__pos__4;
         char v_fil__pos__5;
         char v_fil__pos__6;
         char v_fil__pos__7;
         char v_fil__pos__8;
         char v_fil__pos__9;
        word v_fil__pos__10;
        d_word v_hst;				// host
        word v_hst__pos__1;
         char v_hst__pos__2;
         char v_hst__pos__3;
         char v_hst__pos__4;
         char v_hst__pos__5;
         char v_hst__pos__6;
         char v_hst__pos__7;
         char v_hst__pos__8;
         char v_hst__pos__9;
        word v_hst__pos__10;
        word v_hst__pos__11;
        
//      standard variable blocks (continued)
        d_word v_itm;				// item
        word v_itm__pos__1;
         char v_itm__pos__2;
         char v_itm__pos__3;
         char v_itm__pos__4;
         char v_itm__pos__5;
         char v_itm__pos__6;
         char v_itm__pos__7;
         char v_itm__pos__8;
         char v_itm__pos__9;
        word v_itm__pos__10;
        word v_itm__pos__11;
        d_word v_lin;				// line
        word v_lin__pos__1;
         char v_lin__pos__2;
         char v_lin__pos__3;
         char v_lin__pos__4;
         char v_lin__pos__5;
         char v_lin__pos__6;
         char v_lin__pos__7;
         char v_lin__pos__8;
         char v_lin__pos__9;
        word v_lin__pos__10;
        d_word v_lod;				// load
        word v_lod__pos__1;
         char v_lod__pos__2;
         char v_lod__pos__3;
         char v_lod__pos__4;
         char v_lod__pos__5;
         char v_lod__pos__6;
         char v_lod__pos__7;
         char v_lod__pos__8;
         char v_lod__pos__9;
        word v_lod__pos__10;
        word v_lod__pos__11;
        d_word v_lpd;				// lpad
        word v_lpd__pos__1;
         char v_lpd__pos__2;
         char v_lpd__pos__3;
         char v_lpd__pos__4;
         char v_lpd__pos__5;
         char v_lpd__pos__6;
         char v_lpd__pos__7;
         char v_lpd__pos__8;
         char v_lpd__pos__9;
        word v_lpd__pos__10;
        word v_lpd__pos__11;
        d_word v_rpd;				// rpad
        word v_rpd__pos__1;
         char v_rpd__pos__2;
         char v_rpd__pos__3;
         char v_rpd__pos__4;
         char v_rpd__pos__5;
         char v_rpd__pos__6;
         char v_rpd__pos__7;
         char v_rpd__pos__8;
         char v_rpd__pos__9;
        word v_rpd__pos__10;
        word v_rpd__pos__11;
        d_word v_rps;				// rpos
        word v_rps__pos__1;
         char v_rps__pos__2;
         char v_rps__pos__3;
         char v_rps__pos__4;
         char v_rps__pos__5;
         char v_rps__pos__6;
         char v_rps__pos__7;
         char v_rps__pos__8;
         char v_rps__pos__9;
        word v_rps__pos__10;
        word v_rps__pos__11;
        d_word v_rtb;				// rtab
        word v_rtb__pos__1;
         char v_rtb__pos__2;
         char v_rtb__pos__3;
         char v_rtb__pos__4;
         char v_rtb__pos__5;
         char v_rtb__pos__6;
         char v_rtb__pos__7;
         char v_rtb__pos__8;
         char v_rtb__pos__9;
        word v_rtb__pos__10;
        word v_rtb__pos__11;
        d_word v_si_;				// size
        word v_si___pos__1;
         char v_si___pos__2;
         char v_si___pos__3;
         char v_si___pos__4;
         char v_si___pos__5;
         char v_si___pos__6;
         char v_si___pos__7;
         char v_si___pos__8;
         char v_si___pos__9;
        word v_si___pos__10;
        word v_si___pos__11;
        d_word v_srt;				// sort
        word v_srt__pos__1;
         char v_srt__pos__2;
         char v_srt__pos__3;
         char v_srt__pos__4;
         char v_srt__pos__5;
         char v_srt__pos__6;
         char v_srt__pos__7;
         char v_srt__pos__8;
         char v_srt__pos__9;
        word v_srt__pos__10;
        word v_srt__pos__11;
        d_word v_spn;				// span
        word v_spn__pos__1;
         char v_spn__pos__2;
         char v_spn__pos__3;
         char v_spn__pos__4;
         char v_spn__pos__5;
         char v_spn__pos__6;
         char v_spn__pos__7;
         char v_spn__pos__8;
         char v_spn__pos__9;
        word v_spn__pos__10;
        word v_spn__pos__11;
        
//      standard variable blocks (continued)
        d_word v_sqr;				// sqrt
        word v_sqr__pos__1;
         char v_sqr__pos__2;
         char v_sqr__pos__3;
         char v_sqr__pos__4;
         char v_sqr__pos__5;
         char v_sqr__pos__6;
         char v_sqr__pos__7;
         char v_sqr__pos__8;
         char v_sqr__pos__9;
        word v_sqr__pos__10;
        word v_sqr__pos__11;
        d_word v_stn;				// stno
        word v_stn__pos__1;
         char v_stn__pos__2;
         char v_stn__pos__3;
         char v_stn__pos__4;
         char v_stn__pos__5;
         char v_stn__pos__6;
         char v_stn__pos__7;
         char v_stn__pos__8;
         char v_stn__pos__9;
        word v_stn__pos__10;
        d_word v_tim;				// time
        word v_tim__pos__1;
         char v_tim__pos__2;
         char v_tim__pos__3;
         char v_tim__pos__4;
         char v_tim__pos__5;
         char v_tim__pos__6;
         char v_tim__pos__7;
         char v_tim__pos__8;
         char v_tim__pos__9;
        word v_tim__pos__10;
        word v_tim__pos__11;
        d_word v_trm;				// trim
        word v_trm__pos__1;
         char v_trm__pos__2;
         char v_trm__pos__3;
         char v_trm__pos__4;
         char v_trm__pos__5;
         char v_trm__pos__6;
         char v_trm__pos__7;
         char v_trm__pos__8;
         char v_trm__pos__9;
        word v_trm__pos__10;
        word v_trm__pos__11;
        word v_trm__pos__12;
        d_word v_abe;				// abend
        word v_abe__pos__1;
         char v_abe__pos__2;
         char v_abe__pos__3;
         char v_abe__pos__4;
         char v_abe__pos__5;
         char v_abe__pos__6;
         char v_abe__pos__7;
         char v_abe__pos__8;
         char v_abe__pos__9;
        word v_abe__pos__10;
        d_word v_abo;				// abort
        word v_abo__pos__1;
         char v_abo__pos__2;
         char v_abo__pos__3;
         char v_abo__pos__4;
         char v_abo__pos__5;
         char v_abo__pos__6;
         char v_abo__pos__7;
         char v_abo__pos__8;
         char v_abo__pos__9;
        word v_abo__pos__10;
        word v_abo__pos__11;
        word v_abo__pos__12;
        d_word v_app;				// apply
        word v_app__pos__1;
         char v_app__pos__2;
         char v_app__pos__3;
         char v_app__pos__4;
         char v_app__pos__5;
         char v_app__pos__6;
         char v_app__pos__7;
         char v_app__pos__8;
         char v_app__pos__9;
        word v_app__pos__10;
        word v_app__pos__11;
        d_word v_abn;				// arbno
        word v_abn__pos__1;
         char v_abn__pos__2;
         char v_abn__pos__3;
         char v_abn__pos__4;
         char v_abn__pos__5;
         char v_abn__pos__6;
         char v_abn__pos__7;
         char v_abn__pos__8;
         char v_abn__pos__9;
        word v_abn__pos__10;
        word v_abn__pos__11;
        d_word v_arr;				// array
        word v_arr__pos__1;
         char v_arr__pos__2;
         char v_arr__pos__3;
         char v_arr__pos__4;
         char v_arr__pos__5;
         char v_arr__pos__6;
         char v_arr__pos__7;
         char v_arr__pos__8;
         char v_arr__pos__9;
        word v_arr__pos__10;
        word v_arr__pos__11;
        
//      standard variable blocks (continued)
        d_word v_brk;				// break
        word v_brk__pos__1;
         char v_brk__pos__2;
         char v_brk__pos__3;
         char v_brk__pos__4;
         char v_brk__pos__5;
         char v_brk__pos__6;
         char v_brk__pos__7;
         char v_brk__pos__8;
         char v_brk__pos__9;
        word v_brk__pos__10;
        word v_brk__pos__11;
        d_word v_clr;				// clear
        word v_clr__pos__1;
         char v_clr__pos__2;
         char v_clr__pos__3;
         char v_clr__pos__4;
         char v_clr__pos__5;
         char v_clr__pos__6;
         char v_clr__pos__7;
         char v_clr__pos__8;
         char v_clr__pos__9;
        word v_clr__pos__10;
        word v_clr__pos__11;
        d_word v_ejc;				// eject
        word v_ejc__pos__1;
         char v_ejc__pos__2;
         char v_ejc__pos__3;
         char v_ejc__pos__4;
         char v_ejc__pos__5;
         char v_ejc__pos__6;
         char v_ejc__pos__7;
         char v_ejc__pos__8;
         char v_ejc__pos__9;
        word v_ejc__pos__10;
        word v_ejc__pos__11;
        d_word v_fen;				// fence
        word v_fen__pos__1;
         char v_fen__pos__2;
         char v_fen__pos__3;
         char v_fen__pos__4;
         char v_fen__pos__5;
         char v_fen__pos__6;
         char v_fen__pos__7;
         char v_fen__pos__8;
         char v_fen__pos__9;
        word v_fen__pos__10;
        word v_fen__pos__11;
        word v_fen__pos__12;
        word v_fen__pos__13;
        d_word v_fld;				// field
        word v_fld__pos__1;
         char v_fld__pos__2;
         char v_fld__pos__3;
         char v_fld__pos__4;
         char v_fld__pos__5;
         char v_fld__pos__6;
         char v_fld__pos__7;
         char v_fld__pos__8;
         char v_fld__pos__9;
        word v_fld__pos__10;
        word v_fld__pos__11;
        d_word v_idn;				// ident
        word v_idn__pos__1;
         char v_idn__pos__2;
         char v_idn__pos__3;
         char v_idn__pos__4;
         char v_idn__pos__5;
         char v_idn__pos__6;
         char v_idn__pos__7;
         char v_idn__pos__8;
         char v_idn__pos__9;
        word v_idn__pos__10;
        word v_idn__pos__11;
        d_word v_inp;				// input
        word v_inp__pos__1;
         char v_inp__pos__2;
         char v_inp__pos__3;
         char v_inp__pos__4;
         char v_inp__pos__5;
         char v_inp__pos__6;
         char v_inp__pos__7;
         char v_inp__pos__8;
         char v_inp__pos__9;
        word v_inp__pos__10;
        word v_inp__pos__11;
        word v_inp__pos__12;
        d_word v_lcs;				// lcase
        word v_lcs__pos__1;
         char v_lcs__pos__2;
         char v_lcs__pos__3;
         char v_lcs__pos__4;
         char v_lcs__pos__5;
         char v_lcs__pos__6;
         char v_lcs__pos__7;
         char v_lcs__pos__8;
         char v_lcs__pos__9;
        word v_lcs__pos__10;
        d_word v_loc;				// local
        word v_loc__pos__1;
         char v_loc__pos__2;
         char v_loc__pos__3;
         char v_loc__pos__4;
         char v_loc__pos__5;
         char v_loc__pos__6;
         char v_loc__pos__7;
         char v_loc__pos__8;
         char v_loc__pos__9;
        word v_loc__pos__10;
        word v_loc__pos__11;
        
//      standard variable blocks (continued)
        d_word v_ops;				// opsyn
        word v_ops__pos__1;
         char v_ops__pos__2;
         char v_ops__pos__3;
         char v_ops__pos__4;
         char v_ops__pos__5;
         char v_ops__pos__6;
         char v_ops__pos__7;
         char v_ops__pos__8;
         char v_ops__pos__9;
        word v_ops__pos__10;
        word v_ops__pos__11;
        d_word v_rmd;				// remdr
        word v_rmd__pos__1;
         char v_rmd__pos__2;
         char v_rmd__pos__3;
         char v_rmd__pos__4;
         char v_rmd__pos__5;
         char v_rmd__pos__6;
         char v_rmd__pos__7;
         char v_rmd__pos__8;
         char v_rmd__pos__9;
        word v_rmd__pos__10;
        word v_rmd__pos__11;
        d_word v_rsr;				// rsort
        word v_rsr__pos__1;
         char v_rsr__pos__2;
         char v_rsr__pos__3;
         char v_rsr__pos__4;
         char v_rsr__pos__5;
         char v_rsr__pos__6;
         char v_rsr__pos__7;
         char v_rsr__pos__8;
         char v_rsr__pos__9;
        word v_rsr__pos__10;
        word v_rsr__pos__11;
        d_word v_tbl;				// table
        word v_tbl__pos__1;
         char v_tbl__pos__2;
         char v_tbl__pos__3;
         char v_tbl__pos__4;
         char v_tbl__pos__5;
         char v_tbl__pos__6;
         char v_tbl__pos__7;
         char v_tbl__pos__8;
         char v_tbl__pos__9;
        word v_tbl__pos__10;
        word v_tbl__pos__11;
        d_word v_tra;				// trace
        word v_tra__pos__1;
         char v_tra__pos__2;
         char v_tra__pos__3;
         char v_tra__pos__4;
         char v_tra__pos__5;
         char v_tra__pos__6;
         char v_tra__pos__7;
         char v_tra__pos__8;
         char v_tra__pos__9;
        word v_tra__pos__10;
        word v_tra__pos__11;
        word v_tra__pos__12;
        d_word v_ucs;				// ucase
        word v_ucs__pos__1;
         char v_ucs__pos__2;
         char v_ucs__pos__3;
         char v_ucs__pos__4;
         char v_ucs__pos__5;
         char v_ucs__pos__6;
         char v_ucs__pos__7;
         char v_ucs__pos__8;
         char v_ucs__pos__9;
        word v_ucs__pos__10;
        d_word v_anc;				// anchor
        word v_anc__pos__1;
         char v_anc__pos__2;
         char v_anc__pos__3;
         char v_anc__pos__4;
         char v_anc__pos__5;
         char v_anc__pos__6;
         char v_anc__pos__7;
         char v_anc__pos__8;
         char v_anc__pos__9;
        word v_anc__pos__10;
        d_word v_bkx;				// breakx
        word v_bkx__pos__1;
         char v_bkx__pos__2;
         char v_bkx__pos__3;
         char v_bkx__pos__4;
         char v_bkx__pos__5;
         char v_bkx__pos__6;
         char v_bkx__pos__7;
         char v_bkx__pos__8;
         char v_bkx__pos__9;
        word v_bkx__pos__10;
        word v_bkx__pos__11;
        d_word v_def;				// define
        word v_def__pos__1;
         char v_def__pos__2;
         char v_def__pos__3;
         char v_def__pos__4;
         char v_def__pos__5;
         char v_def__pos__6;
         char v_def__pos__7;
         char v_def__pos__8;
         char v_def__pos__9;
        word v_def__pos__10;
        word v_def__pos__11;
        d_word v_det;				// detach
        word v_det__pos__1;
         char v_det__pos__2;
         char v_det__pos__3;
         char v_det__pos__4;
         char v_det__pos__5;
         char v_det__pos__6;
         char v_det__pos__7;
         char v_det__pos__8;
         char v_det__pos__9;
        word v_det__pos__10;
        word v_det__pos__11;
        
//      standard variable blocks (continued)
        d_word v_dif;				// differ
        word v_dif__pos__1;
         char v_dif__pos__2;
         char v_dif__pos__3;
         char v_dif__pos__4;
         char v_dif__pos__5;
         char v_dif__pos__6;
         char v_dif__pos__7;
         char v_dif__pos__8;
         char v_dif__pos__9;
        word v_dif__pos__10;
        word v_dif__pos__11;
        d_word v_ftr;				// ftrace
        word v_ftr__pos__1;
         char v_ftr__pos__2;
         char v_ftr__pos__3;
         char v_ftr__pos__4;
         char v_ftr__pos__5;
         char v_ftr__pos__6;
         char v_ftr__pos__7;
         char v_ftr__pos__8;
         char v_ftr__pos__9;
        word v_ftr__pos__10;
        d_word v_lst;				// lastno
        word v_lst__pos__1;
         char v_lst__pos__2;
         char v_lst__pos__3;
         char v_lst__pos__4;
         char v_lst__pos__5;
         char v_lst__pos__6;
         char v_lst__pos__7;
         char v_lst__pos__8;
         char v_lst__pos__9;
        word v_lst__pos__10;
        d_word v_nay;				// notany
        word v_nay__pos__1;
         char v_nay__pos__2;
         char v_nay__pos__3;
         char v_nay__pos__4;
         char v_nay__pos__5;
         char v_nay__pos__6;
         char v_nay__pos__7;
         char v_nay__pos__8;
         char v_nay__pos__9;
        word v_nay__pos__10;
        word v_nay__pos__11;
        d_word v_oup;				// output
        word v_oup__pos__1;
         char v_oup__pos__2;
         char v_oup__pos__3;
         char v_oup__pos__4;
         char v_oup__pos__5;
         char v_oup__pos__6;
         char v_oup__pos__7;
         char v_oup__pos__8;
         char v_oup__pos__9;
        word v_oup__pos__10;
        word v_oup__pos__11;
        word v_oup__pos__12;
        d_word v_ret;				// return
        word v_ret__pos__1;
         char v_ret__pos__2;
         char v_ret__pos__3;
         char v_ret__pos__4;
         char v_ret__pos__5;
         char v_ret__pos__6;
         char v_ret__pos__7;
         char v_ret__pos__8;
         char v_ret__pos__9;
        word v_ret__pos__10;
        d_word v_rew;				// rewind
        word v_rew__pos__1;
         char v_rew__pos__2;
         char v_rew__pos__3;
         char v_rew__pos__4;
         char v_rew__pos__5;
         char v_rew__pos__6;
         char v_rew__pos__7;
         char v_rew__pos__8;
         char v_rew__pos__9;
        word v_rew__pos__10;
        word v_rew__pos__11;
        d_word v_stt;				// stoptr
        word v_stt__pos__1;
         char v_stt__pos__2;
         char v_stt__pos__3;
         char v_stt__pos__4;
         char v_stt__pos__5;
         char v_stt__pos__6;
         char v_stt__pos__7;
         char v_stt__pos__8;
         char v_stt__pos__9;
        word v_stt__pos__10;
        word v_stt__pos__11;
        
//      standard variable blocks (continued)
        d_word v_sub;				// substr
        word v_sub__pos__1;
         char v_sub__pos__2;
         char v_sub__pos__3;
         char v_sub__pos__4;
         char v_sub__pos__5;
         char v_sub__pos__6;
         char v_sub__pos__7;
         char v_sub__pos__8;
         char v_sub__pos__9;
        word v_sub__pos__10;
        word v_sub__pos__11;
        d_word v_unl;				// unload
        word v_unl__pos__1;
         char v_unl__pos__2;
         char v_unl__pos__3;
         char v_unl__pos__4;
         char v_unl__pos__5;
         char v_unl__pos__6;
         char v_unl__pos__7;
         char v_unl__pos__8;
         char v_unl__pos__9;
        word v_unl__pos__10;
        word v_unl__pos__11;
        d_word v_col;				// collect
        word v_col__pos__1;
         char v_col__pos__2;
         char v_col__pos__3;
         char v_col__pos__4;
         char v_col__pos__5;
         char v_col__pos__6;
         char v_col__pos__7;
         char v_col__pos__8;
         char v_col__pos__9;
        word v_col__pos__10;
        word v_col__pos__11;
        d_word v_com;				// compare
        word v_com__pos__1;
         char v_com__pos__2;
         char v_com__pos__3;
         char v_com__pos__4;
         char v_com__pos__5;
         char v_com__pos__6;
         char v_com__pos__7;
         char v_com__pos__8;
         char v_com__pos__9;
        word v_com__pos__10;
        d_word v_cnv;				// convert
        word v_cnv__pos__1;
         char v_cnv__pos__2;
         char v_cnv__pos__3;
         char v_cnv__pos__4;
         char v_cnv__pos__5;
         char v_cnv__pos__6;
         char v_cnv__pos__7;
         char v_cnv__pos__8;
         char v_cnv__pos__9;
        word v_cnv__pos__10;
        word v_cnv__pos__11;
        d_word v_enf;				// endfile
        word v_enf__pos__1;
         char v_enf__pos__2;
         char v_enf__pos__3;
         char v_enf__pos__4;
         char v_enf__pos__5;
         char v_enf__pos__6;
         char v_enf__pos__7;
         char v_enf__pos__8;
         char v_enf__pos__9;
        word v_enf__pos__10;
        word v_enf__pos__11;
        d_word v_etx;				// errtext
        word v_etx__pos__1;
         char v_etx__pos__2;
         char v_etx__pos__3;
         char v_etx__pos__4;
         char v_etx__pos__5;
         char v_etx__pos__6;
         char v_etx__pos__7;
         char v_etx__pos__8;
         char v_etx__pos__9;
        word v_etx__pos__10;
        d_word v_ert;				// errtype
        word v_ert__pos__1;
         char v_ert__pos__2;
         char v_ert__pos__3;
         char v_ert__pos__4;
         char v_ert__pos__5;
         char v_ert__pos__6;
         char v_ert__pos__7;
         char v_ert__pos__8;
         char v_ert__pos__9;
        word v_ert__pos__10;
        d_word v_frt;				// freturn
        word v_frt__pos__1;
         char v_frt__pos__2;
         char v_frt__pos__3;
         char v_frt__pos__4;
         char v_frt__pos__5;
         char v_frt__pos__6;
         char v_frt__pos__7;
         char v_frt__pos__8;
         char v_frt__pos__9;
        word v_frt__pos__10;
        d_word v_int;				// integer
        word v_int__pos__1;
         char v_int__pos__2;
         char v_int__pos__3;
         char v_int__pos__4;
         char v_int__pos__5;
         char v_int__pos__6;
         char v_int__pos__7;
         char v_int__pos__8;
         char v_int__pos__9;
        word v_int__pos__10;
        word v_int__pos__11;
        d_word v_nrt;				// nreturn
        word v_nrt__pos__1;
         char v_nrt__pos__2;
         char v_nrt__pos__3;
         char v_nrt__pos__4;
         char v_nrt__pos__5;
         char v_nrt__pos__6;
         char v_nrt__pos__7;
         char v_nrt__pos__8;
         char v_nrt__pos__9;
        word v_nrt__pos__10;
        
//      standard variable blocks (continued)
        d_word v_pfl;				// profile
        word v_pfl__pos__1;
         char v_pfl__pos__2;
         char v_pfl__pos__3;
         char v_pfl__pos__4;
         char v_pfl__pos__5;
         char v_pfl__pos__6;
         char v_pfl__pos__7;
         char v_pfl__pos__8;
         char v_pfl__pos__9;
        word v_pfl__pos__10;
        d_word v_rpl;				// replace
        word v_rpl__pos__1;
         char v_rpl__pos__2;
         char v_rpl__pos__3;
         char v_rpl__pos__4;
         char v_rpl__pos__5;
         char v_rpl__pos__6;
         char v_rpl__pos__7;
         char v_rpl__pos__8;
         char v_rpl__pos__9;
        word v_rpl__pos__10;
        word v_rpl__pos__11;
        d_word v_rvs;				// reverse
        word v_rvs__pos__1;
         char v_rvs__pos__2;
         char v_rvs__pos__3;
         char v_rvs__pos__4;
         char v_rvs__pos__5;
         char v_rvs__pos__6;
         char v_rvs__pos__7;
         char v_rvs__pos__8;
         char v_rvs__pos__9;
        word v_rvs__pos__10;
        word v_rvs__pos__11;
        d_word v_rtn;				// rtntype
        word v_rtn__pos__1;
         char v_rtn__pos__2;
         char v_rtn__pos__3;
         char v_rtn__pos__4;
         char v_rtn__pos__5;
         char v_rtn__pos__6;
         char v_rtn__pos__7;
         char v_rtn__pos__8;
         char v_rtn__pos__9;
        word v_rtn__pos__10;
        d_word v_stx;				// setexit
        word v_stx__pos__1;
         char v_stx__pos__2;
         char v_stx__pos__3;
         char v_stx__pos__4;
         char v_stx__pos__5;
         char v_stx__pos__6;
         char v_stx__pos__7;
         char v_stx__pos__8;
         char v_stx__pos__9;
        word v_stx__pos__10;
        word v_stx__pos__11;
        d_word v_stc;				// stcount
        word v_stc__pos__1;
         char v_stc__pos__2;
         char v_stc__pos__3;
         char v_stc__pos__4;
         char v_stc__pos__5;
         char v_stc__pos__6;
         char v_stc__pos__7;
         char v_stc__pos__8;
         char v_stc__pos__9;
        word v_stc__pos__10;
        d_word v_stl;				// stlimit
        word v_stl__pos__1;
         char v_stl__pos__2;
         char v_stl__pos__3;
         char v_stl__pos__4;
         char v_stl__pos__5;
         char v_stl__pos__6;
         char v_stl__pos__7;
         char v_stl__pos__8;
         char v_stl__pos__9;
        word v_stl__pos__10;
        d_word v_suc;				// succeed
        word v_suc__pos__1;
         char v_suc__pos__2;
         char v_suc__pos__3;
         char v_suc__pos__4;
         char v_suc__pos__5;
         char v_suc__pos__6;
         char v_suc__pos__7;
         char v_suc__pos__8;
         char v_suc__pos__9;
        word v_suc__pos__10;
        word v_suc__pos__11;
        d_word v_alp;				// alphabet
        word v_alp__pos__1;
         char v_alp__pos__2;
         char v_alp__pos__3;
         char v_alp__pos__4;
         char v_alp__pos__5;
         char v_alp__pos__6;
         char v_alp__pos__7;
         char v_alp__pos__8;
         char v_alp__pos__9;
         char v_alp__pos__10;
         char v_alp__pos__11;
         char v_alp__pos__12;
         char v_alp__pos__13;
         char v_alp__pos__14;
         char v_alp__pos__15;
         char v_alp__pos__16;
         char v_alp__pos__17;
        word v_alp__pos__18;
        d_word v_cnt;				// continue
        word v_cnt__pos__1;
         char v_cnt__pos__2;
         char v_cnt__pos__3;
         char v_cnt__pos__4;
         char v_cnt__pos__5;
         char v_cnt__pos__6;
         char v_cnt__pos__7;
         char v_cnt__pos__8;
         char v_cnt__pos__9;
         char v_cnt__pos__10;
         char v_cnt__pos__11;
         char v_cnt__pos__12;
         char v_cnt__pos__13;
         char v_cnt__pos__14;
         char v_cnt__pos__15;
         char v_cnt__pos__16;
         char v_cnt__pos__17;
        word v_cnt__pos__18;
        
//      standard variable blocks (continued)
        d_word v_dtp;				// datatype
        word v_dtp__pos__1;
         char v_dtp__pos__2;
         char v_dtp__pos__3;
         char v_dtp__pos__4;
         char v_dtp__pos__5;
         char v_dtp__pos__6;
         char v_dtp__pos__7;
         char v_dtp__pos__8;
         char v_dtp__pos__9;
         char v_dtp__pos__10;
         char v_dtp__pos__11;
         char v_dtp__pos__12;
         char v_dtp__pos__13;
         char v_dtp__pos__14;
         char v_dtp__pos__15;
         char v_dtp__pos__16;
         char v_dtp__pos__17;
        word v_dtp__pos__18;
        word v_dtp__pos__19;
        d_word v_erl;				// errlimit
        word v_erl__pos__1;
         char v_erl__pos__2;
         char v_erl__pos__3;
         char v_erl__pos__4;
         char v_erl__pos__5;
         char v_erl__pos__6;
         char v_erl__pos__7;
         char v_erl__pos__8;
         char v_erl__pos__9;
         char v_erl__pos__10;
         char v_erl__pos__11;
         char v_erl__pos__12;
         char v_erl__pos__13;
         char v_erl__pos__14;
         char v_erl__pos__15;
         char v_erl__pos__16;
         char v_erl__pos__17;
        word v_erl__pos__18;
        d_word v_fnc;				// fnclevel
        word v_fnc__pos__1;
         char v_fnc__pos__2;
         char v_fnc__pos__3;
         char v_fnc__pos__4;
         char v_fnc__pos__5;
         char v_fnc__pos__6;
         char v_fnc__pos__7;
         char v_fnc__pos__8;
         char v_fnc__pos__9;
         char v_fnc__pos__10;
         char v_fnc__pos__11;
         char v_fnc__pos__12;
         char v_fnc__pos__13;
         char v_fnc__pos__14;
         char v_fnc__pos__15;
         char v_fnc__pos__16;
         char v_fnc__pos__17;
        word v_fnc__pos__18;
        d_word v_fls;				// fullscan
        word v_fls__pos__1;
         char v_fls__pos__2;
         char v_fls__pos__3;
         char v_fls__pos__4;
         char v_fls__pos__5;
         char v_fls__pos__6;
         char v_fls__pos__7;
         char v_fls__pos__8;
         char v_fls__pos__9;
         char v_fls__pos__10;
         char v_fls__pos__11;
         char v_fls__pos__12;
         char v_fls__pos__13;
         char v_fls__pos__14;
         char v_fls__pos__15;
         char v_fls__pos__16;
         char v_fls__pos__17;
        word v_fls__pos__18;
        d_word v_lfl;				// lastfile
        word v_lfl__pos__1;
         char v_lfl__pos__2;
         char v_lfl__pos__3;
         char v_lfl__pos__4;
         char v_lfl__pos__5;
         char v_lfl__pos__6;
         char v_lfl__pos__7;
         char v_lfl__pos__8;
         char v_lfl__pos__9;
         char v_lfl__pos__10;
         char v_lfl__pos__11;
         char v_lfl__pos__12;
         char v_lfl__pos__13;
         char v_lfl__pos__14;
         char v_lfl__pos__15;
         char v_lfl__pos__16;
         char v_lfl__pos__17;
        word v_lfl__pos__18;
        d_word v_lln;				// lastline
        word v_lln__pos__1;
         char v_lln__pos__2;
         char v_lln__pos__3;
         char v_lln__pos__4;
         char v_lln__pos__5;
         char v_lln__pos__6;
         char v_lln__pos__7;
         char v_lln__pos__8;
         char v_lln__pos__9;
         char v_lln__pos__10;
         char v_lln__pos__11;
         char v_lln__pos__12;
         char v_lln__pos__13;
         char v_lln__pos__14;
         char v_lln__pos__15;
         char v_lln__pos__16;
         char v_lln__pos__17;
        word v_lln__pos__18;
        d_word v_mxl;				// maxlngth
        word v_mxl__pos__1;
         char v_mxl__pos__2;
         char v_mxl__pos__3;
         char v_mxl__pos__4;
         char v_mxl__pos__5;
         char v_mxl__pos__6;
         char v_mxl__pos__7;
         char v_mxl__pos__8;
         char v_mxl__pos__9;
         char v_mxl__pos__10;
         char v_mxl__pos__11;
         char v_mxl__pos__12;
         char v_mxl__pos__13;
         char v_mxl__pos__14;
         char v_mxl__pos__15;
         char v_mxl__pos__16;
         char v_mxl__pos__17;
        word v_mxl__pos__18;
        d_word v_ter;				// terminal
        word v_ter__pos__1;
         char v_ter__pos__2;
         char v_ter__pos__3;
         char v_ter__pos__4;
         char v_ter__pos__5;
         char v_ter__pos__6;
         char v_ter__pos__7;
         char v_ter__pos__8;
         char v_ter__pos__9;
         char v_ter__pos__10;
         char v_ter__pos__11;
         char v_ter__pos__12;
         char v_ter__pos__13;
         char v_ter__pos__14;
         char v_ter__pos__15;
         char v_ter__pos__16;
         char v_ter__pos__17;
        word v_ter__pos__18;
        d_word v_bsp;				// backspace
        word v_bsp__pos__1;
         char v_bsp__pos__2;
         char v_bsp__pos__3;
         char v_bsp__pos__4;
         char v_bsp__pos__5;
         char v_bsp__pos__6;
         char v_bsp__pos__7;
         char v_bsp__pos__8;
         char v_bsp__pos__9;
         char v_bsp__pos__10;
         char v_bsp__pos__11;
         char v_bsp__pos__12;
         char v_bsp__pos__13;
         char v_bsp__pos__14;
         char v_bsp__pos__15;
         char v_bsp__pos__16;
         char v_bsp__pos__17;
        word v_bsp__pos__18;
        word v_bsp__pos__19;
        d_word v_pro;				// prototype
        word v_pro__pos__1;
         char v_pro__pos__2;
         char v_pro__pos__3;
         char v_pro__pos__4;
         char v_pro__pos__5;
         char v_pro__pos__6;
         char v_pro__pos__7;
         char v_pro__pos__8;
         char v_pro__pos__9;
         char v_pro__pos__10;
         char v_pro__pos__11;
         char v_pro__pos__12;
         char v_pro__pos__13;
         char v_pro__pos__14;
         char v_pro__pos__15;
         char v_pro__pos__16;
         char v_pro__pos__17;
        word v_pro__pos__18;
        word v_pro__pos__19;
        d_word v_scn;				// scontinue
        word v_scn__pos__1;
         char v_scn__pos__2;
         char v_scn__pos__3;
         char v_scn__pos__4;
         char v_scn__pos__5;
         char v_scn__pos__6;
         char v_scn__pos__7;
         char v_scn__pos__8;
         char v_scn__pos__9;
         char v_scn__pos__10;
         char v_scn__pos__11;
         char v_scn__pos__12;
         char v_scn__pos__13;
         char v_scn__pos__14;
         char v_scn__pos__15;
         char v_scn__pos__16;
         char v_scn__pos__17;
        word v_scn__pos__18;
        d_word v_scn__pos__19;				// dummy entry to end list
        word v_scn__pos__20;				// length gt 9 (scontinue)
        
//      list of svblk pointers for keywords to be dumped. the
//      list is in the order which appears on the dump output.
        word vdmkw;				// anchor
        word vdmkw__pos__1;				// code
        word vdmkw__pos__2;				// compare not printed
        word vdmkw__pos__3;				// dump
        word vdmkw__pos__4;				// errlimit
        word vdmkw__pos__5;				// errtext
        word vdmkw__pos__6;				// errtype
        word vdmkw__pos__7;				// file
        word vdmkw__pos__8;				// fnclevel
        word vdmkw__pos__9;				// ftrace
        word vdmkw__pos__10;				// fullscan
        word vdmkw__pos__11;				// input
        word vdmkw__pos__12;				// lastfile
        word vdmkw__pos__13;				// lastline
        word vdmkw__pos__14;				// lastno
        word vdmkw__pos__15;				// line
        word vdmkw__pos__16;				// maxlength
        word vdmkw__pos__17;				// output
        word vdmkw__pos__18;				// profile
        word vdmkw__pos__19;				// rtntype
        word vdmkw__pos__20;				// stcount
        word vdmkw__pos__21;				// stlimit
        word vdmkw__pos__22;				// stno
        word vdmkw__pos__23;				// trace
        word vdmkw__pos__24;				// trim
        word vdmkw__pos__25;				// end of list
//      table used by gtnvr to search svblk lists
        word vsrch;				// dummy entry to get proper indexing
        word vsrch__pos__1;				// start of 1 char variables (none)
        word vsrch__pos__2;				// start of 2 char variables
        word vsrch__pos__3;				// start of 3 char variables
        word vsrch__pos__4;				// start of 4 char variables
        word vsrch__pos__5;				// start of 5 char variables
        word vsrch__pos__6;				// start of 6 char variables
        word vsrch__pos__7;				// start of 7 char variables
        word vsrch__pos__8;				// start of 8 char variables
        word vsrch__pos__9;				// start of 9 char variables
//      last location in constant section
        word c_yyy;				// last location in constant section
//      the working storage section contains areas which are
//      changed during execution of the program. the value
//      assembled is the initial value before execution starts.
//      all these areas are fixed length areas. variable length
//      data is stored in the static or dynamic regions of the
//      allocated data areas.
//      the values in this area are described either as work
//      areas or as global values. a work area is used in an
//      ephemeral manner and the value is not saved from one
//      entry into a routine to another. a global value is a
//      less temporary location whose value is saved from one
//      call to another.
//      w_aaa marks the start of the working section whilst
//      w_yyy marks its end.  g_aaa marks the division between
//      temporary and global values.
//      global values are further subdivided to facilitate
//      processing by the garbage collector. r_aaa through
//      r_yyy are global values that may point into dynamic
//      storage and hence must be relocated after each garbage
//      collection.  they also serve as root pointers to all
//      allocated data that must be preserved.  pointers between
//      a_aaa and r_aaa may point into code, static storage,
//      or mark the limits of dynamic memory.  these pointers
//      must be adjusted when the working section is saved to a
//      file and subsequently reloaded at a different address.
//      a general part of the approach in this program is not
//      to overlap work areas between procedures even though a
//      small amount of space could be saved. such overlap is
//      considered a source of program errors and decreases the
//      information left behind after a system crash of any kind.
//      the names of these locations are labels with five letter
//      (a-y,_) names. as far as possible the order is kept
//      alphabetical by these names but in some cases there
//      are slight departures caused by other order requirements.
//      unless otherwise documented, the order of work areas
//      does not affect the execution of the spitbol program.
        }; /* struct spitbol_constants */ 				// start of working storage section
        struct spitbol_variables {
        
//      this area is not cleared by initial code
        word cmlab;				// string used to check label legality
        word cmlab__pos__1;
         char cmlab__pos__2;
         char cmlab__pos__3;
         char cmlab__pos__4;
         char cmlab__pos__5;
         char cmlab__pos__6;
         char cmlab__pos__7;
         char cmlab__pos__8;
         char cmlab__pos__9;
//      label to mark start of work area
        word w_aaa;
//      work areas for acess procedure
        word actrm;				// trim indicator
//      work areas for alloc procedure
        word aldyn;				// amount of dynamic store
        word allia;				// dump ia
        word allsv;				// save wb in alloc
//      work areas for alost procedure
        word alsta;				// save wa in alost
//      work areas for array function (s_arr)
        word arcdm;				// count dimensions
        word arnel;				// count elements
        word arptr;				// offset ptr into arblk
        word arsvl;				// save integer low bound
        
//      work areas for arref routine
        word arfsi;				// save current evolving subscript
        word arfxs;				// save base stack pointer
//      work areas for b_efc block routine
        word befof;				// save offset ptr into efblk
//      work areas for b_pfc block routine
        word bpfpf;				// save pfblk pointer
        word bpfsv;				// save old function value
        word bpfxt;				// pointer to stacked arguments
//      work area for collect function (s_col)
        word clsvi;				// save integer argument
//      work areas value for cncrd
        word cnscc;				// pointer to control card string
        word cnswc;				// word count
        word cnr_t;				// pointer to r_ttl or r_stl
//      work areas for convert function (s_cnv)
        word cnvtp;				// save ptr into scvtb
//      work areas for data function (s_dat)
        word datdv;				// save vrblk ptr for datatype name
        word datxs;				// save initial stack pointer
//      work areas for define function (s_def)
        word deflb;				// save vrblk ptr for label
        word defna;				// count function arguments
        word defvr;				// save vrblk ptr for function name
        word defxs;				// save initial stack pointer
//      work areas for dumpr procedure
        word dmarg;				// dump argument
        word dmpsa;				// preserve wa over prtvl call
        word dmpsb;				// preserve wb over syscm call
        word dmpsv;				// general scratch save
        word dmvch;				// chain pointer for variable blocks
        word dmpch;				// save sorted vrblk chain pointer
        word dmpkb;				// dummy kvblk for use in dumpr
        word dmpkt;				// kvvar trblk ptr (must follow dmpkb)
        word dmpkn;				// keyword number (must follow dmpkt)
//      work area for dtach
        word dtcnb;				// name base
        word dtcnm;				// name ptr
//      work areas for dupl function (s_dup)
        word dupsi;				// store integer string length
//      work area for endfile (s_enf)
        word enfch;				// for iochn chain head
        
//      work areas for ertex
        word ertwa;				// save wa
        word ertwb;				// save wb
//      work areas for evali
        word evlin;				// dummy pattern block pcode
        word evlis;				// then node (must follow evlin)
        word evliv;				// value of parm1 (must follow evlis)
        word evlio;				// ptr to original node
        word evlif;				// flag for simple/complex argument
//      work area for expan
        word expsv;				// save op dope vector pointer
//      work areas for gbcol procedure
        word gbcfl;				// garbage collector active flag
        word gbclm;				// pointer to last move block (pass 3)
        word gbcnm;				// dummy first move block
        word gbcns;				// rest of dummy block (follows gbcnm)
        word gbcia;				// dump ia
        word gbcsd;				// first address beyond sediment
        word gbcsf;				// free space within sediment
        word gbsva;				// save wa
        word gbsvb;				// save wb
        word gbsvc;				// save wc
//      work areas for gtnvr procedure
        word gnvhe;				// ptr to end of hash chain
        word gnvnw;				// number of words in string name
        word gnvsa;				// save wa
        word gnvsb;				// save wb
        word gnvsp;				// pointer into vsrch table
        word gnvst;				// pointer to chars of string
//      work areas for gtarr
        word gtawa;				// save wa
//      work areas for gtint
        word gtina;				// save wa
        word gtinb;				// save wb
        
//      work areas for gtnum procedure
        word gtnnf;				// zero/nonzero for result +/-
        word gtnsi;				// general integer save
        word gtndf;				// 0/1 for dec point so far no/yes
        word gtnes;				// zero/nonzero exponent +/-
        word gtnex;				// real exponent
        word gtnsc;				// scale (places after point)
        double gtnsr;				// general real save
        word gtnrd;				// flag for ok real number
//      work areas for gtpat procedure
        word gtpsb;				// save wb
//      work areas for gtstg procedure
        word gtssf;				// 0/1 for result +/-
        word gtsvc;				// save wc
        word gtsvb;				// save wb
        word gtses;				// char + or - for exponent +/-
        double gtsrs;				// general real save
//      work areas for gtvar procedure
        word gtvrc;				// save wc
//      work areas for ioput
        word ioptt;				// type of association
//      work areas for load function
        word lodfn;				// pointer to vrblk for func name
        word lodna;				// count number of arguments
//      mxint is value of maximum positive integer. it is computed at runtime to allow
//      the compilation of spitbol on a machine with smaller word size the the target.
        word mxint;
//      work area for profiler
        word pfsvw;				// to save a w-reg
//      work areas for prtnm procedure
        word prnsi;				// scratch integer loc
//      work areas for prtsn procedure
        word prsna;				// save wa
//      work areas for prtst procedure
        word prsva;				// save wa
        word prsvb;				// save wb
        word prsvc;				// save char counter
//      work area for prtnl
        word prtsa;				// save wa
        word prtsb;				// save wb
//      work area for prtvl
        word prvsi;				// save idval
//      work areas for pattern match routines
        word psave;				// temporary save for current node ptr
        word psavc;				// save cursor in p_spn, p_str
//      work area for relaj routine
        word rlals;				// ptr to list of bounds and adjusts
//      work area for reldn routine
        word rldcd;				// save code adjustment
        word rldst;				// save static adjustment
        word rldls;				// save list pointer
//      work areas for retrn routine
        word rtnbp;				// to save a block pointer
        word rtnfv;				// new function value (result)
        word rtnsv;				// old function value (saved value)
//      work areas for substr function (s_sub)
        word sbssv;				// save third argument
//      work areas for scan procedure
        word scnsa;				// save wa
        word scnsb;				// save wb
        word scnsc;				// save wc
        word scnof;				// save offset
        
//      work area used by sorta, sortc, sortf, sorth
        word srtdf;				// datatype field name
        word srtfd;				// found dfblk address
        word srtff;				// found field name
        word srtfo;				// offset to field name
        word srtnr;				// number of rows
        word srtof;				// offset within row to sort key
        word srtrt;				// root offset
        word srts1;				// save offset 1
        word srts2;				// save offset 2
        word srtsc;				// save wc
        word srtsf;				// sort array first row offset
        word srtsn;				// save n
        word srtso;				// offset to a(0)
        word srtsr;				// 0, non-zero for sort, rsort
        word srtst;				// stride from one row to next
        word srtwc;				// dump wc
//      work areas for stopr routine
        word stpsi;				// save value of stcount
        word stpti;				// save time elapsed
//      work areas for tfind procedure
        word tfnsi;				// number of headers
//      work areas for xscan procedure
        word xscrt;				// save return code
        word xscwb;				// save register wb
//      start of global values in working section
        word g_aaa;
//      global value for alloc procedure
        word alfsf;				// factor in free store pcntage check
//      global values for cmpil procedure
        word cmerc;				// count of initial compile errors
        word cmpln;				// line number of first line of stmt
        word cmpxs;				// save stack ptr in case of errors
        word cmpsn;				// number of next statement to compile
//      global values for cncrd
        word cnsil;				// save scnil during include process.
        word cnind;				// current include file nest level
        word cnspt;				// save scnpt during include process.
        word cnttl;				// flag for -title, -stitl
//      global flag for suppression of compilation statistics.
        word cpsts;				// suppress comp. stats if non zero
//      global values for control card switches
        word cswdb;				// 0/1 for -single/-double
        word cswer;				// 0/1 for -errors/-noerrors
        word cswex;				// 0/1 for -execute/-noexecute
        word cswfl;				// 0/1 for -nofail/-fail
        word cswin;				// xxx for -inxxx
        word cswls;				// 0/1 for -nolist/-list
        word cswno;				// 0/1 for -optimise/-noopt
        word cswpr;				// 0/1 for -noprint/-print
//      global location used by patst procedure
        d_word ctmsk;				// last bit position used in r_ctp
        word curid;				// current id value
        
//      global value for cdwrd procedure
        word cwcof;				// next word offset in current ccblk
//      global locations for dynamic storage pointers
        word dnams;				// size of sediment in baus
//      global area for error processing.
        word erich;				// copy error reports to int.chan if 1
        word erlst;				// for listr when errors go to int.ch.
        word errft;				// fatal error flag
        word errsp;				// error suppression flag
//      global flag for suppression of execution stats
        word exsts;				// suppress exec stats if set
//      global values for exfal and return
        word flprt;				// location of fail offset for return
        word flptr;				// location of failure offset on stack
//      global location to count garbage collections (gbcol)
        word gbsed;				// factor in sediment pcntage check
        word gbcnt;				// count of garbage collections
//      global value for gtcod and gtexp
        word gtcef;				// save fail ptr in case of error
//      global locations for gtstg procedure
        double gtsrn;				// rounding factor 0.5*10**-cfp_s
        double gtssc;				// scaling value 10**cfp_s
        word gtswk;				// ptr to work area for gtstg
//      global flag for header printing
        word headp;				// header printed flag
//      global values for variable hash table
        word hshnb;				// number of hash buckets
//      global areas for init
        word initr;				// save terminal flag
        
//      global values for keyword values which are stored as one
//      word integers. these values must be assembled in the
//      following order (as dictated by k_xxx definition values).
        word kvabe;				// abend
        word kvanc;				// anchor
        word kvcod;				// code
        word kvcom;				// compare
        word kvdmp;				// dump
        word kverl;				// errlimit
        word kvert;				// errtype
        word kvftr;				// ftrace
        word kvfls;				// fullscan
        word kvinp;				// input
        word kvmxl;				// maxlength
        word kvoup;				// output
        word kvpfl;				// profile
        word kvtra;				// trace
        word kvtrm;				// trim
        word kvfnc;				// fnclevel
        word kvlst;				// lastno
        word kvlln;				// lastline
        word kvlin;				// line
        word kvstn;				// stno
//      global values for other keywords
        word kvalp;				// alphabet
        word kvrtn;				// rtntype (scblk pointer)
        word kvstl;				// stlimit
        word kvstc;				// stcount (counts down from stlimit)
//      global values for listr procedure
        word lstid;				// include depth of current image
        word lstlc;				// count lines on source list page
        word lstnp;				// max number of lines on page
        word lstpf;				// set nonzero if current image listed
        word lstpg;				// current source list page number
        word lstpo;				// offset to   page nnn   message
        word lstsn;				// remember last stmnum listed
//      global maximum size of spitbol objects
        word mxlen;				// initialised by sysmx call
//      global execution control variable
        word noxeq;				// set non-zero to inhibit execution
//      global profiler values locations
        word pfdmp;				// set non-0 if &profile set non-0
        word pffnc;				// set non-0 if funct just entered
        word pfstm;				// to store starting time of stmt
        word pfetm;				// to store ending time of stmt
        word pfnte;				// nr of table entries
        word pfste;				// gets int rep of table entry size
        
//      global values used in pattern match routines
        word pmdfl;				// pattern assignment flag
        word pmhbs;				// history stack base pointer
        word pmssl;				// length of subject string in chars
//      global values for interface polling (syspl)
        word polcs;				// poll interval start value
        word polct;				// poll interval counter
//      global flags used for standard file listing options
        word prich;				// printer on interactive channel
        word prstd;				// tested by prtpg
        word prsto;				// standard listing option flag
//      global values for print procedures
        word prbuf;				// ptr to print bfr in static
        word precl;				// extended/compact listing flag
        word prlen;				// length of print buffer in chars
        word prlnw;				// length of print buffer in words
        word profs;				// offset to next location in prbuf
        word prtef;				// endfile flag
        
//      global area for readr
        word rdcln;				// current statement line number
        word rdnln;				// next statement line number
//      global amount of memory reserved for end of execution
        word rsmem;				// reserve memory
//      global area for stmgo counters
        word stmcs;				// counter startup value
        word stmct;				// counter active value
//      adjustable global values
//      all the pointers in this section can point to the
//      dynamic or the static region.
//      when a save file is reloaded, these pointers must
//      be adjusted if static or dynamic memory is now
//      at a different address.  see routine reloc for
//      additional information.
//      some values cannot be move here because of adjacency
//      constraints.  they are handled specially by reloc et al.
//      these values are kvrtn,
//      values gtswk, kvalp, and prbuf are reinitialized by
//      procedure insta, and do not need to appear here.
//      values flprt, flptr, gtcef, and stbas point into the
//      stack and are explicitly adjusted by osint's restart
//      procedure.
        word a_aaa;				// start of adjustable values
        word cmpss;				// save subroutine stack ptr
        word dnamb;				// start of dynamic area
        word dnamp;				// next available loc in dynamic area
        word dname;				// end of available dynamic area
        word hshtb;				// pointer to start of vrblk hash tabl
        word hshte;				// pointer past end of vrblk hash tabl
        word iniss;				// save subroutine stack ptr
        word pftbl;				// gets adrs of (imag) table base
        word prnmv;				// vrblk ptr from last name search
        word statb;				// start of static area
        word state;				// end of static area
        word stxvr;				// vrblk pointer or null
//      relocatable global values
//      all the pointers in this section can point to blocks in
//      the dynamic storage area and must be relocated by the
//      garbage collector. they are identified by r_xxx names.
        word r_aaa;				// start of relocatable values
        word r_arf;				// array block pointer for arref
        word r_ccb;				// ptr to ccblk being built (cdwrd)
        word r_cim;				// ptr to current compiler input str
        word r_cmp;				// copy of r_cim used in cmpil
        word r_cni;				// ptr to next compiler input string
        word r_cnt;				// cdblk pointer for setexit continue
        word r_cod;				// pointer to current cdblk or exblk
        word r_ctp;				// ptr to current ctblk for patst
        word r_cts;				// ptr to last string scanned by patst
        word r_ert;				// trblk pointer for errtype trace
        word r_etx;				// pointer to errtext string
        word r_exs;				// = save xl in expdm
        word r_fcb;				// fcblk chain head
        word r_fnc;				// trblk pointer for fnclevel trace
        word r_gtc;				// keep code ptr for gtcod,gtexp
        word r_ici;				// saved r_cim during include process.
        word r_ifa;				// array of file names by incl. depth
        word r_ifl;				// array of line nums by include depth
        word r_ifn;				// last include file name
        word r_inc;				// table of include file names seen
        word r_io1;				// file arg1 for ioput
        word r_io2;				// file arg2 for ioput
        word r_iof;				// fcblk ptr or 0
        word r_ion;				// name base ptr
        word r_iop;				// predecessor block ptr for ioput
        word r_iot;				// trblk ptr for ioput
        word r_pms;				// subject string ptr in pattern match
        word r_ra2;				// replace second argument last time
        word r_ra3;				// replace third argument last time
        word r_rpt;				// ptr to ctblk replace table last usd
        word r_scp;				// save pointer from last scane call
        word r_sfc;				// current source file name
        word r_sfn;				// ptr to source file name table
        word r_sxl;				// preserve xl in sortc
        word r_sxr;				// preserve xr in sorta/sortc
        word r_stc;				// trblk pointer for stcount trace
        word r_stl;				// source listing sub-title
        word r_sxc;				// code (cdblk) ptr for setexit trap
        word r_ttl;				// source listing title
        word r_xsc;				// string pointer for xscan
        
//      the remaining pointers in this list are used to point
//      to function blocks for normally undefined operators.
        word r_uba;				// binary at
        word r_ubm;				// binary ampersand
        word r_ubn;				// binary number sign
        word r_ubp;				// binary percent
        word r_ubt;				// binary not
        word r_uub;				// unary vertical bar
        word r_uue;				// unary equal
        word r_uun;				// unary number sign
        word r_uup;				// unary percent
        word r_uus;				// unary slash
        word r_uux;				// unary exclamation
        word r_yyy;				// last relocatable location
//      global locations used in scan procedure
        word scnbl;				// set non-zero if scanned past blanks
        word scncc;				// non-zero to scan control card name
        word scngo;				// set non-zero to scan goto field
        word scnil;				// length of current input image
        word scnpt;				// pointer to next location in r_cim
        word scnrs;				// set non-zero to signal rescan
        word scnse;				// start of current element
        word scntp;				// save syntax type from last call
//      global value for indicating stage (see error section)
        word stage;				// initial value = initial compile
        
//      global stack pointer
        word stbas;				// pointer past stack base
//      global values for setexit function (s_stx)
        word stxoc;				// code pointer offset
        word stxof;				// failure offset
//      global value for time keeping
        word timsx;				// time at start of execution
        word timup;				// set when time up occurs
//      global values for xscan and xscni procedures
        word xsofs;				// offset to current location in r_xsc
//      label to mark end of working section
        word w_yyy;
        void (*prc_[19])();				// start of program section
        word lowspmin;
        word end_min_data;
        }; /* struct spitbol_variables */
        extern void sec05();
//	align	2
//	db	bl__i
        extern void s_aaa();				// mark start of code
//      relocation
//      the following section provides services to osint to
//      relocate portions of the workspace.  it is used when
//      a saved memory image must be restarted at a different
//      location.
//      relaj -- relocate a list of pointers
//      (wa)                  ptr past last pointer of list
//      (wb)                  ptr to first pointer of list
//      (xl)                  list of boundaries and adjustments
//      jsr  relaj            call to process list of pointers
//      (wb)                  destroyed
// relaj:
        extern void relaj();				// entry point
//      merge here to check if done
// rlaj0:
        extern void rlaj0();				// restore xl
//      merge here to process next pointer on list
// rlaj1:
        extern void rlaj1();				// load next pointer on list
//      merge here to process next section of stack list
// rlaj2:
        extern void rlaj2();				// ok if past end of section
//      here if not within section
// rlaj3:
        extern void rlaj3();				// advance to next section
//      here when finished processing one pointer
// rlaj4:
        extern void rlaj4();				// increment to next ptr on list
        
//      relcr -- create relocation info after save file reload
//      (wa)                  original s_aaa code section adr
//      (wb)                  original c_aaa constant section adr
//      (wc)                  original g_aaa working section adr
//      (xr)                  ptr to start of static region
//      (cp)                  ptr to start of dynamic region
//      (xl)                  ptr to area to receive information
//      jsr  relcr            create relocation information
//      (wa,wb,wc,xr)         destroyed
//      a block of information is built at (xl) that is used
//      in relocating pointers.  there are rnsi_ instances
//      of a rssi_ word structure.  each instance corresponds
//      to one of the regions that a pointer might point into.
//      the layout of this structure is shown in the definitions
//      section, together with symbolic definitions of the
//      entries as offsets from xl.
// relcr:
        extern void relcr();				// entry point
        
//      reldn -- relocate pointers in the dynamic region
//      (xl)                  list of boundaries and adjustments
//      (xr)                  ptr to first location to process
//      (wc)                  ptr past last location to process
//      jsr  reldn            call to process blocks in dynamic
//      (wa,wb,wc,xr)         destroyed
//      processes all blocks in the dynamic region.  within a
//      block, pointers to the code section, constant section,
//      working globals section, static region, and dynamic
//      region are relocated as needed.
// reldn:
        extern void reldn();				// entry point
//      merge here to process the next block in dynamic
// rld01:
        extern void rld01();				// adjust block type word
//      block type switch. note that blocks with no relocatable
//      fields just return to rld05 to continue to next block.
//      note that dfblks do not appear in dynamic, only in static.
//      ccblks and cmblks are not live when a save file is
//      created, and can be skipped.
//      further note:  static blocks other than vrblks discovered
//      while scanning dynamic must be adjusted at this time.
//      see processing of ffblk for example.
        
//      reldn (continued)
//      arblk
// rld03:
        extern void rld03();				// load length
//      merge here to process pointers in a block
//      (xr)                  ptr to current block
//      (wc)                  ptr past last location to process
//      (wa)                  length (reloc flds + flds at start)
//      (wb)                  offset to first reloc field
// rld04:
        extern void rld04();				// point past last reloc field
        
//      reldn (continued)
//      merge here to advance to next block
//      (xr)                  ptr to current block
//      (wc)                  ptr past last location to process
// rld05:
        extern void rld05();				// block type word
//      cdblk
// rld07:
        extern void rld07();				// load length
//      efblk
//      if the efcod word points to an xnblk, the xnblk type
//      word will not be adjusted.  since this is implementation
//      dependent, we will not worry about it.
// rld08:
        extern void rld08();				// set length
//      evblk
// rld09:
        extern void rld09();				// point past third field
//      exblk
// rld10:
        extern void rld10();				// load length
        
//      reldn (continued)
//      ffblk
//      this block contains a ptr to a dfblk in the static rgn.
//      because there are multiple ffblks pointing to the same
//      dfblk (one for each field name), we only process the
//      dfblk when we encounter the ffblk for the first field.
//      the dfblk in turn contains a pointer to an scblk within
//      static.
// rld11:
        extern void rld11();				// skip dfblk if not first field
//      ffblk (continued)
//      merge here to set up for adjustment of ptrs in ffblk
// rld12:
        extern void rld12();				// set length
//      kvblk, nmblk, p0blk, seblk
// rld13:
        extern void rld13();				// point past second field
//      p1blk, p2blk
//      in p2blks, parm2 contains either a bit mask or the
//      name offset of a variable.  it never requires relocation.
// rld14:
        extern void rld14();				// length (parm2 is non-relocatable)
//      pdblk
//      note that the dfblk pointed to by this pdblk was
//      processed when the ffblk was encountered.  because
//      the data function will be called before any records are
//      defined, the ffblk is encountered before any
//      corresponding pdblk.
// rld15:
        extern void rld15();				// load ptr to dfblk
        
//      reldn (continued)
//      pfblk
// rld16:
        extern void rld16();				// adjust non-contiguous field
//      tbblk, vcblk
// rld17:
        extern void rld17();				// load length
//      teblk
// rld18:
        extern void rld18();				// set length
//      trblk
// rld19:
        extern void rld19();				// set length
//      xrblk
// rld20:
        extern void rld20();				// load length
        
//      reloc -- relocate storage after save file reload
//      (xl)                  list of boundaries and adjustments
//      jsr  reloc            relocate all pointers
//      (wa,wb,wc,xr)         destroyed
//      the list of boundaries and adjustments pointed to by
//      register xl is created by a call to relcr, which should
//      be consulted for information on its structure.
// reloc:
        extern void reloc();				// entry point
        
//      relst -- relocate pointers in the static region
//      (xl)                  list of boundaries and adjustments
//      jsr  relst            call to process blocks in static
//      (wa,wb,wc,xr)         destroyed
//      only vrblks on the hash chain and any profile block are
//      processed.  other static blocks (dfblks) are processed
//      during processing of dynamic blocks.
//      global work locations will be processed at this point,
//      so pointers there can be relied upon.
// relst:
        extern void relst();				// entry point
//      here after dealing with profiler
// rls01:
        extern void rls01();				// point to start of hash table
//      loop through slots in hash table
// rls02:
        extern void rls02();				// done if none left
//      loop through vrblks on one hash chain
// rls03:
        extern void rls03();				// point to next vrblk on chain
//      merge here to process fields of vrblk
// rls04:
        extern void rls04();				// create end ptr
//      here when all vrblks processed
// rls05:
        extern void rls05();				// return to caller
        
//      relws -- relocate pointers in the working section
//      (xl)                  list of boundaries and adjustments
//      jsr  relws            call to process working section
//      (wa,wb,wc,xr)         destroyed
//      pointers between a_aaa and r_yyy are examined and
//      adjusted if necessary.  the pointer kvrtn is also
//      adjusted although it lies outside this range.
//      dname is explicitly adjusted because the limits
//      on dynamic region in stack are to the area actively
//      in use (between dnamb and dnamp), and dname is outside
//      this range.
// relws:
        extern void relws();				// entry point
//      initialisation
//      the following section receives control from the system
//      at the start of a run with the registers set as follows.
//      (wa)                  initial stack pointer
//      (xr)                  points to first word of data area
//      (xl)                  points to last word of data area
// start:
        extern void start();				// entry point
//      now convert free store percentage to a suitable factor
//      for easy testing in alloc routine.
//      now convert free sediment percentage to a suitable factor
//      for easy testing in gbcol routine.
//      initialize values for real conversion routine
//      loop to compute 10**(max number significant digits)
// ini03:
        extern void ini03();				// * 10.0
        
//      now compute starting address for dynamic store and if
//      necessary request more memory.
//      here to store values which mark initial division
//      of data area into static and dynamic
// ini06:
        extern void ini06();				// dynamic base adrs
        
//      loop here if necessary till enough memory obtained
//      so that dname is above dnamb
// ini07:
        extern void ini07();				// store dynamic end address
//      insert text for error 329 in error message table
// ini08:
        extern void ini08();				// point to failure message
//      initialise structures at start of static region
// ini09:
        extern void ini09();				// point to static again
//      initialize number of hash headers
//      loop to clear hash table
// ini11:
        extern void ini11();				// blank a word
//      init table to map statement numbers to source file names
//      initialize table to detect duplicate include file names
//      initialize array to hold names of nested include files
//      init array to hold line numbers of nested include files
//      initialize variable blocks for input and output
        
//      check for expiry date
// ini13:
        extern void ini13();				// call date check
//      now compile source input code
//      print compile statistics
        
//      prepare now to start execution
//      set default input record length
// inix0:
        extern void inix0();				// skip if not default -in72 used
//      reset timer
// inix1:
        extern void inix1();				// get time again
//      merge when listing file set for execution.  also
//      merge here when restarting a save file or load module.
// iniy0:
        extern void iniy0();				// mark headers out regardless
//      here if execution is suppressed
// inix2:
        extern void inix2();				// set abend value to zero
//      here from osint to restart a save file or load module.
// rstrt:
        extern void rstrt();				// entry point
//      this section includes all routines which can be accessed
//      directly from the generated code except system functions.
//      all routines in this section start with a label of the
//      form o_xxx where xxx is three letters. the generated code
//      contains a pointer to the appropriate entry label.
//      since the general form of the generated code consists of
//      pointers to blocks whose first word is the address of the
//      actual entry point label (o_xxx).
//      these routines are in alphabetical order by their
//      entry label names (i.e. by the xxx of the o_xxx name)
//      these routines receive control as follows
//      (cp)                  pointer to next code word
//      (xs)                  current stack pointer
        
//      binary plus (addition)
//	align	2
//	nop
        extern void o_add();				// entry point
//      here to add two integers
//      here to add two reals
// oadd1:
        extern void oadd1();				// add right operand to left
        
//      unary plus (affirmation)
//	align	2
//	nop
        extern void o_aff();				// entry point
        
//      binary bar (alternation)
//	align	2
//	nop
        extern void o_alt();				// entry point
//      merge here from special (left alternation) case
// oalt1:
        extern void oalt1();				// set pcode for alternative node
//      come here if left argument is itself an alternation
//      the result is more efficient if we make the replacement
//      (a / b) / c = a / (b / c)
// oalt2:
        extern void oalt2();				// build the (b / c) node
        
//      array reference (multiple subscripts, by name)
//	align	2
//	nop
        extern void o_amn();				// entry point
        
//      array reference (multiple subscripts, by value)
//	align	2
//	nop
        extern void o_amv();				// entry point
        
//      array reference (one subscript, by name)
//	align	2
//	nop
        extern void o_aon();				// entry point
//      here to use central array reference routine
// oaon1:
        extern void oaon1();				// set number of subscripts to one
//      here if we have a vector reference
// oaon2:
        extern void oaon2();				// use long routine if not integer
//      here for table reference
// oaon3:
        extern void oaon3();				// set flag for name reference
//      here to exit with result on stack
// oaon4:
        extern void oaon4();				// result on stack, get code word
        
//      array reference (one subscript, by value)
//	align	2
//	nop
        extern void o_aov();				// entry point
//      here to use central array reference routine
// oaov1:
        extern void oaov1();				// restack array value
//      here if we have a vector reference
// oaov2:
        extern void oaov2();				// use long routine if not integer
//      here for table reference by value
// oaov3:
        extern void oaov3();				// set flag for value reference
        
//      assignment
//	align	2
//	nop
        extern void o_ass();				// entry point
//      o_rpl (pattern replacement) merges here
// oass0:
        extern void oass0();				// load value to be assigned
        
//      compilation error
//	align	2
//	nop
        extern void o_cer();				// entry point
        
//      unary at (cursor assignment)
//	align	2
//	nop
        extern void o_cas();				// entry point
        
//      concatenation
//	align	2
//	nop
        extern void o_cnc();				// entry point
//      merge here to concatenate two strings
// ocnc1:
        extern void ocnc1();				// load left argument length
//      come here if arguments are not both strings
// ocnc2:
        extern void ocnc2();				// convert right arg to string
        
//      concatenation (continued)
//      come here for null right argument
// ocnc3:
        extern void ocnc3();				// remove right arg from stack
//      here for null left argument
// ocnc4:
        extern void ocnc4();				// unstack one argument
//      here if right argument is not a string
// ocnc5:
        extern void ocnc5();				// move right argument ptr
//      merge here when left argument is not a string
// ocnc6:
        extern void ocnc6();				// convert left arg to pattern
        
//      complementation
//	align	2
//	nop
        extern void o_com();				// entry point
//      merge back here after conversion
// ocom1:
        extern void ocom1();				// jump if integer
//      here to complement integer
// ocom2:
        extern void ocom2();				// load integer value
//      here to complement real
// ocom3:
        extern void ocom3();				// load real value
        
//      binary slash (division)
//	align	2
//	nop
        extern void o_dvd();				// entry point
//      here to divide two integers
//      here to divide two reals
// odvd2:
        extern void odvd2();				// divide left operand by right
        
//      exponentiation
//	align	2
//	nop
        extern void o_exp();				// entry point
//      here to exponentiate an integer base and integer exponent
//      loop to perform exponentiation
// oex13:
        extern void oex13();				// multiply by base
// oexp1:
        extern void oexp1();				// loop if more to go
//      here if integer overflow
// oexp2:
        extern void oexp2();
        
//      exponentiation (continued)
//      here to exponentiate a real to an integer power
// oexp3:
        extern void oexp3();				// convert exponent to one word
//      here for error of 0**0 or 0.0**0
// oexp4:
        extern void oexp4();
//      loop to perform exponentiation
// oex14:
        extern void oex14();				// multiply by base
// oexp5:
        extern void oexp5();				// loop till computation complete
//      here if real overflow
// oexp6:
        extern void oexp6();
//      here with real exponent in (xl), numeric base in (xr)
// oexp7:
        extern void oexp7();				// jump if base real
//      here with real exponent in (xl)
//      numeric base in (xr) and ra
// oexp8:
        extern void oexp8();				// set positive result flag
//      here with non-zero base in (xr) and ra, exponent in (xl)
//      a negative base is allowed if the exponent is integral.
// oexp9:
        extern void oexp9();				// jump if base gt 0.0
//      here with positive base in ra and (xr), exponent in (xl)
// oex10:
        extern void oex10();				// log of base
//      here for non-integral exponent with negative base
// oex11:
        extern void oex11();
//      here with negative integer exponent in ia
// oex12:
        extern void oex12();				// stack base
        
//      failure in expression evaluation
//      this entry point is used if the evaluation of an
//      expression, initiated by the evalx procedure, fails.
//      control is returned to an appropriate point in evalx.
//	align	2
//	nop
        extern void o_fex();				// entry point
        
//      failure during evaluation of a complex or direct goto
//	align	2
//	nop
        extern void o_fif();				// entry point
        
//      function call (more than one argument)
//	align	2
//	nop
        extern void o_fnc();				// entry point
        
//      function name error
//	align	2
//	nop
        extern void o_fne();				// entry point
//      here for error
// ofne1:
        extern void ofne1();
        
//      function call (single argument)
//	align	2
//	nop
        extern void o_fns();				// entry point
        
//      call to undefined function
//	align	2
//	nop
        extern void o_fun();				// entry point
        
//      execute complex goto
//	align	2
//	nop
        extern void o_goc();				// entry point
//      here if goto operand is not natural variable
// ogoc1:
        extern void ogoc1();
        
//      execute direct goto
//	align	2
//	nop
        extern void o_god();				// entry point
        
//      set goto failure trap
//      this routine is executed at the start of a complex or
//      direct failure goto to trap a subsequent fail (see exfal)
//	align	2
//	nop
        extern void o_gof();				// entry point
        
//      binary dollar (immediate assignment)
//      the pattern built by binary dollar is a compound pattern.
//      see description at start of pattern match section for
//      details of the structure which is constructed.
//	align	2
//	nop
        extern void o_ima();				// entry point
        
//      indirection (by name)
//	align	2
//	nop
        extern void o_inn();				// entry point
        
//      interrogation
//	align	2
//	nop
        extern void o_int();				// entry point
        
//      indirection (by value)
//	align	2
//	nop
        extern void o_inv();				// entry point
        
//      keyword reference (by name)
//	align	2
//	nop
        extern void o_kwn();				// entry point
        
//      keyword reference (by value)
//	align	2
//	nop
        extern void o_kwv();				// entry point
        
//      load expression by name
//	align	2
//	nop
        extern void o_lex();				// entry point
        
//      load pattern value
//	align	2
//	nop
        extern void o_lpt();				// entry point
        
//      load variable name
//	align	2
//	nop
        extern void o_lvn();				// entry point
        
//      binary asterisk (multiplication)
//	align	2
//	nop
        extern void o_mlt();				// entry point
//      here to multiply two integers
//      here to multiply two reals
// omlt1:
        extern void omlt1();				// multiply left operand by right
        
//      name reference
//	align	2
//	nop
        extern void o_nam();				// entry point
        
//      negation
//      initial entry
//	align	2
//	nop
        extern void o_nta();				// entry point
//      entry after successful evaluation of operand
//	align	2
//	nop
        extern void o_ntb();				// entry point
//      entry for failure during operand evaluation
//	align	2
//	nop
        extern void o_ntc();				// entry point
        
//      use of undefined operator
//	align	2
//	nop
        extern void o_oun();				// entry point
        
//      binary dot (pattern assignment)
//      the pattern built by binary dot is a compound pattern.
//      see description at start of pattern match section for
//      details of the structure which is constructed.
//	align	2
//	nop
        extern void o_pas();				// entry point
        
//      pattern match (by name, for replacement)
//	align	2
//	nop
        extern void o_pmn();				// entry point
        
//      pattern match (statement)
//      o_pms is used in place of o_pmv when the pattern match
//      occurs at the outer (statement) level since in this
//      case the substring value need not be constructed.
//	align	2
//	nop
        extern void o_pms();				// entry point
        
//      pattern match (by value)
//	align	2
//	nop
        extern void o_pmv();				// entry point
        
//      pop top item on stack
//	align	2
//	nop
        extern void o_pop();				// entry point
        
//      terminate execution (code compiled for end statement)
//	align	2
//	nop
        extern void o_stp();				// entry point
        
//      return name from expression
//      this entry points is used if the evaluation of an
//      expression, initiated by the evalx procedure, returns
//      a name. control is returned to the proper point in evalx.
//	align	2
//	nop
        extern void o_rnm();				// entry point
        
//      pattern replacement
//      when this routine gets control, the following stack
//      entries have been made (see end of match routine p_nth)
//                            subject name base
//                            subject name offset
//                            initial cursor value
//                            final cursor value
//                            subject string pointer
//      (xs) ---------------- replacement value
//	align	2
//	nop
        extern void o_rpl();				// entry point
//      get result length and allocate result scblk
//      move part 1 (start of subject) to result
        
//      pattern replacement (continued)
//      now move in replacement value
// orpl1:
        extern void orpl1();				// load replacement string, pop
//      now move in remainder of string (part 3)
// orpl2:
        extern void orpl2();				// load subject string pointer, pop
//      here if result is null
// orpl3:
        extern void orpl3();				// pop subject str ptr, final cursor
        
//      return value from expression
//      this entry points is used if the evaluation of an
//      expression, initiated by the evalx procedure, returns
//      a value. control is returned to the proper point in evalx
//	align	2
//	nop
        extern void o_rvl();				// entry point
        
//      selection
//      initial entry
//	align	2
//	nop
        extern void o_sla();				// entry point
//      entry after successful evaluation of alternative
//	align	2
//	nop
        extern void o_slb();				// entry point
//      entry at start of subsequent alternatives
//	align	2
//	nop
        extern void o_slc();				// entry point
//      entry at start of last alternative
//	align	2
//	nop
        extern void o_sld();				// entry point
        
//      binary minus (subtraction)
//	align	2
//	nop
        extern void o_sub();				// entry point
//      here to subtract two integers
//      here to subtract two reals
// osub1:
        extern void osub1();				// subtract right operand from left
        
//      dummy operator to return control to trxeq procedure
//	align	2
//	nop
        extern void o_txr();				// entry point
        
//      unexpected failure
//      note that if a setexit trap is operating then
//      transfer to system label continue
//      will result in looping here.  difficult to avoid except
//      with a considerable overhead which is not worthwhile or
//      else by a technique such as setting kverl to zero.
//	align	2
//	nop
        extern void o_unf();				// entry point
//      the first word of every block in dynamic storage and the
//      vrget, vrsto and vrtra fields of a vrblk contain a
//      pointer to an entry point in the program. all such entry
//      points are in the following section except those for
//      pattern blocks which are in the pattern matching segment
//      later on (labels of the form p_xxx), and dope vectors
//      (d_xxx) which are in the dope vector section following
//      the pattern routines (dope vectors are used for cmblks).
//      the entry points in this section have labels of the
//      form b_xxy where xx is the two character block type for
//      the corresponding block and y is any letter.
//      in some cases, the pointers serve no other purpose than
//      to identify the block type. in this case the routine
//      is never executed and thus no code is assembled.
//      for each of these entry points corresponding to a block
//      an entry point identification is assembled (bl_xx).
//      the exact entry conditions depend on the manner in
//      which the routine is accessed and are documented with
//      the individual routines as required.
//      the order of these routines is alphabetical with the
//      following exceptions.
//      the routines for seblk and exblk entries occur first so
//      that expressions can be quickly identified from the fact
//      that their routines lie before the symbol b_e__.
//      these are immediately followed by the routine for a trblk
//      so that the test against the symbol b_t__ checks for
//      trapped values or expression values (see procedure evalp)
//      the pattern routines lie after this section so that
//      patterns are identified with routines starting at or
//      after the initial instruction in these routines (p_aaa).
//      the symbol b_aaa defines the first location for block
//      routines and the symbol p_yyy (at the end of the pattern
//      match routines section) defines the last such entry point
//	align	2
//	db	bl__i
        extern void b_aaa();				// entry point of first block routine
        
//      exblk
//      the routine for an exblk loads the expression onto
//      the stack as a value.
//      (xr)                  pointer to exblk
//	align	2
//	db	bl_ex
        extern void b_exl();				// entry point (exblk)
        
//      seblk
//      the routine for seblk is accessed from the generated
//      code to load the expression value onto the stack.
//	align	2
//	db	bl_se
        extern void b_sel();				// entry point (seblk)
//      define symbol which marks end of entries for expressions
//	align	2
//	db	bl__i
        extern void b_e__();				// entry point
        
//      trblk
//      the routine for a trblk is never executed
//	align	2
//	db	bl_tr
        extern void b_trt();				// entry point (trblk)
//      define symbol marking end of trap and expression blocks
//	align	2
//	db	bl__i
        extern void b_t__();				// end of trblk,seblk,exblk entries
        
//      arblk
//      the routine for arblk is never executed
//	align	2
//	db	bl_ar
        extern void b_art();				// entry point (arblk)
        
//      bcblk
//      the routine for a bcblk is never executed
//      (xr)                  pointer to bcblk
//	align	2
//	db	bl_bc
        extern void b_bct();				// entry point (bcblk)
        
//      bfblk
//      the routine for a bfblk is never executed
//      (xr)                  pointer to bfblk
//	align	2
//	db	bl_bf
        extern void b_bft();				// entry point (bfblk)
        
//      ccblk
//      the routine for ccblk is never entered
//	align	2
//	db	bl_cc
        extern void b_cct();				// entry point (ccblk)
        
//      cdblk
//      the cdblk routines are executed from the generated code.
//      there are two cases depending on the form of cdfal.
//      entry for complex failure code at cdfal
//      (xr)                  pointer to cdblk
//	align	2
//	db	bl_cd
        extern void b_cdc();				// entry point (cdblk)
// bcdc0:
        extern void bcdc0();				// pop garbage off stack
        
//      cdblk (continued)
//      entry for simple failure code at cdfal
//      (xr)                  pointer to cdblk
//	align	2
//	db	bl_cd
        extern void b_cds();				// entry point (cdblk)
// bcds0:
        extern void bcds0();				// pop garbage off stack
        
//      cmblk
//      the routine for a cmblk is never executed
//	align	2
//	db	bl_cm
        extern void b_cmt();				// entry point (cmblk)
        
//      ctblk
//      the routine for a ctblk is never executed
//	align	2
//	db	bl_ct
        extern void b_ctt();				// entry point (ctblk)
        
//      dfblk
//      the routine for a dfblk is accessed from the o_fnc entry
//      to call a datatype function and build a pdblk.
//      (xl)                  pointer to dfblk
//	align	2
//	db	bl_df
        extern void b_dfc();				// entry point
//      loop to acquire field values from stack
// bdfc1:
        extern void bdfc1();				// move a field value
        
//      efblk
//      the routine for an efblk is passed control form the o_fnc
//      entry to call an external function.
//      (xl)                  pointer to efblk
//	align	2
//	db	bl_ef
        extern void b_efc();				// entry point (efblk)
//      loop to convert arguments
// befc1:
        extern void befc1();				// point to next entry
//      here to convert to file
// beff1:
        extern void beff1();				// save entry pointer
//      here to convert to string
// befc2:
        extern void befc2();				// stack arg ptr
        
//      efblk (continued)
//      here to convert an integer
// befc3:
        extern void befc3();				// load next argument
//      here to convert a real
// befc4:
        extern void befc4();				// load next argument
//      integer case merges here
// befc5:
        extern void befc5();				// restore offset
//      string merges here
// befc6:
        extern void befc6();				// store converted result
//      no conversion merges here
// befc7:
        extern void befc7();				// loop back if more to go
//      here after converting all the arguments
        
//      efblk (continued)
//      return here with result in xr
//      first defend against non-standard null string returned
//      here if converted result to check for null string
// befa8:
        extern void befa8();				// jump if not a string
//      return if result is in dynamic storage
// befc8:
        extern void befc8();				// jump if not in dynamic storage
//      here we copy a result into the dynamic region
// befc9:
        extern void befc9();				// get possible type word
//      store type word in result
// bef10:
        extern void bef10();				// stored before copying to dynamic
//      merge for unconverted result
// bef11:
        extern void bef11();				// branch if string result
//      here to return a string result that was not in dynamic.
//      cannot use the simple word copy above because it will not
//      guarantee zero padding in the last word.
// bef12:
        extern void bef12();				// save source string pointer
        
//      evblk
//      the routine for an evblk is never executed
//	align	2
//	db	bl_ev
        extern void b_evt();				// entry point (evblk)
        
//      ffblk
//      the routine for an ffblk is executed from the o_fnc entry
//      to call a field function and extract a field value/name.
//      (xl)                  pointer to ffblk
//	align	2
//	db	bl_ff
        extern void b_ffc();				// entry point (ffblk)
//      loop to find correct ffblk for this pdblk
// bffc1:
        extern void bffc1();				// jump if this is the correct ffblk
//      here for bad argument
// bffc2:
        extern void bffc2();
        
//      ffblk (continued)
//      here after locating correct ffblk
// bffc3:
        extern void bffc3();				// load field offset
//      here after getting value in (xr), xl is garbage
// bffc4:
        extern void bffc4();				// store value on stack (over pdblk)
//      here if called by name
// bffc5:
        extern void bffc5();				// store name offset (base is set)
        
//      icblk
//      the routine for icblk is executed from the generated
//      code to load an integer value onto the stack.
//      (xr)                  pointer to icblk
//	align	2
//	db	bl_ic
        extern void b_icl();				// entry point (icblk)
        
//      kvblk
//      the routine for a kvblk is never executed.
//	align	2
//	db	bl_kv
        extern void b_kvt();				// entry point (kvblk)
        
//      nmblk
//      the routine for a nmblk is executed from the generated
//      code for the case of loading a name onto the stack
//      where the name is that of a natural variable which can
//      be preevaluated at compile time.
//      (xr)                  pointer to nmblk
//	align	2
//	db	bl_nm
        extern void b_nml();				// entry point (nmblk)
        
//      pdblk
//      the routine for a pdblk is never executed
//	align	2
//	db	bl_pd
        extern void b_pdt();				// entry point (pdblk)
        
//      pfblk
//      the routine for a pfblk is executed from the entry o_fnc
//      to call a program defined function.
//      (xl)                  pointer to pfblk
//      the following stack entries are made before passing
//      control to the program defined function.
//                            saved value of first argument
//                            .
//                            saved value of last argument
//                            saved value of first local
//                            .
//                            saved value of last local
//                            saved value of function name
//                            saved code block ptr (r_cod)
//                            saved code pointer (-r_cod)
//                            saved value of flprt
//                            saved value of flptr
//                            pointer to pfblk
//      flptr --------------- zero (to be overwritten with offs)
//	align	2
//	db	bl_pf
        extern void b_pfc();				// entry point (pfblk)
//      loop to find old value of function
// bpf01:
        extern void bpf01();				// save pointer
//      set value to null and save old function value
        
//      pfblk (continued)
//      loop to save old argument values and set new ones
// bpf02:
        extern void bpf02();				// load vrblk ptr for next argument
//      loop through possible trblk chain to find value
// bpf03:
        extern void bpf03();				// save pointer
//      save old value and get new value
//      now process locals
// bpf04:
        extern void bpf04();				// restore pfblk pointer
//      loop to process locals
// bpf05:
        extern void bpf05();				// load vrblk ptr for next local
//      loop through possible trblk chain to find value
// bpf06:
        extern void bpf06();				// save pointer
//      save old value and set null as new value
        
//      pfblk (continued)
//      here after processing arguments and locals
// bpf07:
        extern void bpf07();				// zero reg xr in case
//      here if &profile = 1
//       here if &profile = 2
// bpf7a:
        extern void bpf7a();				// get start time of calling stmt
//      both types of profile merge here
// bpf7b:
        extern void bpf7b();				// set start time of 1st func stmt
//      no profiling merges here
// bpf7c:
        extern void bpf7c();				// stack icblk ptr (or zero)
//      here to actually jump to function
// bpf08:
        extern void bpf08();				// point to vrblk of entry label
// bpf8a:
        extern void bpf8a();				// off to execute function
//      here if tracing is possible
// bpf09:
        extern void bpf09();				// load possible call trace trblk
//      here if call traced
        
//      pfblk (continued)
//      here to test for ftrace trace
// bpf10:
        extern void bpf10();				// jump if ftrace is off
//      here for print trace
// bpf11:
        extern void bpf11();				// print statement number
//      loop to print argument values
// bpf12:
        extern void bpf12();				// load comma
//      merge here first time (no comma required)
// bpf13:
        extern void bpf13();				// save arg ctr (over failoffs is ok)
        
//      here after dealing with one argument
//      merge here in no args case to print paren
// bpf15:
        extern void bpf15();				// load right paren
//      merge here to exit with test for fnclevel trace
// bpf16:
        extern void bpf16();				// increment fnclevel
//      call function after trace tests complete
//      here if calling a function whose entry label is undefined
// bpf17:
        extern void bpf17();				// reset so exfal can return to evalx
        
//      rcblk
//      the routine for an rcblk is executed from the generated
//      code to load a real value onto the stack.
//      (xr)                  pointer to rcblk
//	align	2
//	db	bl_rc
        extern void b_rcl();				// entry point (rcblk)
        
//      scblk
//      the routine for an scblk is executed from the generated
//      code to load a string value onto the stack.
//      (xr)                  pointer to scblk
//	align	2
//	db	bl_sc
        extern void b_scl();				// entry point (scblk)
        
//      tbblk
//      the routine for a tbblk is never executed
//	align	2
//	db	bl_tb
        extern void b_tbt();				// entry point (tbblk)
        
//      teblk
//      the routine for a teblk is never executed
//	align	2
//	db	bl_te
        extern void b_tet();				// entry point (teblk)
        
//      vcblk
//      the routine for a vcblk is never executed
//	align	2
//	db	bl_vc
        extern void b_vct();				// entry point (vcblk)
        
//      vrblk
//      the vrblk routines are executed from the generated code.
//      there are six entries for vrblk covering various cases
//	align	2
//	db	bl__i
        extern void b_vr_();				// mark start of vrblk entry points
//      entry for vrget (trapped case). this routine is called
//      from the generated code to load the value of a variable.
//      this entry point is used if an access trace or input
//      association is currently active.
//      (xr)                  pointer to vrget field of vrblk
//	align	2
//	db	bl__i
        extern void b_vra();				// entry point
        
//      vrblk (continued)
//      entry for vrsto (error case. this routine is called from
//      the executed code for an attempt to modify the value
//      of a protected (pattern valued) natural variable.
//	align	2
//	nop
        extern void b_vre();				// entry point
        
//      vrblk (continued)
//      entry for vrtra (untrapped case). this routine is called
//      from the executed code to transfer to a label.
//      (xr)                  pointer to vrtra field of vrblk
//	align	2
//	nop
        extern void b_vrg();				// entry point
        
//      vrblk (continued)
//      entry for vrget (untrapped case). this routine is called
//      from the generated code to load the value of a variable.
//      (xr)                  points to vrget field of vrblk
//	align	2
//	nop
        extern void b_vrl();				// entry point
        
//      vrblk (continued)
//      entry for vrsto (untrapped case). this routine is called
//      from the generated code to store the value of a variable.
//      (xr)                  pointer to vrsto field of vrblk
//	align	2
//	nop
        extern void b_vrs();				// entry point
        
//      vrblk (continued)
//      vrtra (trapped case). this routine is called from the
//      generated code to transfer to a label when a label
//      trace is currently active.
//	align	2
//	nop
        extern void b_vrt();				// entry point
//      here for print trace -- print colon ( label name )
// bvrt1:
        extern void bvrt1();				// print statement number
//      merge here to jump to label
// bvrt2:
        extern void bvrt2();				// load pointer to actual code
        
//      vrblk (continued)
//      entry for vrsto (trapped case). this routine is called
//      from the generated code to store the value of a variable.
//      this entry is used when a value trace or output
//      association is currently active.
//      (xr)                  pointer to vrsto field of vrblk
//	align	2
//	nop
        extern void b_vrv();				// entry point
        
//      xnblk
//      the routine for an xnblk is never executed
//	align	2
//	db	bl_xn
        extern void b_xnt();				// entry point (xnblk)
        
//      xrblk
//      the routine for an xrblk is never executed
//	align	2
//	db	bl_xr
        extern void b_xrt();				// entry point (xrblk)
//      mark entry address past last block action routine
//	align	2
//	db	bl__i
        extern void b_yyy();				// last block routine entry point
//      the following section consists of the pattern matching
//      routines. all pattern nodes contain a pointer (pcode)
//      to one of the routines in this section (p_xxx).
//      note that this section follows the b_xxx routines to
//      enable a fast test for the pattern datatype.
//	align	2
//	db	bl__i
        extern void p_aaa();				// entry to mark first pattern
//      the entry conditions to the match routine are as follows
//      (see o_pmn, o_pmv, o_pms and procedure match).
//      stack contents.
//                            name base (o_pmn only)
//                            name offset (o_pmn only)
//                            type (0-o_pmn, 1-o_pmv, 2-o_pms)
//      pmhbs --------------- initial cursor (zero)
//                            initial node pointer
//      xs ------------------ =ndabo (anchored), =nduna (unanch)
//      register values.
//           (xs)             set as shown in stack diagram
//           (xr)             pointer to initial pattern node
//           (wb)             initial cursor (zero)
//      global pattern values
//           r_pms            pointer to subject string scblk
//           pmssl            length of subject string in chars
//           pmdfl            dot flag, initially zero
//           pmhbs            set as shown in stack diagram
//      control is passed by branching through the pcode
//      field of the initial pattern node (bri (xr)).
        
//      description of algorithm
//      a pattern structure is represented as a linked graph
//      of nodes with the following structure.
//           +------------------------------------+
//           i                pcode               i
//           +------------------------------------+
//           i                pthen               i
//           +------------------------------------+
//           i                parm1               i
//           +------------------------------------+
//           i                parm2               i
//           +------------------------------------+
//      pcode is a pointer to the routine which will perform
//      the match of this particular node type.
//      pthen is a pointer to the successor node. i.e. the node
//      to be matched if the attempt to match this node succeeds.
//      if this is the last node of the pattern pthen points
//      to the dummy node ndnth which initiates pattern exit.
//      parm1, parm2 are parameters whose use varies with the
//      particular node. they are only present if required.
//      alternatives are handled with the special alternative
//      node whose parameter points to the node to be matched
//      if there is a failure on the successor path.
//      the following example illustrates the manner in which
//      the structure is built up. the pattern is
//      (a / b / c) (d / e)   where / is alternation
//      in the diagram, the node marked + represents an
//      alternative node and the dotted line from a + node
//      represents the parameter pointer to the alternative.
//      +---+     +---+     +---+     +---+
//      i + i-----i a i-----i + i-----i d i-----
//      +---+     +---+  i  +---+     +---+
//        .              i    .
//        .              i    .
//      +---+     +---+  i  +---+
//      i + i-----i b i--i  i e i-----
//      +---+     +---+  i  +---+
//        .              i
//        .              i
//      +---+            i
//      i c i------------i
//      +---+
        
//      during the match, the registers are used as follows.
//      (xr)                  points to the current node
//      (xl)                  scratch
//      (xs)                  main stack pointer
//      (wb)                  cursor (number of chars matched)
//      (wa,wc)               scratch
//      to keep track of alternatives, the main stack is used as
//      a history stack and contains two word entries.
//      word 1                saved cursor value
//      word 2                node to match on failure
//      when a failure occurs, the most recent entry on this
//      stack is popped off to restore the cursor and point
//      to the node to be matched as an alternative. the entry
//      at the bottom of the stack points to the following
//      special nodes depending on the scan mode.
//      anchored mode         the bottom entry points to the
//                            special node ndabo which causes an
//                            abort. the cursor value stored
//                            with this entry is always zero.
//      unanchored mode       the bottom entry points to the
//                            special node nduna which moves the
//                            anchor point and restarts the match
//                            the cursor saved with this entry
//                            is the number of characters which
//                            lie before the initial anchor point
//                            (i.e. the number of anchor moves).
//                            this entry is three words long and
//                            also contains the initial pattern.
//      entries are made on this history stack by alternative
//      nodes and by some special compound patterns as described
//      later on. the following global locations are used during
//      pattern matching.
//      r_pms                 pointer to subject string
//      pmssl                 length of subject string
//      pmdfl                 flag set non-zero for dot patterns
//      pmhbs                 base ptr for current history stack
//      the following exit points are available to match routines
//      succp                 success in matching current node
//      failp                 failure in matching current node
        
//      compound patterns
//      some patterns have implicit alternatives and their
//      representation in the pattern structure consists of a
//      linked set of nodes as indicated by these diagrams.
//      as before, the + represents an alternative node and
//      the dotted line from a + node is the parameter pointer
//      to the alternative pattern.
//      arb
//      ---
//           +---+            this node (p_arb) matches null
//           i b i-----       and stacks cursor, successor ptr,
//           +---+            cursor (copy) and a ptr to ndarc.
//      bal
//      ---
//           +---+            the p_bal node scans a balanced
//           i b i-----       string and then stacks a pointer
//           +---+            to itself on the history stack.
        
//      compound pattern structures (continued)
//      arbno
//      -----
//           +---+            this alternative node matches null
//      +----i + i-----       the first time and stacks a pointer
//      i    +---+            to the argument pattern x.
//      i      .
//      i      .
//      i    +---+            node (p_aba) to stack cursor
//      i    i a i            and history stack base ptr.
//      i    +---+
//      i      i
//      i      i
//      i    +---+            this is the argument pattern. as
//      i    i x i            indicated, the successor of the
//      i    +---+            pattern is the p_abc node
//      i      i
//      i      i
//      i    +---+            this node (p_abc) pops pmhbs,
//      +----i c i            stacks old pmhbs and ptr to ndabd
//           +---+            (unless optimization has occurred)
//      structure and execution of this pattern resemble those of
//      recursive pattern matching and immediate assignment.
//      the alternative node at the head of the structure matches
//      null initially but on subsequent failure ensures attempt
//      to match the argument.  before the argument is matched
//      p_aba stacks the cursor, pmhbs and a ptr to p_abb.  if
//      the argument cant be matched , p_abb removes this special
//      stack entry and fails.
//      if argument is matched , p_abc restores the outer pmhbs
//      value (saved by p_aba) .  then if the argument has left
//      alternatives on stack it stacks the inner value of pmhbs
//      and a ptr to ndabd. if argument left nothing on the stack
//      it optimises by removing items stacked by p_aba.  finally
//      a check is made that argument matched more than the null
//      string (check is intended to prevent useless looping).
//      if so the successor is again the alternative node at the
//      head of the structure , ensuring a possible extra attempt
//      to match the arg if necessary.  if not , the successor to
//      alternative is taken so as to terminate the loop.  p_abd
//      restores inner pmhbs ptr and fails , thus trying to match
//      alternatives left by the arbno argument.
        
//      compound pattern structures (continued)
//      breakx
//      ------
//           +---+            this node is a break node for
//      +----i b i            the argument to breakx, identical
//      i    +---+            to an ordinary break node.
//      i      i
//      i      i
//      i    +---+            this alternative node stacks a
//      i    i + i-----       pointer to the breakx node to
//      i    +---+            allow for subsequent failure
//      i      .
//      i      .
//      i    +---+            this is the breakx node itself. it
//      +----i x i            matches one character and then
//           +---+            proceeds back to the break node.
//      fence
//      -----
//           +---+            the fence node matches null and
//           i f i-----       stacks a pointer to node ndabo to
//           +---+            abort on a subsequent rematch
//      succeed
//      -------
//           +---+            the node for succeed matches null
//           i s i-----       and stacks a pointer to itself
//           +---+            to repeat the match on a failure.
        
//      compound patterns (continued)
//      binary dot (pattern assignment)
//      -------------------------------
//           +---+            this node (p_paa) saves the current
//           i a i            cursor and a pointer to the
//           +---+            special node ndpab on the stack.
//             i
//             i
//           +---+            this is the structure for the
//           i x i            pattern left argument of the
//           +---+            pattern assignment call.
//             i
//             i
//           +---+            this node (p_pac) saves the cursor,
//           i c i-----       a ptr to itself, the cursor (copy)
//           +---+            and a ptr to ndpad on the stack.
//      the function of the match routine for ndpab (p_pab)
//      is simply to unstack itself and fail back onto the stack.
//      the match routine for p_pac also sets the global pattern
//      flag pmdfl non-zero to indicate that pattern assignments
//      may have occured in the pattern match
//      if pmdfl is set at the end of the match (see p_nth), the
//      history stack is scanned for matching ndpab-ndpad pairs
//      and the corresponding pattern assignments are executed.
//      the function of the match routine for ndpad (p_pad)
//      is simply to remove its entry from the stack and fail.
//      this includes removing the special node pointer stored
//      in addition to the standard two entries on the stack.
        
//      compount pattern structures (continued)
//      fence (function)
//      ----------------
//           +---+            this node (p_fna) saves the
//           i a i            current history stack and a
//           +---+            pointer to ndfnb on the stack.
//             i
//             i
//           +---+            this is the pattern structure
//           i x i            given as the argument to the
//           +---+            fence function.
//             i
//             i
//           +---+            this node p_fnc restores the outer
//           i c i            history stack ptr saved in p_fna,
//           +---+            and stacks the inner stack base
//                            ptr and a pointer to ndfnd on the
//                            stack.
//      ndfnb (f_fnb) simply is the failure exit for pattern
//      argument failure, and it pops itself and fails onto the
//      stack.
//      the match routine p_fnc allows for an optimization when
//      the fence pattern leaves no alternatives.  in this case,
//      the ndfnb entry is popped, and the match continues.
//      ndfnd (p_fnd) is entered when the pattern fails after
//      going through a non-optimized p_fnc, and it pops the
//      stack back past the innter stack base created by p_fna
        
//      compound patterns (continued)
//      expression patterns (recursive pattern matches)
//      -----------------------------------------------
//      initial entry for a pattern node is to the routine p_exa.
//      if the evaluated result of the expression is itself a
//      pattern, then the following steps are taken to arrange
//      for proper recursive processing.
//      1)   a pointer to the current node (the p_exa node) is
//           stored on the history stack with a dummy cursor.
//      2)   a special history stack entry is made in which the
//           node pointer points to ndexb, and the cursor value
//           is the saved value of pmhbs on entry to this node.
//           the match routine for ndexb (p_exb) restores pmhbs
//           from this cursor entry, pops off the p_exa node
//           pointer and fails.
//      3)   the resulting history stack pointer is saved in
//           pmhbs to establish a new level of history stack.
//      after matching a pattern, the end of match routine gets
//      control (p_nth). this routine proceeds as follows.
//      1)   load the current value of pmhbs and recognize the
//           outer level case by the fact that the associated
//           cursor in this case is the pattern match type code
//           which is less than 3. terminate the match in this
//           case and continue execution of the program.
//      2)   otherwise make a special history stack entry in
//           which the node pointer points to the special node
//           ndexc and the cursor is the current value of pmhbs.
//           the match routine for ndexc (p_exc) resets pmhbs to
//           this (inner) value and and then fails.
//      3)   using the history stack entry made on starting the
//           expression (accessible with the current value of
//           pmhbs), restore the p_exa node pointer and the old
//           pmhbs setting. take the successor and continue.
//      an optimization is possible if the expression pattern
//      makes no entries on the history stack. in this case,
//      instead of building the p_exc node in step 2, it is more
//      efficient to simply pop off the p_exb entry and its
//      associated node pointer. the effect is the same.
        
//      compound patterns (continued)
//      binary dollar (immediate assignment)
//      ------------------------------------
//           +---+            this node (p_ima) stacks the cursor
//           i a i            pmhbs and a ptr to ndimb and resets
//           +---+            the stack ptr pmhbs.
//             i
//             i
//           +---+            this is the left structure for the
//           i x i            pattern left argument of the
//           +---+            immediate assignment call.
//             i
//             i
//           +---+            this node (p_imc) performs the
//           i c i-----       assignment, pops pmhbs and stacks
//           +---+            the old pmhbs and a ptr to ndimd.
//      the structure and execution of this pattern are similar
//      to those of the recursive expression pattern matching.
//      the match routine for ndimb (p_imb) restores the outer
//      level value of pmhbs, unstacks the saved cursor and fails
//      the match routine p_imc uses the current value of pmhbs
//      to locate the p_imb entry. this entry is used to make
//      the assignment and restore the outer level value of
//      pmhbs. finally, the inner level value of pmhbs and a
//      pointer to the special node ndimd are stacked.
//      the match routine for ndimd (p_imd) restores the inner
//      level value of pmhbs and fails back into the stack.
//      an optimization occurs if the inner pattern makes no
//      entries on the history stack. in this case, p_imc pops
//      the p_imb entry instead of making a p_imd entry.
        
//      arbno
//      see compound patterns section for stucture and
//      algorithm for matching this node type.
//      no parameters
//	align	2
//	db	bl_p0
        extern void p_aba();				// p0blk
        
//      arbno (remove p_aba special stack entry)
//      no parameters (dummy pattern)
//	align	2
//	nop
        extern void p_abb();				// entry point
        
//      arbno (check if arg matched null string)
//      no parameters (dummy pattern)
//	align	2
//	db	bl_p0
        extern void p_abc();				// p0blk
//      optimise case of no extra entries on stack from arbno arg
// pabc1:
        extern void pabc1();				// remove ndabb entry and cursor
//      merge to check for matching of null string
// pabc2:
        extern void pabc2();				// allow further attempt if non-null
        
//      arbno (try for alternatives in arbno argument)
//      no parameters (dummy pattern)
//	align	2
//	nop
        extern void p_abd();				// entry point
        
//      abort
//      no parameters
//	align	2
//	db	bl_p0
        extern void p_abo();				// p0blk
        
//      alternation
//      parm1                 alternative node
//	align	2
//	db	bl_p1
        extern void p_alt();				// p1blk
        
//      any (one character argument) (1-char string also)
//      parm1                 character argument
//	align	2
//	db	bl_p1
        extern void p_ans();				// p1blk
        
//      any (multi-character argument case)
//      parm1                 pointer to ctblk
//      parm2                 bit mask to select bit in ctblk
//	align	2
//	db	bl_p2
        extern void p_any();				// p2blk
//      expression argument case merges here
// pany1:
        extern void pany1();				// fail if no characters left
        
//      any (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        extern void p_ayd();				// p1blk
        
//      p_arb                 initial arb match
//      no parameters
//      the p_arb node is part of a compound pattern structure
//      for an arb pattern (see description of compound patterns)
//	align	2
//	db	bl_p0
        extern void p_arb();				// p0blk
        
//      p_arc                 extend arb match
//      no parameters (dummy pattern)
//	align	2
//	nop
        extern void p_arc();				// entry point
        
//      bal
//      no parameters
//      the p_bal node is part of the compound structure built
//      for bal (see section on compound patterns).
//	align	2
//	db	bl_p0
        extern void p_bal();				// p0blk
//      loop to scan out characters
// pbal1:
        extern void pbal1();				// load next character, bump pointer
//      here after processing one character
// pbal2:
        extern void pbal2();				// loop back unless end of string
//      here on left paren
// pbal3:
        extern void pbal3();				// bump paren level
//      here for right paren
// pbal4:
        extern void pbal4();				// fail if no matching left paren
//      here after successfully scanning a balanced string
// pbal5:
        extern void pbal5();				// stack cursor
        
//      break (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        extern void p_bkd();				// p1blk
        
//      break (one character argument)
//      parm1                 character argument
//	align	2
//	db	bl_p1
        extern void p_bks();				// p1blk
//      loop to scan till break character found
// pbks1:
        extern void pbks1();				// load next char, bump pointer
        
//      break (multi-character argument)
//      parm1                 pointer to ctblk
//      parm2                 bit mask to select bit column
//	align	2
//	db	bl_p2
        extern void p_brk();				// p2blk
//      expression argument merges here
// pbrk1:
        extern void pbrk1();				// load subject string length
//      loop to search for break character
// pbrk2:
        extern void pbrk2();				// load next char, bump pointer
        
//      breakx (extension)
//      this is the entry which causes an extension of a breakx
//      match when failure occurs. see section on compound
//      patterns for full details of breakx matching.
//      no parameters
//	align	2
//	db	bl_p0
        extern void p_bkx();				// p0blk
        
//      breakx (expression argument)
//      see section on compound patterns for full structure of
//      breakx pattern. the actual character matching uses a
//      break node. however, the entry for the expression
//      argument case is separated to get proper error messages.
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        extern void p_bxd();				// p1blk
        
//      cursor assignment
//      parm1                 name base
//      parm2                 name offset
//	align	2
//	db	bl_p2
        extern void p_cas();				// p2blk
        
//      expression node (p_exa, initial entry)
//      see compound patterns description for the structure and
//      algorithms for handling expression nodes.
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        extern void p_exa();				// p1blk
//      here if result of expression is a pattern
//      here if result of expression is not a pattern
// pexa1:
        extern void pexa1();				// jump if it is already a string
//      merge here with string pointer in xl
// pexa2:
        extern void pexa2();				// just succeed if null string
        
//      expression node (p_exb, remove ndexb entry)
//      see compound patterns description for the structure and
//      algorithms for handling expression nodes.
//      no parameters (dummy pattern)
//	align	2
//	nop
        extern void p_exb();				// entry point
        
//      expression node (p_exc, remove ndexc entry)
//      see compound patterns description for the structure and
//      algorithms for handling expression nodes.
//      no parameters (dummy pattern)
//	align	2
//	nop
        extern void p_exc();				// entry point
        
//      fail
//      no parameters
//	align	2
//	db	bl_p0
        extern void p_fal();				// p0blk
        
//      fence
//      see compound patterns section for the structure and
//      algorithm for matching this node type.
//      no parameters
//	align	2
//	db	bl_p0
        extern void p_fen();				// p0blk
        
//      fence (function)
//      see compound patterns comments at start of this section
//      for details of scheme
//      no parameters
//	align	2
//	db	bl_p0
        extern void p_fna();				// p0blk
        
//      fence (function) (reset history stack and fail)
//      no parameters (dummy pattern)
//	align	2
//	db	bl_p0
        extern void p_fnb();				// p0blk
        
//      fence (function) (make fence trap entry on stack)
//      no parameters (dummy pattern)
//	align	2
//	db	bl_p0
        extern void p_fnc();				// p0blk
//      here when fence function left nothing on the stack
// pfnc1:
        extern void pfnc1();				// pop off p_fnb entry
        
//      fence (function) (skip past alternatives on failure)
//      no parameters (dummy pattern)
//	align	2
//	db	bl_p0
        extern void p_fnd();				// p0blk
        
//      immediate assignment (initial entry, save current cursor)
//      see compound patterns description for details of the
//      structure and algorithm for matching this node type.
//      no parameters
//	align	2
//	db	bl_p0
        extern void p_ima();				// p0blk
        
//      immediate assignment (remove cursor mark entry)
//      see compound patterns description for details of the
//      structure and algorithms for matching this node type.
//      no parameters (dummy pattern)
//	align	2
//	nop
        extern void p_imb();				// entry point
        
//      immediate assignment (perform actual assignment)
//      see compound patterns description for details of the
//      structure and algorithms for matching this node type.
//      parm1                 name base of variable
//      parm2                 name offset of variable
//	align	2
//	db	bl_p2
        extern void p_imc();				// p2blk
//      here if no entries made on history stack
// pimc1:
        extern void pimc1();				// remove ndimb entry and cursor
//      merge here to perform assignment
// pimc2:
        extern void pimc2();				// save current (final) cursor
        
//      immediate assignment (remove ndimd entry on failure)
//      see compound patterns description for details of the
//      structure and algorithms for matching this node type.
//      no parameters (dummy pattern)
//	align	2
//	nop
        extern void p_imd();				// entry point
        
//      len (integer argument)
//      parm1                 integer argument
//	align	2
//	db	bl_p1
        extern void p_len();				// p1blk
//      expression argument case merges here
// plen1:
        extern void plen1();				// push cursor indicated amount
        
//      len (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        extern void p_lnd();				// p1blk
        
//      notany (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        extern void p_nad();				// p1blk
        
//      notany (one character argument)
//      parm1                 character argument
//	align	2
//	db	bl_p1
        extern void p_nas();				// entry point
        
//      notany (multi-character string argument)
//      parm1                 pointer to ctblk
//      parm2                 bit mask to select bit column
//	align	2
//	db	bl_p2
        extern void p_nay();				// p2blk
//      expression argument case merges here
// pnay1:
        extern void pnay1();				// fail if no characters left
        
//      end of pattern match
//      this routine is entered on successful completion.
//      see description of expression patterns in compound
//      pattern section for handling of recursion in matching.
//      this pattern also results from an attempt to convert the
//      null string to a pattern via convert()
//      no parameters (dummy pattern)
//	align	2
//	db	bl_p0
        extern void p_nth();				// p0blk (dummy)
//      here we are at the end of matching an expression pattern
//      here if no history stack entries during pattern
// pnth1:
        extern void pnth1();				// remove p_exb entry and node ptr
//      here if end of match at outer level
// pnth2:
        extern void pnth2();				// save final cursor in safe place
        
//      end of pattern match (continued)
//      now we must perform pattern assignments. this is done by
//      scanning the history stack for matching ndpab-ndpad pairs
// pnth3:
        extern void pnth3();				// point past cursor entry
//      here for ndpab entry, stack initial cursor
//      note that there must be more entries on the stack.
//      here for ndpad entry. the starting cursor from the
//      matching ndpad entry is now the top stack entry.
// pnth4:
        extern void pnth4();				// load final cursor
//      build substring and perform assignment
        
//      end of pattern match (continued)
//      here check for end of entries
// pnth5:
        extern void pnth5();				// loop if more entries to scan
//      here after dealing with pattern assignments
// pnth6:
        extern void pnth6();				// wipe out history stack
//      here we have a call by value, build substring
//      here for call by name, make stack entries for o_rpl
// pnth7:
        extern void pnth7();				// stack initial cursor
//      here with xl pointing to scblk or bcblk
// pnth8:
        extern void pnth8();				// stack subject pointer
//      here to obey next code word
// pnth9:
        extern void pnth9();				// get next code word
        
//      pos (integer argument)
//      parm1                 integer argument
//	align	2
//	db	bl_p1
        extern void p_pos();				// p1blk
//      optimize pos if it is the first pattern element,
//      unanchored mode, cursor is zero and pos argument
//      is not beyond end of string.  force cursor position
//      and number of unanchored moves.
//      this optimization is performed invisible provided
//      the argument is either a simple integer or an
//      expression that is an untraced variable (that is,
//      it has no side effects that would be lost by short-
//      circuiting the normal logic of failing and moving the
//      unanchored starting point.)
//      pos (integer argument)
//      parm1                 integer argument
//      expression argument circuit merges here
// ppos2:
        extern void ppos2();				// fail if not unanchored mode
        
//      pos (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        extern void p_psd();				// p1blk
// ppos1:
        extern void ppos1();				// succeed if at right location
        
//      pattern assignment (initial entry, save cursor)
//      see compound patterns description for the structure and
//      algorithms for matching this node type.
//      no parameters
//	align	2
//	db	bl_p0
        extern void p_paa();				// p0blk
        
//      pattern assignment (remove saved cursor)
//      see compound patterns description for the structure and
//      algorithms for matching this node type.
//      no parameters (dummy pattern)
//	align	2
//	nop
        extern void p_pab();				// entry point
        
//      pattern assignment (end of match, make assign entry)
//      see compound patterns description for the structure and
//      algorithms for matching this node type.
//      parm1                 name base of variable
//      parm2                 name offset of variable
//	align	2
//	db	bl_p2
        extern void p_pac();				// p2blk
        
//      pattern assignment (remove assign entry)
//      see compound patterns description for the structure and
//      algorithms for matching this node type.
//      no parameters (dummy node)
//	align	2
//	nop
        extern void p_pad();				// entry point
        
//      rem
//      no parameters
//	align	2
//	db	bl_p0
        extern void p_rem();				// p0blk
        
//      rpos (expression argument)
//      optimize rpos if it is the first pattern element,
//      unanchored mode, cursor is zero and rpos argument
//      is not beyond end of string.  force cursor position
//      and number of unanchored moves.
//      this optimization is performed invisibly provided
//      the argument is either a simple integer or an
//      expression that is an untraced variable (that is,
//      it has no side effects that would be lost by short-
//      circuiting the normal logic of failing and moving the
//      unanchored starting point).
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        extern void p_rpd();				// p1blk
// prps1:
        extern void prps1();				// get length of string
        
//      rpos (integer argument)
//      parm1                 integer argument
//	align	2
//	db	bl_p1
        extern void p_rps();				// p1blk
//      rpos (integer argument)
//      parm1                 integer argument
//      expression argument merges here
// prps2:
        extern void prps2();				// fail if not unanchored mode
        
//      rtab (integer argument)
//      parm1                 integer argument
//	align	2
//	db	bl_p1
        extern void p_rtb();				// p1blk
//      expression argument case merges here
// prtb1:
        extern void prtb1();				// save initial cursor
        
//      rtab (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        extern void p_rtd();				// p1blk
        
//      span (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        extern void p_spd();				// p1blk
        
//      span (multi-character argument case)
//      parm1                 pointer to ctblk
//      parm2                 bit mask to select bit column
//	align	2
//	db	bl_p2
        extern void p_spn();				// p2blk
//      expression argument case merges here
// pspn1:
        extern void pspn1();				// copy subject string length
//      loop to scan matching characters
// pspn2:
        extern void pspn2();				// load next character, bump pointer
//      here after scanning matching characters
// pspn3:
        extern void pspn3();				// succeed if chars matched
        
//      span (one character argument)
//      parm1                 character argument
//	align	2
//	db	bl_p1
        extern void p_sps();				// p1blk
//      loop to scan matching characters
// psps1:
        extern void psps1();				// load next character, bump pointer
//      here after scanning matching characters
// psps2:
        extern void psps2();				// succeed if chars matched
        
//      multi-character string
//      note that one character strings use the circuit for
//      one character any arguments (p_an1).
//      parm1                 pointer to scblk for string arg
//	align	2
//	db	bl_p1
        extern void p_str();				// p1blk
//      merge here after evaluating expression with string value
// pstr1:
        extern void pstr1();				// save node pointer
        
//      succeed
//      see section on compound patterns for details of the
//      structure and algorithms for matching this node type
//      no parameters
//	align	2
//	db	bl_p0
        extern void p_suc();				// p0blk
        
//      tab (integer argument)
//      parm1                 integer argument
//	align	2
//	db	bl_p1
        extern void p_tab();				// p1blk
//      expression argument case merges here
// ptab1:
        extern void ptab1();				// fail if too far already
        
//      tab (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        extern void p_tbd();				// p1blk
        
//      anchor movement
//      no parameters (dummy node)
//	align	2
//	nop
        extern void p_una();				// entry point
        
//      end of pattern match routines
//      the following entry point marks the end of the pattern
//      matching routines and also the end of the entry points
//      referenced from the first word of blocks in dynamic store
//	align	2
//	db	bl__i
        extern void p_yyy();				// mark last entry in pattern section
//      the following section contains the routines for labels
//      which have a predefined meaning in snobol4.
//      control is passed directly to the label name entry point.
//      entry names are of the form l_xxx where xxx is the three
//      letter variable name identifier.
//      entries are in alphabetical order
        
//      abort
//	align	2
//	nop
        extern void l_abo();				// entry point
//      merge here if execution terminates in error
// labo1:
        extern void labo1();				// load error code
// labo2:
        extern void labo2();				// print error message
//      here if no error had occured
// labo3:
        extern void labo3();
        
//      continue
//	align	2
//	nop
        extern void l_cnt();				// entry point
//      merge here after execution error
// lcnt1:
        extern void lcnt1();				// load continuation code block ptr
//      here if error did not occur in complex failure goto
// lcnt2:
        extern void lcnt2();				// add failure offset
//      here if no previous error
// lcnt3:
        extern void lcnt3();				// fatal error
//      here if error in evaluation of failure goto.
//      cannot continue back to failure goto!
// lcnt4:
        extern void lcnt4();				// fatal error
        
//      end
//	align	2
//	nop
        extern void l_end();				// entry point
//      merge here from end code circuit
// lend0:
        extern void lend0();				// point to message /normal term.../
        
//      freturn
//	align	2
//	nop
        extern void l_frt();				// entry point
        
//      nreturn
//	align	2
//	nop
        extern void l_nrt();				// entry point
        
//      return
//	align	2
//	nop
        extern void l_rtn();				// entry point
        
//      scontinue
//	align	2
//	nop
        extern void l_scn();				// entry point
//      here if no user interrupt
// lscn1:
        extern void lscn1();				// fatal error
//      here if in scontinue loop or if no previous error
// lscn2:
        extern void lscn2();				// fatal error
        
//      undefined label
//	align	2
//	nop
        extern void l_und();				// entry point
//      the following section contains coding for functions
//      which are predefined and available at the snobol level.
//      these routines receive control directly from the code or
//      indirectly through the o_fnc, o_fns or cfunc routines.
//      in both cases the conditions on entry are as follows
//      the arguments are on the stack. the number of arguments
//      has been adjusted to correspond to the svblk svnar field.
//      in certain functions the direct call is not permitted
//      and in these instances we also have.
//      (wa)                  actual number of arguments in call
//      control returns by placing the function result value on
//      on the stack and continuing execution with the next
//      word from the generated code.
//      the names of the entry points of these functions are of
//      the form s_xxx where xxx is the three letter code for
//      the system variable name. the functions are in order
//      alphabetically by their entry names.
        
//      any
//	align	2
//	nop
        extern void s_any();				// entry point
        
//      apply
//      apply does not permit the direct (fast) call so that
//      wa contains the actual number of arguments passed.
//	align	2
//	nop
        extern void s_app();				// entry point
//      loop to move arguments up on stack
// sapp1:
        extern void sapp1();				// point to next argument
//      merge here to call function (wa = number of arguments)
// sapp2:
        extern void sapp2();				// adjust stack ptr for apply 1st arg
//      here for invalid first argument
// sapp3:
        extern void sapp3();
        
//      arbno
//      arbno builds a compound pattern. see description at
//      start of pattern matching section for structure formed.
//	align	2
//	nop
        extern void s_abn();				// entry point
        
//      arg
//	align	2
//	nop
        extern void s_arg();				// entry point
//      here if 1st argument is bad
// sarg1:
        extern void sarg1();
        
//      array
//	align	2
//	nop
        extern void s_arr();				// entry point
//      here for integer first argument, build vcblk
        
//      array (continued)
//      here if first argument is not an integer
// sar02:
        extern void sar02();				// replace argument on stack
//      the following code is executed twice. the first time
//      (arptr eq 0), it is used to count the number of elements
//      and number of dimensions. the second time (arptr gt 0) is
//      used to actually fill in the dim,lbd fields of the arblk.
// sar03:
        extern void sar03();				// load one as default low bound
//      here we have a colon ending a low bound
        
//      array (continued)
//      merge here to process upper bound
// sar04:
        extern void sar04();				// convert high bound to integer
//      here in second pass to store lbd and dim in arblk
//      here in pass 1
// sar05:
        extern void sar05();				// bump dimension count
//      merge here after processing one set of bounds
// sar06:
        extern void sar06();				// loop back unless end of bounds
        
//      array (continued)
//      here at end of pass one, build arblk
//      loop to allow space for dimensions
// sar07:
        extern void sar07();				// allow space for one set of bounds
//      now allocate space for arblk
//      loop to clear entire arblk to default value
// sar08:
        extern void sar08();				// set one word
        
//      array (continued)
//      now set initial fields of arblk
//      here after filling in bounds information (end pass two)
// sar09:
        extern void sar09();				// reload pointer to arblk
//      here for bad dimension
// sar10:
        extern void sar10();
//      here if array is too large
// sar11:
        extern void sar11();
        
//      atan
//	align	2
//	nop
        extern void s_atn();				// entry point
        
        
//      backspace
//	align	2
//	nop
        extern void s_bsp();				// entry point
        
//      break
//	align	2
//	nop
        extern void s_brk();				// entry point
        
//      breakx
//      breakx is a compound pattern. see description at start
//      of pattern matching section for structure formed.
//	align	2
//	nop
        extern void s_bkx();				// entry point
//      now hook breakx node on at front end
        
//      char
//	align	2
//	nop
        extern void s_chr();				// entry point
//      here if char argument is out of range
// schr1:
        extern void schr1();
        
//      chop
//	align	2
//	nop
        extern void s_chp();				// entry point
        
//      clear
//	align	2
//	nop
        extern void s_clr();				// entry point
//      loop to scan out names in first argument. variables in
//      the list are flagged by setting vrget of vrblk to zero.
// sclr1:
        extern void sclr1();				// set delimiter one = comma
//      here after flagging variables in argument list
// sclr2:
        extern void sclr2();				// point to start of hash table
//      loop through slots in hash table
// sclr3:
        extern void sclr3();				// exit returning null if none left
//      loop through vrblks on one hash chain
// sclr4:
        extern void sclr4();				// point to next vrblk on chain
        
//      clear (continued)
//      here for flagged variable, do not set value to null
//      here to set value of a variable to null
//      protected variables (arb, etc) are exempt
// sclr5:
        extern void sclr5();				// check for protected variable
//      loop to locate value at end of possible trblk chain
// sclr6:
        extern void sclr6();				// save block pointer
//      now store the null value
        
//      code
//	align	2
//	nop
        extern void s_cod();				// entry point
        
//      collect
//	align	2
//	nop
        extern void s_col();				// entry point
        
//      convert
//	align	2
//	nop
        extern void s_cnv();				// entry point
//      here for program defined datatype
//      here if not program defined datatype
// scv01:
        extern void scv01();				// save string argument
//      loop through table entries
// scv02:
        extern void scv02();				// load next table entry, bump pointer
        
//      convert (continued)
//      here we have a match
// scv03:
        extern void scv03();				// copy entry number
//      here if no match with table entry
// scv04:
        extern void scv04();				// restore table pointer, merge
//      merge here if lengths did not match
// scv05:
        extern void scv05();				// bump entry number
//      here to convert to string
// scv06:
        extern void scv06();				// replace string argument on stack
        
//      convert (continued)
//      here to convert to integer
// scv07:
        extern void scv07();				// convert to integer
//      here to convert to real
// scv08:
        extern void scv08();				// convert to real
//      here to convert to name
// scv09:
        extern void scv09();				// return if already a name
//      here to convert to pattern
// scv10:
        extern void scv10();				// convert to pattern
//      convert to array
//      if the first argument is a table, then we go through
//      an intermediate array of addresses that is sorted to
//      provide a result ordered by time of entry in the
//      original table.  see c3.762.
// scv11:
        extern void scv11();				// save argument on stack
//      here for each row of this 2-column array
// scv12:
        extern void scv12();				// get teblk address
//      convert to table
// scv19:
        extern void scv19();				// load first word of block
        
//      convert (continued)
//      here to convert an array to table
//      here we have an arblk of the right shape
//      loop to initialize bucket ptrs to point to table
// scv20:
        extern void scv20();				// set bucket ptr to point to tbblk
//      loop to copy elements from array to table
// scv21:
        extern void scv21();				// point to arblk
        
//      convert (continued)
//      loop to chase down trblk chain for value
// scv22:
        extern void scv22();				// point to next value
//      here with name in xr, value in xl
// scv23:
        extern void scv23();				// stack value
//      here after moving all elements to tbblk
// scv24:
        extern void scv24();				// load tbblk pointer
//      convert to expression
// scv25:
        extern void scv25();				// by value
//      convert to code
// scv26:
        extern void scv26();				// convert to code
//      convert to numeric
// scv27:
        extern void scv27();				// convert to numeric
// scv31:
        extern void scv31();				// stack result
        
//      second argument not string or null
// scv29:
        extern void scv29();
//      copy
//	align	2
//	nop
        extern void s_cop();				// entry point
        
//      cos
//	align	2
//	nop
        extern void s_cos();				// entry point
        
//      data
//	align	2
//	nop
        extern void s_dat();				// entry point
//      scan out datatype name
//      here after scanning datatype name
// sdat1:
        extern void sdat1();				// save name ptr
//      loop to scan field names and stack vrblk pointers
// sdat2:
        extern void sdat2();				// delimiter one = right paren
//      here after scanning out one field name
// sdat3:
        extern void sdat3();				// locate vrblk for field name
        
//      data (continued)
//      now build the dfblk
//      loop to move field name vrblk pointers to dfblk
// sdat4:
        extern void sdat4();				// move one field name vrblk pointer
//      now define the datatype function
        
//      data (continued)
//      loop to build ffblks
//      notice that the ffblks are constructed in reverse order
//      so that the required offsets can be obtained from
//      successive decrementation of the pdblk length (in wc).
// sdat5:
        extern void sdat5();				// set length of ffblk
//      here we must chain an old ffblk ptr to preserve it in the
//      case of multiple field functions with the same name
//      merge here to define field function
// sdat6:
        extern void sdat6();				// load vrblk pointer
        
//      datatype
//	align	2
//	nop
        extern void s_dtp();				// entry point
        
//      date
//	align	2
//	nop
        extern void s_dte();				// entry point
        
//      define
//	align	2
//	nop
        extern void s_def();				// entry point
//      scan function name
// sdf01:
        extern void sdf01();				// prepare to scan first argument
//      here after scanning out function name
// sdf02:
        extern void sdf02();				// get variable name
//      loop to scan argument names and stack vrblk pointers
// sdf03:
        extern void sdf03();				// delimiter one = right paren
        
//      define (continued)
//      here after scanning an argument name
// sdf04:
        extern void sdf04();				// skip if non-null
//      here after dealing with the case of no arguments
// sdf05:
        extern void sdf05();				// get vrblk pointer
//      here after scanning out function argument names
// sdf06:
        extern void sdf06();				// save number of arguments
//      loop to scan local names and stack vrblk pointers
// sdf07:
        extern void sdf07();				// set delimiter one = comma
//      here after scanning out a local name
// sdf08:
        extern void sdf08();				// get vrblk pointer
        
//      define (continued)
//      here after scanning locals, build pfblk
// sdf09:
        extern void sdf09();				// copy count of locals
//      loop to move locals and args to pfblk
// sdf10:
        extern void sdf10();				// store one entry and bump pointers
        
//      define (continued)
//      now deal with label
// sdf11:
        extern void sdf11();				// pop stack
//      here for erroneous label
// sdf12:
        extern void sdf12();
        
//      detach
//	align	2
//	nop
        extern void s_det();				// entry point
        
//      differ
//	align	2
//	nop
        extern void s_dif();				// entry point
        
//      dump
//	align	2
//	nop
        extern void s_dmp();				// entry point
        
//      dupl
//	align	2
//	nop
        extern void s_dup();				// entry point
//      here for case of duplication of a string
//      merge here with result length in wa
// sdup1:
        extern void sdup1();				// save string pointer
//      loop through duplications
// sdup2:
        extern void sdup2();				// point back to argument string
        
//      dupl (continued)
//      here if too large, set max length and let alocs catch it
// sdup3:
        extern void sdup3();				// set impossible length for alocs
//      here if not a string
// sdup4:
        extern void sdup4();				// convert argument to pattern
//      here to duplicate a pattern argument
//      loop to duplicate by successive concatenation
// sdup5:
        extern void sdup5();				// copy current value as right argumnt
//      here to exit after constructing pattern
// sdup6:
        extern void sdup6();				// store result on stack
//      fail if second arg is out of range
// sdup7:
        extern void sdup7();				// pop first argument
        
//      eject
//	align	2
//	nop
        extern void s_ejc();				// entry point
//      here to eject standard output file
// sejc1:
        extern void sejc1();				// call routine to eject printer
        
//      endfile
//	align	2
//	nop
        extern void s_enf();				// entry point
//      loop to find trtrf block
// senf1:
        extern void senf1();				// remember previous entry
//      find fcblk
// senf2:
        extern void senf2();				// copy ptr
//      remove fcblk
// senf3:
        extern void senf3();				// delete fcblk from chain
//      loop which detaches all vbls on iochn chain
// senf4:
        extern void senf4();				// get chain head
        
//      eq
//	align	2
//	nop
        extern void s_eqf();				// entry point
        
//      eval
//	align	2
//	nop
        extern void s_evl();				// entry point
//      here if called by value
// sevl1:
        extern void sevl1();				// set flag for by value
//      here if called by name
// sevl2:
        extern void sevl2();				// set flag for by name
        
//      exit
//	align	2
//	nop
        extern void s_ext();				// entry point
//      merge to call osint exit routine
// sext1:
        extern void sext1();				// get fcblk chain header
//      check for option respecification
//      sysxi returns 0 in wa when a file has been resumed,
//      1 when this is a continuation of an exit(4) or exit(-4)
//      action.
// sext2:
        extern void sext2();				// get value in work reg
//      deal with header option (fiddled by prpar)
// sext3:
        extern void sext3();				// assume no headers
//      almost ready to resume running
// sext4:
        extern void sext4();				// get execution time start (sgd11)
//      here after exit(4) or exit(-4) -- create save file
//      or load module and continue execution.
//      return integer 1 to signal the continuation of the
//      original execution.
// sext5:
        extern void sext5();				// integer one
        
//      exp
//	align	2
//	nop
        extern void s_exp();				// entry point
        
//      field
//	align	2
//	nop
        extern void s_fld();				// entry point
//      here if first argument is a datatype function name
//      here for bad first argument
// sfld1:
        extern void sfld1();
        
//      fence
//	align	2
//	nop
        extern void s_fnc();				// entry point
        
//      ge
//	align	2
//	nop
        extern void s_gef();				// entry point
        
//      gt
//	align	2
//	nop
        extern void s_gtf();				// entry point
        
//      host
//	align	2
//	nop
        extern void s_hst();				// entry point
//      return host string
// shst1:
        extern void shst1();				// null string if syshs uncooperative
//      copy string and return
// shst2:
        extern void shst2();				// build copy of string
//      return actual string pointed to by xl
// shst3:
        extern void shst3();				// treat xl like an scblk ptr
//      return copy of block pointed to by xr
// shst4:
        extern void shst4();				// stack results
        
//      ident
//	align	2
//	nop
        extern void s_idn();				// entry point
        
//      input
//	align	2
//	nop
        extern void s_inp();				// entry point
        
//      integer
//	align	2
//	nop
        extern void s_int();				// entry point
        
//      item
//      item does not permit the direct (fast) call so that
//      wa contains the actual number of arguments passed.
//	align	2
//	nop
        extern void s_itm();				// entry point
//      deal with case of no args
//      check for name/value cases
// sitm1:
        extern void sitm1();				// get current code pointer
//      here if called by value
//      here for call by name
// sitm2:
        extern void sitm2();				// set code for call by name
        
//      le
//	align	2
//	nop
        extern void s_lef();				// entry point
        
//      len
//	align	2
//	nop
        extern void s_len();				// entry point
        
//      leq
//	align	2
//	nop
        extern void s_leq();				// entry point
        
//      lge
//	align	2
//	nop
        extern void s_lge();				// entry point
        
//      lgt
//	align	2
//	nop
        extern void s_lgt();				// entry point
        
//      lle
//	align	2
//	nop
        extern void s_lle();				// entry point
        
//      llt
//	align	2
//	nop
        extern void s_llt();				// entry point
        
//      lne
//	align	2
//	nop
        extern void s_lne();				// entry point
        
//      ln
//	align	2
//	nop
        extern void s_lnf();				// entry point
// slnf1:
        extern void slnf1();
//      here for bad argument
// slnf2:
        extern void slnf2();
        
//      local
//	align	2
//	nop
        extern void s_loc();				// entry point
//      here if we have a program defined function name
//      here if first argument is no good
// sloc1:
        extern void sloc1();
        
//      load
//	align	2
//	nop
        extern void s_lod();				// entry point
//      here after successfully scanning function name
// slod1:
        extern void slod1();				// locate vrblk
//      loop to scan argument datatype names
// slod2:
        extern void slod2();				// delimiter one is right paren
        
//      load (continued)
//      come here to analyze the datatype pointer in (xr). this
//      code is used both for arguments (wa=1,2) and for the
//      result datatype (with wa set to zero).
// slod3:
        extern void slod3();				// stack datatype name pointer
//      merge here with proper datatype code in wb
// slod4:
        extern void slod4();				// store code on stack
//      here we scan out the result type (arg stopped by ) )
        
//      load (continued)
//      here after processing all args and result
// slod5:
        extern void slod5();				// get number of arguments
//      loop to set argument type codes from stack
// slod6:
        extern void slod6();				// store one type code from stack
//      now load the external function and perform definition
        
//      lpad
//	align	2
//	nop
        extern void s_lpd();				// entry point
//      merge to check first arg
// slpd1:
        extern void slpd1();				// get first argument (string to pad)
//      now we are ready for the pad
//      (xl)                  pointer to string to pad
//      (wb)                  pad character
//      (wc)                  length to pad string to
//      loop to perform pad
// slpd2:
        extern void slpd2();				// store pad character, bump ptr
//      now copy string
//      here to exit with result on stack
// slpd3:
        extern void slpd3();				// load next code word
//      here if 2nd arg is negative or large
// slpd4:
        extern void slpd4();				// zero pad count
        
//      lt
//	align	2
//	nop
        extern void s_ltf();				// entry point
        
//      ne
//	align	2
//	nop
        extern void s_nef();				// entry point
        
//      notany
//	align	2
//	nop
        extern void s_nay();				// entry point
        
//      opsyn
//	align	2
//	nop
        extern void s_ops();				// entry point
//      here for function opsyn (third arg zero)
//      merge here to perform function definition
// sops1:
        extern void sops1();				// call function definer
//      here for operator opsyn (third arg non-zero)
// sops2:
        extern void sops2();				// get operator name
        
//      opsyn (continued)
//      now set to search for matching unary or binary operator
//      name as appropriate. note that there are =opbun undefined
//      binary operators and =opuun undefined unary operators.
//      merge here to check list (wb = number to check)
// sops3:
        extern void sops3();				// set counter to control loop
//      loop to search for name match
// sops4:
        extern void sops4();				// jump if names match
//      here if bad operator name
// sops5:
        extern void sops5();
//      come here on finding a match in the operator name table
// sops6:
        extern void sops6();				// copy pointer to function block ptr
        
//      output
//	align	2
//	nop
        extern void s_oup();				// entry point
        
//      pos
//	align	2
//	nop
        extern void s_pos();				// entry point
        
//      prototype
//	align	2
//	nop
        extern void s_pro();				// entry point
//      here for table
// spro1:
        extern void spro1();				// subtract standard fields
//      merge for vector
// spro2:
        extern void spro2();				// convert to integer
//      here for vector
// spro3:
        extern void spro3();				// subtract standard fields
//      here for array
// spro4:
        extern void spro4();				// point to prototype field
        
//      remdr
//	align	2
//	nop
        extern void s_rmd();				// entry point
//      both arguments integer
// srm01:
        extern void srm01();				// get remainder
//      make sign of result match sign of first argument
// srm02:
        extern void srm02();				// adjust sign of result
// srm03:
        extern void srm03();				// should be pos, and result negative
//      fail first argument
// srm04:
        extern void srm04();
//      fail if overflow
// srm05:
        extern void srm05();
//      here with 1st argument in (xr), 2nd in (xl), both real
//      result = n1 - chop(n1/n2)*n2
// srm06:
        extern void srm06();				// set positive flag
// srm07:
        extern void srm07();				// compute n1/n2
//      make sign of result match sign of first argument
//      -result is in ra at this point
// srm08:
        extern void srm08();				// adjust sign of result
// srm09:
        extern void srm09();				// should be pos, and result negative
//      fail if overflow
// srm10:
        extern void srm10();
        
//      replace
//      the actual replace operation uses an scblk whose cfp_a
//      chars contain the translated versions of all the chars.
//      the table pointer is remembered from call to call and
//      the table is only built when the arguments change.
//      we also perform an optimization gleaned from spitbol 370.
//      if the second argument is &alphabet, there is no need to
//      to build a replace table.  the third argument can be
//      used directly as the replace table.
//	align	2
//	nop
        extern void s_rpl();				// entry point
//      check to see if this is the same table as last time
//      here we build a new replace table (note wa = 2nd arg len)
// srpl1:
        extern void srpl1();				// load 3rd argument length
//      here we allocate a new table
//      merge here with pointer to new table block in (xr)
// srpl2:
        extern void srpl2();				// compute length of scblk
        
//      replace (continued)
//      now we must plug selected entries as required. note that
//      we are short of index registers for the following loop.
//      hence the need to repeatedly re-initialise char ptr xl
//      loop to plug chars
// srpl3:
        extern void srpl3();				// point to 2nd arg
        
//      replace (continued)
//      here to use r_rpt as replace table.
// srpl4:
        extern void srpl4();				// replace table to use
//      here to perform translate using table in xl.
// srpl5:
        extern void srpl5();				// get first argument
// srpl8:
        extern void srpl8();				// stack result
//      error point
// srpl6:
        extern void srpl6();
        
//      rewind
//	align	2
//	nop
        extern void s_rew();				// entry point
        
//      reverse
//	align	2
//	nop
        extern void s_rvs();				// entry point
//      loop to move chars in reverse order
// srvs1:
        extern void srvs1();				// load next char from argument
//      here when complete to execute next code word
// srvs4:
        extern void srvs4();				// complete store characters
// srvs2:
        extern void srvs2();				// load next code word
        
//      rpad
//	align	2
//	nop
        extern void s_rpd();				// entry point
//      merge to check first arg.
// srpd1:
        extern void srpd1();				// get first argument (string to pad)
//      now we are ready for the pad
//      (xl)                  pointer to string to pad
//      (wb)                  pad character
//      (wc)                  length to pad string to
//      copy argument string
//      loop to supply pad characters
// srpd2:
        extern void srpd2();				// store pad character, bump ptr
//      here if 2nd arg is negative or large
// srpd3:
        extern void srpd3();				// zero pad count
        
//      rtab
//	align	2
//	nop
        extern void s_rtb();				// entry point
        
//      tab
//	align	2
//	nop
        extern void s_tab();				// entry point
        
//      rpos
//	align	2
//	nop
        extern void s_rps();				// entry point
        
//      rsort
//	align	2
//	nop
        extern void s_rsr();				// entry point
        
//      setexit
//	align	2
//	nop
        extern void s_stx();				// entry point
//      here to set/reset setexit trap
// sstx1:
        extern void sstx1();				// store new vrblk pointer (or null)
//      here if bad argument
// sstx2:
        extern void sstx2();
//      sin
//	align	2
//	nop
        extern void s_sin();				// entry point
        
//      sqrt
//	align	2
//	nop
        extern void s_sqr();				// entry point
//      here if bad argument
// ssqr1:
        extern void ssqr1();
        
        
//      sort
//	align	2
//	nop
        extern void s_srt();				// entry point
        
//      span
//	align	2
//	nop
        extern void s_spn();				// entry point
        
//      size
//	align	2
//	nop
        extern void s_si_();				// entry point
//      merge with bfblk or scblk ptr in xr.  wa has length.
        
//      stoptr
//	align	2
//	nop
        extern void s_stt();				// entry point
        
//      substr
//	align	2
//	nop
        extern void s_sub();				// entry point
//      merge with bfblk or scblk ptr in xr.  wa has length
//      merge
// ssub2:
        extern void ssub2();				// save string length
        
//      table
//	align	2
//	nop
        extern void s_tbl();				// entry point
//      merge here with number of headers in wc
// stbl1:
        extern void stbl1();				// make table
        
//      tan
//	align	2
//	nop
        extern void s_tan();				// entry point
        
//      time
//	align	2
//	nop
        extern void s_tim();				// entry point
        
//      trace
//	align	2
//	nop
        extern void s_tra();				// entry point
//      here with vrblk or zero in xl
// str01:
        extern void str01();				// load third argument (tag)
//      here to call system trace toggle routine
// str02:
        extern void str02();				// call it
//      here for bad fourth argument
// str03:
        extern void str03();
        
//      trim
//	align	2
//	nop
        extern void s_trm();				// entry point
        
//      unload
//	align	2
//	nop
        extern void s_unl();				// entry point
//      the following section contains utility routines used for
//      various purposes throughout the system. these differ
//      from the procedures in the utility procedures section in
//      they are not in procedure form and they do not return
//      to their callers. they are accessed with a branch type
//      instruction after setting the registers to appropriate
//      parameter values.
//      the register values required for each routine are
//      documented at the start of each routine. registers not
//      mentioned may contain any values except that xr,xl
//      can only contain proper collectable pointers.
//      some of these routines will tolerate garbage pointers
//      in xl,xr on entry. this is always documented and in
//      each case, the routine clears these garbage values before
//      exiting after completing its task.
//      the routines have names consisting of five letters
//      and are assembled in alphabetical order.
        
//      arref -- array reference
//      (xl)                  may be non-collectable
//      (xr)                  number of subscripts
//      (wb)                  set zero/nonzero for value/name
//                            the value in wb must be collectable
//      stack                 subscripts and array operand
//      brn  arref            jump to call function
//      arref continues by executing the next code word with
//      the result name or value placed on top of the stack.
//      to deal with the problem of accessing subscripts in the
//      order of stacking, xl is used as a subscript pointer
//      working below the stack pointer.
// arref:
        extern void arref();
//      here for array (arblk)
// arf01:
        extern void arf01();				// jump if wrong number of dims
//      loop to compute subscripts by multiplications
// arf02:
        extern void arf02();				// multiply total by next dimension
//      merge here first time
// arf03:
        extern void arf03();				// load next subscript
        
//      arref (continued)
//      here with integer subscript in (ia)
// arf04:
        extern void arf04();				// point to array
//      here with integer subscript computed
//      merge here to get value for value call
// arf05:
        extern void arf05();				// get value
//      return value
// arf06:
        extern void arf06();				// pop stack entries
        
//      arref (continued)
//      here for vector
// arf07:
        extern void arf07();				// error if more than 1 subscript
//      return name
// arf08:
        extern void arf08();				// pop stack entries
//      here if subscript count is wrong
// arf09:
        extern void arf09();
//      table
// arf10:
        extern void arf10();				// error if more than 1 subscript
//      here for bad table reference
// arf11:
        extern void arf11();
//      here for bad subscript
// arf12:
        extern void arf12();
//      here to signal failure
// arf13:
        extern void arf13();				// finished with array pointer
        
//      cfunc -- call a function
//      cfunc is used to call a snobol level function. it is
//      used by the apply function (s_app), the function
//      trace routine (trxeq) and the main function call entry
//      (o_fnc, o_fns). in the latter cases, cfunc is used only
//      if the number of arguments is incorrect.
//      (xl)                  pointer to function block
//      (wa)                  actual number of arguments
//      (xs)                  points to stacked arguments
//      brn  cfunc            jump to call function
//      cfunc continues by executing the function
// cfunc:
        extern void cfunc();
//      here if too many arguments supplied, pop them off
//      here if too few arguments
// cfnc1:
        extern void cfnc1();				// load required number of arguments
//      loop to supply extra null arguments
// cfnc2:
        extern void cfnc2();				// stack a null argument
//      merge here to jump to function
// cfnc3:
        extern void cfnc3();				// jump through fcode field
        
//      exfal -- exit signalling snobol failure
//      (xl,xr)               may be non-collectable
//      brn  exfal            jump to fail
//      exfal continues by executing the appropriate fail goto
// exfal:
        extern void exfal();
        
//      exint -- exit with integer result
//      (xl,xr)               may be non-collectable
//      (ia)                  integer value
//      brn  exint            jump to exit with integer
//      exint continues by executing the next code word
//      which it does by falling through to exixr
// exint:
        extern void exint();
        
//      exixr -- exit with result in (xr)
//      (xr)                  result
//      (xl)                  may be non-collectable
//      brn  exixr            jump to exit with result in (xr)
//      exixr continues by executing the next code word
//      which it does by falling through to exits.
// exixr:
        extern void exixr();
//      exits -- exit with result if any stacked
//      (xr,xl)               may be non-collectable
//      brn  exits            enter exits routine
// exits:
        extern void exits();
        
//      exnam -- exit with name in (xl,wa)
//      (xl)                  name base
//      (wa)                  name offset
//      (xr)                  may be non-collectable
//      brn  exnam            jump to exit with name in (xl,wa)
//      exnam continues by executing the next code word
// exnam:
        extern void exnam();
        
//      exnul -- exit with null result
//      (xl,xr)               may be non-collectable
//      brn  exnul            jump to exit with null value
//      exnul continues by executing the next code word
// exnul:
        extern void exnul();
        
//      exrea -- exit with real result
//      (xl,xr)               may be non-collectable
//      (ra)                  real value
//      brn  exrea            jump to exit with real value
//      exrea continues by executing the next code word
// exrea:
        extern void exrea();
        
//      exsid -- exit setting id field
//      exsid is used to exit after building any of the following
//      blocks (arblk, tbblk, pdblk, vcblk). it sets the idval.
//      (xr)                  ptr to block with idval field
//      (xl)                  may be non-collectable
//      brn  exsid            jump to exit after setting id field
//      exsid continues by executing the next code word
// exsid:
        extern void exsid();
//      here with old idval in wa
// exsi1:
        extern void exsi1();				// bump id value
        
//      exvnm -- exit with name of variable
//      exvnm exits after stacking a value which is a nmblk
//      referencing the name of a given natural variable.
//      (xr)                  vrblk pointer
//      (xl)                  may be non-collectable
//      brn  exvnm            exit with vrblk pointer in xr
// exvnm:
        extern void exvnm();
        
//      flpop -- fail and pop in pattern matching
//      flpop pops the node and cursor on the stack and then
//      drops through into failp to cause pattern failure
//      (xl,xr)               may be non-collectable
//      brn  flpop            jump to fail and pop stack
// flpop:
        extern void flpop();
        
//      failp -- failure in matching pattern node
//      failp is used after failing to match a pattern node.
//      see pattern match routines for details of use.
//      (xl,xr)               may be non-collectable
//      brn  failp            signal failure to match
//      failp continues by matching an alternative from the stack
// failp:
        extern void failp();
        
//      indir -- compute indirect reference
//      (wb)                  nonzero/zero for by name/value
//      brn  indir            jump to get indirect ref on stack
//      indir continues by executing the next code word
// indir:
        extern void indir();
//      here to get value of natural variable
// indr1:
        extern void indr1();				// jump through vrget field of vrblk
//      here if operand is a name
// indr2:
        extern void indr2();				// load name base
        
//      match -- initiate pattern match
//      (wb)                  match type code
//      brn  match            jump to initiate pattern match
//      match continues by executing the pattern match. see
//      pattern match routines (p_xxx) for full details.
// match:
        extern void match();
//      merge here with subject value on stack
// mtch1:
        extern void mtch1();				// convert subject to string
//      here for unanchored
//      here in anchored mode
// mtch2:
        extern void mtch2();				// dummy cursor value
        
//      retrn -- return from function
//      (wa)                  string pointer for return type
//      brn  retrn            jump to return from (snobol) func
//      retrn continues by executing the code at the return point
//      the stack is cleaned of any garbage left by other
//      routines which may have altered flptr since function
//      entry by using flprt, reserved for use only by
//      function call and return.
// retrn:
        extern void retrn();
//      here if not level zero return
// rtn01:
        extern void rtn01();				// pop stack
//      here if there may be a trace
        
//      retrn (continued)
//      here to test for ftrace
// rtn02:
        extern void rtn02();				// jump if ftrace is off
//      here for print trace of function return
// rtn03:
        extern void rtn03();				// print statement number
//      for freturn, just print function name
//      here for return or nreturn, print function name = value
// rtn04:
        extern void rtn04();				// print name = value
//      here after completing trace
// rtn05:
        extern void rtn05();				// pop pfblk pointer
//      merge here if no trace required
// rtn06:
        extern void rtn06();				// set rtntype keyword
        
//      retrn (continued)
//      get value of function
// rtn07:
        extern void rtn07();				// save block pointer
//      here if &profile = 1. start time must be frigged to
//      appear earlier than it actually is, by amount used before
//      the call.
//      here if &profile = 2
// rtn7a:
        extern void rtn7a();				// load saved time
//      both profile types merge here
// rtn7b:
        extern void rtn7b();				// store back correct start time
//      merge here if no profiling
// rtn7c:
        extern void rtn7c();				// get number of args
//      loop to restore functions and locals
// rtn08:
        extern void rtn08();				// load next vrblk pointer
//      loop to find value block
// rtn09:
        extern void rtn09();				// save block pointer
//      now restore function value and exit
// rtn10:
        extern void rtn10();				// restore ptr to last function block
        
//      retrn (continued)
//      here for nreturn
//      here if returned result is a name
// rtn11:
        extern void rtn11();				// load name base
//      merge here with returned name in (xl,wa)
// rtn12:
        extern void rtn12();				// preserve xl
        
//      stcov -- signal statement counter overflow
//      brn  stcov            jump to signal statement count oflo
//      permit up to 10 more statements to be obeyed so that
//      setexit trap can regain control.
//      stcov continues by issuing the error message
// stcov:
        extern void stcov();
        
//      stmgo -- start execution of new statement
//      (xr)                  pointer to cdblk for new statement
//      brn  stmgo            jump to execute new statement
//      stmgo continues by executing the next statement
// stmgo:
        extern void stmgo();
//      here to execute first code word of statement
// stgo1:
        extern void stgo1();				// load next code word
//      check profiling, polling, stlimit, statement tracing
// stgo2:
        extern void stgo2();				// skip if no profiling
//      here when finished with profiling
// stgo3:
        extern void stgo3();				// set lastno
//      here to check for polling
//      check statement limit
// stgo4:
        extern void stgo4();				// get stmt count
//      reset stmgo counter
// stgo5:
        extern void stgo5();				// reset counter
        
//      stopr -- terminate run
//      (xr)                  points to ending message
//      brn stopr             jump to terminate run
//      terminate run and print statistics.  on entry xr points
//      to ending message or is zero if message  printed already.
// stopr:
        extern void stopr();
// stpra:
        extern void stpra();				// use the reserve memory
//      look to see if an ending message is supplied
// stpr0:
        extern void stpr0();				// eject printer
//      merge here if no message to print
// stpr1:
        extern void stpr1();				// print blank line
// stpr5:
        extern void stpr5();				// get statement number
//      Only list peformance statistics giving stmts / millisec, etc.
//      if program ran for more than one millisecond.
        
//      stopr (continued)
//      merge to skip message (overflow or negative stlimit)
// stpr2:
        extern void stpr2();				// load count of collections
//      check if dump requested
// stpr3:
        extern void stpr3();				// print profile if wanted
//      here after sysea call and suppressing error msg print
// stpr4:
        extern void stpr4();
        
//      succp -- signal successful match of a pattern node
//      see pattern match routines for details
//      (xr)                  current node
//      (wb)                  current cursor
//      (xl)                  may be non-collectable
//      brn  succp            signal successful pattern match
//      succp continues by matching the successor node
// succp:
        extern void succp();
        
//      sysab -- print /abnormal end/ and terminate
// sysab:
        extern void sysab();
        
//      systu -- print /time up/ and terminate
// systu:
        extern void systu();
//      the following section contains procedures which are
//      used for various purposes throughout the system.
//      each procedure is preceded by a description of the
//      calling sequence. usually the arguments are in registers
//      but arguments can also occur on the stack and as
//      parameters assembled after the jsr instruction.
//      the following considerations apply to these descriptions.
//      1)   the stack pointer (xs) is not changed unless the
//           change is explicitly documented in the call.
//      2)   registers whose entry values are not mentioned
//           may contain any value except that xl,xr may only
//           contain proper (collectable) pointer values.
//           this condition on means that the called routine
//           may if it chooses preserve xl,xr by stacking.
//      3)   registers not mentioned on exit contain the same
//           values as they did on entry except that values in
//           xr,xl may have been relocated by the collector.
//      4)   registers which are destroyed on exit may contain
//           any value except that values in xl,xr are proper
//           (collectable) pointers.
//      5)   the code pointer register points to the current
//           code location on entry and is unchanged on exit.
//      in the above description, a collectable pointer is one
//      which either points outside the dynamic region or
//      points to the start of a block in the dynamic region.
//      in those cases where the calling sequence contains
//      parameters which are used as alternate return points,
//      these parameters may be replaced by error codes
//      assembled with the err instruction. this will result
//      in the posting of the error if the return is taken.
//      the procedures all have names consisting of five letters
//      and are in alphabetical order by their names.
        
//      acess - access variable value with trace/input checks
//      acess loads the value of a variable. trace and input
//      associations are tested for and executed as required.
//      acess also handles the special cases of pseudo-variables.
//      (xl)                  variable name base
//      (wa)                  variable name offset
//      jsr  acess            call to access value
//      ppm  loc              transfer loc if access failure
//      (xr)                  variable value
//      (wa,wb,wc)            destroyed
//      (xl,ra)               destroyed
//      failure can occur if an input association causes an end
//      of file condition or if the evaluation of an expression
//      associated with an expression variable fails.
// acess:
        extern void acess();				// entry point (recursive)
//      loop here to check for successive trblks
// acs02:
        extern void acs02();				// jump if not trapped
//      here if trapped
//      here for expression variable, evaluate variable
        
//      acess (continued)
//      here on reading end of file
// acs03:
        extern void acs03();				// pop trblk ptr, name base and offset
//      merge here when evaluation of expression fails
// acs04:
        extern void acs04();				// take alternate (failure) return
//      here if not keyword or expression variable
// acs05:
        extern void acs05();				// load trap type code
//      here for input association
//      here to read from standard input file
//      here for input from other than standard input file
// acs06:
        extern void acs06();				// fcblk ptr
// acs6a:
        extern void acs6a();				// allocate string of correct size
        
//      acess (continued)
//      merge here after obtaining input record
// acs07:
        extern void acs07();				// load trim indicator
//      loop to chase to end of trblk chain and store value
// acs08:
        extern void acs08();				// save pointer to this trblk
//      come here to move to next trblk
// acs09:
        extern void acs09();				// load forward ptr to next value
//      here to check for access trace trblk
// acs10:
        extern void acs10();				// loop back if not access trace
        
//      acess (continued)
//      here for full function trace
//      here for case of print trace
// acs11:
        extern void acs11();				// print statement number
//      here for keyword variable
// acs12:
        extern void acs12();				// load keyword number
//      common exit with keyword value as integer in (ia)
// acs13:
        extern void acs13();				// build icblk
//      here if not one word keyword value
// acs14:
        extern void acs14();				// jump if special case
//      here if special keyword case
// acs15:
        extern void acs15();				// load rtntype in case
        
//      acess (continued)
//      lcase
// acs24:
        extern void acs24();				// load pointer to lcase string
//      ucase
// acs25:
        extern void acs25();				// load pointer to ucase string
//      file
// acs26:
        extern void acs26();				// load current stmt number
//      lastfile
// acs27:
        extern void acs27();				// load last stmt number
//      merge here to map statement number in wc to file name
// acs28:
        extern void acs28();				// obtain file name for this stmt
//      alphabet
// acs16:
        extern void acs16();				// load pointer to alphabet string
//      rtntype merges here
// acs17:
        extern void acs17();				// copy string ptr to proper reg
//      common return point
// acs18:
        extern void acs18();				// return to acess caller
//      here for stcount (ia has stlimit)
// acs19:
        extern void acs19();				// if counting suppressed
// acs29:
        extern void acs29();				// stcount = limit - left
//      errtext
// acs20:
        extern void acs20();				// get errtext string
//      here to read a record from terminal
// acs21:
        extern void acs21();				// buffer length
//      error returns
// acs22:
        extern void acs22();				// pop unused scblk
// acs23:
        extern void acs23();				// pop unused scblk
        
//      acomp -- compare two arithmetic values
//      1(xs)                 first argument
//      0(xs)                 second argument
//      jsr  acomp            call to compare values
//      ppm  loc              transfer loc if arg1 is non-numeric
//      ppm  loc              transfer loc if arg2 is non-numeric
//      ppm  loc              transfer loc for arg1 lt arg2
//      ppm  loc              transfer loc for arg1 eq arg2
//      ppm  loc              transfer loc for arg1 gt arg2
//      (normal return is never given)
//      (wa,wb,wc,ia,ra)      destroyed
//      (xl,xr)               destroyed
// acomp:
        extern void acomp();				// entry point
        #define P_PRC_ACOMP 0
        #define P_PRCLEN_ACOMP 5
//      here for integer arguments
//      here if arg1 gt arg2
// acmp1:
        extern void acmp1();				// take gt exit
//      here if arg1 eq arg2
// acmp2:
        extern void acmp2();				// take eq exit
        
//      acomp (continued)
//      here for integer overflow on subtract
// acmp3:
        extern void acmp3();				// load second argument
//      here for real operands
// acmp4:
        extern void acmp4();				// subtract to compare
//      here if arg1 lt arg2
// acmp5:
        extern void acmp5();				// take lt exit
//      here if overflow on real subtraction
// acmp6:
        extern void acmp6();				// reload arg2
//      here if arg1 non-numeric
// acmp7:
        extern void acmp7();				// take error exit
//      here if arg2 non-numeric
// acmp8:
        extern void acmp8();				// take error exit
        
//      alloc                 allocate block of dynamic storage
//      (wa)                  length required in bytes
//      jsr  alloc            call to allocate block
//      (xr)                  pointer to allocated block
//      a possible alternative to aov ... and following stmt is -
//      mov  dname,xr .  sub  wa,xr .  blo xr,dnamp,aloc2 .
//      mov  dnamp,xr .  add  wa,xr
// alloc:
        extern void alloc();				// entry point
//      common exit point
// aloc1:
        extern void aloc1();				// point to next available loc
//      here if insufficient room, try a garbage collection
// aloc2:
        extern void aloc2();				// save wb
// alc2a:
        extern void alc2a();				// set no upward move for gbcol
//      see if room after gbcol or sysmm call
// aloc3:
        extern void aloc3();				// point to first available loc
//      failed again, see if we can get more core
// alc3a:
        extern void alc3a();				// try to get more memory
//      sysmm failed and there was no sediment to collect
// alc3b:
        extern void alc3b();				// get the reserve memory
        
//      here after successful garbage collection
// aloc4:
        extern void aloc4();				// save ia
//      merge to restore ia and wb
// aloc5:
        extern void aloc5();				// recover ia
        
//      alocs -- allocate string block
//      alocs is used to build a frame for a string block into
//      which the actual characters are placed by the caller.
//      all strings are created with a call to alocs (the
//      exceptions occur in trimr and s_rpl procedures).
//      (wa)                  length of string to be allocated
//      jsr  alocs            call to allocate scblk
//      (xr)                  pointer to resulting scblk
//      (wa)                  destroyed
//      (wc)                  character count (entry value of wa)
//      the resulting scblk has the type word and the length
//      filled in and the last word is cleared to zero characters
//      to ensure correct right padding of the final word.
// alocs:
        extern void alocs();				// entry point
//      insufficient memory
// alcs0:
        extern void alcs0();				// else clear garbage xr value
//      merge here with xr pointing beyond new block
// alcs1:
        extern void alcs1();				// set updated storage pointer
//      come here if string is too long
// alcs2:
        extern void alcs2();
        
//      alost -- allocate space in static region
//      (wa)                  length required in bytes
//      jsr  alost            call to allocate space
//      (xr)                  pointer to allocated block
//      (wb)                  destroyed
//      note that the coding ensures that the resulting value
//      of state is always less than dnamb. this fact is used
//      in testing a variable name for being in the static region
// alost:
        extern void alost();				// entry point
//      merge back here after allocating new chunk
// alst1:
        extern void alst1();				// point to current end of area
//      here if no room, prepare to move dynamic storage up
// alst2:
        extern void alst2();				// save wa
//      here with amount to move up in wa
// alst3:
        extern void alst3();				// allocate block to ensure room
        
//      arith -- fetch arithmetic operands
//      arith is used by functions and operators which expect
//      two numeric arguments (operands) which must both be
//      integer or both be real. arith fetches two arguments from
//      the stack and performs any necessary conversions.
//      1(xs)                 first argument (left operand)
//      0(xs)                 second argument (right operand)
//      jsr  arith            call to fetch numeric arguments
//      ppm  loc              transfer loc for opnd 1 non-numeric
//      ppm  loc              transfer loc for opnd 2 non-numeric
//      ppm  loc              transfer loc for real operands
//      for integer args, control returns past the parameters
//      (ia)                  left operand value
//      (xr)                  ptr to icblk for left operand
//      (xl)                  ptr to icblk for right operand
//      (xs)                  popped twice
//      (wa,wb,ra)            destroyed
//      for real arguments, control returns to the location
//      specified by the third parameter.
//      (ra)                  left operand value
//      (xr)                  ptr to rcblk for left operand
//      (xl)                  ptr to rcblk for right operand
//      (wa,wb,wc)            destroyed
//      (xs)                  popped twice
        
//      arith (continued)
//      entry point
// arith:
        extern void arith();				// entry point
        #define P_PRC_ARITH 1
        #define P_PRCLEN_ARITH 3
//      here if right arg is an integer
// arth1:
        extern void arth1();				// jump if left arg not integer
//      exit for integer case
// arth2:
        extern void arth2();				// load left operand value
//      here for right operand integer, left operand not
// arth3:
        extern void arth3();				// convert left arg to numeric
//      here we must convert real-integer to real-real
        
//      arith (continued)
//      here if right argument is real
// arth4:
        extern void arth4();				// jump if left arg real
//      here for real-real
// arth5:
        extern void arth5();				// load left operand value
//      here for error converting right argument
// arth6:
        extern void arth6();				// pop unwanted left arg
//      here for error converting left operand
// arth7:
        extern void arth7();				// take appropriate error return
        
//      asign -- perform assignment
//      asign performs the assignment of a value to a variable
//      with appropriate checks for output associations and
//      value trace associations which are executed as required.
//      asign also handles the special cases of assignment to
//      pattern and expression variables.
//      (wb)                  value to be assigned
//      (xl)                  base pointer for variable
//      (wa)                  offset for variable
//      jsr  asign            call to assign value to variable
//      ppm  loc              transfer loc for failure
//      (xr,xl,wa,wb,wc)      destroyed
//      (ra)                  destroyed
//      failure occurs if the evaluation of an expression
//      associated with an expression variable fails.
// asign:
        extern void asign();				// entry point (recursive)
//      merge back here to assign result to expression variable.
// asg01:
        extern void asg01();				// point to variable value
//      here if value is trapped
// asg02:
        extern void asg02();				// restore name base
//      here for assignment to expression variable
        
//      asign (continued)
//      here for failure during expression evaluation
// asg03:
        extern void asg03();				// remove stacked value entry
//      here if not keyword or expression variable
// asg04:
        extern void asg04();				// save ptr to first trblk
//      loop to chase down trblk chain and assign value at end
// asg05:
        extern void asg05();				// save ptr to this trblk
//      loop to process trblk entries on chain
// asg06:
        extern void asg06();				// load type code of trblk
//      here to move to next trblk on chain
// asg07:
        extern void asg07();				// point to next trblk on chain
//      here to process value trace
// asg08:
        extern void asg08();				// ignore value trace if trace off
        
//      asign (continued)
//      here for print trace
// asg09:
        extern void asg09();				// print statement number
//      here for output association
// asg10:
        extern void asg10();				// ignore output assoc if output off
// asg1b:
        extern void asg1b();				// copy trblk pointer
//      merge with string or buffer to output in xr
// asg11:
        extern void asg11();				// fcblk ptr
//      here for output to file
// asg1a:
        extern void asg1a();				// call system output routine
//      if not printable, get datatype name instead
// asg12:
        extern void asg12();				// call datatype routine
//      here to print a string to standard output or terminal
// asg13:
        extern void asg13();				// jump if terminal output
        
//      asign (continued)
//      here for keyword assignment
// asg14:
        extern void asg14();				// load keyword number
//      here to do assignment if not protected
// asg15:
        extern void asg15();				// store new value
//      here for special case of stlimit
//      since stcount is maintained as (stlimit-stcount)
//      it is also necessary to modify stcount appropriately.
// asg16:
        extern void asg16();				// subtract old limit
// asg25:
        extern void asg25();				// reload new limit value
//      here for special case of errtype
// asg17:
        extern void asg17();				// ok to signal if in range
//      here if value assigned is out of range
// asg18:
        extern void asg18();
//      here for special case of errtext
// asg19:
        extern void asg19();				// stack value
//      here for keyword profile
// asg21:
        extern void asg21();				// moan if not 0,1, or 2
// asg22:
        extern void asg22();				// note value on first assignment
// asg23:
        extern void asg23();				// store new value
//      here for keyword maxlngth
// asg24:
        extern void asg24();				// if acceptable value
//      here for keyword fullscan
// asg26:
        extern void asg26();				// if acceptable value
        
//      asinp -- assign during pattern match
//      asinp is like asign and has a similar calling sequence
//      and effect. the difference is that the global pattern
//      variables are saved and restored if required.
//      (xl)                  base pointer for variable
//      (wa)                  offset for variable
//      (wb)                  value to be assigned
//      jsr  asinp            call to assign value to variable
//      ppm  loc              transfer loc if failure
//      (xr,xl)               destroyed
//      (wa,wb,wc,ra)         destroyed
// asinp:
        extern void asinp();				// entry point, recursive
//      here if variable is trapped
// asnp1:
        extern void asnp1();				// restore base pointer
//      here if failure in asign call
// asnp2:
        extern void asnp2();				// restore dot flag
        
//      blkln -- determine length of block
//      blkln determines the length of a block in dynamic store.
//      (wa)                  first word of block
//      (xr)                  pointer to block
//      jsr  blkln            call to get block length
//      (wa)                  length of block in bytes
//      (xl)                  destroyed
//      blkln is used by the garbage collector and is not
//      permitted to call gbcol directly or indirectly.
//      the first word stored in the block (i.e. at xr) may
//      be anything, but the contents of wa must be correct.
// blkln:
        extern void blkln();				// entry point
        
//      blkln (continued)
//      here for blocks with length in second word
// bln00:
        extern void bln00();				// load length
//      here for length in third word (ar,cd,df,ef,ex,pf,tb,vc)
// bln01:
        extern void bln01();				// load length from third word
//      here for two word blocks (p0,se)
// bln02:
        extern void bln02();				// load length (two words)
//      here for three word blocks (nm,p1,ev,kv)
// bln03:
        extern void bln03();				// load length (three words)
//      here for four word blocks (p2,te,bc)
// bln04:
        extern void bln04();				// load length (four words)
//      here for five word blocks (ff,tr)
// bln05:
        extern void bln05();				// load length
        
//      blkln (continued)
//      here for ctblk
// bln06:
        extern void bln06();				// set size of ctblk
//      here for icblk
// bln07:
        extern void bln07();				// set size of icblk
//      here for pdblk
// bln08:
        extern void bln08();				// point to dfblk
//      here for rcblk
// bln09:
        extern void bln09();				// set size of rcblk
//      here for scblk
// bln10:
        extern void bln10();				// load length in characters
//      here for length in fourth word (cd,ex)
// bln12:
        extern void bln12();				// load length from cdlen/exlen
        
//      copyb -- copy a block
//      (xs)                  block to be copied
//      jsr  copyb            call to copy block
//      ppm  loc              return if block has no idval field
//                            normal return if idval field
//      (xr)                  copy of block
//      (xs)                  popped
//      (xl,wa,wb,wc)         destroyed
// copyb:
        extern void copyb();				// entry point
        #define P_PRC_COPYB 2
        #define P_PRCLEN_COPYB 1
//      here for array (arblk)
//      here for vector, program defined
// cop01:
        extern void cop01();				// point to pdfld = vcvls
//      merge here for arblk, vcblk, pdblk to delete trap
//      blocks from all value fields (the copy is untrapped)
// cop02:
        extern void cop02();				// load next pointer
//      loop to get value at end of trblk chain
// cop03:
        extern void cop03();				// jump if not trapped
        
//      copyb (continued)
//      here with untrapped value in xl
// cop04:
        extern void cop04();				// store real value, bump pointer
//      here to copy a table
// cop05:
        extern void cop05();				// zero id to stop dump blowing up
//      loop through buckets in table
// cop06:
        extern void cop06();				// load table pointer
//      loop through teblks on one chain
// cop07:
        extern void cop07();				// load pointer to next teblk
//      loop to set real value after removing trap chain
// cop08:
        extern void cop08();				// load value
//      common exit point
// cop09:
        extern void cop09();				// load pointer to block
//      alternative return
// cop10:
        extern void cop10();				// return
        
//      cdgcg -- generate code for complex goto
//      used by cmpil to process complex goto tree
//      (wb)                  must be collectable
//      (xr)                  expression pointer
//      jsr  cdgcg            call to generate complex goto
//      (xl,xr,wa)            destroyed
// cdgcg:
        extern void cdgcg();				// entry point
//      return point
// cdgc1:
        extern void cdgc1();				// goto operator
//      direct goto
// cdgc2:
        extern void cdgc2();				// generate operand by value
        
//      cdgex -- build expression block
//      cdgex is passed a pointer to an expression tree (see
//      expan) and returns an expression (seblk or exblk).
//      (wa)                  0 if by value, 1 if by name
//      (wc)                  some collectable value
//      (wb)                  integer in range 0 le x le mxlen
//      (xl)                  ptr to expression tree
//      jsr  cdgex            call to build expression
//      (xr)                  ptr to seblk or exblk
//      (xl,wa,wb)            destroyed
// cdgex:
        extern void cdgex();				// entry point, recursive
//      here for natural variable, build seblk
//      here if not variable, build exblk
// cdgx1:
        extern void cdgx1();				// copy tree pointer
        
//      cdgex (continued)
//      here if expression can be evaluated by name
//      here if expression can only be evaluated by value
// cdgx2:
        extern void cdgx2();				// generate code by value
//      merge here to construct exblk
// cdgx3:
        extern void cdgx3();				// generate return word
        
//      cdgnm -- generate code by name
//      cdgnm is called during the compilation process to
//      generate code by name for an expression. see cdblk
//      description for details of code generated. the input
//      to cdgnm is an expression tree as generated by expan.
//      cdgnm is a recursive procedure which proceeds by making
//      recursive calls to generate code for operands.
//      (wb)                  integer in range 0 le n le dnamb
//      (xr)                  ptr to tree generated by expan
//      (wc)                  constant flag (see below)
//      jsr  cdgnm            call to generate code by name
//      (xr,wa)               destroyed
//      (wc)                  set non-zero if non-constant
//      wc is set to a non-zero (collectable) value if the
//      expression for which code is generated cannot be
//      evaluated at compile time, otherwise wc is unchanged.
//      the code is generated in the current ccblk (see cdwrd).
// cdgnm:
        extern void cdgnm();				// entry point, recursive
//      merge here for operand yielding value (e.g. constant)
// cgn01:
        extern void cgn01();
//      here for natural variable reference
// cgn02:
        extern void cgn02();				// load variable load call
        
//      cdgnm (continued)
//      here to exit with wc set correctly
// cgn03:
        extern void cgn03();				// restore entry wb
//      here for cmblk
// cgn04:
        extern void cgn04();				// copy cmblk pointer
//      here to generate code for array reference
// cgn05:
        extern void cgn05();				// point to array operand
//      loop to generate code for array operand and subscripts
// cgn06:
        extern void cgn06();				// generate code for next operand
//      generate appropriate array call
        
//      cdgnm (continued)
//      here to exit generating word (non-constant)
// cgn07:
        extern void cgn07();				// set result non-constant
//      here to generate code for functions and undefined oprs
// cgn08:
        extern void cgn08();				// copy cmblk pointer
//      here to generate code for defered expression
// cgn09:
        extern void cgn09();				// check if variable
//      here to generate code for indirect reference
// cgn10:
        extern void cgn10();				// get operand
//      here to generate code for keyword reference
// cgn11:
        extern void cgn11();				// get operand
//      keyword, indirect merge here
// cgn12:
        extern void cgn12();				// generate code for operator
        
//      cdgvl -- generate code by value
//      cdgvl is called during the compilation process to
//      generate code by value for an expression. see cdblk
//      description for details of the code generated. the input
//      to cdgvl is an expression tree as generated by expan.
//      cdgvl is a recursive procedure which proceeds by making
//      recursive calls to generate code for operands.
//      (wb)                  integer in range 0 le n le dnamb
//      (xr)                  ptr to tree generated by expan
//      (wc)                  constant flag (see below)
//      jsr  cdgvl            call to generate code by value
//      (xr,wa)               destroyed
//      (wc)                  set non-zero if non-constant
//      wc is set to a non-zero (collectable) value if the
//      expression for which code is generated cannot be
//      evaluated at compile time, otherwise wc is unchanged.
//      if wc is non-zero on entry, then preevaluation is not
//      allowed regardless of the nature of the operand.
//      the code is generated in the current ccblk (see cdwrd).
// cdgvl:
        extern void cdgvl();				// entry point, recursive
//      here for variable value reference
// cgvl0:
        extern void cgvl0();				// indicate non-constant value
//      merge here for simple constant (icblk,rcblk,scblk)
//      and for variables corresponding to constant keywords.
// cgv00:
        extern void cgv00();				// copy ptr to var or constant
        
//      cdgvl (continued)
//      here for tree node (cmblk)
// cgv01:
        extern void cgv01();				// save entry wb
//      prepare to generate code for cmblk. wc is set to the
//      value of cswno (zero if -optimise, 1 if -noopt) to
//      start with and is reset non-zero for any non-constant
//      code generated. if it is still zero after generating all
//      the cmblk code, then its value is computed as the result.
//      here with wc set appropriately
// cgv02:
        extern void cgv02();				// switch to appropriate generator
        
//      cdgvl (continued)
//      here to generate code for array reference
// cgv03:
        extern void cgv03();				// set offset to array operand
//      loop to generate code for array operand and subscripts
// cgv04:
        extern void cgv04();				// gen value code for next operand
//      generate call to appropriate array reference routine
//      here to generate code for function call
// cgv05:
        extern void cgv05();				// set offset to first argument
//      loop to generate code for arguments
// cgv06:
        extern void cgv06();				// jump if all generated
//      here to generate actual function call
// cgv07:
        extern void cgv07();				// get number of arg ptrs (bytes)
        
//      cdgvl (continued)
//      here if fast function call is allowed
//      test for correct number of args for fast call
// cgv08:
        extern void cgv08();				// load ptr to svfnc field
//      here if too many arguments, prepare to generate o_pops
//      here if too few arguments, prepare to generate nulls
// cgv09:
        extern void cgv09();				// get number of missing arguments
//      loop to generate calls to fix argument count
// cgv10:
        extern void cgv10();				// generate one call
//      here after adjusting arg count as required
// cgv11:
        extern void cgv11();				// copy pointer to svfnc field
        
//      cdgvl (continued)
//      come here if fast call is not permitted
// cgv12:
        extern void cgv12();				// set one arg call in case
//      one arg case merges here
// cgv13:
        extern void cgv13();				// generate =o_fns or arg count
//      here for deferred expression
// cgv14:
        extern void cgv14();				// point to expression tree
//      here to generate code for selection
// cgv15:
        extern void cgv15();				// zero ptr to chain of forward jumps
//      0(xs)                 is the offset to the previous word
//                            which requires filling in with an
//                            offset to the following o_slc,o_sld
//      1(xs)                 is the head of a chain of offset
//                            pointers indicating those locations
//                            to be filled with offsets past
//                            the end of all the alternatives
// cgv16:
        extern void cgv16();				// generate o_slc (o_sla first time)
        
//      cdgvl (continued)
//      now to fill in the skip offset to o_slc,o_sld
//      here to generate code for last alternative
//      loop to plug offsets past structure
// cgv17:
        extern void cgv17();				// make next ptr absolute
//      here for binary ops with value operands
// cgv18:
        extern void cgv18();				// load left operand pointer
//      here for unary ops with value operand (binops merge)
// cgv19:
        extern void cgv19();				// load right (only) operand ptr
        
//      cdgvl (continued)
//      merge here to generate operator call from cmopn field
// cgv20:
        extern void cgv20();				// load operator call pointer
//      here for assignment
// cgv21:
        extern void cgv21();				// load left operand pointer
//      here for assignment to simple variable
//      here if not simple variable assignment
// cgv22:
        extern void cgv22();				// test for pattern match on left side
//      here for pattern replacement
//      here for assignment to complex variable
// cgv23:
        extern void cgv23();				// inhibit pre-evaluation
        
//      cdgvl (continued)
//      here for concatenation
// cgv24:
        extern void cgv24();				// load left operand ptr
//      here if left arg of concatenation is predicate function
// cgv25:
        extern void cgv25();				// reload left arg
//      here to generate code for pattern, immediate assignment
// cgv26:
        extern void cgv26();				// load left operand
//      here for unops with arg by name (binary _ . merge)
// cgv27:
        extern void cgv27();				// load right operand ptr
        
//      cdgvl (continued)
//      here for keyword by value. this is constant only if
//      the operand is one of the special system variables with
//      the svckw bit set to indicate a constant keyword value.
//      note that the only constant operand by name is a variable
//      here to generate code for negation
// cgv28:
        extern void cgv28();				// get initial word
//      here to generate code for undefined binary operator
// cgv29:
        extern void cgv29();				// load left operand ptr
        
//      cdgvl (continued)
//      here to generate code for undefined unary operator
// cgv30:
        extern void cgv30();				// set unop code + 1
//      merge here for undefined operators
//      here to generate code for interrogation, indirection
// cgv31:
        extern void cgv31();				// set non constant
//      here to exit generating a word, result not constant
// cgv32:
        extern void cgv32();				// generate word, merge
//      here to exit with no word generated, not constant
// cgv33:
        extern void cgv33();				// indicate result is not constant
//      common exit point
// cgv34:
        extern void cgv34();				// pop initial code offset
//      here to return after dealing with wc setting
// cgv35:
        extern void cgv35();				// return to cdgvl caller
//      exit here to generate word and test for constant
// cgv36:
        extern void cgv36();				// generate word
        
//      cdgvl (continued)
//      here to preevaluate constant sub-expression
//      merge here to generate pointer to resulting constant
// cgv37:
        extern void cgv37();				// copy constant pointer
        
//      cdwrd -- generate one word of code
//      cdwrd writes one word into the current code block under
//      construction. a new, larger, block is allocated if there
//      is insufficient room in the current block. cdwrd ensures
//      that there are at least four words left in the block
//      after entering the new word. this guarantees that any
//      extra space at the end can be split off as a ccblk.
//      (wa)                  word to be generated
//      jsr  cdwrd            call to generate word
// cdwrd:
        extern void cdwrd();				// entry point
//      merge back here after allocating larger block
// cdwd1:
        extern void cdwd1();				// load ptr to ccblk being built
//      here we allocate an entirely fresh block
//      here we have a block we can use
// cdwd2:
        extern void cdwd2();				// load current offset
//      here if no room in current block
        
//      cdwrd (continued)
//      here with new block size in wa
// cdwd3:
        extern void cdwd3();				// allocate new block
//      here with room in current block
// cdwd4:
        extern void cdwd4();				// load current offset
//      here if compiled code is too long for cdblk
// cdwd5:
        extern void cdwd5();
        
//      cmgen -- generate code for cmblk ptr
//      cmgen is a subsidiary procedure used to generate value
//      code for a cmblk ptr from the main code generators.
//      (xl)                  cmblk pointer
//      (wb)                  offset to pointer in cmblk
//      jsr  cmgen            call to generate code
//      (xr,wa)               destroyed
//      (wb)                  bumped by one word
// cmgen:
        extern void cmgen();				// entry point, recursive
        
//      cmpil (compile source code)
//      cmpil is used to convert snobol4 source code to internal
//      form (see cdblk format). it is used both for the initial
//      compile and at run time by the code and convert functions
//      this procedure has control for the entire duration of
//      initial compilation. an error in any procedure called
//      during compilation will lead first to the error section
//      and ultimately back here for resumed compilation. the
//      re-entry points after an error are specially labelled -
//      cmpce                 resume after control card error
//      cmple                 resume after label error
//      cmpse                 resume after statement error
//      jsr  cmpil            call to compile code
//      (xr)                  ptr to cdblk for entry statement
//      (xl,wa,wb,wc,ra)      destroyed
//      the following global variables are referenced
//      cmpln                 line number of first line of
//                            statement to be compiled
//      cmpsn                 number of next statement
//                            to be compiled.
//      cswxx                 control card switch values are
//                            changed when relevant control
//                            cards are met.
//      cwcof                 offset to next word in code block
//                            being built (see cdwrd).
//      lstsn                 number of statement most recently
//                            compiled (initially set to zero).
//      r_cim                 current (initial) compiler image
//                            (zero for initial compile call)
//      r_cni                 used to point to following image.
//                            (see readr procedure).
//      scngo                 goto switch for scane procedure
//      scnil                 length of current image excluding
//                            characters removed by -input.
//      scnpt                 current scan offset, see scane.
//      scnrs                 rescan switch for scane procedure.
//      scnse                 offset (in r_cim) of most recently
//                            scanned element. set zero if not
//                            currently scanning items
        
//      cmpil (continued)
//      stage               stgic  initial compile in progress
//                          stgxc  code/convert compile
//                          stgev  building exblk for eval
//                          stgxt  execute time (outside compile)
//                          stgce  initial compile after end line
//                          stgxe  execute compile after end line
//      cmpil also uses a fixed number of locations on the
//      main stack as follows. (the definitions of the actual
//      offsets are in the definitions section).
//      cmstm(xs)             pointer to expan tree for body of
//                            statement (see expan procedure).
//      cmsgo(xs)             pointer to tree representation of
//                            success goto (see procedure scngo)
//                            zero if no success goto is given
//      cmfgo(xs)             like cmsgo for failure goto.
//      cmcgo(xs)             set non-zero only if there is a
//                            conditional goto. used for -fail,
//                            -nofail code generation.
//      cmpcd(xs)             pointer to cdblk for previous
//                            statement. zero for 1st statement.
//      cmffp(xs)             set non-zero if cdfal in previous
//                            cdblk needs filling with forward
//                            pointer, else set to zero.
//      cmffc(xs)             same as cmffp for current cdblk
//      cmsop(xs)             offset to word in previous cdblk
//                            to be filled in with forward ptr
//                            to next cdblk for success goto.
//                            zero if no fill in is required.
//      cmsoc(xs)             same as cmsop for current cdblk.
//      cmlbl(xs)             pointer to vrblk for label of
//                            current statement. zero if no label
//      cmtra(xs)             pointer to cdblk for entry stmnt.
        
//      cmpil (continued)
//      entry point
// cmpil:
        extern void cmpil();				// entry point
//      loop to initialize stack working locations
// cmp00:
        extern void cmp00();				// store a zero, make one entry
//      loop through statements
// cmp01:
        extern void cmp01();				// set scan pointer offset
//      loop here after comment or control card
//      also special entry after control card error
// cmpce:
        extern void cmpce();				// clear possible garbage xr value
// cmpc2:
        extern void cmpc2();				// read next input image
//      for execute time compile, permit embedded control cards
//      and comments (by skipping to next semi-colon)
// cmp02:
        extern void cmp02();				// get current image
//      skip to semi-colon
// cmp03:
        extern void cmp03();				// end loop if end of image
        
//      cmpil (continued)
//      here with image available to scan. note that if the input
//      string is null, then everything is ok since null is
//      actually assembled as a word of blanks.
// cmp04:
        extern void cmp04();				// point to current image
//      drop in or jump from error section if scane failed
// cmple:
        extern void cmple();				// point to bad line
//      loop to scan label
// cmp05:
        extern void cmp05();				// skip if semicolon
        
//      cmpil (continued)
//      enter loop at this point
// cmp06:
        extern void cmp06();				// else load next character
//      here after scanning out label
// cmp07:
        extern void cmp07();				// save updated scan offset
//      here for end label scanned out
//      here check for valid initial transfer
//      here for bad transfer label
// cmp08:
        extern void cmp08();
//      here for end of input (no end label detected)
// cmp09:
        extern void cmp09();				// clear garbage xr value
//      here after processing end line (merge here on end error)
// cmp10:
        extern void cmp10();				// set stop call pointer
        
//      cmpil (continued)
//      here after processing label other than end
// cmp11:
        extern void cmp11();				// jump if code call - redef. ok
//      here after dealing with label
//      null statements and statements just containing a
//      constant subject are optimized out by resetting the
//      current ccblk to empty.
// cmp12:
        extern void cmp12();				// set flag for statement body
//      loop to process goto fields
// cmp13:
        extern void cmp13();				// set goto flag
//      here for unconditional goto (i.e. not f or s)
//      here for success goto
// cmp14:
        extern void cmp14();				// scan success goto field
//      uncontional goto merges here
// cmp15:
        extern void cmp15();				// error if sgoto already given
//      here for failure goto
// cmp16:
        extern void cmp16();				// scan goto field
        
//      cmpil (continued)
//      here for duplicated goto field
// cmp17:
        extern void cmp17();
//      here to generate code
// cmp18:
        extern void cmp18();				// stop positional error flags
//      here after dealing with special pattern match case
// cmp19:
        extern void cmp19();				// generate code for body of statement
//      here for simple success goto (label)
//      here for complex success goto
// cmp20:
        extern void cmp20();				// no code if same as fgoto
//      here for no success goto
// cmp21:
        extern void cmp21();				// set success fill in offset
        
//      cmpil (continued)
//      here to deal with failure goto
// cmp22:
        extern void cmp22();				// load failure goto pointer
//      here for complex failure goto
//      here if no failure goto given
// cmp23:
        extern void cmp23();				// load unexpected failure call in cas
//      merge here with cdfal value in wa, simple cdblk
//      also special entry after statement error
// cmpse:
        extern void cmpse();				// set cdtyp for simple case
        
//      cmpil (continued)
//      merge here to build cdblk
//      (wa)                  cdfal value to be generated
//      (wb)                  cdtyp value to be generated
//      at this stage, we chop off an appropriate chunk of the
//      current ccblk and convert it into a cdblk. the remainder
//      of the ccblk is reformatted to be the new ccblk.
// cmp25:
        extern void cmp25();				// point to ccblk
//      merge after doing label
// cmp26:
        extern void cmp26();				// set type word for new cdblk
//      set pointers in previous code block as required
//      here to deal with success forward pointer
// cmp27:
        extern void cmp27();				// load success offset
        
//      cmpil (continued)
//      now set fill in pointers for this statement
// cmp28:
        extern void cmp28();				// copy failure fill in flag
//      here after compiling one statement
// cmp29:
        extern void cmp29();				// jump if not end line just done
//      return
// cmp30:
        extern void cmp30();				// load initial entry cdblk pointer
//      here at end of goto field
// cmp31:
        extern void cmp31();				// get fail goto
//      control card found
// cmp32:
        extern void cmp32();				// point past ch_mn
        
//      cncrd -- control card processor
//      called to deal with control cards
//      r_cim                 points to current image
//      (wb)                  offset to 1st char of control card
//      jsr  cncrd            call to process control cards
//      (xl,xr,wa,wb,wc,ia)   destroyed
// cncrd:
        extern void cncrd();				// entry point
//      loop here if more than one control card
// cnc01:
        extern void cnc01();				// return if end of image
// cnc0a:
        extern void cnc0a();				// set flag for scane
//      try to match name
// cnc02:
        extern void cnc02();				// point to name
//      inner loop to match card name chars
// cnc03:
        extern void cnc03();				// bump standard names ptr
//      here to initiate the loop
// cnc04:
        extern void cnc04();				// comp. up to cfp_c chars at once
        
//      cncrd (continued)
//      matched - branch on card offset
//      not matched yet. align std names ptr and try again
// cnc05:
        extern void cnc05();				// bump standard names ptr
//      invalid control card name
// cnc06:
        extern void cnc06();
//      special processing for -inxxx
// cnc07:
        extern void cnc07();				// get next char
        
//      cncrd (continued)
//      check for more control cards before returning
// cnc08:
        extern void cnc08();				// preserve in case xeq time compile
//      return point
// cnc09:
        extern void cnc09();				// return
//      -double
// cnc10:
        extern void cnc10();				// set switch
//      -dump
//      this is used for system debugging . it has the effect of
//      producing a core dump at compilation time
// cnc11:
        extern void cnc11();				// call dumper
//      -eject
// cnc12:
        extern void cnc12();				// return if -nolist
//      -errors
// cnc13:
        extern void cnc13();				// clear switch
//      -execute
// cnc14:
        extern void cnc14();				// clear switch
//      -fail
// cnc15:
        extern void cnc15();				// set switch
//      -list
// cnc16:
        extern void cnc16();				// set switch
//      list code line if execute time compile
        
//      cncrd (continued)
//      -noerrors
// cnc17:
        extern void cnc17();				// set switch
//      -noexecute
// cnc18:
        extern void cnc18();				// set switch
//      -nofail
// cnc19:
        extern void cnc19();				// clear switch
//      -nolist
// cnc20:
        extern void cnc20();				// clear switch
//      -nooptimise
// cnc21:
        extern void cnc21();				// set switch
//      -noprint
// cnc22:
        extern void cnc22();				// clear switch
//      -optimise
// cnc24:
        extern void cnc24();				// clear switch
//      -print
// cnc25:
        extern void cnc25();				// set switch
        
//      cncrd (continued)
//      -single
// cnc27:
        extern void cnc27();				// clear switch
//      -space
// cnc28:
        extern void cnc28();				// return if -nolist
//      merge with count of lines to skip
// cnc29:
        extern void cnc29();				// bump line count
//      skip lines
// cnc30:
        extern void cnc30();				// print a blank
        
//      cncrd (continued)
//      -stitl
// cnc31:
        extern void cnc31();				// ptr to r_stl
//      -title
// cnc32:
        extern void cnc32();				// clear subtitle
//      common processing for -title, -stitl
// cnc33:
        extern void cnc33();				// null in case needed
//      store title/subtitle
// cnc34:
        extern void cnc34();				// point to storage location
//      store offset to page nn message for short title
// cnc35:
        extern void cnc35();				// store offset
//      -trace
//      provided for system debugging.  toggles the system label
//      trace switch at compile time
// cnc36:
        extern void cnc36();				// toggle switch
//      -include
// cnc41:
        extern void cnc41();				// set flag for scane
//      record the name and line number of the current input file
//      here to switch to include file named in r_ifn
//      make note of the complete file name for error messages
//      here for -include during execute-time compile
//      here for excessive include file nesting
// cnc42:
        extern void cnc42();
//      here if include file could not be opened
// cnc43:
        extern void cnc43();				// release allocated scblk
//      -line n filename
// cnc44:
        extern void cnc44();				// scan integer after -line
// cnc45:
        extern void cnc45();				// adjust number by one
// cnc46:
        extern void cnc46();				// set flag for scane
//      here if file name not present
// cnc47:
        extern void cnc47();				// set to rescan the terminator
        
//      dffnc -- define function
//      dffnc is called whenever a new function is assigned to
//      a variable. it deals with external function use counts.
//      (xr)                  pointer to vrblk
//      (xl)                  pointer to new function block
//      jsr  dffnc            call to define function
//      (wa,wb)               destroyed
// dffnc:
        extern void dffnc();				// entry point
//      here after dealing with new function use count
// dffn1:
        extern void dffn1();				// save vrblk pointer
//      here after dealing with old function use count
// dffn2:
        extern void dffn2();				// restore vrblk pointer
//      for system variable, check for illegal redefinition
//      here if redefinition is permitted
// dffn3:
        extern void dffn3();				// store new function pointer
        
//      dtach -- detach i/o associated names
//      detaches trblks from i/o associated variables, removes
//      entry from iochn chain attached to filearg1 vrblk and may
//      remove vrblk access and store traps.
//      input, output, terminal are handled specially.
//      (xl)                  i/o assoc. vbl name base ptr
//      (wa)                  offset to name
//      jsr  dtach            call for detach operation
//      (xl,xr,wa,wb,wc)      destroyed
// dtach:
        extern void dtach();				// entry point
//      loop to search for i/o trblk
// dtch1:
        extern void dtch1();				// copy name pointer
//      continue after block deletion
// dtch2:
        extern void dtch2();				// point to next value
//      delete an old association
// dtch3:
        extern void dtch3();				// delete trblk
//      loop to search iochn chain for name ptr
// dtch4:
        extern void dtch4();				// remember link ptr
        
//      dtach (continued)
//      prepare to resume i/o trblk scan
// dtch5:
        extern void dtch5();				// recover xl ...
//      exit point
// dtch6:
        extern void dtch6();				// possible vrblk ptr
        
//      dtype -- get datatype name
//      (xr)                  object whose datatype is required
//      jsr  dtype            call to get datatype
//      (xr)                  result datatype
// dtype:
        extern void dtype();				// entry point
//      here if program defined
// dtyp1:
        extern void dtyp1();				// point to dfblk
        
//      dumpr -- print dump of storage
//      (xr)                  dump argument (see below)
//      jsr  dumpr            call to print dump
//      (xr,xl)               destroyed
//      (wa,wb,wc,ra)         destroyed
//      the dump argument has the following significance
//      dmarg = 0             no dump printed
//      dmarg = 1             partial dump (nat vars, keywords)
//      dmarg = 2             full dump (arrays, tables, etc.)
//      dmarg = 3             full dump + null variables
//      dmarg ge 4            core dump
//      since dumpr scrambles store, it is not permissible to
//      collect in mid-dump. hence a collect is done initially
//      and then if store runs out an error message is produced.
// dumpr:
        extern void dumpr();				// entry point
//      first all natural variable blocks (vrblk) whose values
//      are non-null are linked in lexical order using dmvch as
//      the chain head and chaining through the vrget fields.
//      note that this scrambles store if the process is
//      interrupted before completion e.g. by exceeding time  or
//      print limits. since the subsequent core dumps and
//      failures if execution is resumed are very confusing, the
//      execution time error routine checks for this event and
//      attempts an unscramble. similar precautions should be
//      observed if translate time dumping is implemented.
//      loop through headers in hash table
// dmp00:
        extern void dmp00();				// copy hash bucket pointer
//      loop through vrblks on one chain
// dmp01:
        extern void dmp01();				// point to next vrblk on chain
        
//      dumpr (continued)
//      loop to find value and skip if null
// dmp02:
        extern void dmp02();				// load value
// dmp2a:
        extern void dmp2a();				// loop back if value is trapped
//      non-null value, prepare to search chain
//      here with name pointer for new block in xr
// dmp03:
        extern void dmp03();				// save pointer to chars
//      loop to search chain for correct insertion point
// dmp04:
        extern void dmp04();				// save chain pointer
//      here prepare to compare the names
//      (wa)                  scratch
//      (wb)                  pointer to string of entering vrblk
//      (wc)                  pointer to entering vrblk
//      (xr)                  pointer to string of current block
//      (xl)                  scratch
// dmp05:
        extern void dmp05();				// point to entering vrblk string
//      here when new length is longer than old length
// dmp06:
        extern void dmp06();				// load shorter length
        
//      dumpr (continued)
//      here we move out on the chain
// dmp07:
        extern void dmp07();				// copy chain pointer
//      here after locating the proper insertion point
// dmp08:
        extern void dmp08();				// copy chain pointer
//      here after processing all vrblks on one chain
// dmp09:
        extern void dmp09();				// loop back if more buckets to go
//      loop to generate dump of natural variable values
// dmp10:
        extern void dmp10();				// load pointer to next entry on chain
//      prepare to print keywords
// dmp11:
        extern void dmp11();				// print blank line
        
//      dumpr (continued)
//      loop to dump keyword values
// dmp12:
        extern void dmp12();				// load next svblk ptr from table
//      here after completing partial dump
// dmp13:
        extern void dmp13();				// exit if partial dump complete
//      loop through blocks in dynamic storage
// dmp14:
        extern void dmp14();				// jump if end of used region
//      merge here to move to next block
// dmp15:
        extern void dmp15();				// get length of block
        
//      dumpr (continued)
//      here for vector
// dmp16:
        extern void dmp16();				// set offset to first value
//      here for array
// dmp17:
        extern void dmp17();				// set offset to arpro field
//      here for program defined
// dmp18:
        extern void dmp18();				// point to values, merge
//      here for table (others merge)
// dmp19:
        extern void dmp19();				// ignore block if zero id value
//      loop to print contents of array, vector, or program def
// dmp20:
        extern void dmp20();				// copy block pointer
//      loop to find value and ignore nulls
// dmp21:
        extern void dmp21();				// load next value
// dmp2b:
        extern void dmp2b();				// loop back if trapped
        
//      dumpr (continued)
//      here to dump a table
// dmp22:
        extern void dmp22();				// set offset to first bucket
//      loop through table buckets
// dmp23:
        extern void dmp23();				// save tbblk pointer
//      loop to process teblks on one chain
// dmp24:
        extern void dmp24();				// point to next teblk
//      loop to find value and ignore if null
// dmp25:
        extern void dmp25();				// load next value
//      here to move to next hash chain
// dmp26:
        extern void dmp26();				// restore tbblk pointer
//      here after completing dump
// dmp27:
        extern void dmp27();				// eject printer
//      merge here if no dump given (dmarg=0)
// dmp28:
        extern void dmp28();				// return to dump caller
//      call system core dump routine
// dmp29:
        extern void dmp29();				// call it
        
//      ermsg -- print error code and error message
//      kvert                 error code
//      jsr  ermsg            call to print message
//      (xr,xl,wa,wb,wc,ia)   destroyed
// ermsg:
        extern void ermsg();				// entry point
        
//      ertex -- get error message text
//      (wa)                  error code
//      jsr  ertex            call to get error text
//      (xr)                  ptr to error text in dynamic
//      (r_etx)               copy of ptr to error text
//      (xl,wc,ia)            destroyed
// ertex:
        extern void ertex();				// entry point
//      return
// ert01:
        extern void ert01();				// restore wb
//      return errtext contents instead of null
// ert02:
        extern void ert02();				// get errtext
        
//      evali -- evaluate integer argument
//      evali is used by pattern primitives len,tab,rtab,pos,rpos
//      when their argument is an expression value.
//      (xr)                  node pointer
//      (wb)                  cursor
//      jsr  evali            call to evaluate integer
//      ppm  loc              transfer loc for non-integer arg
//      ppm  loc              transfer loc for out of range arg
//      ppm  loc              transfer loc for evaluation failure
//      ppm  loc              transfer loc for successful eval
//      (the normal return is never taken)
//      (xr)                  ptr to node with integer argument
//      (wc,xl,ra)            destroyed
//      on return, the node pointed to has the integer argument
//      in parm1 and the proper successor pointer in pthen.
//      this allows merging with the normal (integer arg) case.
// evali:
        extern void evali();				// entry point (recursive)
//      here if evaluation fails
// evli1:
        extern void evli1();				// take failure return
//      here if argument is not integer
// evli2:
        extern void evli2();				// take non-integer error exit
//      here if argument is out of range
// evli3:
        extern void evli3();				// take out-of-range error exit
        
//      evalp -- evaluate expression during pattern match
//      evalp is used to evaluate an expression (by value) during
//      a pattern match. the effect is like evalx, but pattern
//      variables are stacked and restored if necessary.
//      evalp also differs from evalx in that if the result is
//      an expression it is reevaluated. this occurs repeatedly.
//      to support optimization of pos and rpos, evalp uses wc
//      to signal the caller for the case of a simple vrblk
//      that is not an expression and is not trapped.  because
//      this case cannot have any side effects, optimization is
//      possible.
//      (xr)                  node pointer
//      (wb)                  pattern match cursor
//      jsr  evalp            call to evaluate expression
//      ppm  loc              transfer loc if evaluation fails
//      (xl)                  result
//      (wa)                  first word of result block
//      (wc)                  zero if simple vrblk, else non-zero
//      (xr,wb)               destroyed (failure case only)
//      (ra)                  destroyed
//      the expression pointer is stored in parm1 of the node
//      control returns to failp on failure of evaluation
// evalp:
        extern void evalp();				// entry point (recursive)
//      here for case of seblk
//      we can give a fast return if the value of the vrblk is
//      not an expression and is not trapped.
//      here for exblk or seblk with expr value or trapped value
// evlp1:
        extern void evlp1();				// check for stack space
        
//      evalp (continued)
//      loop back here to reevaluate expression result
// evlp2:
        extern void evlp2();				// set flag for by value
//      here to restore pattern values after successful eval
//      here to return after simple vrblk case
// evlp3:
        extern void evlp3();				// simple vrblk, no side effects
//      here for failure during evaluation
// evlp4:
        extern void evlp4();				// restore history stack base pointer
        
//      evals -- evaluate string argument
//      evals is used by span, any, notany, break, breakx when
//      they are passed an expression argument.
//      (xr)                  node pointer
//      (wb)                  cursor
//      jsr  evals            call to evaluate string
//      ppm  loc              transfer loc for non-string arg
//      ppm  loc              transfer loc for evaluation failure
//      ppm  loc              transfer loc for successful eval
//      (the normal return is never taken)
//      (xr)                  ptr to node with parms set
//      (xl,wc,ra)            destroyed
//      on return, the node pointed to has a character table
//      pointer in parm1 and a bit mask in parm2. the proper
//      successor is stored in pthen of this node. thus it is
//      ok for merging with the normal (multi-char string) case.
// evals:
        extern void evals();				// entry point (recursive)
//      here if evaluation fails
// evls1:
        extern void evls1();				// take failure return
//      here if argument is not string
// evls2:
        extern void evls2();				// pop successor and cursor
        
//      evalx -- evaluate expression
//      evalx is called to evaluate an expression
//      (xr)                  pointer to exblk or seblk
//      (wb)                  0 if by value, 1 if by name
//      jsr  evalx            call to evaluate expression
//      ppm  loc              transfer loc if evaluation fails
//      (xr)                  result if called by value
//      (xl,wa)               result name base,offset if by name
//      (xr)                  destroyed (name case only)
//      (xl,wa)               destroyed (value case only)
//      (wb,wc,ra)            destroyed
// evalx:
        extern void evalx();				// entry point, recursive
//      here for seblk
//      merge here to exit for seblk case
// evlx1:
        extern void evlx1();				// return to evalx caller
        
//      evalx (continued)
//      here for full expression (exblk) case
//      if an error occurs in the expression code at execution
//      time, control is passed via error section to exfal
//      without returning to this routine.
//      the following entries are made on the stack before
//      giving control to the expression code
//                            evalx return point
//                            saved value of r_cod
//                            code pointer (-r_cod)
//                            saved value of flptr
//                            0 if by value, 1 if by name
//      flptr --------------- *exflc, fail offset in exblk
// evlx2:
        extern void evlx2();				// get code pointer
//      here to execute first code word of expression
// evlx0:
        extern void evlx0();				// clear garbage xl
        
//      evalx (continued)
//      come here if successful return by value (see o_rvl)
// evlx3:
        extern void evlx3();				// load value
//      here for expression returning by name (see o_rnm)
// evlx4:
        extern void evlx4();				// load name offset
//      here after loading correct result into xr or xl,wa
// evlx5:
        extern void evlx5();				// note successful
//      here for failure in expression evaluation (see o_fex)
// evlx6:
        extern void evlx6();				// note unsuccessful
//      restore environment
// evlx7:
        extern void evlx7();				// skip if was not previously xt
//      merge with stage set up
// evlx8:
        extern void evlx8();				// pop name/value indicator, *exfal
//      merge here for failure in seblk case
// evlx9:
        extern void evlx9();				// take failure exit
        
//      exbld -- build exblk
//      exbld is used to build an expression block from the
//      code compiled most recently in the current ccblk.
//      (xl)                  offset in ccblk to start of code
//      (wb)                  integer in range 0 le n le mxlen
//      jsr  exbld            call to build exblk
//      (xr)                  ptr to constructed exblk
//      (wa,wb,xl)            destroyed
// exbld:
        extern void exbld();				// entry point
//      this loop searches for negation and selection code so
//      that the offsets computed whilst code was in code block
//      can be transformed to reduced values applicable in an
//      exblk.
// exbl1:
        extern void exbl1();				// get next code word
//      no selection found or merge to exit on termination
// exbl2:
        extern void exbl2();				// pop exblk ptr into xr
        
//      exbld (continued)
//      selection or negation found
//      reduce the offsets as needed. offsets occur in words
//      following code words -
//           =onta_, =osla_, =oslb_, =oslc_
// exbl3:
        extern void exbl3();				// adjust offset
// exbl4:
        extern void exbl4();				// decrement count
//      continue search for more offsets
// exbl5:
        extern void exbl5();				// get next code word
        
//      expan -- analyze expression
//      the expression analyzer (expan) procedure is used to scan
//      an expression and convert it into a tree representation.
//      see the description of cmblk in the structures section
//      for detailed format of tree blocks.
//      the analyzer uses a simple precedence scheme in which
//      operands and operators are placed on a single stack
//      and condensations are made when low precedence operators
//      are stacked after a higher precedence operator. a global
//      variable (in wb) keeps track of the level as follows.
//      0    scanning outer level of statement or expression
//      1    scanning outer level of normal goto
//      2    scanning outer level of direct goto
//      3    scanning inside array brackets
//      4    scanning inside grouping parentheses
//      5    scanning inside function parentheses
//      this variable is saved on the stack on encountering a
//      grouping and restored at the end of the grouping.
//      another global variable (in wc) counts the number of
//      items at one grouping level and is incremented for each
//      comma encountered. it is stacked with the level indicator
//      the scan is controlled by a three state finite machine.
//      a global variable stored in wa is the current state.
//      wa=0                  nothing scanned at this level
//      wa=1                  operand expected
//      wa=2                  operator expected
//      (wb)                  call type (see below)
//      jsr  expan            call to analyze expression
//      (xr)                  pointer to resulting tree
//      (xl,wa,wb,wc,ra)      destroyed
//      the entry value of wb indicates the call type as follows.
//      0    scanning either the main body of a statement or the
//           text of an expression (from eval call). valid
//           terminators are colon, semicolon. the rescan flag is
//           set to return the terminator on the next scane call.
//      1    scanning a normal goto. the only valid
//           terminator is a right paren.
//      2    scanning a direct goto. the only valid
//           terminator is a right bracket.
        
//      expan (continued)
//      entry point
// expan:
        extern void expan();				// entry point
//      loop here for successive entries
// exp01:
        extern void exp01();				// scan next element
        
//      expan (continued)
//      here for rbr,rpr,col,smc,cma in state 0
//      set to rescan the terminator encountered and create
//      a null constant (case of omitted null)
// exp02:
        extern void exp02();				// set to rescan element
//      here for var or con in states 0,1
//      stack the variable/constant and set state=2
// exp03:
        extern void exp03();				// stack pointer to operand
//      here for var,con,lpr,fnc,uop in state 2
//      we rescan the element and create a concatenation operator
//      this is the case of the blank concatenation operator.
// exp04:
        extern void exp04();				// set to rescan element
//      merge here when xr set up with proper concatenation dvblk
// exp4a:
        extern void exp4a();				// merge bop if blanks, else error
//      dcv  scnse            adjust start of element location
//      here for cma,rpr,rbr,col,smc,bop(s=1) bop(s=0)
//      this is an erronous contruction
//exp05 dcv  scnse            adjust start of element location
// exp05:
        extern void exp05();
//      here for lpr (s=0,1)
// exp06:
        extern void exp06();				// set new level indicator
        
//      expan (continued)
//      merge here to store old level on stack and start new one
// exp07:
        extern void exp07();				// stack cmopn value
//      here for lbr (s=0,1)
//      this is an illegal use of left bracket
// exp08:
        extern void exp08();
//      here for lbr (s=2)
//      set new level and start to scan subscripts
// exp09:
        extern void exp09();				// load array ptr for cmopn
//      here for fnc (s=0,1)
//      stack old level and start to scan arguments
// exp10:
        extern void exp10();				// set new lev indic (xr=vrblk=cmopn)
//      here for cma (s=2)
//      increment argument count and continue
// exp11:
        extern void exp11();				// increment counter
        
//      expan (continued)
//      here for rpr (s=2)
//      at outer level in a normal goto this is a terminator
//      otherwise it must terminate a function or grouping
// exp12:
        extern void exp12();				// end of normal goto
//      here at end of function arguments
// exp13:
        extern void exp13();				// set cmtyp value for function
//      here for end of grouping
// exp14:
        extern void exp14();				// jump if end of grouping
//      merge here to build cmblk for level just scanned and
//      to pop up to the previous scan level before continuing.
// exp15:
        extern void exp15();				// dump operators at this level
//      loop to move remaining words to cmblk
// exp16:
        extern void exp16();				// move one operand ptr from stack
        
//      expan (continued)
//      complete cmblk and stack pointer to it on stack
//      here at end of a parenthesized expression
// exp17:
        extern void exp17();				// dump operators at this level
//      here for rbr (s=2)
//      at outer level in a direct goto, this is a terminator.
//      otherwise it must terminate a subscript list.
// exp18:
        extern void exp18();				// set cmtyp for array reference
        
//      expan (continued)
//      here for col,smc (s=2)
//      error unless terminating statement body at outer level
// exp19:
        extern void exp19();				// rescan terminator
//      here at normal end of expression
// exp20:
        extern void exp20();				// dump remaining operators
//      missing right paren
// exp21:
        extern void exp21();
//      missing right paren in goto field
// exp22:
        extern void exp22();
//      missing bracket in goto
// exp23:
        extern void exp23();
//      missing array bracket
// exp24:
        extern void exp24();
        
//      expan (continued)
//      loop here when an operator causes an operator dump
// exp25:
        extern void exp25();
//      here for bop (s=2)
//      remove operators (condense) from stack until no more
//      left at this level or top one has lower precedence.
//      loop here till this condition is met.
// exp26:
        extern void exp26();				// load operator dvptr from stack
//      here for uop (s=0,1)
//      binary operator merges after precedence check
//      the operator dv is stored on the stack and the scan
//      continues after setting the scan state to one.
// exp27:
        extern void exp27();				// stack operator dvptr on stack
//      here for special case of binary =. the syntax allows a
//      null right argument for this operator to be left
//      out. accordingly we reset to state zero to get proper
//      action on a terminator (supply a null constant).
        
//      expap -- test for pattern match tree
//      expap is passed an expression tree to determine if it
//      is a pattern match. the following are recogized as
//      matches in the context of this call.
//      1)   an explicit use of binary question mark
//      2)   a concatenation
//      3)   an alternation whose left operand is a concatenation
//      (xr)                  ptr to expan tree
//      jsr  expap            call to test for pattern match
//      ppm  loc              transfer loc if not a pattern match
//      (wa)                  destroyed
//      (xr)                  unchanged (if not match)
//      (xr)                  ptr to binary operator blk if match
// expap:
        extern void expap();				// entry point
//      here for alternation. change (a b) / c to a qm (b / c)
//      exit here for pattern match
// expp1:
        extern void expp1();				// restore entry xl
//      exit here if not pattern match
// expp2:
        extern void expp2();				// restore entry xl
        
//      expdm -- dump operators at current level (for expan)
//      expdm uses expop to condense all operators at this syntax
//      level. the stack bottom is recognized from the level
//      value which is saved on the top of the stack.
//      jsr  expdm            call to dump operators
//      (xs)                  popped as required
//      (xr,wa)               destroyed
// expdm:
        extern void expdm();				// entry point
        #define P_PRC_EXPDM 3
        #define P_PRCLEN_EXPDM 0
//      loop to dump operators
// exdm1:
        extern void exdm1();				// jump if stack bottom (saved level
//      here after popping all operators
// exdm2:
        extern void exdm2();				// restore xl
        
//      expop-- pop operator (for expan)
//      expop is used by the expan routine to condense one
//      operator from the top of the syntax stack. an appropriate
//      cmblk is built for the operator (unary or binary) and a
//      pointer to this cmblk is stacked.
//      expop is also used by scngf (goto field scan) procedure
//      jsr  expop            call to pop operator
//      (xs)                  popped appropriately
//      (xr,xl,wa)            destroyed
// expop:
        extern void expop();				// entry point
        #define P_PRC_EXPOP 4
        #define P_PRCLEN_EXPOP 0
//      here for binary operator
//      common exit point
// expo1:
        extern void expo1();				// store type code for cmblk
//      here for unary operator
// expo2:
        extern void expo2();				// set size of unary operator cmblk
        
//      filnm -- obtain file name from statement number
//      filnm takes a statement number and examines the file name
//      table pointed to by r_sfn to find the name of the file
//      containing the given statement.  table entries are
//      arranged in order of ascending statement number (there
//      is only one hash bucket in this table).  elements are
//      added to the table each time there is a change in
//      file name, recording the then current statement number.
//      to find the file name, the linked list of teblks is
//      scanned for an element containing a subscript (statement
//      number) greater than the argument statement number, or
//      the end of chain.  when this condition is met, the
//      previous teblk contains the desired file name as its
//      value entry.
//      (wc)                  statement number
//      jsr  filnm            call to obtain file name
//      (xl)                  file name (scblk)
//      (ia)                  destroyed
// filnm:
        extern void filnm();				// entry point
//      loop through teblks on hash chain
// filn1:
        extern void filn1();				// next element to examine
//      here if desired stmt number is ge teblk stmt number
//      here if chain exhausted or desired block found.
// filn2:
        extern void filn2();				// previous teblk
//      no table or no table entries
// filn3:
        extern void filn3();				// restore wb
        
//      gbcol -- perform garbage collection
//      gbcol performs a garbage collection on the dynamic region
//      all blocks which are no longer in use are eliminated
//      by moving blocks which are in use down and resetting
//      dnamp, the pointer to the next available location.
//      (wb)                  move offset (see below)
//      jsr  gbcol            call to collect garbage
//      (xr)                  sediment size after collection
//      the following conditions must be met at the time when
//      gbcol is called.
//      1)   all pointers to blocks in the dynamic area must be
//           accessible to the garbage collector. this means
//           that they must occur in one of the following.
//           a)               main stack, with current top
//                            element being indicated by xs
//           b)               in relocatable fields of vrblks.
//           c)               in register xl at the time of call
//           e)               in the special region of working
//                            storage where names begin with r_.
//      2)   all pointers must point to the start of blocks with
//           the sole exception of the contents of the code
//           pointer register which points into the r_cod block.
//      3)   no location which appears to contain a pointer
//           into the dynamic region may occur unless it is in
//           fact a pointer to the start of the block. however
//           pointers outside this area may occur and will
//           not be changed by the garbage collector.
//           it is especially important to make sure that xl
//           does not contain a garbage value from some process
//           carried out before the call to the collector.
//      gbcol has the capability of moving the final compacted
//      result up in memory (with addresses adjusted accordingly)
//      this is used to add space to the static region. the
//      entry value of wb is the number of bytes to move up.
//      the caller must guarantee that there is enough room.
//      furthermore the value in wb if it is non-zero, must be at
//      least 256 so that the mwb instruction conditions are met.
        
//      gbcol (continued)
//      the algorithm, which is a modification of the lisp-2
//      garbage collector devised by r.dewar and k.belcher
//      takes three passes as follows.
//      1)   all pointers in memory are scanned and blocks in use
//           determined from this scan. note that this procedure
//           is recursive and uses the main stack for linkage.
//           the marking process is thus similar to that used in
//           a standard lisp collector. however the method of
//           actually marking the blocks is different.
//           the first field of a block normally contains a
//           code entry point pointer. such an entry pointer
//           can be distinguished from the address of any pointer
//           to be processed by the collector. during garbage
//           collection, this word is used to build a back chain
//           of pointers through fields which point to the block.
//           the end of the chain is marked by the occurence
//           of the word which used to be in the first word of
//           the block. this backchain serves both as a mark
//           indicating that the block is in use and as a list of
//           references for the relocation phase.
//      2)   storage is scanned sequentially to discover which
//           blocks are currently in use as indicated by the
//           presence of a backchain. two pointers are maintained
//           one scans through looking at each block. the other
//           is incremented only for blocks found to be in use.
//           in this way, the eventual location of each block can
//           be determined without actually moving any blocks.
//           as each block which is in use is processed, the back
//           chain is used to reset all pointers which point to
//           this block to contain its new address, i.e. the
//           address it will occupy after the blocks are moved.
//           the first word of the block, taken from the end of
//           the chain is restored at this point.
//           during pass 2, the collector builds blocks which
//           describe the regions of storage which are to be
//           moved in the third pass. there is one descriptor for
//           each contiguous set of good blocks. the descriptor
//           is built just behind the block to be moved and
//           contains a pointer to the next block and the number
//           of words to be moved.
//      3)   in the third and final pass, the move descriptor
//           blocks built in pass two are used to actually move
//           the blocks down to the bottom of the dynamic region.
//           the collection is then complete and the next
//           available location pointer is reset.
        
//      gbcol (continued)
//      the garbage collector also recognizes the concept of
//      sediment.  sediment is defined as long-lived objects
//      which percipitate to the bottom of dynamic storage.
//      moving these objects during repeated collections is
//      inefficient.  it also contributes to thrashing on
//      systems with virtual memory.  in a typical worst-case
//      situation, there may be several megabytes of live objects
//      in the sediment, and only a few dead objects in need of
//      collection.  without recognising sediment, the standard
//      collector would move those megabytes of objects downward
//      to squeeze out the dead objects.  this type of move
//      would result in excessive thrasing for very little memory
//      gain.
//      scanning of blocks in the sediment cannot be avoided
//      entirely, because these blocks may contain pointers to
//      live objects above the sediment.  however, sediment
//      blocks need not be linked to a back chain as described
//      in pass one above.  since these blocks will not be moved,
//      pointers to them do not need to be adjusted.  eliminating
//      unnecessary back chain links increases locality of
//      reference, improving virtual memory performance.
//      because back chains are used to mark blocks whose con-
//      tents have been processed, a different marking system
//      is needed for blocks in the sediment.  since block type
//      words point to odd-parity entry addresses, merely incre-
//      menting the type word serves to mark the block as pro-
//      cessed.  during pass three, the type words are decre-
//      mented to restore them to their original value.
        
//      gbcol (continued)
//      the variable dnams contains the number of bytes of memory
//      currently in the sediment.  setting dnams to zero will
//      eliminate the sediment and force it to be included in a
//      full garbage collection.  gbcol returns a suggested new
//      value for dnams (usually dnamp-dnamb) in xr which the
//      caller can store in dnams if it wishes to maintain the
//      sediment.  that is, data remaining after a garbage
//      collection is considered to be sediment.  if one accepts
//      the common lore that most objects are either very short-
//      or very long-lived, then this naive setting of dnams
//      probably includes some short-lived objects toward the end
//      of the sediment.
//      knowing when to reset dnams to zero to collect the sedi-
//      ment is not precisely known.  we force it to zero prior
//      to producing a dump, when gbcol is invoked by collect()
//      (so that the sediment is invisible to the user), when
//      sysmm is unable to obtain additional memory, and when
//      gbcol is called to relocate the dynamic area up in memory
//      (to make room for enlarging the static area).  if there
//      are no other reset situations, this leads to the inexo-
//      rable growth of the sediment, possible forcing a modest
//      program to begin to use virtual memory that it otherwise
//      would not.
//      as we scan sediment blocks in pass three, we maintain
//      aggregate counts of the amount of dead and live storage,
//      which is used to decide when to reset dnams.  when the
//      ratio of free storage found in the sediment to total
//      sediment size exceeds a threshold, the sediment is marked
//      for collection on the next gbcol call.
        
//      gbcol (continued)
// gbcol:
        extern void gbcol();				// entry point
// gbc0a:
        extern void gbc0a();				// start of dynamic area
//      inform sysgc that collection to commence
//      process stack entries
//      process the stack
// gbc00:
        extern void gbc00();				// process pointers on stack
//      process special work locations
//      prepare to process variable blocks
//      loop through hash slots
// gbc01:
        extern void gbc01();				// point to next slot
        
//      gbcol (continued)
//      loop through variables on one hash chain
// gbc02:
        extern void gbc02();				// load ptr to next vrblk
//      here at end of one hash chain
// gbc03:
        extern void gbc03();				// restore bucket pointer
        
//      gbcol (continued)
//      now we are ready to start pass two. registers are used
//      as follows in pass two.
//      (xr)                  scans through all blocks
//      (wc)                  pointer to eventual location
//      the move description blocks built in this pass have
//      the following format.
//      word 1                pointer to next move block,
//                            zero if end of chain of blocks
//      word 2                length of blocks to be moved in
//                            bytes. set to the address of the
//                            first byte while actually scanning
//                            the blocks.
//      the first entry on this chain is a special entry
//      consisting of the two words gbcnm and gbcns. after
//      building the chain of move descriptors, gbcnm points to
//      the first real move block, and gbcns is the length of
//      blocks in use at the start of storage which need not
//      be moved since they are in the correct position.
// gbc04:
        extern void gbc04();				// jump if end of sediment
//      here for unused sediment block
// gbc4b:
        extern void gbc4b();				// get length of this block
//      here at end of sediment.  remember size of free blocks
//      within the sediment.  this will be used later to decide
//      how to set the sediment size returned to caller.
//      then scan rest of dynamic area above sediment.
//      (wb) = aggregate size of free blocks in sediment
//      (xr) = first location past sediment
// gbc4c:
        extern void gbc4c();				// size of sediment free space
//      loop through a series of blocks in use
// gbc05:
        extern void gbc05();				// jump if end of used region
//      here for block in use, loop to relocate references
// gbc06:
        extern void gbc06();				// copy pointer
        
//      gbcol (continued)
//      at end of chain, restore first word and bump past
//      here at end of a series of blocks in use
// gbc07:
        extern void gbc07();				// copy pointer past last block
//      loop through a series of blocks not in use
// gbc08:
        extern void gbc08();				// jump if end of used region
//      here for a block in use after processing a series of
//      blocks which were not in use, build new move block.
// gbc09:
        extern void gbc09();				// point 2 words behind for move block
        
//      gbcol (continued)
//      here for pass three -- actually move the blocks down
//      (xl)                  pointer to old location
//      (xr)                  pointer to new location
// gbc10:
        extern void gbc10();				// point to storage above sediment
//      loop through move descriptors
// gbc11:
        extern void gbc11();				// point to next move block
//      now test for move up
// gbc12:
        extern void gbc12();				// set next available loc ptr
//      merge here to exit
// gbc13:
        extern void gbc13();				// clear garbage value in xr
//      decide whether to mark sediment for collection next time.
//      this is done by examining the ratio of previous sediment
//      free space to the new sediment size.
// gb13a:
        extern void gb13a();				// restore ia
//      garbage collection not allowed whilst dumping
// gbc14:
        extern void gbc14();				// fatal error
        
//      gbcpf -- process fields for garbage collector
//      this procedure is used by the garbage collector to
//      process fields in pass one. see gbcol for full details.
//      (xr)                  ptr to first location to process
//      (xl)                  ptr past last location to process
//      jsr  gbcpf            call to process fields
//      (xr,wa,wb,wc,ia)      destroyed
//      note that although this procedure uses a recursive
//      approach, it controls its own stack and is not recursive.
// gbcpf:
        extern void gbcpf();				// entry point
//      merge here to go down a level and start a new loop
//      1(xs)                 next lvl field ptr (0 at outer lvl)
//      0(xs)                 ptr past last field to process
//      (xr)                  ptr to first field to process
//      loop to process successive fields
// gpf01:
        extern void gpf01();				// load field contents
//      here we have a ptr to a block in the dynamic area.
//      link this field onto the reference backchain.
//      now see if this block has been processed before
// gpf1a:
        extern void gpf1a();				// jump if not already processed
//      here to restore pointer in xr to field just processed
// gpf02:
        extern void gpf02();				// restore field pointer
//      here to move to next field
// gpf2a:
        extern void gpf2a();				// bump to next field
        
//      gbcpf (continued)
//      here we pop up a level after finishing a block
//      here to process an active block which has not been done
//      since sediment blocks are not marked by putting them on
//      the back chain, they must be explicitly marked in another
//      manner.  if odd parity entry points are present, mark by
//      temporarily converting to even parity.  if odd parity not
//      available, the entry point is adjusted by the value in
//      gbcmk.
// gpf03:
        extern void gpf03();				// if not within sediment
// gpf3a:
        extern void gpf3a();				// copy block pointer
//      block type switch. note that blocks with no relocatable
//      fields just return to gpf02 here to continue to next fld.
        
//      gbcpf (continued)
//      cmblk
// gpf04:
        extern void gpf04();				// load length
//      here to push down to new level
//      (wc)                  field ptr at previous level
//      (xr)                  ptr to new block
//      (wa)                  length (reloc flds + flds at start)
//      (wb)                  offset to first reloc field
// gpf05:
        extern void gpf05();				// point past last reloc field
//      arblk
// gpf06:
        extern void gpf06();				// load length
//      ccblk
// gpf07:
        extern void gpf07();				// set length in use
        
//      gbcpf (continued)
//      cdblk
// gpf19:
        extern void gpf19();				// load length
//      tbblk, vcblk
// gpf08:
        extern void gpf08();				// load length
//      xrblk
// gpf09:
        extern void gpf09();				// load length
//      evblk, nmblk, p0blk
// gpf10:
        extern void gpf10();				// point past second field
//      ffblk
// gpf11:
        extern void gpf11();				// set length
//      p1blk, p2blk
// gpf12:
        extern void gpf12();				// length (parm2 is non-relocatable)
        
//      gbcpf (continued)
//      pdblk
// gpf13:
        extern void gpf13();				// load ptr to dfblk
//      pfblk
// gpf14:
        extern void gpf14();				// length past last reloc
//      teblk
// gpf15:
        extern void gpf15();				// set length
//      trblk
// gpf16:
        extern void gpf16();				// set length
//      exblk
// gpf17:
        extern void gpf17();				// load length
        
//      gtarr -- get array
//      gtarr is passed an object and returns an array if possibl
//      (xr)                  value to be converted
//      (wa)                  0 to place table addresses in array
//                            non-zero for keys/values in array
//      jsr  gtarr            call to get array
//      ppm  loc              transfer loc for all null table
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  resulting array
//      (xl,wa,wb,wc)         destroyed
// gtarr:
        extern void gtarr();				// entry point
//      here we convert a table to an array
//      the following code is executed twice. on the first pass,
//      signalled by xr=0, the number of non-null elements in
//      the table is counted in wb. in the second pass, where
//      xr is a pointer into the arblk, the name and value are
//      entered into the current arblk location provided gtawa
//      is non-zero.  if gtawa is zero, the address of the teblk
//      is entered into the arblk twice (c3.762).
// gtar1:
        extern void gtar1();				// point to table
//      loop through buckets in table block
//      next three lines of code rely on tenxt having a value
//      1 less than tbbuk.
// gtar2:
        extern void gtar2();				// copy bucket pointer
//      loop through teblks on one bucket chain
// gtar3:
        extern void gtar3();				// point to next teblk
//      loop to find value down trblk chain
// gtar4:
        extern void gtar4();				// load value
        
//      gtarr (continued)
//      now check for null and test cases
//      here in second pass
// gtar5:
        extern void gtar5();				// jump if address wanted
//      here to record teblk address in arblk.  this allows
//      a sort routine to sort by ascending address.
// gta5a:
        extern void gta5a();				// store teblk address in name
//      here after scanning teblks on one chain
// gtar6:
        extern void gtar6();				// loop back if more buckets to go
//      here after counting non-null elements
        
//      gtarr (continued)
//      here after filling in element values
// gtar7:
        extern void gtar7();				// restore arblk pointer
//      now we need the array prototype which is of the form nn,2
//      this is obtained by building the string for nn02 and
//      changing the zero to a comma before storing it.
//      normal return
// gtar8:
        extern void gtar8();				// return to caller
//      null table non-conversion return
// gtar9:
        extern void gtar9();				// restore stack for conv err (sgd02)
//      impossible conversion return
// gta9a:
        extern void gta9a();				// return
//      array size too large
// gta9b:
        extern void gta9b();
        
//      gtcod -- convert to code
//      (xr)                  object to be converted
//      jsr  gtcod            call to convert to code
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  pointer to resulting cdblk
//      (xl,wa,wb,wc,ra)      destroyed
//      if a spitbol error occurs during compilation or pre-
//      evaluation, control is passed via error section to exfal
//      without returning to this routine.
// gtcod:
        extern void gtcod();				// entry point
//      here we must generate a cdblk by compilation
//      merge here if no convert required
// gtcd1:
        extern void gtcd1();				// give normal gtcod return
//      here if unconvertible
// gtcd2:
        extern void gtcd2();				// give error return
        
//      gtexp -- convert to expression
//      (wb)                  0 if by value, 1 if by name
//      (xr)                  input value to be converted
//      jsr  gtexp            call to convert to expression
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  pointer to result exblk or seblk
//      (xl,wa,wb,wc,ra)      destroyed
//      if a spitbol error occurs during compilation or pre-
//      evaluation, control is passed via error section to exfal
//      without returning to this routine.
// gtexp:
        extern void gtexp();				// entry point
//      check the last character of the string for colon or
//      semicolon.  these characters can legitimately end an
//      expression in open code, so expan will not detect them
//      as errors, but they are invalid as terminators for a
//      string that is being converted to expression form.
//      here we convert a string by compilation
//      merge here if no conversion required
// gtex1:
        extern void gtex1();				// return to gtexp caller
//      here if unconvertible
// gtex2:
        extern void gtex2();				// take error exit
        
//      gtint -- get integer value
//      gtint is passed an object and returns an integer after
//      performing any necessary conversions.
//      (xr)                  value to be converted
//      jsr  gtint            call to convert to integer
//      ppm  loc              transfer loc for convert impossible
//      (xr)                  resulting integer
//      (wc,ra)               destroyed
//      (wa,wb)               destroyed (only on conversion err)
//      (xr)                  unchanged (on convert error)
// gtint:
        extern void gtint();				// entry point
//      here we convert a real to integer
//      here after successful conversion to integer
// gtin1:
        extern void gtin1();				// restore wa
//      common exit point
// gtin2:
        extern void gtin2();				// return to gtint caller
//      here on conversion error
// gtin3:
        extern void gtin3();				// take convert error exit
        
//      gtnum -- get numeric value
//      gtnum is given an object and returns either an integer
//      or a real, performing any necessary conversions.
//      (xr)                  object to be converted
//      jsr  gtnum            call to convert to numeric
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  pointer to result (int or real)
//      (wa)                  first word of result block
//      (wb,wc,ra)            destroyed
//      (xr)                  unchanged (on convert error)
// gtnum:
        extern void gtnum();				// entry point
//      at this point the only possibility is to convert a string
//      to an integer or real as appropriate.
//      initialize numeric conversion
//      merge back here after ignoring leading blank
// gtn01:
        extern void gtn01();				// load first character
        
//      gtnum (continued)
//      here if first digit is non-digit
// gtn02:
        extern void gtn02();				// jump if non-blank
// gtna2:
        extern void gtna2();				// else decr count and loop back
//      here for first character non-blank, non-digit
// gtn03:
        extern void gtn03();				// jump if plus sign
//      merge here after processing sign
// gtn04:
        extern void gtn04();				// jump if chars left
//      loop to fetch characters of an integer
// gtn05:
        extern void gtn05();				// load next character
//      merge here for first digit
// gtn06:
        extern void gtn06();				// save current value
//      here to exit with converted integer value
// gtn07:
        extern void gtn07();				// jump if negative (all set)
        
//      gtnum (continued)
//      here for a non-digit character while attempting to
//      convert an integer, check for trailing blanks or real.
// gtn08:
        extern void gtn08();				// jump if a blank
//      here we scan out blanks to end of string
// gtn09:
        extern void gtn09();				// get next char
// gtna9:
        extern void gtna9();				// loop back if more chars to check
//      loop to collect mantissa of real
// gtn10:
        extern void gtn10();				// load next character
//      merge here to collect first real digit
// gtn11:
        extern void gtn11();				// convert digit to number
        
//      gtnum (continued)
//      here if non-digit found while collecting a real
// gtn12:
        extern void gtn12();				// jump if not dec point
//      here if not decimal point
// gtn13:
        extern void gtn13();				// jump if e for exponent
//      here check for trailing blanks
// gtn14:
        extern void gtn14();				// jump if blank
// gtnb4:
        extern void gtnb4();				// get next character
//      here to read and process an exponent
// gtn15:
        extern void gtn15();				// set exponent sign positive
//      check for exponent sign
// gtn16:
        extern void gtn16();				// load first exponent character
//      merge here after processing exponent sign
// gtn17:
        extern void gtn17();				// jump if chars left
//      loop to convert exponent digits
// gtn18:
        extern void gtn18();				// load next character
        
//      gtnum (continued)
//      merge here for first exponent digit
// gtn19:
        extern void gtn19();				// jump if not digit
//      here to check for trailing blanks after exponent
// gtn20:
        extern void gtn20();				// jump if blank
// gtnc0:
        extern void gtnc0();				// get next character
//      merge here after collecting exponent
// gtn21:
        extern void gtn21();				// save collected exponent
//      merge here with exponent (0 if none given)
// gtn22:
        extern void gtn22();				// error if not digits collected
//      here we have a negative exponent, so scale down
//      loop to scale down in steps of 10**10
// gtn23:
        extern void gtn23();				// jump if 10 or less to go
        
//      gtnum (continued)
//      here scale rest of way from powers of ten table
// gtn24:
        extern void gtn24();				// jump if scaled
//      loop to point to powers of ten table entry
// gtn25:
        extern void gtn25();				// bump pointer
//      come here to scale result up (positive exponent)
// gtn26:
        extern void gtn26();				// get absolute value of exponent
//      loop to scale up in steps of 10**10
// gtn27:
        extern void gtn27();				// jump if 10 or less to go
//      here to scale up rest of way with table
// gtn28:
        extern void gtn28();				// jump if scaled
//      loop to point to proper entry in powers of ten table
// gtn29:
        extern void gtn29();				// bump pointer
        
//      gtnum (continued)
//      here with real value scaled and ready except for sign
// gtn30:
        extern void gtn30();				// jump if positive
//      here with properly signed real value in (ra)
// gtn31:
        extern void gtn31();				// build real block
//      here with properly signed integer value in (ia)
// gtn32:
        extern void gtn32();				// build icblk
//      real merges here
// gtn33:
        extern void gtn33();				// load first word of result block
//      common exit point
// gtn34:
        extern void gtn34();				// return to gtnum caller
//      come here if overflow occurs during collection of integer
//      have to restore wb which cvm may have destroyed.
// gtn35:
        extern void gtn35();				// reload current character
//      here for unconvertible to string or conversion error
// gtn36:
        extern void gtn36();				// reload original argument
        
//      gtnvr -- convert to natural variable
//      gtnvr locates a variable block (vrblk) given either an
//      appropriate name (nmblk) or a non-null string (scblk).
//      (xr)                  argument
//      jsr  gtnvr            call to convert to natural variable
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  pointer to vrblk
//      (wa,wb)               destroyed (conversion error only)
//      (wc)                  destroyed
// gtnvr:
        extern void gtnvr();				// entry point
//      common error exit
// gnv01:
        extern void gnv01();				// take convert-error exit
//      here if not name
// gnv02:
        extern void gnv02();				// save wa
        
//      gtnvr (continued)
//      loop to search hash chain
// gnv03:
        extern void gnv03();				// copy hash chain pointer
//      merge here with string ptr (like vrblk) in xl
// gnv04:
        extern void gnv04();				// back for next vrblk if lengths ne
//      loop to compare characters of the two names
// gnv05:
        extern void gnv05();				// jump if no match for next vrblk
//      exit point after finding vrblk or building new one
// gnv06:
        extern void gnv06();				// restore wa
//      common exit point
// gnv07:
        extern void gnv07();				// return to gtnvr caller
//      not found, prepare to search system variable table
// gnv08:
        extern void gnv08();				// clear garbage xr pointer
        
//      gtnvr (continued)
//      loop to search entries in standard variable table
// gnv09:
        extern void gnv09();				// save table pointer
//      loop to check for matching names
// gnv10:
        extern void gnv10();				// jump if name mismatch
//      here we have a match in the standard variable table
//      here if no match with table entry in svblks table
// gnv11:
        extern void gnv11();				// bump past word of chars
//      loop to bump table ptr for each flagged word
// gnv12:
        extern void gnv12();				// load bit to test
//      here after dealing with one word (one bit)
// gnv13:
        extern void gnv13();				// remove bit already processed
//      here if not system variable
// gnv14:
        extern void gnv14();				// copy vrlen value
        
//      gtnvr (continued)
//      merge here to build vrblk
// gnv15:
        extern void gnv15();				// allocate space for vrblk (static)
//      here for non-system variable -- set chars of name
//      here for system variable case to fill in fields where
//      necessary from the fields present in the svblk.
// gnv16:
        extern void gnv16();				// load pointer to svblk
//      skip past keyword number (svknm) if present
        
//      gtnvr (continued)
//      here test for function (svfnc and svnar)
// gnv17:
        extern void gnv17();				// get test bit
//      now test for label (svlbl)
// gnv18:
        extern void gnv18();				// get test bit
//      now test for value (svval)
// gnv19:
        extern void gnv19();				// load test bit
        
//      gtpat -- get pattern
//      gtpat is passed an object in (xr) and returns a
//      pattern after performing any necessary conversions
//      (xr)                  input argument
//      jsr  gtpat            call to convert to pattern
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  resulting pattern
//      (wa)                  destroyed
//      (wb)                  destroyed (only on convert error)
//      (xr)                  unchanged (only on convert error)
// gtpat:
        extern void gtpat();				// entry point
//      here if not pattern, try for string
//      here we have a string
//      here for null string. generate pointer to null pattern.
        
//      gtpat (continued)
//      here for non-null string
// gtpt1:
        extern void gtpt1();				// load pcode for multi-char string
//      here for one character string, share one character any
//      here if argument is not convertible to string
// gtpt2:
        extern void gtpt2();				// set pcode for expression in case
//      here we have an error (conversion impossible)
//      merge here to build node for string or expression
// gtpt3:
        extern void gtpt3();				// call routine to build pattern node
//      common exit after successful conversion
// gtpt4:
        extern void gtpt4();				// restore wb
//      merge here to exit if no conversion required
// gtpt5:
        extern void gtpt5();				// return to gtpat caller
        
//      gtrea -- get real value
//      gtrea is passed an object and returns a real value
//      performing any necessary conversions.
//      (xr)                  object to be converted
//      jsr  gtrea            call to convert object to real
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  pointer to resulting real
//      (wa,wb,wc,ra)         destroyed
//      (xr)                  unchanged (convert error only)
// gtrea:
        extern void gtrea();				// entry point
//      here for case of an integer to convert to real
// gtre1:
        extern void gtre1();				// load integer
//      exit with real
// gtre2:
        extern void gtre2();				// return to gtrea caller
//      here on conversion error
// gtre3:
        extern void gtre3();				// take convert error exit
        
//      gtsmi -- get small integer
//      gtsmi is passed a snobol object and returns an address
//      integer in the range (0 le n le dnamb). such a value can
//      only be derived from an integer in the appropriate range.
//      small integers never appear as snobol values. however,
//      they are used internally for a variety of purposes.
//      -(xs)                 argument to convert (on stack)
//      jsr  gtsmi            call to convert to small integer
//      ppm  loc              transfer loc for not integer
//      ppm  loc              transfer loc for lt 0, gt dnamb
//      (xr,wc)               resulting small int (two copies)
//      (xs)                  popped
//      (ra)                  destroyed
//      (wa,wb)               destroyed (on convert error only)
//      (xr)                  input arg (convert error only)
// gtsmi:
        extern void gtsmi();				// entry point
        #define P_PRC_GTSMI 5
        #define P_PRCLEN_GTSMI 2
//      here if not an integer
//      merge here with integer
// gtsm1:
        extern void gtsm1();				// load integer value
//      here if unconvertible to integer
// gtsm2:
        extern void gtsm2();				// take non-integer error exit
//      here if out of range
// gtsm3:
        extern void gtsm3();				// take out-of-range error exit
        
//      gtstg -- get string
//      gtstg is passed an object and returns a string with
//      any necessary conversions performed.
//      -(xs)                 input argument (on stack)
//      jsr  gtstg            call to convert to string
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  pointer to resulting string
//      (wa)                  length of string in characters
//      (xs)                  popped
//      (ra)                  destroyed
//      (xr)                  input arg (convert error only)
// gtstg:
        extern void gtstg();				// entry point
        #define P_PRC_GTSTG 6
        #define P_PRCLEN_GTSTG 1
//      here if not a string already
// gts01:
        extern void gts01();				// restack argument in case error
//      here on conversion error
// gts02:
        extern void gts02();				// restore xl
        
//      gtstg (continued)
//      here to convert a name (only possible if natural var)
// gts03:
        extern void gts03();				// load name base
//      merge here with string in xr, length in wa
// gts04:
        extern void gts04();				// set offset to zero
//      come here to convert an integer
// gts05:
        extern void gts05();				// load integer value
        
//      gtstg (continued)
//      here with sign flag set and sign forced negative as
//      required by the cvd instruction.
// gts06:
        extern void gts06();				// point to result work area
//      loop to convert digits into work area
// gts07:
        extern void gts07();				// convert one digit into wa
//      merge here after converting integer or real into work
//      area. wb is set to nstmx - (number of chars in result).
// gts08:
        extern void gts08();				// get max number of characters
//      here after dealing with sign
// gts09:
        extern void gts09();				// recall length to move
        
//      gtstg (continued)
//      here to convert a real
// gts10:
        extern void gts10();				// load real
//      now scale the real to the range (0.1 le x lt 1.0)
// gts11:
        extern void gts11();				// initialize exponent to zero
//      loop to scale up in steps of 10**10
// gts12:
        extern void gts12();				// save real value
//      test for scale down required
// gts13:
        extern void gts13();				// reload value
//      loop to scale down in steps of 10**10
// gts14:
        extern void gts14();				// subtract 10**10 to compare
        
//      gtstg (continued)
//      at this point we have (1.0 le x lt 10**10)
//      complete scaling with powers of ten table
// gts15:
        extern void gts15();				// point to powers of ten table
//      loop to locate correct entry in table
// gts16:
        extern void gts16();				// reload value
//      we are now scaled, so round by adding 0.5 * 10**(-cfp_s)
// gts17:
        extern void gts17();				// get value again
//      the rounding operation may have pushed us up past
//      1.0 again, so check one more time.
//      here if rounding did not muck up scaling
// gts18:
        extern void gts18();				// reload rounded value
        
//      gtstg (continued)
//      now we have completed the scaling as follows
//      (ia)                  signed exponent
//      (ra)                  scaled real (absolute value)
//      if the exponent is negative or greater than cfp_s, then
//      we convert the number in the form.
//      (neg sign) 0 . (cpf_s digits) e (exp sign) (exp digits)
//      if the exponent is positive and less than or equal to
//      cfp_s, the number is converted in the form.
//      (neg sign) (exponent digits) . (cfp_s-exponent digits)
//      in both cases, the formats obtained from the above
//      rules are modified by deleting trailing zeros after the
//      decimal point. there are no leading zeros in the exponent
//      and the exponent sign is always present.
// gts19:
        extern void gts19();				// set num dec digits = cfp_s
//      here if we can use the format without an exponent
// gts20:
        extern void gts20();				// compute digits after decimal point
        
//      gtstg (continued)
//      merge here as follows
//      (ia)                  exponent absolute value
//      gtses                 character for exponent sign
//      (ra)                  positive fraction
//      (xl)                  number of digits after dec point
// gts21:
        extern void gts21();				// point to work area
//      loop to generate digits of exponent
// gts22:
        extern void gts22();				// convert a digit into wa
//      here generate exponent sign and e
//      here to generate the fraction
// gts23:
        extern void gts23();				// convert real to integer (10**cfp_s)
//      loop to suppress trailing zeros
// gts24:
        extern void gts24();				// jump if no digits left to do
        
//      gtstg (continued)
//      loop to generate digits after decimal point
// gts25:
        extern void gts25();				// convert a digit into wa
//      merge here first time
// gts26:
        extern void gts26();				// store digit
//      here generate the decimal point
// gts27:
        extern void gts27();				// load decimal point
//      here generate the digits before the decimal point
// gts28:
        extern void gts28();				// convert a digit into wa
//      exit point after successful conversion
// gts29:
        extern void gts29();				// restore xl
//      merge here if no conversion required
// gts30:
        extern void gts30();				// load string length
//      here to return string for real zero
// gts31:
        extern void gts31();				// point to string
        
//      gtvar -- get variable for i/o/trace association
//      gtvar is used to point to an actual variable location
//      for the detach,input,output,trace,stoptr system functions
//      (xr)                  argument to function
//      jsr  gtvar            call to locate variable pointer
//      ppm  loc              transfer loc if not ok variable
//      (xl,wa)               name base,offset of variable
//      (xr,ra)               destroyed
//      (wb,wc)               destroyed (convert error only)
//      (xr)                  input arg (convert error only)
// gtvar:
        extern void gtvar();				// entry point
//      here on conversion error
// gtvr1:
        extern void gtvr1();				// take convert error exit
//      here if not a name, try convert to natural variable
// gtvr2:
        extern void gtvr2();				// save wc
//      here for name obtained
// gtvr3:
        extern void gtvr3();				// all ok if not natural variable
//      common exit point
// gtvr4:
        extern void gtvr4();				// return to caller
        
        
//      hashs -- compute hash index for string
//      hashs is used to convert a string to a unique integer
//      value. the resulting hash value is a positive integer
//      in the range 0 to cfp_m
//      (xr)                  string to be hashed
//      jsr  hashs            call to hash string
//      (ia)                  hash value
//      (xr,wb,wc)            destroyed
//      the hash function used is as follows.
//      start with the length of the string.
//      if there is more than one character in a word,
//      take the first e_hnw words of the characters from
//      the string or all the words if fewer than e_hnw.
//      compute the exclusive or of all these words treating
//      them as one word bit string values.
//      if there is just one character in a word,
//      then mimic the word by word hash by shifting
//      successive characters to get a similar effect.
//      e_hnw is set to zero in case only one character per word.
//      move the result as an integer with the mti instruction.
//      the test on e_hnw is done dynamically. this should be done
//      eventually using conditional assembly, but that would require
//      changes to the build process (ds 8 may 2013).
// hashs:
        extern void hashs();				// entry point
//      here with count of words to check in wc
// hshs1:
        extern void hshs1();				// set counter to control loop
//      loop to compute exclusive or
// hshs2:
        extern void hshs2();				// exclusive or next word of chars
//      merge here with exclusive or in wb
// hshs3:
        extern void hshs3();				// zeroise undefined bits
//      here if just one character per word
// hshsa:
        extern void hshsa();				// load string length in characters
// hsh24:
        extern void hsh24();				// load next character
// hsh23:
        extern void hsh23();				// load next character
// hsh22:
        extern void hsh22();				// load next character
// hsh21:
        extern void hsh21();				// load next character
// hsh20:
        extern void hsh20();				// load next character
// hsh19:
        extern void hsh19();				// load next character
// hsh18:
        extern void hsh18();				// load next character
// hsh17:
        extern void hsh17();				// load next character
// hsh16:
        extern void hsh16();				// load next character
// hsh15:
        extern void hsh15();				// load next character
// hsh14:
        extern void hsh14();				// load next character
// hsh13:
        extern void hsh13();				// load next character
// hsh12:
        extern void hsh12();				// load next character
// hsh11:
        extern void hsh11();				// load next character
// hsh10:
        extern void hsh10();				// load next character
// hsh09:
        extern void hsh09();				// load next character
// hsh08:
        extern void hsh08();				// load next character
// hsh07:
        extern void hsh07();				// load next character
// hsh06:
        extern void hsh06();				// load next character
// hsh05:
        extern void hsh05();				// load next character
// hsh04:
        extern void hsh04();				// load next character
// hsh03:
        extern void hsh03();				// load next character
// hsh02:
        extern void hsh02();				// load next character
// hsh01:
        extern void hsh01();				// load next character
// hsh00:
        extern void hsh00();				// restore xl
//      icbld -- build integer block
//      (ia)                  integer value for icblk
//      jsr  icbld            call to build integer block
//      (xr)                  pointer to result icblk
//      (wa)                  destroyed
// icbld:
        extern void icbld();				// entry point
//      construct icblk
// icbl1:
        extern void icbl1();				// load pointer to next available loc
//      merge here with xr pointing past the block obtained
// icbl2:
        extern void icbl2();				// set new pointer
//      optimise by not building icblks for small integers
// icbl3:
        extern void icbl3();				// convert integer to offset
        
//      ident -- compare two values
//      ident compares two values in the sense of the ident
//      differ functions available at the snobol level.
//      (xr)                  first argument
//      (xl)                  second argument
//      jsr  ident            call to compare arguments
//      ppm  loc              transfer loc if ident
//      (normal return if differ)
//      (xr,xl,wc,ra)         destroyed
// ident:
        extern void ident();				// entry point
//      for all other datatypes, must be differ if xr ne xl
//      merge here for differ
// iden1:
        extern void iden1();				// take differ exit
//      here for strings, ident only if lengths and chars same
// iden2:
        extern void iden2();				// load arg 1 length
//      buffer and string comparisons merge here
// idn2a:
        extern void idn2a();				// point to chars of arg 1
//      loop to compare characters. note that wc cannot be zero
//      since all null strings point to nulls and give xl=xr.
// iden3:
        extern void iden3();				// differ if chars do not match
        
//      ident (continued)
//      here to exit for case of two ident strings
//      here for integers, ident if same values
// iden4:
        extern void iden4();				// load arg 1
//      here for reals, ident if same values
// iden5:
        extern void iden5();				// load arg 1
//      here for names, ident if bases and offsets same
// iden6:
        extern void iden6();				// differ if different offset
//      merge here to signal ident for identical pointers
// iden7:
        extern void iden7();				// take ident exit
//      here for differ strings
// iden8:
        extern void iden8();				// clear garbage ptr in xr
        
//      inout - used to initialise input and output variables
//      (xl)                  pointer to vbl name string
//      (wb)                  trblk type
//      jsr  inout            call to perform initialisation
//      (xl)                  vrblk ptr
//      (xr)                  trblk ptr
//      (wa,wc)               destroyed
//      note that trter (= trtrf) field of standard i/o variables
//      points to corresponding svblk not to a trblk as is the
//      case for ordinary variables.
// inout:
        extern void inout();				// entry point
        
//      insta - used to initialize structures in static region
//      (xr)                  pointer to starting static location
//      jsr  insta            call to initialize static structure
//      (xr)                  ptr to next free static location
//      (wa,wb,wc)            destroyed
//      note that this procedure establishes the pointers
//      prbuf, gtswk, and kvalp.
// insta:
        extern void insta();				// entry point
//      initialize print buffer with blank words
//      loop to clear buffer
// inst1:
        extern void inst1();				// store blank
//      allocate work area for gtstg conversion procedure
//      build alphabet string for alphabet keyword and replace
//      loop to enter character codes in order
// inst2:
        extern void inst2();				// store next code
        
//      iofcb -- get input/output fcblk pointer
//      used by endfile, eject and rewind to find the fcblk
//      (if any) corresponding to their argument.
//      -(xs)                 argument
//      jsr  iofcb            call to find fcblk
//      ppm  loc              arg is an unsuitable name
//      ppm  loc              arg is null string
//      ppm  loc              arg file not found
//      (xs)                  popped
//      (xl)                  ptr to filearg1 vrblk
//      (xr)                  argument
//      (wa)                  fcblk ptr or 0
//      (wb,wc)               destroyed
// iofcb:
        extern void iofcb();				// entry point
        #define P_PRC_IOFCB 7
        #define P_PRCLEN_IOFCB 3
//      loop to find file arg1 trblk
// iofc1:
        extern void iofc1();				// get possible trblk ptr
//      fail return
// iofc2:
        extern void iofc2();				// fail
//      null arg
// iofc3:
        extern void iofc3();				// null arg return
//      file not found
// iofc4:
        extern void iofc4();				// file not found return
        
//      ioppf -- process filearg2 for ioput
//      (r_xsc)               filearg2 ptr
//      jsr  ioppf            call to process filearg2
//      (xl)                  filearg1 ptr
//      (xr)                  file arg2 ptr
//      -(xs)...-(xs)         fields extracted from filearg2
//      (wc)                  no. of fields extracted
//      (wb)                  input/output flag
//      (wa)                  fcblk ptr or 0
// ioppf:
        extern void ioppf();				// entry point
        #define P_PRC_IOPPF 8
        #define P_PRCLEN_IOPPF 0
//      loop to extract fields
// iopp1:
        extern void iopp1();				// get delimiter
        
//      ioput -- routine used by input and output
//      ioput sets up input/output  associations. it builds
//      such trace and file control blocks as are necessary and
//      calls sysfc,sysio to perform checks on the
//      arguments and to open the files.
//         +-----------+   +---------------+       +-----------+
//      +-.i           i   i               i------.i   =b_xrt  i
//      i  +-----------+   +---------------+       +-----------+
//      i  /           /        (r_fcb)            i    *4     i
//      i  /           /                           +-----------+
//      i  +-----------+   +---------------+       i           i-
//      i  i   name    +--.i    =b_trt     i       +-----------+
//      i  /           /   +---------------+       i           i
//      i   (first arg)    i =trtin/=trtou i       +-----------+
//      i                  +---------------+             i
//      i                  i     value     i             i
//      i                  +---------------+             i
//      i                  i(trtrf) 0   or i--+          i
//      i                  +---------------+  i          i
//      i                  i(trfpt) 0   or i----+        i
//      i                  +---------------+  i i        i
//      i                     (i/o trblk)     i i        i
//      i  +-----------+                      i i        i
//      i  i           i                      i i        i
//      i  +-----------+                      i i        i
//      i  i           i                      i i        i
//      i  +-----------+   +---------------+  i i        i
//      i  i           +--.i    =b_trt     i.-+ i        i
//      i  +-----------+   +---------------+    i        i
//      i  /           /   i    =trtfc     i    i        i
//      i  /           /   +---------------+    i        i
//      i    (filearg1     i     value     i    i        i
//      i         vrblk)   +---------------+    i        i
//      i                  i(trtrf) 0   or i--+ i        .
//      i                  +---------------+  i .  +-----------+
//      i                  i(trfpt) 0   or i------./   fcblk   /
//      i                  +---------------+  i    +-----------+
//      i                       (trtrf)       i
//      i                                     i
//      i                                     i
//      i                  +---------------+  i
//      i                  i    =b_xrt     i.-+
//      i                  +---------------+
//      i                  i      *5       i
//      i                  +---------------+
//      +------------------i               i
//                         +---------------+       +-----------+
//                         i(trtrf) o   or i------.i  =b_xrt   i
//                         +---------------+       +-----------+
//                         i  name offset  i       i    etc    i
//                         +---------------+
//                           (iochn - chain of name pointers)
        
//      ioput (continued)
//      no additional trap blocks are used for standard input/out
//      files. otherwise an i/o trap block is attached to second
//      arg (filearg1) vrblk. see diagram above for details of
//      the structure built.
//      -(xs)                 1st arg (vbl to be associated)
//      -(xs)                 2nd arg (file arg1)
//      -(xs)                 3rd arg (file arg2)
//      (wb)                  0 for input, 3 for output assoc.
//      jsr  ioput            call for input/output association
//      ppm  loc              3rd arg not a string
//      ppm  loc              2nd arg not a suitable name
//      ppm  loc              1st arg not a suitable name
//      ppm  loc              inappropriate file spec for i/o
//      ppm  loc              i/o file does not exist
//      ppm  loc              i/o file cannot be read/written
//      ppm  loc              i/o fcblk currently in use
//      (xs)                  popped
//      (xl,xr,wa,wb,wc)      destroyed
// ioput:
        extern void ioput();				// entry point
        #define P_PRC_IOPUT 9
        #define P_PRCLEN_IOPUT 7
// iopa0:
        extern void iopa0();				// keep file arg2
//      null filearg1
// iop00:
        extern void iop00();				// skip if both args null
        
//      ioput (continued)
//      here with 0 or fcblk ptr in (xl)
// iop01:
        extern void iop01();				// get trace type
//      loop to end of trblk chain if any
// iop02:
        extern void iop02();				// copy blk ptr
//      ioput (continued)
//      store new association
// iop03:
        extern void iop03();				// link to this trblk
//      non standard file
//      see if an fcblk has already been allocated.
// iop04:
        extern void iop04();				// in case no fcblk found
        
//      ioput (continued)
//      search possible trblk chain to pick up the fcblk
// iop05:
        extern void iop05();				// remember blk ptr
//      wa = 0 or fcblk ptr
//      wb = ptr to preceding blk to which any trtrf block
//           for file arg1 must be chained.
// iop06:
        extern void iop06();				// keep possible fcblk ptr
//      obtain fcblk in dynamic
// iop6a:
        extern void iop6a();				// get space for fcblk
//      merge
// iop6b:
        extern void iop6b();				// point to fcblk
//      clear fcblk
// iop07:
        extern void iop07();				// clear a word
        
//      ioput (continued)
//      complete fcblk initialisation
// iop09:
        extern void iop09();				// get possible trblk ptr
//      a new trblk is needed
//      here if existing trblk
// iop10:
        extern void iop10();				// do not release if sysio fails
//      xr is ptr to trblk, xl is fcblk ptr or 0
// iop1a:
        extern void iop1a();				// store fcblk ptr
//      call sysio to complete file accessing
// iop11:
        extern void iop11();				// copy fcblk ptr or 0
//      sysfc may have returned a pointer to a private fcblk
// iop12:
        extern void iop12();				// jump if private fcblk
//      failure returns
// iop13:
        extern void iop13();				// 3rd arg not a string
// iop14:
        extern void iop14();				// 2nd arg unsuitable
// iop15:
        extern void iop15();				// discard trblk pointer
// iop16:
        extern void iop16();				// file spec wrong
// iop26:
        extern void iop26();				// fcblk in use
//      i/o file does not exist
// iop17:
        extern void iop17();				// is there a trblk to release
// iopa7:
        extern void iopa7();				// i/o file does not exist
//      i/o file cannot be read/written
// iop18:
        extern void iop18();				// is there a trblk to release
// iopa8:
        extern void iopa8();				// i/o file cannot be read/written
        
//      ioput (continued)
//      add to iochn chain of associated variables unless
//      already present.
// iop19:
        extern void iop19();				// wc = name base, wb = name offset
//      search loop
// iop20:
        extern void iop20();				// next link of chain
//      not found
// iop21:
        extern void iop21();				// space needed
//      insert fcblk on fcblk chain for sysej, sysxi
// iop22:
        extern void iop22();				// skip if no fcblk
//      see if fcblk already on chain
// iop23:
        extern void iop23();				// not on if end of chain
//      not found so add an entry for this fcblk
// iop24:
        extern void iop24();				// space needed
//      return
// iop25:
        extern void iop25();				// return to caller
        
//      ktrex -- execute keyword trace
//      ktrex is used to execute a possible keyword trace. it
//      includes the test on trace and tests for trace active.
//      (xl)                  ptr to trblk (or 0 if untraced)
//      jsr  ktrex            call to execute keyword trace
//      (xl,wa,wb,wc)         destroyed
//      (ra)                  destroyed
// ktrex:
        extern void ktrex();				// entry point (recursive)
//      here for print trace
// ktrx1:
        extern void ktrx1();				// stack vrblk ptr for kwnam
//      here to exit after completing trace
// ktrx2:
        extern void ktrx2();				// restore entry xr
//      merge here to exit if no trace required
// ktrx3:
        extern void ktrx3();				// return to ktrex caller
        
//      kwnam -- get pseudo-variable name for keyword
//      1(xs)                 name base for vrblk
//      0(xs)                 offset (should be *vrval)
//      jsr  kwnam            call to get pseudo-variable name
//      (xs)                  popped twice
//      (xl,wa)               resulting pseudo-variable name
//      (xr,wa,wb)            destroyed
// kwnam:
        extern void kwnam();				// entry point
        #define P_PRC_KWNAM 10
        #define P_PRCLEN_KWNAM 0
//      here if not keyword name
// kwnm1:
        extern void kwnm1();
        
//      lcomp-- compare two strings lexically
//      1(xs)                 first argument
//      0(xs)                 second argument
//      jsr  lcomp            call to compare aruments
//      ppm  loc              transfer loc for arg1 not string
//      ppm  loc              transfer loc for arg2 not string
//      ppm  loc              transfer loc if arg1 llt arg2
//      ppm  loc              transfer loc if arg1 leq arg2
//      ppm  loc              transfer loc if arg1 lgt arg2
//      (the normal return is never taken)
//      (xs)                  popped twice
//      (xr,xl)               destroyed
//      (wa,wb,wc,ra)         destroyed
// lcomp:
        extern void lcomp();				// entry point
        #define P_PRC_LCOMP 11
        #define P_PRCLEN_LCOMP 5
//      here with smaller length in (wa)
// lcmp1:
        extern void lcmp1();				// if null string, compare lengths
// lcmp7:
        extern void lcmp7();				// if equal, jump if lengths unequal
        
//      lcomp (continued)
//      here if initial strings identical, but lengths unequal
// lcmp2:
        extern void lcmp2();				// jump if arg 1 length gt arg 2 leng
//      here if first arg llt second arg
// lcmp3:
        extern void lcmp3();				// take llt exit
//      here if first arg lgt second arg
// lcmp4:
        extern void lcmp4();				// take lgt exit
//      here if first arg is not a string
// lcmp5:
        extern void lcmp5();				// take bad first arg exit
//      here for second arg not a string
// lcmp6:
        extern void lcmp6();				// take bad second arg error exit
        
//      listr -- list source line
//      listr is used to list a source line during the initial
//      compilation. it is called from scane and scanl.
//      jsr  listr            call to list line
//      (xr,xl,wa,wb,wc)      destroyed
//      global locations used by listr
//      cnttl                 flag for -title, -stitl
//      erlst                 if listing on account of an error
//      lstid                 include depth of current image
//      lstlc                 count lines on current page
//      lstnp                 max number of lines/page
//      lstpf                 set non-zero if the current source
//                            line has been listed, else zero.
//      lstpg                 compiler listing page number
//      lstsn                 set if stmnt num to be listed
//      r_cim                 pointer to current input line.
//      r_ttl                 title for source listing
//      r_stl                 ptr to sub-title string
//      entry point
// listr:
        extern void listr();				// entry point
//      here after printing title (if needed)
// list0:
        extern void list0();				// load pointer to current image
//      print statement number
// list1:
        extern void list1();				// else print statement number
//      here to test for printing include depth
// list2:
        extern void list2();				// include depth of image
        
//      listr (continued)
//      here after printing statement number and include depth
// list8:
        extern void list8();				// point past statement number
//      here after printing source image
// list3:
        extern void list3();				// set flag for line printed
//      merge here to exit
// list4:
        extern void list4();				// return to listr caller
//      print title after -title or -stitl card
// list5:
        extern void list5();				// clear flag
//      eject to new page and list title
// list6:
        extern void list6();				// eject
//      list title
// list7:
        extern void list7();				// list title
        
//      listt -- list title and subtitle
//      used during compilation to print page heading
//      jsr  listt            call to list title
//      (xr,wa)               destroyed
// listt:
        extern void listt();				// entry point
//      print sub-title (if any)
//      return point
// lstt1:
        extern void lstt1();				// print a blank line
        
//      newfn -- record new source file name
//      newfn is used after switching to a new include file, or
//      after a -line statement which contains a file name.
//      (xr)                  file name scblk
//      jsr  newfn
//      (wa,wb,wc,xl,xr,ra)   destroyed
//      on return, the table that maps statement numbers to file
//      names has been updated to include this new file name and
//      the current statement number.  the entry is made only if
//      the file name had changed from its previous value.
// newfn:
        extern void newfn();				// entry point
//     here if new name and old name identical
// nwfn1:
        extern void nwfn1();				// pop stack
        
//      nexts -- acquire next source image
//      nexts is used to acquire the next source image at compile
//      time. it assumes that a prior call to readr has input
//      a line image (see procedure readr). before the current
//      image is finally lost it may be listed here.
//      jsr  nexts            call to acquire next input line
//      (xr,xl,wa,wb,wc)      destroyed
//      global values affected
//      lstid                 include depth of next image
//      r_cni                 on input, next image. on
//                            exit reset to zero
//      r_cim                 on exit, set to point to image
//      rdcln                 current ln set from next line num
//      scnil                 input image length on exit
//      scnse                 reset to zero on exit
//      lstpf                 set on exit if line is listed
// nexts:
        extern void nexts();				// entry point
//      here to call lister
// nxts1:
        extern void nxts1();				// list line
//      here after possible listing
// nxts2:
        extern void nxts2();				// point to next image
//      here with length in (wa)
// nxts3:
        extern void nxts3();				// use as record length
        
//      patin -- pattern construction for len,pos,rpos,tab,rtab
//      these pattern types all generate a similar node type. so
//      the construction code is shared. see functions section
//      for actual entry points for these five functions.
//      (wa)                  pcode for expression arg case
//      (wb)                  pcode for integer arg case
//      jsr  patin            call to build pattern node
//      ppm  loc              transfer loc for not integer or exp
//      ppm  loc              transfer loc for int out of range
//      (xr)                  pointer to constructed node
//      (xl,wa,wb,wc,ia)      destroyed
// patin:
        extern void patin();				// entry point
        #define P_PRC_PATIN 12
        #define P_PRCLEN_PATIN 2
//      common successful exit point
// ptin1:
        extern void ptin1();				// build pattern node
//      here if argument is not an integer
// ptin2:
        extern void ptin2();				// copy expr arg case pcode
//      here for error of out of range integer argument
// ptin3:
        extern void ptin3();				// take out-of-range error exit
        
//      patst -- pattern construction for any,notany,
//               break,span and breakx pattern functions.
//      these pattern functions build similar types of nodes and
//      the construction code is shared. see functions section
//      for actual entry points for these five pattern functions.
//      0(xs)                 string argument
//      (wb)                  pcode for one char argument
//      (xl)                  pcode for multi-char argument
//      (wc)                  pcode for expression argument
//      jsr  patst            call to build node
//      ppm  loc              if not string or expr (or null)
//      (xs)                  popped past string argument
//      (xr)                  pointer to constructed node
//      (xl)                  destroyed
//      (wa,wb,wc,ra)         destroyed
//      note that there is a special call to patst in the evals
//      procedure with a slightly different form. see evals
//      for details of the form of this call.
// patst:
        extern void patst();				// entry point
        #define P_PRC_PATST 13
        #define P_PRCLEN_PATST 1
//      here for one char string case
//      common exit point after successful construction
// pats1:
        extern void pats1();				// call routine to build node
        
//      patst (continued)
//      here for multi-character string case
// pats2:
        extern void pats2();				// save multi-char pcode
//      here we must allocate a new character table
//      loop to clear all bits in table to zeros
// pats3:
        extern void pats3();				// move word of zero bits
//      merge here with bit position available
// pats4:
        extern void pats4();				// save parm2 (new bit position)
        
//      patst (continued)
//      loop to set bits in column of table
// pats5:
        extern void pats5();				// load next character
//      complete processing for multi-char string case
// pats6:
        extern void pats6();				// load ctblk ptr as parm1 for pbild
//      here if argument is not a string
//      note that the call from evals cannot pass an expression
//      since evalp always reevaluates expressions.
// pats7:
        extern void pats7();				// set pcode for expression argument
        
//      pbild -- build pattern node
//      (xr)                  parm1 (only if required)
//      (wb)                  pcode for node
//      (wc)                  parm2 (only if required)
//      jsr  pbild            call to build node
//      (xr)                  pointer to constructed node
//      (wa)                  destroyed
// pbild:
        extern void pbild();				// entry point
//      here for two parameter case
//      here for one parameter case
// pbld1:
        extern void pbld1();				// set size of p1blk
//      merge here from two parm case
// pbld2:
        extern void pbld2();				// store first parameter
//      here for case of no parameters
// pbld3:
        extern void pbld3();				// set size of p0blk
//      merge here from other cases
// pbld4:
        extern void pbld4();				// store pcode
        
//      pconc -- concatenate two patterns
//      (xl)                  ptr to right pattern
//      (xr)                  ptr to left pattern
//      jsr  pconc            call to concatenate patterns
//      (xr)                  ptr to concatenated pattern
//      (xl,wa,wb,wc)         destroyed
//      to concatenate two patterns, all successors in the left
//      pattern which point to the nothen node must be changed to
//      point to the right pattern. however, this modification
//      must be performed on a copy of the left argument rather
//      than the left argument itself, since the left argument
//      may be pointed to by some other variable value.
//      accordingly, it is necessary to copy the left argument.
//      this is not a trivial process since we must avoid copying
//      nodes more than once and the pattern is a graph structure
//      the following algorithm is employed.
//      the stack is used to store a list of nodes which
//      have already been copied. the format of the entries on
//      this list consists of a two word block. the first word
//      is the old address and the second word is the address
//      of the copy. this list is searched by the pcopy
//      routine to avoid making duplicate copies. a trick is
//      used to accomplish the concatenation at the same time.
//      a special entry is made to start with on the stack. this
//      entry records that the nothen node has been copied
//      already and the address of its copy is the right pattern.
//      this automatically performs the correct replacements.
// pconc:
        extern void pconc();				// entry point
        
//      pconc (continued)
//      the following loop scans entries in the list and makes
//      sure that their successors have been copied.
// pcnc1:
        extern void pcnc1();				// jump if all entries processed
//      now check for special case of alternation node where
//      parm1 points to a node and must be copied like pthen.
//      here at end of copy process
// pcnc2:
        extern void pcnc2();				// restore stack pointer
        
//      pcopy -- copy a pattern node
//      pcopy is called from the pconc procedure to copy a single
//      pattern node. the copy is only carried out if the node
//      has not been copied already.
//      (xr)                  pointer to node to be copied
//      (xt)                  ptr to current loc in copy list
//      (wc)                  pointer to list of copied nodes
//      jsr  pcopy            call to copy a node
//      (wa)                  pointer to copy
//      (wb,xr)               destroyed
// pcopy:
        extern void pcopy();				// entry point
        #define P_PRC_PCOPY 14
        #define P_PRCLEN_PCOPY 0
//      loop to search list of nodes copied already
// pcop1:
        extern void pcop1();				// point to next entry on list
//      here if not in list, perform copy
//      here if we find entry in list
// pcop2:
        extern void pcop2();				// load address of copy from list
//      common exit point
// pcop3:
        extern void pcop3();				// restore xt
        
//      prflr -- print profile
//      prflr is called to print the contents of the profile
//      table in a fairly readable tabular format.
//      jsr  prflr            call to print profile
//      (wa,ia)               destroyed
// prflr:
        extern void prflr();
//      loop here to print successive entries
// prfl1:
        extern void prfl1();				// bump stmt nr
//      merge after printing time
// prfl2:
        extern void prfl2();				// thats another line
//      here to go to next entry
// prfl3:
        extern void prfl3();				// bump index ptr (sgd07)
//      here to exit
// prfl4:
        extern void prfl4();				// return
        
//      prflu -- update an entry in the profile table
//      on entry, kvstn contains nr of stmt to profile
//      jsr  prflu            call to update entry
//      (ia)                  destroyed
// prflu:
        extern void prflu();
//      here if space for profile table not yet allocated.
//      calculate size needed, allocate a static xnblk, and
//      initialize it all to zero.
//      the time taken for this will be attributed to the current
//      statement (assignment to keywd profile), but since the
//      timing for this statement is up the pole anyway, this
//      doesnt really matter...
//      loop here to zero the block data
// pflu1:
        extern void pflu1();				// blank a word
//      end of allocation. merge back into routine
// pflu2:
        extern void pflu2();				// load nr of stmt just ended
//      merge here to exit
// pflu3:
        extern void pflu3();				// restore callers xr
//      here if profile is suppressed because a program defined
//      function is about to be entered, and so the current stmt
//      has not yet finished
// pflu4:
        extern void pflu4();				// reset the condition flag
        
//      prpar - process print parameters
//      (wc)                  if nonzero associate terminal only
//      jsr  prpar            call to process print parameters
//      (xl,xr,wa,wb,wc)      destroyed
//      since memory allocation is undecided on initial call,
//      terminal cannot be associated. the entry with wc non-zero
//      is provided so a later call can be made to complete this.
// prpar:
        extern void prpar();				// entry point
//      store line count/page
// prpa1:
        extern void prpa1();				// store number of lines/page
//      store print buffer length
// prpa2:
        extern void prpa2();				// store value
//      process bits options
// prpa3:
        extern void prpa3();				// bit 3 mask
//      check if fail reports goto interactive channel
// prpa4:
        extern void prpa4();				// bit 1 mask
        
//      prpar (continued)
//       continue option processing
// prpa5:
        extern void prpa5();				// bit 7 mask
//      check for -print/-noprint
// prpa6:
        extern void prpa6();				// bit 11 mask
//      check for terminal
//      associate terminal
// prpa8:
        extern void prpa8();				// note terminal associated
//      return point
// prpa9:
        extern void prpa9();				// return
        
//      prtch -- print a character
//      prtch is used to print a single character
//      (wa)                  character to be printed
//      jsr  prtch            call to print character
// prtch:
        extern void prtch();				// entry point
//      here after making sure we have room
// prch1:
        extern void prch1();				// point to print buffer
        
//      prtic -- print to interactive channel
//      prtic is called to print the contents of the standard
//      print buffer to the interactive channel. it is only
//      called after prtst has set up the string for printing.
//      it does not clear the buffer.
//      jsr  prtic            call for print
//      (wa,wb)               destroyed
// prtic:
        extern void prtic();				// entry point
//      return
// prtc1:
        extern void prtc1();				// restore xr
//      error occured
// prtc2:
        extern void prtc2();				// prevent looping
        
//      prtis -- print to interactive and standard printer
//      prtis puts a line from the print buffer onto the
//      interactive channel (if any) and the standard printer.
//      it always prints to the standard printer but does
//      not duplicate lines if the standard printer is
//      interactive.  it clears down the print buffer.
//      jsr  prtis            call for printing
//      (wa,wb)               destroyed
// prtis:
        extern void prtis();				// entry point
//      merge and exit
// prts1:
        extern void prts1();				// print to standard printer
        
//      prtin -- print an integer
//      prtin prints the integer value which is in the integer
//      accumulator. blocks built in dynamic storage
//      during this process are immediately deleted.
//      (ia)                  integer value to be printed
//      jsr  prtin            call to print integer
//      (ia,ra)               destroyed
// prtin:
        extern void prtin();				// entry point
//      delete icblk from dynamic store
// prti1:
        extern void prti1();				// stack ptr for gtstg
        
//      prtmi -- print message and integer
//      prtmi is used to print messages together with an integer
//      value starting in column 15 (used by the routines at
//      the end of compilation).
//      jsr  prtmi            call to print message and integer
// prtmi:
        extern void prtmi();				// entry point
        
//      prtmm -- print memory used and available
//      prtmm is used to provide memory usage information in
//      both the end-of-compile and end-of-run statistics.
//      jsr  prtmm            call to print memory stats
// prtmm:
        extern void prtmm();
        
//      prtmx  -- as prtmi with extra copy to interactive chan.
//      jsr  prtmx            call for printing
//      (wa,wb)               destroyed
// prtmx:
        extern void prtmx();				// entry point
        
//      prtnl -- print new line (end print line)
//      prtnl prints the contents of the print buffer, resets
//      the buffer to all blanks and resets the print pointer.
//      jsr  prtnl            call to print line
// prtnl:
        extern void prtnl();				// entry point
//      call syspr
// prnl0:
        extern void prnl0();				// save entry xr
//      loop to blank buffer
// prnl1:
        extern void prnl1();				// store word of blanks, bump ptr
//      exit point
//      file full or no output file for load module
// prnl2:
        extern void prnl2();				// jump if not first time
//      stop at once
// prnl3:
        extern void prnl3();				// ending code
        
//      prtnm -- print variable name
//      prtnm is used to print a character representation of the
//      name of a variable (not a value of datatype name)
//      names of pseudo-variables may not be passed to prtnm.
//      (xl)                  name base
//      (wa)                  name offset
//      jsr  prtnm            call to print name
//      (wb,wc,ra)            destroyed
// prtnm:
        extern void prtnm();				// entry point (recursive, see prtvl)
//      here for natural variable name, recognized by the fact
//      that the name base points into the static area.
//      common exit point
// prn01:
        extern void prn01();				// restore name base
//      here for case of non-natural variable
// prn02:
        extern void prn02();				// copy name offset
//      for program defined datatype, prt fld name, left paren
        
//      prtnm (continued)
//      now we print an identifying name for the object if one
//      can be found. the following code searches for a natural
//      variable which contains this object as value. if such a
//      variable is found, its name is printed, else the value
//      of the object (as printed by prtvl) is used instead.
//      first we point to the parent tbblk if this is the case of
//      a table element. to do this, chase down the trnxt chain.
// prn03:
        extern void prn03();				// jump if we got there (or not te)
//      now we are ready for the search. to speed things up in
//      the case of calls from dump where the same name base
//      will occur repeatedly while dumping an array or table,
//      we remember the last vrblk pointer found in prnmv. so
//      first check to see if we have this one again.
// prn04:
        extern void prn04();				// point to vrblk we found last time
//      loop through hash slots
// prn05:
        extern void prn05();				// copy slot pointer
//      loop through vrblks on one hash chain
// prn06:
        extern void prn06();				// point to next vrblk on hash chain
//      merge here first time to check block we found last time
// prn07:
        extern void prn07();				// copy vrblk pointer
        
//      prtnm (continued)
//      loop to find value (chase down possible trblk chain)
// prn08:
        extern void prn08();				// load value
//      now we have the value, is this the block we want
//      here to move to next hash slot
// prn09:
        extern void prn09();				// loop back if more to go
//      here when we find a matching entry
// prn10:
        extern void prn10();				// copy vrblk pointer
//      merge here if no entry found
// prn11:
        extern void prn11();				// load first word of name base
//      for program defined datatype, add right paren and exit
//      merge here to print final right paren or bracket
// prn12:
        extern void prn12();				// print final character
        
//      prtnm (continued)
//      here for array or table
// prn13:
        extern void prn13();				// load left bracket
//      here for table, print subscript value
//      merge here from array case to print right bracket
// prn14:
        extern void prn14();				// load right bracket
//      here for array or vector, to print subscript(s)
// prn15:
        extern void prn15();				// copy name offset
//      here for vector
        
//      prtnm (continued)
//      here for array. first calculate absolute subscript
//      offsets by successive divisions by the dimension values.
//      this must be done right to left since the elements are
//      stored row-wise. the subscripts are stacked as integers.
// prn16:
        extern void prn16();				// load length of bounds info
//      loop to stack subscript offsets
// prn17:
        extern void prn17();				// point to next set of bounds
//      loop to print subscripts from stack adjusting by adding
//      the appropriate low bound value from the arblk
// prn18:
        extern void prn18();				// load a comma
//      merge here first time in (no comma required)
// prn19:
        extern void prn19();				// load subscript offset as integer
        
//      prtnv -- print name value
//      prtnv is used by the trace and dump routines to print
//      a line of the form
//      name = value
//      note that the name involved can never be a pseudo-var
//      (xl)                  name base
//      (wa)                  name offset
//      jsr  prtnv            call to print name = value
//      (wb,wc,ra)            destroyed
// prtnv:
        extern void prtnv();				// entry point
        
//      prtpg  -- print a page throw
//      prints a page throw or a few blank lines on the standard
//      listing channel depending on the listing options chosen.
//      jsr  prtpg            call for page eject
// prtpg:
        extern void prtpg();				// entry point
//      check type of listing
// prp01:
        extern void prp01();				// preserve xr
//      perform an eject
// prp02:
        extern void prp02();				// eject
//      compact or interactive channel listing. cant print
//      blanks until check made for headers printed and flag set.
// prp03:
        extern void prp03();				// remember headp
        
//      prptg (continued)
//      print the heading
// prp04:
        extern void prp04();				// jump if header listed
//      merge if header not printed
// prp05:
        extern void prp05();				// restore xr
//      return
// prp06:
        extern void prp06();				// return
        
//      prtps - print page with test for standard listing option
//      if the standard listing option is selected, insist that
//      an eject be done
//      jsr  prtps            call for eject
// prtps:
        extern void prtps();				// entry point
        
//      prtsn -- print statement number
//      prtsn is used to initiate a print trace line by printing
//      asterisks and the current statement number. the actual
//      format of the output generated is.
//      ***nnnnn**** iii.....iiii
//      nnnnn is the statement number with leading zeros replaced
//      by asterisks (e.g. *******9****)
//      iii...iii represents a variable length output consisting
//      of a number of letter i characters equal to fnclevel.
//      jsr  prtsn            call to print statement number
//      (wc)                  destroyed
// prtsn:
        extern void prtsn();				// entry point
//      loop to generate letter i fnclevel times
// prsn1:
        extern void prsn1();				// jump if all set
//      merge with all letter i characters generated
// prsn2:
        extern void prsn2();				// get blank
        
//      prtst -- print string
//      prtst places a string of characters in the print buffer
//      see prtnl for global locations used
//      note that the first word of the block (normally b_scl)
//      is not used and need not be set correctly (see prtvn)
//      (xr)                  string to be printed
//      jsr  prtst            call to print string
//      (profs)               updated past chars placed
// prtst:
        extern void prtst();				// entry point
//      call syspr
// prst0:
        extern void prst0();				// save wa
//      loop to print successive lines for long string
// prst1:
        extern void prst1();				// load string length
        
//      prtst (continued)
//      here with chars to print and some room in buffer
// prst2:
        extern void prst2();				// jump if room for rest of string
//      merge here with character count in wa
// prst3:
        extern void prst3();				// point to print buffer
//      here to exit after printing string
// prst4:
        extern void prst4();				// restore entry wb
        
//      prttr -- print to terminal
//      called to print contents of standard print buffer to
//      online terminal. clears buffer down and resets profs.
//      jsr  prttr            call for print
//      (wa,wb)               destroyed
// prttr:
        extern void prttr();				// entry point
//      loop to clear buffer
// prtt1:
        extern void prtt1();				// clear a word
        
//      prtvl -- print a value
//      prtvl places an appropriate character representation of
//      a data value in the print buffer for dump/trace use.
//      (xr)                  value to be printed
//      jsr  prtvl            call to print value
//      (wa,wb,wc,ra)         destroyed
// prtvl:
        extern void prtvl();				// entry point, recursive
//      loop back here after finding a trap block (trblk)
// prv01:
        extern void prv01();				// copy idval (if any)
//      here for blocks for which we just print datatype name
// prv02:
        extern void prv02();				// get datatype name
//      common exit point
// prv03:
        extern void prv03();				// reload argument
//      here for trblk
// prv04:
        extern void prv04();				// load real value
        
//      prtvl (continued)
//      here for array (arblk)
//      print array ( prototype ) blank number idval
// prv05:
        extern void prv05();				// preserve argument
//      vcblk, tbblk, bcblk merge here for ) blank number idval
// prv06:
        extern void prv06();				// load right paren
//      pdblk merges here to print blank number idval
// prv07:
        extern void prv07();				// load blank
//      here for integer (icblk), real (rcblk)
//      print character representation of value
// prv08:
        extern void prv08();				// stack argument for gtstg
        
//      prtvl (continued)
//      name (nmblk)
//      for pseudo-variable, just print datatype name (name)
//      for all other names, print dot followed by name rep
// prv09:
        extern void prv09();				// load name base
//      program datatype (pdblk)
//      print datatype name ch_bl ch_nm idval
// prv10:
        extern void prv10();				// get datatype name
//      here for string (scblk)
//      print quote string-characters quote
// prv11:
        extern void prv11();				// load single quote
        
//      prtvl (continued)
//      here for simple expression (seblk)
//      print asterisk variable-name
// prv12:
        extern void prv12();				// load asterisk
//      here for table (tbblk) and array (vcblk)
//      print datatype ( prototype ) blank number idval
// prv13:
        extern void prv13();				// preserve argument
//      print prototype
// prv14:
        extern void prv14();				// move as integer
        
//      prtvn -- print natural variable name
//      prtvn prints the name of a natural variable
//      (xr)                  pointer to vrblk
//      jsr  prtvn            call to print variable name
// prtvn:
        extern void prtvn();				// entry point
//      merge here with dummy scblk pointer in xr
// prvn1:
        extern void prvn1();				// print string name of variable
        
//      rcbld -- build a real block
//      (ra)                  real value for rcblk
//      jsr  rcbld            call to build real block
//      (xr)                  pointer to result rcblk
//      (wa)                  destroyed
// rcbld:
        extern void rcbld();				// entry point
//      merge here with xr pointing past the block obtained
// rcbl1:
        extern void rcbl1();				// set new pointer
        
//      readr -- read next source image at compile time
//      readr is used to read the next source image. to process
//      continuation cards properly, the compiler must read one
//      line ahead. thus readr does not destroy the current image
//      see also the nexts routine which actually gets the image.
//      jsr  readr            call to read next image
//      (xr)                  ptr to next image (0 if none)
//      (r_cni)               copy of pointer
//      (wa,wb,wc,xl)         destroyed
// readr:
        extern void readr();				// entry point
// reada:
        extern void reada();				// max read length
// read0:
        extern void read0();				// use smaller of string lnth ...
//      perform the trim
// read1:
        extern void read1();				// set trimr to perform trim
//      merge here after read
// read2:
        extern void read2();				// store copy of pointer
//      merge here if no read attempted
// read3:
        extern void read3();				// return to readr caller
//      here on end of file or new source file name.
//      if this is a new source file name, the r_sfn table will
//      be augmented with a new table entry consisting of the
//      current compiler statement number as subscript, and the
//      file name as value.
// read4:
        extern void read4();				// jump if true end of file
//      here on end of file
// read5:
        extern void read5();				// pop unused scblk
//      outer nesting of execute-time compile of -include
//      resume with any string remaining prior to -include.
// read6:
        extern void read6();				// zero ptr as result
        
//      sbstr -- build a substring
//      (xl)                  ptr to scblk/bfblk with chars
//      (wa)                  number of chars in substring
//      (wb)                  offset to first char in scblk
//      jsr  sbstr            call to build substring
//      (xr)                  ptr to new scblk with substring
//      (xl)                  zero
//      (wa,wb,wc,xl,ia)      destroyed
//      note that sbstr is called with a dummy string pointer
//      (pointing into a vrblk or svblk) to copy the name of a
//      variable as a standard string value.
// sbstr:
        extern void sbstr();				// entry point
//      return point
// sbst1:
        extern void sbst1();				// clear garbage pointer in xl
//      here for null substring
// sbst2:
        extern void sbst2();				// set null string as result
        
//      stgcc -- compute counters for stmt startup testing
//      jsr  stgcc            call to recompute counters
//      (wa,wb)               destroyed
//      on exit, stmcs and stmct contain the counter value to
//      tested in stmgo.
// stgcc:
        extern void stgcc();
//      here if profiling or if stcount tracing enabled
// stgc1:
        extern void stgc1();				// count polcs times within stmg
//      check that stmcs does not exceed kvstl
// stgc2:
        extern void stgc2();				// breakout count start value
//      re-initialize counter
// stgc3:
        extern void stgc3();				// update breakout count start value
        
//      tfind -- locate table element
//      (xr)                  subscript value for element
//      (xl)                  pointer to table
//      (wb)                  zero by value, non-zero by name
//      jsr  tfind            call to locate element
//      ppm  loc              transfer location if access fails
//      (xr)                  element value (if by value)
//      (xr)                  destroyed (if by name)
//      (xl,wa)               teblk name (if by name)
//      (xl,wa)               destroyed (if by value)
//      (wc,ra)               destroyed
//      note that if a call by value specifies a non-existent
//      subscript, the default value is returned without building
//      a new teblk.
// tfind:
        extern void tfind();				// entry point
//      here for blocks for which we use the second word of the
//      block as the hash source (see block formats for details).
// tfn00:
        extern void tfn00();				// load second word
//      merge here with one word hash source in wa
// tfn01:
        extern void tfn01();				// convert to integer
        
//      tfind (continued)
//      here for integer or real
//      possibility of overflow exist on twos complement
//      machine if hash source is most negative integer or is
//      a real having the same bit pattern.
// tfn02:
        extern void tfn02();				// load value as hash source
//      for pattern, use first word (pcode) as source
// tfn03:
        extern void tfn03();				// load first word as hash source
//      for name, use offset as hash source
// tfn04:
        extern void tfn04();				// load offset as hash source
//      here for string
// tfn05:
        extern void tfn05();				// call routine to compute hash
//      merge here with hash source in (ia)
// tfn06:
        extern void tfn06();				// compute hash index by remaindering
//      loop through teblks on hash chain
// tfn07:
        extern void tfn07();				// save teblk pointer
//      here if no match with that teblk
//      here if no match with any teblk on chain
        
//      tfind (continued)
//      here we have found a matching element
// tfn08:
        extern void tfn08();				// restore teblk pointer
//      common exit for entry found
// tfn09:
        extern void tfn09();				// pop stack entries
//      here if no teblks on the hash chain
// tfn10:
        extern void tfn10();				// get offset to bucket ptr
//      merge here with (xl,wc) base,offset of final link
// tfn11:
        extern void tfn11();				// tbblk pointer
//      here we must build a new teblk
//      acess fail return
// tfn12:
        extern void tfn12();				// alternative return
        
//      tmake -- make new table
//      (xl)                  initial lookup value
//      (wc)                  number of buckets desired
//      jsr  tmake            call to make new table
//      (xr)                  new table
//      (wa,wb)               destroyed
// tmake:
        extern void tmake();
//      loop to initialize all bucket pointers
// tma01:
        extern void tma01();				// store tbblk ptr in bucket header
        
//      vmake -- create a vector
//      (wa)                  number of elements in vector
//      (xl)                  default value for vector elements
//      jsr  vmake            call to create vector
//      ppm  loc              if vector too large
//      (xr)                  pointer to vcblk
//      (wa,wb,wc,xl)         destroyed
// vmake:
        extern void vmake();				// entry point
//      loop to set vector elements to default value
// vmak1:
        extern void vmak1();				// store one value
//      here if desired vector size too large
// vmak2:
        extern void vmak2();				// fail return
        
//      scane -- scan an element
//      scane is called at compile time (by expan ,cmpil,cncrd)
//      to scan one element from the input image.
//      (scncc)               non-zero if called from cncrd
//      jsr  scane            call to scan element
//      (xr)                  result pointer (see below)
//      (xl)                  syntax type code (t_xxx)
//      the following global locations are used.
//      r_cim                 pointer to string block (scblk)
//                            for current input image.
//      r_cni                 pointer to next input image string
//                            pointer (zero if none).
//      r_scp                 save pointer (exit xr) from last
//                            call in case rescan is set.
//      scnbl                 this location is set non-zero on
//                            exit if scane scanned past blanks
//                            before locating the current element
//                            the end of a line counts as blanks.
//      scncc                 cncrd sets this non-zero to scan
//                            control card names and clears it
//                            on return
//      scnil                 length of current input image
//      scngo                 if set non-zero on entry, f and s
//                            are returned as separate syntax
//                            types (not letters) (goto pro-
//                            cessing). scngo is reset on exit.
//      scnpt                 offset to current loc in r_cim
//      scnrs                 if set non-zero on entry, scane
//                            returns the same result as on the
//                            last call (rescan). scnrs is reset
//                            on exit from any call to scane.
//      scntp                 save syntax type from last
//                            call (in case rescan is set).
        
//      scane (continued)
//      element scanned       xl        xr
//      ---------------       --        --
//      control card name     0         pointer to scblk for name
//      unary operator        t_uop     ptr to operator dvblk
//      left paren            t_lpr     t_lpr
//      left bracket          t_lbr     t_lbr
//      comma                 t_cma     t_cma
//      function call         t_fnc     ptr to function vrblk
//      variable              t_var     ptr to vrblk
//      string constant       t_con     ptr to scblk
//      integer constant      t_con     ptr to icblk
//      real constant         t_con     ptr to rcblk
//      binary operator       t_bop     ptr to operator dvblk
//      right paren           t_rpr     t_rpr
//      right bracket         t_rbr     t_rbr
//      colon                 t_col     t_col
//      semi-colon            t_smc     t_smc
//      f (scngo ne 0)        t_fgo     t_fgo
//      s (scngo ne 0)        t_sgo     t_sgo
        
//      scane (continued)
//      entry point
// scane:
        extern void scane();				// entry point
//      here for rescan request
//      come here to read new image to test for continuation
// scn01:
        extern void scn01();				// read next image
//      here for continuation line
// scn02:
        extern void scn02();				// acquire next source image
        
//      scane (continued)
//      merge here to scan next element on current line
// scn03:
        extern void scn03();				// load current offset
//      loop here to ignore leading blanks and tabs
// scn05:
        extern void scn05();				// jump if trailing
//      the following jump is used repeatedly for scanning out
//      the characters of a numeric constant or variable name.
//      the registers are used as follows.
//      (xr)                  scratch
//      (xl)                  ptr to next character
//      (wa)                  current scan offset
//      (wb)                  *dvubs (0 if scanning name,const)
//      (wc)                  =opdvs (0 if scanning constant)
// scn06:
        extern void scn06();				// get next character
//      switch table for switch on character
        
//      scane (continued)
        
//      scane (continued)
//      here for illegal character (underline merges)
// scn07:
        extern void scn07();				// jump if scanning name or constant
        
//      scane (continued)
//      here for digits 0-9
// scn08:
        extern void scn08();				// keep scanning if name/constant
//      here for letter. loop here when scanning name/constant
// scn09:
        extern void scn09();				// jump if end of image
//      come here for delimiter ending name or constant
// scn10:
        extern void scn10();				// reset offset to point to delimiter
//      come here after finishing scan of name or constant
// scn11:
        extern void scn11();				// store updated scan offset
//      here after scanning out numeric constant
//      merge here to exit with constant
// scn12:
        extern void scn12();				// set result type of constant
        
//      scane (continued)
//      common exit point (xr,xl) set
// scn13:
        extern void scn13();				// restore wa
//      here if conversion error on numeric item
// scn14:
        extern void scn14();
//      here after scanning out variable name
// scn15:
        extern void scn15();				// build string name of variable
//      here for single quote (start of string constant)
// scn16:
        extern void scn16();				// terminator if scanning name or cnst
//      here for double quote (start of string constant)
// scn17:
        extern void scn17();				// terminator if scanning name or cnst
//      loop to scan out string constant
// scn18:
        extern void scn18();				// error if end of image
        
//      scane (continued)
//      here after scanning out string constant
//      here if no matching quote found
// scn19:
        extern void scn19();				// set updated scan pointer
//      here for f (possible failure goto)
// scn20:
        extern void scn20();				// set return code for fail goto
//      here for s (possible success goto)
// scn21:
        extern void scn21();				// set success goto as return code
//      special goto cases merge here
// scn22:
        extern void scn22();				// treat as normal letter if not goto
//      merge here for special character exit
// scn23:
        extern void scn23();				// jump if end of name/constant
//      here for underline
// scn24:
        extern void scn24();				// part of name if scanning name
        
//      scane (continued)
//      here for left paren
// scn25:
        extern void scn25();				// set left paren return code
//      here for left paren after name (function call)
//      processing for special characters
// scn26:
        extern void scn26();				// right paren, set code
// scn27:
        extern void scn27();				// right bracket, set code
// scn28:
        extern void scn28();				// left bracket, set code
// scn29:
        extern void scn29();				// colon, set code
// scn30:
        extern void scn30();				// semi-colon, set code
// scn31:
        extern void scn31();				// comma, set code
        
//      scane (continued)
//      here for operators. on entry, wc points to the table of
//      operator dope vectors and wb is the increment to step
//      to the next pair (binary/unary) of dope vectors in the
//      list. on reaching scn46, the pointer has been adjusted to
//      point to the appropriate pair of dope vectors.
//      the first three entries are special since they can occur
//      as part of a variable name (.) or constant (.+-).
// scn32:
        extern void scn32();				// dot can be part of name or constant
// scn33:
        extern void scn33();				// plus can be part of constant
// scn34:
        extern void scn34();				// minus can be part of constant
// scn35:
        extern void scn35();				// not
// scn36:
        extern void scn36();				// dollar
// scn37:
        extern void scn37();				// exclamation
// scn38:
        extern void scn38();				// percent
// scn39:
        extern void scn39();				// asterisk
// scn40:
        extern void scn40();				// slash
// scn41:
        extern void scn41();				// number sign
// scn42:
        extern void scn42();				// at sign
// scn43:
        extern void scn43();				// vertical bar
// scn44:
        extern void scn44();				// ampersand
// scn45:
        extern void scn45();				// question mark
//      all operators come here (equal merges directly)
//      (wc) points to the binary/unary pair of operator dvblks.
// scn46:
        extern void scn46();				// operator terminates name/constant
//      here for unary operator
        
//      scane (continued)
//      merge here to require preceding blanks
// scn47:
        extern void scn47();				// all ok if preceding blanks, exit
//      fail operator in this position
// scn48:
        extern void scn48();
//      here for asterisk, could be ** substitute for exclamation
// scn49:
        extern void scn49();				// end of name if scanning name
//      unary *
// scn50:
        extern void scn50();				// recover stored offset
//      here for ** as substitute for exclamation
// scn51:
        extern void scn51();				// save scan pointer past 2nd *
        
//      scngf -- scan goto field
//      scngf is called from cmpil to scan and analyze a goto
//      field including the surrounding brackets or parentheses.
//      for a normal goto, the result returned is either a vrblk
//      pointer for a simple label operand, or a pointer to an
//      expression tree with a special outer unary operator
//      (o_goc). for a direct goto, the result returned is a
//      pointer to an expression tree with the special outer
//      unary operator o_god.
//      jsr  scngf            call to scan goto field
//      (xr)                  result (see above)
//      (xl,wa,wb,wc)         destroyed
// scngf:
        extern void scngf();				// entry point
//      here for left paren (normal goto)
// scng1:
        extern void scng1();				// set expan flag for normal goto
//      here for left bracket (direct goto)
// scng2:
        extern void scng2();				// set expan flag for direct goto
        
//      scngf (continued)
//      merge here to build outer unary operator block
// scng3:
        extern void scng3();				// stack operator dv pointer
//      common exit point
// scng4:
        extern void scng4();				// return to caller
        
//      setvr -- set vrget,vrsto fields of vrblk
//      setvr sets the proper values in the vrget and vrsto
//      fields of a vrblk. it is called whenever trblks are
//      added or subtracted (trace,stoptr,input,output,detach)
//      (xr)                  pointer to vrblk
//      jsr  setvr            call to set fields
//      (xl,wa)               destroyed
//      note that setvr ignores the call if xr does not point
//      into the static region (i.e. is some other name base)
// setvr:
        extern void setvr();				// entry point
//      here if we have a vrblk
//      merge here to exit to caller
// setv1:
        extern void setv1();				// return to setvr caller
        
//      sorta -- sort array
//      routine to sort an array or table on same basis as in
//      sitbol. a table is converted to an array, leaving two
//      dimensional arrays and vectors as cases to be considered.
//      whole rows of arrays are permuted according to the
//      ordering of the keys they contain, and the stride
//      referred to, is the the length of a row. it is one
//      for a vector.
//      the sort used is heapsort, fundamentals of data structure
//      horowitz and sahni, pitman 1977, page 347.
//      it is an order n*log(n) algorithm. in order
//      to make it stable, comparands may not compare equal. this
//      is achieved by sorting a copy array (referred to as the
//      sort array) containing at its high address end, byte
//      offsets to the rows to be sorted held in the original
//      array (referred to as the key array). sortc, the
//      comparison routine, accesses the keys through these
//      offsets and in the case of equality, resolves it by
//      comparing the offsets themselves. the sort permutes the
//      offsets which are then used in a final operation to copy
//      the actual items into the new array in sorted order.
//      references to zeroth item are to notional item
//      preceding first actual item.
//      reverse sorting for rsort is done by having the less than
//      test for keys effectively be replaced by a
//      greater than test.
//      1(xs)                 first arg - array or table
//      0(xs)                 2nd arg - index or pdtype name
//      (wa)                  0 , non-zero for sort , rsort
//      jsr  sorta            call to sort array
//      ppm  loc              transfer loc if table is empty
//      (xr)                  sorted array
//      (xl,wa,wb,wc)         destroyed
        
//      sorta (continued)
// sorta:
        extern void sorta();				// entry point
        #define P_PRC_SORTA 15
        #define P_PRCLEN_SORTA 1
//      compute n and offset to item a(0) in vector case
// srt01:
        extern void srt01();				// offset to a(0)
//      here for array
// srt02:
        extern void srt02();				// get possible dimension
        
//      sorta (continued)
//      here with sort column index in ia in array case
// srt03:
        extern void srt03();				// subtract low bound
//      separate pre-processing for arrays and vectors done.
//      to simplify later key comparisons, removal of any trblk
//      trap blocks from entries in key array is effected.
//      (xl) = 1(xs) = pointer to key array
//      (xs) = pointer to sort array
//      wa = number of items, n (converted to bytes).
//      wb = offset to first item of arrays.
//      wc = offset to a(0)
// srt04:
        extern void srt04();				// return if only a single item
//      loop through array
// srt05:
        extern void srt05();				// get an entry
//      hunt along trblk chain
// srt06:
        extern void srt06();				// jump out if not trblk
        
//      sorta (continued)
//      xr is value from end of chain
// srt07:
        extern void srt07();				// store as array entry
//      store key offsets at top of sort array
// srt08:
        extern void srt08();				// store an offset
//      perform the sort on offsets in sort array.
//      (srtsn)               number of items to sort, n (bytes)
//      (srtso)               offset to a(0)
// srt09:
        extern void srt09();				// get n
//      loop to form initial heap
// srt10:
        extern void srt10();				// sorth(i,n)
//      sorting loop. at this point, a(1) is the largest
//      item, since algorithm initialises it as, and then maintains
//      it as, root of tree.
// srt11:
        extern void srt11();				// i = i - 1 (n - 1 initially)
        
//      sorta (continued)
//      offsets have been permuted into required order by sort.
//      copy array elements over them.
// srt12:
        extern void srt12();				// base adrs of key array
//      copying loop for successive items. sorted offsets are
//      held at end of sort array.
// srt13:
        extern void srt13();				// adrs of next of sorted offsets
//      return point
// srt15:
        extern void srt15();				// pop result array ptr
//      error point
// srt16:
        extern void srt16();
// srt17:
        extern void srt17();
//      return point if input table is empty
// srt18:
        extern void srt18();				// return indication of null table
        
//      sortc --  compare sort keys
//      compare two sort keys given their offsets. if
//      equal, compare key offsets to give stable sort.
//      note that if srtsr is non-zero (request for reverse
//      sort), the quoted returns are inverted.
//      for objects of differing datatypes, the entry point
//      identifications are compared.
//      (xl)                  base adrs for keys
//      (wa)                  offset to key 1 item
//      (wb)                  offset to key 2 item
//      (srtsr)               zero/non-zero for sort/rsort
//      (srtof)               offset within row to comparands
//      jsr  sortc            call to compare keys
//      ppm  loc              key1 less than key2
//                            normal return, key1 gt than key2
//      (xl,xr,wa,wb)         destroyed
// sortc:
        extern void sortc();				// entry point
        
//      sortc (continued)
//      merge after dealing with field name. try for strings.
// src01:
        extern void src01();				// get type code
//      datatypes different.  now try for numeric
// src02:
        extern void src02();				// keep arg1
// src14:
        extern void src14();				// stack
//      return if key1 smaller (sort), greater (rsort)
// src03:
        extern void src03();				// jump if rsort
// src04:
        extern void src04();				// restore wc
//      return if key1 greater (sort), smaller (rsort)
// src05:
        extern void src05();				// jump if rsort
// src06:
        extern void src06();				// restore wc
//      keys are of same datatype
// src07:
        extern void src07();				// item first created is less
//      drop through or merge for identical or equal objects
// src08:
        extern void src08();				// test offsets or key addrss instead
        
//      sortc (continued)
//      strings
// src09:
        extern void src09();				// stack
//      arithmetic comparison failed - recover args
// src10:
        extern void src10();				// get arg1
//      here to compare datatype ids
// src11:
        extern void src11();				// get block type word
//      datatype field name used
// src12:
        extern void src12();				// call routine to find field 1
        
//      sortf -- find field for sortc
//      routine used by sortc to obtain item corresponding
//      to a given field name, if this exists, in a programmer
//      defined object passed as argument.
//      if such a match occurs, record is kept of datatype
//      name, field name and offset to field in order to
//      short-circuit later searches on same type. note that
//      dfblks are stored in static and hence cannot be moved.
//      (srtdf)               vrblk pointer of field name
//      (xl)                  possible pdblk pointer
//      jsr  sortf            call to search for field name
//      (xl)                  item found or original pdblk ptr
//      (wc)                  destroyed
// sortf:
        extern void sortf();				// entry point
//      here with xl pointing to found field
// srtf1:
        extern void srtf1();				// get item from field
//      return point
// srtf2:
        extern void srtf2();				// restore xr
// srtf3:
        extern void srtf3();				// return
        
//      sortf (continued)
//      conduct a search
// srtf4:
        extern void srtf4();				// copy original pointer
//      loop to find name in pdfblk
// srtf5:
        extern void srtf5();				// count down
//      found
// srtf6:
        extern void srtf6();				// keep field name ptr
        
//      sorth -- heap routine for sorta
//      this routine constructs a heap from elements of array, a.
//      in this application, the elements are offsets to keys in
//      a key array.
//      (xs)                  pointer to sort array base
//      1(xs)                 pointer to key array base
//      (wa)                  max array index, n (in bytes)
//      (wc)                  offset j in a to root (in *1 to *n)
//      jsr  sorth            call sorth(j,n) to make heap
//      (xl,xr,wb)            destroyed
// sorth:
        extern void sorth();				// entry point
        #define P_PRC_SORTH 16
        #define P_PRCLEN_SORTH 0
//      loop to move down tree using doubled index j
// srh01:
        extern void srh01();				// done if j gt n
//      compare sons. (wa) right son, (wb) left son
        
//      sorth (continued)
//      compare root with greater son
// srh02:
        extern void srh02();				// key array base adrs
//      finish by copying root offset back into array
// srh03:
        extern void srh03();				// convert to words
        
//      trace -- set/reset a trace association
//      this procedure is shared by trace and stoptr to
//      either initiate or stop a trace respectively.
//      (xl)                  trblk ptr (trace) or zero (stoptr)
//      1(xs)                 first argument (name)
//      0(xs)                 second argument (trace type)
//      jsr  trace            call to set/reset trace
//      ppm  loc              transfer loc if 1st arg is bad name
//      ppm  loc              transfer loc if 2nd arg is bad type
//      (xs)                  popped
//      (xl,xr,wa,wb,wc,ia)   destroyed
// trace:
        extern void trace();				// entry point
        #define P_PRC_TRACE 17
        #define P_PRCLEN_TRACE 2
//      here for l,k,f,c,r
//      here for f,c,r
// trc01:
        extern void trc01();				// point to vrblk for name
        
//      trace (continued)
//      here for f,c to set/reset call trace
//      here for f,r to set/reset return trace
// trc02:
        extern void trc02();				// set/reset return trace
//      here for l to set/reset label trace
// trc03:
        extern void trc03();				// point to vrblk
//      here with old label trace association deleted
// trc04:
        extern void trc04();				// error if undefined label
//      here for stoptr case for label
// trc05:
        extern void trc05();				// store label ptr back in vrblk
        
//      trace (continued)
//      here for k (keyword)
// trc06:
        extern void trc06();				// point to vrblk
//      merge here with trblk set up in wb (or zero)
// trc07:
        extern void trc07();				// point to svblk
//      fnclevel
//      errtype
// trc08:
        extern void trc08();				// set/reset errtype trace
//      stcount
// trc09:
        extern void trc09();				// set/reset stcount trace
        
//      trace (continued)
//      a,v merge here with trtyp value in wc
// trc10:
        extern void trc10();				// locate variable
//      loop to search trblk chain
// trc11:
        extern void trc11();				// point to next entry
//      here to delete an old trblk of the type we were given
// trc12:
        extern void trc12();				// get ptr to next block or value
//      here after deleting any old association of this type
// trc13:
        extern void trc13();				// jump if stoptr case
//      here to make sure vrget,vrsto are set properly
// trc14:
        extern void trc14();				// recall possible vrblk pointer
//      here for bad trace type
// trc15:
        extern void trc15();				// take bad trace type error exit
//      pop stack before failing
// trc16:
        extern void trc16();				// pop stack
//      here for bad name argument
// trc17:
        extern void trc17();				// take bad name error exit
        
//      trbld -- build trblk
//      trblk is used by the input, output and trace functions
//      to construct a trblk (trap block)
//      (xr)                  trtag or trter
//      (xl)                  trfnc or trfpt
//      (wb)                  trtyp
//      jsr  trbld            call to build trblk
//      (xr)                  pointer to trblk
//      (wa)                  destroyed
// trbld:
        extern void trbld();				// entry point
        
//      trimr -- trim trailing blanks
//      trimr is passed a pointer to an scblk which must be the
//      last block in dynamic storage. trailing blanks are
//      trimmed off and the dynamic storage pointer reset to
//      the end of the (possibly) shortened block.
//      (wb)                  non-zero to trim trailing blanks
//      (xr)                  pointer to string to trim
//      jsr  trimr            call to trim string
//      (xr)                  pointer to trimmed string
//      (xl,wa,wb,wc)         destroyed
//      the call with wb zero still performs the end zero pad
//      and dnamp readjustment. it is used from acess if kvtrm=0.
// trimr:
        extern void trimr();				// entry point
//      loop through characters from right to left
// trim0:
        extern void trim0();				// load next character
// trim1:
        extern void trim1();				// else decrement character count
//      here if result is null (null or all-blank input)
// trim2:
        extern void trim2();				// wipe out input string block
        
//      trimr (continued)
//      here with non-blank found (merge for no trim)
// trim3:
        extern void trim3();				// set new length
//      loop to zero pad last word of characters
// trim4:
        extern void trim4();				// store zero character
//      common exit point
// trim5:
        extern void trim5();				// clear garbage xl pointer
        
//      trxeq -- execute function type trace
//      trxeq is used to execute a trace when a fourth argument
//      has been supplied. trace has already been decremented.
//      (xr)                  pointer to trblk
//      (xl,wa)               name base,offset for variable
//      jsr  trxeq            call to execute trace
//      (wb,wc,ra)            destroyed
//      the following stack entries are made before passing
//      control to the trace function using the cfunc routine.
//                            trxeq return point word(s)
//                            saved value of trace keyword
//                            trblk pointer
//                            name base
//                            name offset
//                            saved value of r_cod
//                            saved code ptr (-r_cod)
//                            saved value of flptr
//      flptr --------------- zero (dummy fail offset)
//                            nmblk for variable name
//      xs ------------------ trace tag
//      r_cod and the code ptr are set to dummy values which
//      cause control to return to the trxeq procedure on success
//      or failure (trxeq ignores a failure condition).
// trxeq:
        extern void trxeq();				// entry point (recursive)
        
//      trxeq (continued)
//      now prepare arguments for function
//      see o_txr for details of return to this point
// trxq1:
        extern void trxq1();				// point back to our stack entries
//      here if the target function is not defined
// trxq2:
        extern void trxq2();
        
//      xscan -- execution function argument scan
//      xscan scans out one token in a prototype argument in
//      array,clear,data,define,load function calls. xscan
//      calls must be preceded by a call to the initialization
//      procedure xscni. the following variables are used.
//      r_xsc                 pointer to scblk for function arg
//      xsofs                 offset (num chars scanned so far)
//      (wa)                  non-zero to skip and trim blanks
//      (wc)                  delimiter one (ch_xx)
//      (xl)                  delimiter two (ch_xx)
//      jsr  xscan            call to scan next item
//      (xr)                  pointer to scblk for token scanned
//      (wa)                  completion code (see below)
//      (wc,xl)               destroyed
//      the scan starts from the current position and continues
//      until one of the following three conditions occurs.
//      1)   delimiter one is encountered  (wa set to 1)
//      2)   delimiter two encountered  (wa set to 2)
//      3)   end of string encountered  (wa set to 0)
//      the result is a string containing all characters scanned
//      up to but not including any delimiter character.
//      the pointer is left pointing past the delimiter.
//      if only one delimiter is to be detected, delimiter one
//      and delimiter two should be set to the same value.
//      in the case where the end of string is encountered, the
//      string includes all the characters to the end of the
//      string. no further calls can be made to xscan until
//      xscni is called to initialize a new argument scan
        
//      xscan (continued)
// xscan:
        extern void xscan();				// entry point
//      loop to search for delimiter
// xscn1:
        extern void xscn1();				// load next character
//      here after performing any leading blank trimming.
// xscn2:
        extern void xscn2();				// decrement count of chars left
//      here for runout
// xscn3:
        extern void xscn3();				// point to string block
        
//      xscan (continued)
//      here if delimiter one found
// xscn4:
        extern void xscn4();				// set return code
//      here if delimiter two found
// xscn5:
        extern void xscn5();				// set return code
//      merge here after detecting a delimiter
// xscn6:
        extern void xscn6();				// reload pointer to string
//      common exit point
// xscn7:
        extern void xscn7();				// clear garbage character ptr in xr
//      final exit point
// xscn8:
        extern void xscn8();				// load return code
        
//      xscni -- execution function argument scan
//      xscni initializes the scan used for prototype arguments
//      in the clear, define, load, data, array functions. see
//      xscan for the procedure which is used after this call.
//      -(xs)                 argument to be scanned (on stack)
//      jsr  xscni            call to scan argument
//      ppm  loc              transfer loc if arg is not string
//      ppm  loc              transfer loc if argument is null
//      (xs)                  popped
//      (xr,r_xsc)            argument (scblk ptr)
//      (wa)                  argument length
//      (ia,ra)               destroyed
// xscni:
        extern void xscni();				// entry point
        #define P_PRC_XSCNI 18
        #define P_PRCLEN_XSCNI 2
//      here if argument is not a string
// xsci1:
        extern void xsci1();				// take not-string error exit
//      here for null string
// xsci2:
        extern void xsci2();				// take null-string error exit
//      control comes here if the main stack overflows
        extern void sec06();				// start of stack overflow section
//      no chance of recovery in mid garbage collection
// stak1:
        extern void stak1();				// point to message
//      this section of code is entered whenever a procedure
//      return via an err parameter or an erb opcode is obeyed.
//      (wa)                  is the error code
//      the global variable stage indicates the point at which
//      the error occured as follows.
//      stage=stgic           error during initial compile
//      stage=stgxc           error during compile at execute
//                            time (code, convert function calls)
//      stage=stgev           error during compilation of
//                            expression at execution time
//                            (eval, convert function call).
//      stage=stgxt           error at execute time. compiler
//                            not active.
//      stage=stgce           error during initial compile after
//                            scanning out the end line.
//      stage=stgxe           error during compile at execute
//                            time after scanning end line.
//      stage=stgee           error during expression evaluation
        extern void sec07();				// start of error section
        #define err_ sec07
// error:
        extern void error();				// jump if error in scanning label
        
//      error during initial compile
//      the error message is printed as part of the compiler
//      output. this printout includes the offending line (if not
//      printed already) and an error flag under the appropriate
//      column as indicated by scnse unless scnse is set to zero.
//      after printing the message, the generated code is
//      modified to an error call and control is returned to
//      the cmpil procedure after resetting the stack pointer.
//      if the error occurs after the end line, control returns
//      in a slightly different manner to ensure proper cleanup.
// err01:
        extern void err01();				// reset stack pointer
//      loop to replace all chars but tabs by blanks
// erra1:
        extern void erra1();				// get next char
        
//      merge to store blank or tab in error line
// erra2:
        extern void erra2();				// store char
//      here after placing error flag as required
// err02:
        extern void err02();				// print blank line
// erra0:
        extern void erra0();				// generate flag and error message
// erra3:
        extern void erra3();				// in case of fatal error
//      count error, inhibit execution if required
        
//      loop to scan to end of statement
// err03:
        extern void err03();				// point to start of image
//      generate error call in code and return to cmpil
//      error during execute time compile or expression evaluatio
//      execute time compilation is initiated through gtcod or
//      gtexp which are called by compile, code or eval.
//      before causing statement failure through exfal it is
//      helpful to set keyword errtext and for generality
//      these errors may be handled by the setexit mechanism.
// err04:
        extern void err04();				// abort if too many fatal errors
//      pop stack until find flptr for most deeply nested prog.
//      defined function call or call of eval / code.
// erra4:
        extern void erra4();				// pop stack
//      test errlimit
// errb4:
        extern void errb4();				// jump if errlimit non-zero
//      return from prog. defined function is outstanding
// errc4:
        extern void errc4();				// restore stack from flptr
        
//      error at execute time.
//      the action taken on an error is as follows.
//      if errlimit keyword is zero, an abort is signalled,
//      see coding for system label abort at l_abo.
//      otherwise, errlimit is decremented and an errtype trace
//      generated if required. control returns either via a jump
//      to continue (to take the failure exit) or a specified
//      setexit trap is executed and control passes to the trap.
//      if 3 or more fatal errors occur an abort is signalled
//      regardless of errlimit and setexit - looping is all too
//      probable otherwise. fatal errors include stack overflow
//      and exceeding stlimit.
// err05:
        extern void err05();				// restore main prog s-r stack ptr
//      merge here from err08 and err04 (error 320)
// err06:
        extern void err06();				// abort if errlimit is zero
//      merge from err04
// err07:
        extern void err07();				// abort if too many fatal errors
//      interrupted partly through a dump whilst store is in a
//      mess so do a tidy up operation. see dumpr for details.
// err08:
        extern void err08();				// chain head for affected vrblks
//      label to mark end of code
// s_yyy:
        extern void s_yyy();				// loop through chain
//      end of assembly
        //b ||ttl|27,l i c e n s e -- software license for this program||||1
        // BEGIN_ENTRY_DEFINITION
        // entry label c workaround
        // We make a list of the entries and their meaning
        // Then we convert the list into a hash table at runtime just for entries
        #define NUMBER_ELAB_ENTRIES 242
        #define NUMBER_ELAB_HASH_ENTRIES 16381
        #define ELAB_HASH_MULTIPLY 92203
        typedef struct elab_meaning { void (*call_entry)(); char meaning;} elab_meaning;
        extern struct elab_meaning elab_meanings[NUMBER_ELAB_ENTRIES];
        extern struct elab_meaning elab[NUMBER_ELAB_HASH_ENTRIES];
        // END_ENTRY_DEFINITION
        struct elab_meaning elab_meanings[242] = {
             {.call_entry=s_aaa,.meaning=BL__I},
             {.call_entry=o_add,.meaning=0},
             {.call_entry=o_aff,.meaning=0},
             {.call_entry=o_alt,.meaning=0},
             {.call_entry=o_amn,.meaning=0},
             {.call_entry=o_amv,.meaning=0},
             {.call_entry=o_aon,.meaning=0},
             {.call_entry=o_aov,.meaning=0},
             {.call_entry=o_ass,.meaning=0},
             {.call_entry=o_cer,.meaning=0},
             {.call_entry=o_cas,.meaning=0},
             {.call_entry=o_cnc,.meaning=0},
             {.call_entry=o_com,.meaning=0},
             {.call_entry=o_dvd,.meaning=0},
             {.call_entry=o_exp,.meaning=0},
             {.call_entry=o_fex,.meaning=0},
             {.call_entry=o_fif,.meaning=0},
             {.call_entry=o_fnc,.meaning=0},
             {.call_entry=o_fne,.meaning=0},
             {.call_entry=o_fns,.meaning=0},
             {.call_entry=o_fun,.meaning=0},
             {.call_entry=o_goc,.meaning=0},
             {.call_entry=o_god,.meaning=0},
             {.call_entry=o_gof,.meaning=0},
             {.call_entry=o_ima,.meaning=0},
             {.call_entry=o_inn,.meaning=0},
             {.call_entry=o_int,.meaning=0},
             {.call_entry=o_inv,.meaning=0},
             {.call_entry=o_kwn,.meaning=0},
             {.call_entry=o_kwv,.meaning=0},
             {.call_entry=o_lex,.meaning=0},
             {.call_entry=o_lpt,.meaning=0},
             {.call_entry=o_lvn,.meaning=0},
             {.call_entry=o_mlt,.meaning=0},
             {.call_entry=o_nam,.meaning=0},
             {.call_entry=o_nta,.meaning=0},
             {.call_entry=o_ntb,.meaning=0},
             {.call_entry=o_ntc,.meaning=0},
             {.call_entry=o_oun,.meaning=0},
             {.call_entry=o_pas,.meaning=0},
             {.call_entry=o_pmn,.meaning=0},
             {.call_entry=o_pms,.meaning=0},
             {.call_entry=o_pmv,.meaning=0},
             {.call_entry=o_pop,.meaning=0},
             {.call_entry=o_stp,.meaning=0},
             {.call_entry=o_rnm,.meaning=0},
             {.call_entry=o_rpl,.meaning=0},
             {.call_entry=o_rvl,.meaning=0},
             {.call_entry=o_sla,.meaning=0},
             {.call_entry=o_slb,.meaning=0},
             {.call_entry=o_slc,.meaning=0},
             {.call_entry=o_sld,.meaning=0},
             {.call_entry=o_sub,.meaning=0},
             {.call_entry=o_txr,.meaning=0},
             {.call_entry=o_unf,.meaning=0},
             {.call_entry=b_aaa,.meaning=BL__I},
             {.call_entry=b_exl,.meaning=BL_EX},
             {.call_entry=b_sel,.meaning=BL_SE},
             {.call_entry=b_e__,.meaning=BL__I},
             {.call_entry=b_trt,.meaning=BL_TR},
             {.call_entry=b_t__,.meaning=BL__I},
             {.call_entry=b_art,.meaning=BL_AR},
             {.call_entry=b_bct,.meaning=BL_BC},
             {.call_entry=b_bft,.meaning=BL_BF},
             {.call_entry=b_cct,.meaning=BL_CC},
             {.call_entry=b_cdc,.meaning=BL_CD},
             {.call_entry=b_cds,.meaning=BL_CD},
             {.call_entry=b_cmt,.meaning=BL_CM},
             {.call_entry=b_ctt,.meaning=BL_CT},
             {.call_entry=b_dfc,.meaning=BL_DF},
             {.call_entry=b_efc,.meaning=BL_EF},
             {.call_entry=b_evt,.meaning=BL_EV},
             {.call_entry=b_ffc,.meaning=BL_FF},
             {.call_entry=b_icl,.meaning=BL_IC},
             {.call_entry=b_kvt,.meaning=BL_KV},
             {.call_entry=b_nml,.meaning=BL_NM},
             {.call_entry=b_pdt,.meaning=BL_PD},
             {.call_entry=b_pfc,.meaning=BL_PF},
             {.call_entry=b_rcl,.meaning=BL_RC},
             {.call_entry=b_scl,.meaning=BL_SC},
             {.call_entry=b_tbt,.meaning=BL_TB},
             {.call_entry=b_tet,.meaning=BL_TE},
             {.call_entry=b_vct,.meaning=BL_VC},
             {.call_entry=b_vr_,.meaning=BL__I},
             {.call_entry=b_vra,.meaning=BL__I},
             {.call_entry=b_vre,.meaning=0},
             {.call_entry=b_vrg,.meaning=0},
             {.call_entry=b_vrl,.meaning=0},
             {.call_entry=b_vrs,.meaning=0},
             {.call_entry=b_vrt,.meaning=0},
             {.call_entry=b_vrv,.meaning=0},
             {.call_entry=b_xnt,.meaning=BL_XN},
             {.call_entry=b_xrt,.meaning=BL_XR},
             {.call_entry=b_yyy,.meaning=BL__I},
             {.call_entry=p_aaa,.meaning=BL__I},
             {.call_entry=p_aba,.meaning=BL_P0},
             {.call_entry=p_abb,.meaning=0},
             {.call_entry=p_abc,.meaning=BL_P0},
             {.call_entry=p_abd,.meaning=0},
             {.call_entry=p_abo,.meaning=BL_P0},
             {.call_entry=p_alt,.meaning=BL_P1},
             {.call_entry=p_ans,.meaning=BL_P1},
             {.call_entry=p_any,.meaning=BL_P2},
             {.call_entry=p_ayd,.meaning=BL_P1},
             {.call_entry=p_arb,.meaning=BL_P0},
             {.call_entry=p_arc,.meaning=0},
             {.call_entry=p_bal,.meaning=BL_P0},
             {.call_entry=p_bkd,.meaning=BL_P1},
             {.call_entry=p_bks,.meaning=BL_P1},
             {.call_entry=p_brk,.meaning=BL_P2},
             {.call_entry=p_bkx,.meaning=BL_P0},
             {.call_entry=p_bxd,.meaning=BL_P1},
             {.call_entry=p_cas,.meaning=BL_P2},
             {.call_entry=p_exa,.meaning=BL_P1},
             {.call_entry=p_exb,.meaning=0},
             {.call_entry=p_exc,.meaning=0},
             {.call_entry=p_fal,.meaning=BL_P0},
             {.call_entry=p_fen,.meaning=BL_P0},
             {.call_entry=p_fna,.meaning=BL_P0},
             {.call_entry=p_fnb,.meaning=BL_P0},
             {.call_entry=p_fnc,.meaning=BL_P0},
             {.call_entry=p_fnd,.meaning=BL_P0},
             {.call_entry=p_ima,.meaning=BL_P0},
             {.call_entry=p_imb,.meaning=0},
             {.call_entry=p_imc,.meaning=BL_P2},
             {.call_entry=p_imd,.meaning=0},
             {.call_entry=p_len,.meaning=BL_P1},
             {.call_entry=p_lnd,.meaning=BL_P1},
             {.call_entry=p_nad,.meaning=BL_P1},
             {.call_entry=p_nas,.meaning=BL_P1},
             {.call_entry=p_nay,.meaning=BL_P2},
             {.call_entry=p_nth,.meaning=BL_P0},
             {.call_entry=p_pos,.meaning=BL_P1},
             {.call_entry=p_psd,.meaning=BL_P1},
             {.call_entry=p_paa,.meaning=BL_P0},
             {.call_entry=p_pab,.meaning=0},
             {.call_entry=p_pac,.meaning=BL_P2},
             {.call_entry=p_pad,.meaning=0},
             {.call_entry=p_rem,.meaning=BL_P0},
             {.call_entry=p_rpd,.meaning=BL_P1},
             {.call_entry=p_rps,.meaning=BL_P1},
             {.call_entry=p_rtb,.meaning=BL_P1},
             {.call_entry=p_rtd,.meaning=BL_P1},
             {.call_entry=p_spd,.meaning=BL_P1},
             {.call_entry=p_spn,.meaning=BL_P2},
             {.call_entry=p_sps,.meaning=BL_P1},
             {.call_entry=p_str,.meaning=BL_P1},
             {.call_entry=p_suc,.meaning=BL_P0},
             {.call_entry=p_tab,.meaning=BL_P1},
             {.call_entry=p_tbd,.meaning=BL_P1},
             {.call_entry=p_una,.meaning=0},
             {.call_entry=p_yyy,.meaning=BL__I},
             {.call_entry=l_abo,.meaning=0},
             {.call_entry=l_cnt,.meaning=0},
             {.call_entry=l_end,.meaning=0},
             {.call_entry=l_frt,.meaning=0},
             {.call_entry=l_nrt,.meaning=0},
             {.call_entry=l_rtn,.meaning=0},
             {.call_entry=l_scn,.meaning=0},
             {.call_entry=l_und,.meaning=0},
             {.call_entry=s_any,.meaning=0},
             {.call_entry=s_app,.meaning=0},
             {.call_entry=s_abn,.meaning=0},
             {.call_entry=s_arg,.meaning=0},
             {.call_entry=s_arr,.meaning=0},
             {.call_entry=s_atn,.meaning=0},
             {.call_entry=s_bsp,.meaning=0},
             {.call_entry=s_brk,.meaning=0},
             {.call_entry=s_bkx,.meaning=0},
             {.call_entry=s_chr,.meaning=0},
             {.call_entry=s_chp,.meaning=0},
             {.call_entry=s_clr,.meaning=0},
             {.call_entry=s_cod,.meaning=0},
             {.call_entry=s_col,.meaning=0},
             {.call_entry=s_cnv,.meaning=0},
             {.call_entry=s_cop,.meaning=0},
             {.call_entry=s_cos,.meaning=0},
             {.call_entry=s_dat,.meaning=0},
             {.call_entry=s_dtp,.meaning=0},
             {.call_entry=s_dte,.meaning=0},
             {.call_entry=s_def,.meaning=0},
             {.call_entry=s_det,.meaning=0},
             {.call_entry=s_dif,.meaning=0},
             {.call_entry=s_dmp,.meaning=0},
             {.call_entry=s_dup,.meaning=0},
             {.call_entry=s_ejc,.meaning=0},
             {.call_entry=s_enf,.meaning=0},
             {.call_entry=s_eqf,.meaning=0},
             {.call_entry=s_evl,.meaning=0},
             {.call_entry=s_ext,.meaning=0},
             {.call_entry=s_exp,.meaning=0},
             {.call_entry=s_fld,.meaning=0},
             {.call_entry=s_fnc,.meaning=0},
             {.call_entry=s_gef,.meaning=0},
             {.call_entry=s_gtf,.meaning=0},
             {.call_entry=s_hst,.meaning=0},
             {.call_entry=s_idn,.meaning=0},
             {.call_entry=s_inp,.meaning=0},
             {.call_entry=s_int,.meaning=0},
             {.call_entry=s_itm,.meaning=0},
             {.call_entry=s_lef,.meaning=0},
             {.call_entry=s_len,.meaning=0},
             {.call_entry=s_leq,.meaning=0},
             {.call_entry=s_lge,.meaning=0},
             {.call_entry=s_lgt,.meaning=0},
             {.call_entry=s_lle,.meaning=0},
             {.call_entry=s_llt,.meaning=0},
             {.call_entry=s_lne,.meaning=0},
             {.call_entry=s_lnf,.meaning=0},
             {.call_entry=s_loc,.meaning=0},
             {.call_entry=s_lod,.meaning=0},
             {.call_entry=s_lpd,.meaning=0},
             {.call_entry=s_ltf,.meaning=0},
             {.call_entry=s_nef,.meaning=0},
             {.call_entry=s_nay,.meaning=0},
             {.call_entry=s_ops,.meaning=0},
             {.call_entry=s_oup,.meaning=0},
             {.call_entry=s_pos,.meaning=0},
             {.call_entry=s_pro,.meaning=0},
             {.call_entry=s_rmd,.meaning=0},
             {.call_entry=s_rpl,.meaning=0},
             {.call_entry=s_rew,.meaning=0},
             {.call_entry=s_rvs,.meaning=0},
             {.call_entry=s_rpd,.meaning=0},
             {.call_entry=s_rtb,.meaning=0},
             {.call_entry=s_tab,.meaning=0},
             {.call_entry=s_rps,.meaning=0},
             {.call_entry=s_rsr,.meaning=0},
             {.call_entry=s_stx,.meaning=0},
             {.call_entry=s_sin,.meaning=0},
             {.call_entry=s_sqr,.meaning=0},
             {.call_entry=s_srt,.meaning=0},
             {.call_entry=s_spn,.meaning=0},
             {.call_entry=s_si_,.meaning=0},
             {.call_entry=s_stt,.meaning=0},
             {.call_entry=s_sub,.meaning=0},
             {.call_entry=s_tbl,.meaning=0},
             {.call_entry=s_tan,.meaning=0},
             {.call_entry=s_tim,.meaning=0},
             {.call_entry=s_tra,.meaning=0},
             {.call_entry=s_trm,.meaning=0},
             {.call_entry=s_unl,.meaning=0},
         }; /* elab_meanings */
        struct elab_meaning elab[NUMBER_ELAB_HASH_ENTRIES];
        /* l i c e n s e -- software license for this program*/
//     copyright 1983-2012 robert b. k. dewar
//     copyright 2012-2015 david shields
//     this file is part of macro spitbol.
//     macro spitbol is free software: you can redistribute it and/or modify
//     it under the terms of the gnu general public license as published by
//     the free software foundation, either version 2 of the license, or
//     (at your option) any later version.
//     macro spitbol is distributed in the hope that it will be useful,
//     but without any warranty; without even the implied warranty of
//     merchantability or fitness for a particular purpose.  see the
//     gnu general public license for more details.
//     you should have received a copy of the gnu general public license
//     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.
        //b ||ttl|27,s p i t b o l -- notes to implementors||||21
        /* s p i t b o l -- notes to implementors*/
//      m a c r o   s p i t b o l     v e r s i o n   13.01
//      ---------------------------------------------------
//      date of release  -  january 2013
//      macro spitbol is maintained by
//           dr. david shields
//           260 garth rd apt 3h4
//           scarsdale, ny 10583
//      e-mail - thedaveshields at gmail dot com
//      version 3.7 was maintained by
//           mark emmer
//           catspaw, inc.
//           p.o. box 1123
//           salida, colorado 81021
//           u.s.a
//      e-mail - marke at snobol4 dot com
//      versions 2.6 through 3.4 were maintained by
//           dr. a. p. mccann (deceased)
//           department of computer studies
//           university of leeds
//           leeds ls2 9jt
//           england.
//      from 1979 through early 1983 a number of fixes and
//      enhancements were made by steve duff and robert goldberg.
        //b ||ttl|27,s p i t b o l - revision history||||53
        /* s p i t b o l - revision history*/
        //b ||ejc|||||54
        
//      r e v i s i o n   h i s t o r y
//      -------------------------------
//      version 13.01 (january 2013, david shields)
//      this version has the same functionality as the previous release, but with
//      many internal code changes.
//      support for x86-64 has been added, but is not currently working.
//      the description of the minimal language formerly found here as comments
//      is now to be found in the file minimal-reference-manual.html
//      version 3.8 (june 2012, david shields)
//      --------------------------------------
//	       this version is very close to v3.7, with the same functionality.
//              the source is now maintained using git, so going forward
//              the detailed revision history will be recorded in the git
//              commit logs, not in this file.
//      version 3.6a to 3.7 (november 1, 1991, mark b. emmer)
//      -----------------------------------------------------
//
//      bugs fixed
//      ----------
//
//      b3.701  add btkwv and refined test at cdgvl+9 to prevent
//              variable names alphabet, lcase, ucase from being
//              pre-evaluated because of their associated
//              constant keywords.  the code
//                 alphabet = "abc"; output = size(alphabet)
//              returned zero because of pre-evaluation.
//      b3.702  delay binding to function block of fourth
//              argument to trace function.  this permits the
//              trace function to be invoked before the 4th
//              argument function is defined.  accomplished by
//              storing a vrblk pointer in trfnc, and fetching
//              its vrfnc entry later, in trxeq.
//      b3.703  references to keywords with constant pattern
//              values (&arb, &bal, etc.) did not work.  a wtb
//              instruction had been omitted at acs14+2.
//      b3.704  if a program employed the code function to
//              redefine a label that was the entry location of
//              a user-defined function, the function would
//              continue to jump to its old function body.  pfcod
//              in pfblk was pointing directly to the target code
//              block, instead of doing so indirectly through the
//              vrblk for the entry label.
//      b3.705  the test that required a label to be defined
//              before it could be used as the entry of a user-
//              defined function has been removed.  functions
//              may be defined even if the label is yet
//              undefined.
//      b3.706  after a compilation error in the code function,
//              the eval function produces spurrious errors.  the
//              code offset cwcof was not being reset to the
//              beginning of code block.  add line at err04+1 to
//              accomplish this reset.
//      b3.707  inconsistant tests with mxlen corrected.  several
//              places were testing with bge instead of bgt,
//              resulting in such anomalies as the statement
//                 &maxlngth = &maxlngth
//              failing.  since mxlen is guaranteed to be
//              strictly less than dnamb, it is permissible to
//              create objects of size mxlen.  bge changed to
//              bgt at locations
//                 s$arr+14, sar07+8, alobf+3, asg14+8, gtar6+10.
//      b3.708  exit(command string) was not loading ptr to fcb
//              chain into wb.  corrected at sext1.
//      b3.709  change patst to return non-string error for null
//              argument.  previously, break(), any(), etc., were
//              succeeding, contrary to the language definition.
//      b3.710  convert function with null second argument
//              crashed system by calling flstg with wa=0.  added
//              test at s$cnv, moved error 74 to separate erb at
//              scv29.
//      b3.711  leq(,) crashed system.  lcomp did not obey
//              minimal assumption that cmc opcode will always
//              be called with wa .gt. 0.  added test at lcmp1.
//      b3.712  modified line at sdf07+4 to use register wa
//              instead of wb.  this corrects problem of define
//              function with local variable list that begins
//              with comma-  define("f(x),l1,l2")
//      b3.713  erroneous plc on uninitialised r$cim in listr.
//      b3.714  erroneous call to flstg possible with null string
//              at sdat1.
//      b3.715  when copy function used with table argument, fix
//              problem at cop07.  when copying first teblk on a
//              chain, the pseudo-previous block pointer in xr
//              is pushed on the stack prior to calling alloc.
//              this is not a valid block pointer, as it points
//              within the tbblk.  if the subsequent alloc
//              invokes gbcol, the heap becomes scrambled.
//              recoded to save pointer to start of block, plus
//              offset in wb.
//      b3.716  at iop01, if gtvar triggered garbage collection
//              via alost, trap block in wc was not collected.
//              save wc on stack to make it collectable across
//              gtvar call.
//      b3.717  at asg10, allow case of variable with more than
//              one trblk, as happens with the following stmt -
//              output(.output, .output, filename).
//      b3.718  at senf1, trblk chain search was reloading chain
//              head, causing infinite loop if the desired trblk
//              was not the first on chain.  system crashed with
//              trace(.v1) output(.v2,.v1,file).
//      b3.719  prototype strings (define, load, data, etc.) were
//              allowing blank characters, producing bogus
//              variable names.
//      b3.720  the fact that iofcb destroyed register wc was not
//              documented.  b$efc conversion of file argument
//              never worked because wc and xt were destroyed by
//              call to iofcb.
//      b3.721  ioput left a trblk attached to filearg1 if sysio
//              failed.  subsequent use of this filearg1 variable
//              in another i/o call would crash system.
//      b3.722  add chk at evlp1 to catch recursive pattern error.
//      b3.723  allow -line to work properly within code function
//              by setting cmpln directly in cnc44.  if file name
//              absent, decrement scnpt to rescan terminator.
//      b3.724  when mxlen exceeds start of dynamic memory, round
//              it up to multiple of word size prior to storing
//              in dnamb at ini06.
//      b3.725  provide right padding of zero characters to any
//              string returned by an external function.
//      b3.726  reset flptr at bpf17 for undefined function
//              when evalx is evaluating an expression.
//      b3.727  modify code after read5 for outer nesting of
//              an execute-time compile of -include statement.
//              create a substring of remainder of original
//              code function argument string and return as
//              result of readr function
//      b3.728  the definition of the aov opcode is corrected.
//              formerly the definition specified that the branch
//              was to be taken if the result of the addition
//              exceeded cfp$m, implying a test for overflow
//              from signed addition.
//              however, address arithmetic must be unsigned to
//              allow for systems where the high order address
//              bit is set.  therefore, the test must be for
//              carry out of the high order bit, if the result
//              would exceed cfp$l.
//      b3.729  a label trace on the entry label for a function
//              was undetected, resulting in a transfer to
//              b$trt and subsequent crash.  see bpf08 for fix.
//      b3.730  pop first argument to substr if it is a buffer.
//      b3.731  pattern replacement with buffer subject returned
//              null string instead of new subject value.
//              changed to behave as if subject was a string.
//      b3.732  if convert function was called with a buffer
//              first argument and "buffer" second argument,
//              it would convert the buffer to a string, and
//              then back to a buffer.  this has be corrected
//              to simply return the first argument as the
//              function result.
//      b3.733  detect external function returning a null string
//              unconverted result at bef12, and jump to exnul.
//      b3.734  fix problem at ins04 when inserting zero length
//              string into buffer.  defend against invoking
//              mvc with a zero value in wa, which will cause
//              some implementations to wrap the counter.
//      b3.735  add overflow test for cos and sin to detect
//              out-of-range argument.
//      b3.736  fixed problem introduced with b3.727 not
//              restoring r$cim, scnpt and scnil after creating
//              substring.
//      b3.737  fixed tfind to place default value in newly
//              allocated teblk.
//      b3.738  added bl$p0 to p$nth entry point.  the expression
//              datatype(convert("","pattern")) would crash when
//              the dtype function uses the non-existant type
//              word preceding p$nth.
//      b3.739  bug at gtn35 in the case of overflow during cvm.
//              wb can be destroyed by cvm on some platforms.
//      b3.740  protect scontinue from usage in other than error
//              320 case.
//      b3.741  protect continue from usage following error
//              evaluating complex failure goto.
//
//
//      changes
//      -------
//
//      c3.701  add .culk conditional to include &lcase, &ucase.
//      c3.702  add -line nn "filename" control card.
//      c3.703  move .cnld conditional up in routine dffnc to
//              omit all tests for b$efc.
//      c3.704  add conditional .cicc to ignore unrecognized
//              control cards.
//      c3.705  add conditional .cnsc to omit string to numeric
//              conversion in sort.  the presence of this
//              conversion mode produces a sort result that is
//              dependent upon the order of input data.
//              for example, given input data "2", 5, "10",
//              string comparison yields "10" lt "2", but string
//              to integer conversion yields "2" lt 5 lt "10".
//      c3.706  add seventh return from syshs that allows callee
//              to return a string pointer and length.  this is
//              done to eliminate the need for the caller to have
//              an scblk big enough to accommodate long strings.
//      c3.707  add eighth return from syshs to force copy of
//              block pointed to by xr.
//      c3.708  made -copy a synonym for -include.
//      c3.709  add conditional .cbyt for statistics displayed
//              in bytes rather than words.
//      c3.710  dump null valued variables when dump = 3.  core
//              dump produced for dump = 4.
//      c3.711  restrict minimum value to which keyword maxlngth
//              can be set to 1,024 via new variable mnlen.
//      c3.712  add conditional symbol .cmth for extended math
//              functions- atan, chop, cos, exp, ln, sin, sqrt,
//              tan.  x**y and remdr(x,y) are extended to include
//              reals.
//      c3.713  add bit to syspp to set -print upon entry
//      c3.714  add conditional .csfn to track source file name
//              associated with each code block.
//      c3.715  add conditional .cinc for -include control card
//              feature.  the format of the card is
//                 -include "filename"
//              include control cards may be used during both the
//              initial compile and execute-time compile.  the
//              filename is saved in a table, and redundant
//              includes of that file are ignored.
//      c3.716  add conditional .csln to include source line
//              number in code blocks.  release current ccblk
//              after initial compile.
//      c3.717  changed rilen to 258 (from 120) to provide
//              uniform input line length when reading from
//              terminal or input.
//      c3.718  add additional exit to iofcb to distinguish
//              argument not convertable to string and argument
//              file not open.
//      c3.719  add fourth and fifth arguments to host function.
//      c3.720  add &compare keyword to control string
//              comparisons.
//      c3.721  setup pfdmp at iniy0 in case osint forced
//              &profile non-zero.
//      c3.722  add conditional symbol .caex to include up arrow
//              as synonym for exponentiation.
//      c3.723  add conditional .ccmc and external function syscm
//              to provide string comparison using collation
//              sequence other than strict ordering of character
//              codes (international compares).
//      c3.724  add conditional .cpol and external function syspl
//              to provide interactive control of spitbol
//              execution.
//      c3.725  add conditional symbol .cera and external
//              function sysea to provide advice of compilation
//              and runtime errors to osint.
//      c3.726  add cmpln, rdcln, rdnln to track source line
//              number.
//      c3.727  converted error messages to upper/lower case.
//      c3.728  add conditional .cgbc to external routine sysgc.
//              called at the start and end of garbage collection
//              to perform any needed notification to operating
//              system or user.
//      c3.729  modified last line of s$set from exnul to exint
//              so seek can return final file position after
//              seek.
//      c3.730  place mov xr,(xs) at s$rmd+4 to allow real second
//              arg to remdr.
//      c3.731  remove redundant bge xr,=cfp$u,scn07 at scn06+4
//      c3.732  change definition of cmc and trc such that only
//              xl must be cleared after operation.  note, this
//              change was subsequently voided.  cmc and trc must
//              clear both xl and xr, because utility routines
//              may preserve xl or xr on the stack, and the stack
//              is collectable by gbcol.
//      c3.733  remove most branches to exits and exixr.
//              instead, jump directly to next code word.
//      c3.734  add error 260 for array too large in gtarr.
//      c3.735  add conditional .cs32 to initialize stlim to
//              2147483647.
//      c3.736  add second argument to exit function, allowing
//              user to specify file name of load module being
//              written.  if omitted, osint will provide a
//              default name.
//      c3.737  add conditional .cspr to include spare locations
//              in working area.  these may be used in later bug
//              fixes without changing the size of the working
//              storage and obsoleting modules created by exit().
//              subsuently removed in c3.767.
//      c3.738  add r$cts to remember last string used to build
//              bit column in patst.
//      c3.739  change flstg to type e procedure instead of r.
//      c3.740  standardize on big-endian systems.  at the
//              implementors choice, the zgb opcode can also
//              perform a byte swap if necessary to achieve big-
//              endian byte ordering.  this is done so that
//              systems with similar word lengths will produce
//              the same hash code for strings, and hence the
//              same ordering for table entries.  the hashs
//              procedure has an additional zgb added to reorder
//              the length word.
//      c3.741  add conditional .csou to cause assignments to
//              output and terminal variables to be processed
//              through calls to sysou rather than through
//              listing buffer.  done to eliminate short record
//              lengths enforced by buffer size.  a code of 0 or
//              1 is passed to sysou instead of an fcblk.
//      c3.742  increased iniln, inils, rilen to 1024.
//      c3.743  add bit to syspp to set noerrors mode.
//      c3.744  add .ccmk conditional to include keyword compare
//              even if syscm is not being included.  done to
//              provide identical data regions in systems that
//              implement syscm and those which do not, so that
//              save files can be exchanged in the next release.
//      c3.745  add wc return parameter to sysil to allow
//              interface to inform spitbol if file about to be
//              read is a binary file.  if so, no blank trimming
//              occurs.
//      c3.746  fold load function argument types to upper case.
//      c3.747  add .cexp conditional to have sysex pop its
//              arguments.
//      c3.748  in stopr, do not attempt to display file name and
//              line number if stopping because of stack overflow
//              during garbage collection.  pointers to file name
//              table and code block are wrong.
//      c3.749  add bit to syspp to set case folding mode.
//      c3.750  add additional return from sysld if insufficient
//              memory to load/call external function.
//      c3.751  add additional returns from sysex if insufficient
//              memory or bad argument type.
//      c3.752  ignore leading and trailing blanks in arguments
//              within prototype strings to clear, data, define
//              and load.
//      c3.753  test for fatal error at err04 and abort if so.
//              force termination on stack overflow by setting
//              errft to 4 in stack overflow section.
//      c3.754  recode copy loop at srt14 to exchange usage of
//              registers xl and xr.  this permits use of the
//              mvw order instead of the explicit loop coding
//              previously employed.
//      c3.755  add .ceng conditional to include routines needed
//              by text processing engine. add routines enevs and
//              engts for use by engine or debugger.  copy xr to
//              xl around call to syspl to allow syspl to
//              trigger garbage collection.
//      c3.756  add &file, &lastfile, &line, &lastline keywords.
//              for now, line and lastline are maintained in the
//              same manner as stno and lastno, which adds over-
//              head to the statement initialization code.  a
//              possible change is to create a stmln procedure
//              that maps statement numbers to line numbers.
//              one simple strategy would be to sweep code blocks
//              in memory looking for the statement number and
//              extracting the line number from that code block.
//              such a procedure would also allow line numbers
//              (and file names) to be added to statement profile
//              reports.
//      c3.757  change sort to fail instead of producing error
//              message if argument table is null.  change sorta
//              to return failure.  add another return to gtarr
//              to distinguish null table from bad argument.
//      c3.758  create procedure prtmm to display memory usage
//              statistics, and call it when producing end-of-
//              run stats.
//      c3.759  add label scontinue to allow setexit to resume
//              execution exactly where it was interrupted.
//      c3.760  add snobol4 backspace function and conditional
//              .cbsp.
//      c3.761  add additional arguments to sysgc to assist
//              virtual memory managers.
//      c3.762  the method of converting a table to an array has
//              been revised.  previously, table elements were
//              copied to the result array in the order they were
//              encountered along the various hash chains.  this
//              appeared to the user as a random ordering.  how-
//              ever, spitbol/370 as well as sil snobol4 ordered
//              array elements according to their time of entry
//              into the table.  user programs that relied upon
//              this behavior malfunctioned when ported to macro
//              spitbol.
//              to remedy this, the conversion is performed in
//              three steps:
//              1. convert table to an array placing the address
//                 of each teblk in the array instead of the key
//                 and value.
//              2. sort the array of addresses.  this orders ele-
//                 ments by time of creation (ascending address).
//              3. scan the array, replacing addresses with the
//                 key and value from the referenced teblk.
//              the affected portions of the program are at s$cnv
//              and in gtarr, which now accepts an additional
//              argument specifying whether to place key/values
//              in the array or teblk addresses.
//      c3.763  if case-folding is active, fold the function name
//              provided to the load() function before passing it
//              to sysld.
//      c3.764  add sediment algorithm to garbage collector,
//              conditioned on .csed.
//      c3.765  add optimization to discard null statements and
//              statements which just have a constant subject
//              (see code at cmp12).
//      c3.766  rearranged order of initial objects in static
//              memory so that hash table is the last of the four
//              object created by initialization code.  this is
//              done so that the print buffer, gts work area, and
//              &alphabet keywords do not need to be saved in
//              any save file created by osint.  added routine to
//              initialize these structures.
//      c3.767  removed .cspr conditional and spare locations.
//      c3.768  added .crel conditional and extensive routines
//              (reloc et. al.) to perform relocation of data
//              in working section, static region, and dynamic
//              region after reload of a saved memory image.
//              routines relaj, relcr, and reloc are invoked
//              by osint after reloading a save file.
//              it is now possible to reload such an image even
//              if the spitbol compiler and its data structures
//              are reloaded to other addresses.  the working
//              section has been extensively rearranged to
//              accommodate the reloc procedure.
//      c3.769  zero r$ccb (interim ccblk ptr) in collect,
//              convert, eval, and exit functions to release
//              unneeded ccblk memory.
//      c3.770  add exit(4) and exit(-4) to allow execution to
//              continue after writing save file or load module.
//              revised sysxi interface to detect continuation
//              after performance of exit(4) or exit(-4) action.
//      c3.771  change filnm to preserve registers.
//      c3.772  addition of .cncr and syscr (real to string
//              system routine option).
//      c3.773  modified replace function to optimize usage
//              when second argument is &alphabet.  in this case,
//              the third argument can be used as the translate
//              table directly.
//      c3.774  modified conditionals for buffers and reals so
//              that their respective block codes are always
//              present, even if these data types are conditioned
//              out.  this provides consistent block code
//              numbering for external functions.
//      c3.775  modified alobf to test string length against
//              kvmxl instead of mxlen.  also, alobf was testing
//              total size of bfblk, instead of just string len.
//      c3.776  move utility routines source up to lie between
//              predefined snobol functions (s$xxx) routines and
//              utility procedures.  this was done to assist
//              translation on platforms such as apple macintosh
//              that use 15-bit offsets to store error exits (ppm
//              branches).  offsets to labels like exfal were
//              just too far away.  similarly, functions tfind,
//              tmake, and vmake are located out of alphabetic
//              order to satisfy the macintosh's limited range
//              for subroutine calls.  move built-in labels
//              beyond the block and pattern routines to get it
//              within 32k of the error routines.
//      c3.777  at scn46, allow colon, right paren and right
//              bracket to terminate = operator with default
//              null operand.
//      c3.778  added .ctet conditional for table entry trace.
//      c3.779  introduce cfp$l, the largest unsigned value
//              that may be stored in a one-word integer.  this
//              is done to accommodate machines where memory
//              addresses have the high-order address bit set.
//      c3.780  perform replace in place if first arg is buffer.
//      c3.781  perform reverse in place if first arg is buffer.
//      c3.782  change sysou to accept buffer as well as string
//              to be output.  change code at asg11 to prevent
//              conversion of buffer to string.
//      c3.783  optimize pos and rpos when it is the first node
//              of a pattern and has either an integer or simple
//              expression variable argument.  if unanchored mode
//              and the cursor is zero, it is advanced directly
//              to the desired cursor position.
//      c3.784  perform trim function in place if arg is buffer.
//      c3.785  add gtstb procedure to get a string or buffer
//              argument for replace, reverse, size, trim, etc.
//      c3.786  change leq, lgt, etc. to perform comparisons
//              without converting buffer arguments to strings.
//              this is done by changing lcomp to accept buffer
//              argument(s).  this also affects sort function,
//              which will compare two buffers as strings.
//      c3.787  change gtnum to use characters in buffer without
//              conversion to a string.  this implies that acomp
//              will perform arithmetic comparisons of buffers
//              without converting to strings first.
//      c3.788  perform comparisons of strings and buffers in
//              sortc.
//      c3.789  change insbf to allow insertion of a buffer into
//              a buffer without first converting it to a string.
//              note that this only works when the two buffers
//              are not the same.
//      c3.790  documentation change:  note that all of the block
//              move opcodes should have wa .gt. 0.  not all
//              implementations avoid moving objects when wa is
//              zero.
//      c3.791  change ident to provide buffer/buffer and
//              buffer/string comparisons, to accommodate users
//              who perform ident(buf) to check for null string
//              in buffer.
//      c3.792  added fullscan keyword initialized to one.  user
//              may set to any non-zero value, will receive an
//              error message if attempts to set to zero, since
//              quickscan mode is not supported.
//      c3.793  rewrote statement startup code at stmgo to only
//              perform checking of profiling, stcount tracing,
//              and statement counting if necessary.
//      c3.794  add additional exit to sysfc and ioput to signal
//              that i/o channel (fcblk) is already in use.
//              added error message numbers 289 and 290.
//      c3.795  added optional integer argument to date function
//              to specify format of date string returned by
//              sysdt.
//
//
//      version 3.6 to 3.6a (oct 83)
//      ---------------------------
//
//      changes
//      -------
//
//      c3.617  add .cnlf. if defined, then arguments to external
//              functions may be declared to have type file.
//              such arguments must have been used as second
//              arg to input() or output() and a pointer to the
//              fcb is passed to the external function.
//
//
//      version 3.5 to 3.6 (jun 83)
//      ---------------------------
//
//      codes used to identify authors are (sgd) for duff,
//      (reg) for  goldberg, and (lds) for shields.
//
//      bugs fixed
//      ----------
//      b3.601  (sgd) to fix multiple trap block problem in asign
//      b3.602  (sgd) patch in gtarr to fix null convert.
//      b3.603  (sgd) inserted missing wtb after sysmm calls.
//      b3.604  (sgd) use string length in hashs.
//      b3.605  (sgd) fixed serious parser problem
//              relating to (x y) on line being viewed as pattern
//              match.  fixed by addition of new cmtyp value
//              c$cnp (concatenation - not pattern match).
//      b3.606  (sgd) fixed exit(n) respecification code
//              to properly observe header semantics on return.
//      b3.607  (sgd) bypass prtpg call at initialization
//              following compilation if no output generated.
//              this prevents output files consisting of the
//              headers and a few blank lines when there is no
//              source listing and no compilation stats.
//              also fix timsx initialization in same code.
//      b3.608  (sgd) b$efc code did not check for
//              unconverted result returning null string.
//      b3.609  (sgd) load pfvbl field in retrn for
//              return tracing. this was causing bug on return
//              traces that tried to access the variable name.
//      b3.610  (sgd) fixed problem relating to compilation of
//              goto fields containing small integers
//              (in const sec).
//      b3.611  (reg) prevent clear() from clobbering protected
//              variables at label sclr5.
//      b3.612  (reg) fixed gtexp from accepting trailing
//              semicolon or colon. this is not a legal way
//              to end an expression.
//      b3.613  (reg) fixed difficulties with listings during
//              execution when no listing generated during
//              compilation. -list to code() caused bomb.
//              fix is to reset r$ttl and r$stl to nulls not 0
//              after compilation.
//              (listr and listt expect nulls)
//              when listing and statistics routed to different
//              file than execution output, error message is sent
//              to execution output (and gets separated from
//              ... in statement ... msg). labo1 calls sysax and
//              stopr does not call sysax if entered from labo1.
//      b3.614  (lds) fix misuse of wc just after asg10.
//      b3.615  (lds) add comment pointing out suspicious code
//              after tfn02
//      b3.616  (lds) fix inconsistent declaration of sorth.
//      b3.617  (lds) insert missing conditional tests on cnbf.
//      b3.618  (lds) fix some violations of minimal language
//              that had slipped past some translators.
//      b3.619  (lds) correct error introduced in fixing b3.614.
        //b ||ejc|||||630
        
//      changes
//      -------
//
//
//      c3.601  (sgd) addition of .cnci and sysci (int to string
//              system routine option)
//      c3.602  (reg) changed iniln and and inils to 258
//      c3.603  (sgd) merged in profiler patches, repaired code.
//      c3.604  (sgd) added buffer type and symbol cnbf
//      c3.605  (sgd) added char function.  char(n) returns nth
//              character of host machine character set.
//      c3.606  (reg) added cfp$u to ease translation on smaller
//              systems - conditional .cucf
//      c3.607  (reg) added lower case support, conditional .culc
//      c3.608  (reg) added set i/o function, conditional .cust
//      c3.609  (reg) conditionalized page eject after call to
//              sysbx and added another before call to sysbx,
//              so that, if desired by the implementor,
//              standard output will reflect assignments made
//              by executing program only.
//              conditional .cuej controls - if defined then
//              eject is before call to sysbx.
//      c3.610  (lds) introduce .ctmd to support systm that
//              reports elapsed time in deciseconds instead of
//              milliseconds.
//      c3.611  (lds)  provide place for .def or .und for each
//              conditional  option, so that settings can be
//              changed without changing line numbers.
//              current settings are for 808x translation.
//      c3.612  (lds) obey (new) restriction that operand in
//              conditional branch instruction cannot have form
//              (x)+ in order to simplify translations for which
//              postincrement not readily available.
//      c3.613  (reg,lds) add op
//                    flc wreg
//              that folds character in wreg to upper case.
//              this op is used only if .culc is defined.
//              this change also involves addition of keyword
//              &case which when nonzero (the initial setting)
//              causes the case folding just described to be
//              done.
//      c3.614  (lds) add option .cs16 to permit initialization
//              of statement limit values to 32767 for 16 bit
//              machines.
//      c3.615  (lds) permit return point and entry point
//              addresses to be distinguished by their parity
//              instead of by lying within a certain range
//              of values.  introduce conditional symbols
//              .crpp  return points have odd parity
//              .cepp  entry points have odd parity
//      c3.616  (lds) introduce new minimal opcodes to branch
//              according to parity,
//                bev  opn,plbl  branch if address even
//                bod  opn,plbl  branch if address odd
//              an address is even if it is a multiple of cfp$b.
        //b ||ejc|||||686
        
//      documentation revisions
//      -----------------------
//
//      d3.601  (lds) bring minimal machine description up to
//              date
//
        //b ||ejc|||||693
        
//      version 3.4 to 3.5 (feb 79)
//      ---------------------------
//
//
//      bugs fixed
//      ----------
//
//      b3.401  prtst should be declared as an r type procedure.
//      b3.402  timing error if spitbol fails in dump.
//      b3.403  error in handling omitted args of operators.
//      b3.404  too many lines put on first page of listing.
//      b3.405  leading unary operator in eval erroneously needed
//              preceding blank.
//      b3.406  identifying name in dump of array or table values
//              was omitted.
//      b3.407  eval unable to return a deferred expression.
//      b3.408  illegal if setexit code branches to return.
//      b3.409  illegal on detaching input, output, terminal.
//
//      changes
//      -------
//
//      c3.401  -sequ and -nose control cards removed.
//      c3.402  option provided to suppress system identification
//              on listing.
//      c3.403  description of sysbx slightly revised.
//      c3.404  permissible to modify scblk length before taking
//              error returns from sysin, sysrd, sysri.
//      c3.405  conditional .cnld may be defined to omit load().
//      c3.406  conditional .cnex may be defined to omit exit().
//      c3.407  table now accepts a third argument specifying
//              default initial lookup value.
//      c3.408  routines sort, rsort for sorting arrays and table
//              introduced. specification is as in sitbol.
//              routines may be omitted by defining .cnsr .
//      c3.409  error in code(), eval() call now causes statement
//              failure but errtext keyword is still set.
//      c3.410  arg to code() may contain embedded control cards
//              and comment delimited by a semicolon.
//
//      documentation revisions
//      -----------------------
//
//      d3.401  purpose of restriction 2 in minimal section -6-
//              (operations on char values), erroneously stated
//              to be for cmc, rather than for ceq, cne.
//              descriptions of above opcodes revised.
//      d3.402  description of ent clarified.
//      d3.403  descriptions of several opcodes revised to remove
//              technically invalid literals e.g. =0 , *1.
//      d3.405  restricted use of letter z in minimal clarified.
//      d3.406  divide by zero explicitly mentioned in relation
//              to overflow setting.
        //b ||ejc|||||747
        
//      version 3.3 to 3.4 (oct 78)
//      ---------------------------
//
//
//      bugs fixed
//      ----------
//
//      b3.301  illegal for erroneous eval() arg.
//      b3.302  address arithmetic overflow in alloc and alocs.
//      b3.303  -eject and -space ignored -nolist option.
//      b3.304  erroneous argument scan in load().
//      b3.305  erroneous plc on uninitialised r$cim in nexts.
//      b3.306  ldi used instead of mti after prv07.
//      b3.307  misuse of rmi at erra2.
//      b3.308  misuse of mti in hashs.
//      b3.309  bug in -sequ card sequence number checking.
//      b3.310  stack overflow error message not always printed.
//      b3.311  corrupt prototype print for traced arrays.
//      b3.312  pattern first arg in dupl caused error.
//      b3.313  omitted csc in s$rpd, erroneous csc in convert.
//      b3.314  misplaced btw in exbld.
//      b3.315  incorrect code in hashs.
//      b3.316  failure of load to scan integer arg.
//      b3.317  table access with negative integer arg. failed.
//      b3.318  error in returning result of loaded function.
//      b3.319  =e$srs used after ini01 instead of *e$srs.
//      b3.320  err used instead of erb after systu
//      b3.321  label could start with disallowed character.
//      b3.322  continue after setexit had bad heuristic.
        //b ||ejc|||||777
        
//
//
//      changes
//      -------
//
//      c3.301  sysax and .csax introduced - see sysax
//              in procedures section.
//      c3.302  variable mxlen introduced. contains the maximum
//              size of a spitbol object and is not changeable
//              after initialisation. may be defaulted or set
//              explicitly by sysmx.
//      c3.303  syshs returns revised - see syshs.
//      c3.304  new minimal opcode aov to fix b3.302.
//      c3.305  inhibit stlimit check if stlimit made negative.
//      c3.306  cfp$m is required to be of form 2**n - 1.
//      c3.307  dupl made to conform to sil snobol4 standard.
//      c3.308  lch and sch actions more closely defined.
//      c3.309  batch initialisation code omitted if conditional
//              assembly symbol .cnbt (no batch) defined.
//      c3.310  (wa) contains argument count in sysex call.
//      c3.311  sysfc  may request allocation of static fcblk.
//      c3.312  if ia,wc overlap, restriction put on dumping/
//              restoring these registers.
//      c3.313  new listing option intermediate between compact
//              and extended provided (see syspp).
//      c3.314  revision of sysxi interface to permit options for
//              load module standard o/p file (see sysxi,syspp).
//      c3.315  last arg of substr may be omitted - treated
//              as remainder of string.
        //b ||ejc|||||807
        
//      version 3.2 to 3.3 (jan 78)
//      ---------------------------
//
//      bugs fixed
//      ----------
//
//      b3.201  array reference and external function load
//              routines illegally accessed information
//              beyond the stack front.
//              similar fault in unanchored pattern matching.
//      b3.202  dump(1) produced dump(2) type output.
//      b3.203  wtb conversion omitted in code following
//              ini01, ini02, exbld.
//      b3.204  incorrect fail return from tfind in arref.
//      b3.205  endfile did not detach i/o associated variables.
//      b3.206  -space with omitted arg. failed
//      b3.207  looped if dump keyword non-zero after stack
//              overflow in garbage collect failure.
//      b3.208  failure in reading numbers with trailing blanks.
//
//      changes
//      -------
//
//      the extensive changes made here mostly result from a
//      snobol4 implementors meeting held at new york university
//      in august 1977. they are aimed at
//           (1) having spitbol conform to certain snobol4
//           language standards  and
//           (2) producing a stable definition of minimal by
//           carrying out a few essential revisions in the light
//           of experience in its use.
//
//      changes to spitbol
//      ------------------
//
//      c3.201  default values for keywords trim and anchor are
//              zero. on systems where records are customarily
//              handled without traling blanks, there is no
//              obligation to supply such blanks.
//      c3.202  default value of -inxx control card is -in72.
        //b ||ejc|||||848
        
//      c3.203  the second argument of input and output is
//              permitted to be an integer as in snobol4.
//              in addition input(), output() now give a snobol4
//              statement failure if sysio uses the file not
//              found return.
//              the third argument has a recommended format and
//              to override its default delimiter (,) a
//              conditional assembly symbol, .ciod, is used.
//              interfaces to sysef,sysej,syfc,sysio,sysrw
//              are revised.
//              wc may now be used to return from sysio, a max
//              record length.
//      c3.204  a new configuration parameter cfp$f (scblk offset
//              is introduced. cfp$u is removed.
//      c3.205  implementation and version identification is
//              required - see sysid.
//      c3.206  routine sysmx returns the maximum length of
//              spitbol objects (strings arrays etc).  this
//              information is not now needed at time of entry to
//              spitbol and hence wc should be zero on entry.
//      c3.207  a conditional parameter .cnra permits assembly
//              of a more compact version with no real
//              arithmetic code.
//      c3.208  terminal is a new pre-associated variable
//              capable of performing input and output to an
//              online terminal.
//              sysri is a new routine used in the implementation
//              of this. see also syspp.
//      c3.209  the environment parameters e$--- are now
//              provided by the minimal translator using the
//              revised   equ  *   format (see c3.229 and start
//              of spitbol definitions section - some reordering
//              of symbols has occurred).
//      c3.210  the interface of sysxi has been slightly revised.
//              unavailability of i/o channels after exit(1),
//              exit(-1) is documented together with additional
//              error return usage for sysin,sysou,syspr,sysrd.
//      c3.211  spitbol error codes have been frozen - see c3.230
//      c3.212  the utility routines arref etc. are now
//              introduced by rtn statements.
//      c3.213  sysrl (record length for std input file) is
//              removed. since implementation of a general -inxxx
//              control card and an ability to specify max record
//              length using the third argument of input, sysrl
//              has become redundant.
//      c3.214  sysej and sysxi are now passed a chain linking
//              all fcblks in use.
//      c3.215  a special ending code in sysej is used when
//              attempts to use standard output channel fail.
//      c3.216  restriction c3.233 observed so simplifying
//              optimised translation of ent with omitted val.
        //b ||ejc|||||900
        
//
//      changes to minimal
//      ------------------
//
//      c3.220  minimal opcodes dec, dim, inc, and bmp
//              are withdrawn and replaced by the more consistent
//              set dca, dcv, ica, icv.
//      c3.221  chs has been replaced by the more generally
//              useful zgb (still likely to be a no-op for most
//              implementations however).
//      c3.222  the set of character comparisons has been
//              reduced to ceq and cne to ease implementation
//              problems.
//      c3.223  opcode irz is removed and dvi, rmi orders are
//              redefined to conform to more common usage.
//      c3.224  new opcodes ssl and sss are defined. their use
//              permits return links for n type procedures to be
//              placed on a local stack if desired.
//      c3.225  opcode mnz complements zer. it moves a non-zero
//              flag to its destination.
//      c3.226  for some machines it is preferable for the stack
//              to build up rather than down. to permit this
//              without need for massive changes in minimal and
//              recoding of existing programs, a scheme has been
//              devised in which an additional register name, xt,
//              is used as a synonym for xl when this register
//              is involved in stack manipulation- see section 4.
//      c3.227  section 0 of a minimal program is renamed the
//              procedure section. it now contains, in addition
//              to exp, specifications of internal procedures
//              and routines by means of the inp and inr opcodes.
//      c3.228  the literal operand formats =int and *int have
//              been withdrawn. =dlbl and *dlbl must be used in
//              their stead.
//      c3.229  the format
//              label  equ  *nn
//              used to specify values supplied by the minimal
//              translator for char. codes etc. is replaced by
//              label  equ  *
//              where the order in which the definitions are
//              supplied by the translator should match the
//              order of occurrence in the definitions section.
//      c3.230  the format of err,erb opcodes is changed to
//              require a numeric operand.
//      c3.231  the rtn opcode is used to introduce routines
//              (which are quite distinct from procedures).
//      c3.232  conditional assembly directives may be nested.
//      c3.233  minor restriction placed on the omission of
//              val with the ent opcode.
        //b ||ejc|||||950
        
//      version 3.1 to 3.2 (aug 77)
//      ---------------------------
//
//      bugs fixed
//      ----------
//
//      b3.101  astonishing this was unnoticed for three years.
//              bad code for snobol4 integer divide, /, gave
//              wrong result for operands of opposite signs.
//              implementations have either wrongly translated
//              dvi and got correct result or correctly
//              translated dvi and got wrong result - leeds had
//              one of each. see also c3.106.
//              test program no. 1 now extended to check /
//              more thoroughly.
//      b3.102  garbage collection bug in scane
//
//      changes
//      -------
//
//      c3.101  option to use additional characters ch$ht,ch$vt
//              (horizontal and vertical tab) with same syntactic
//              significance as ch$bl (blank).
//      c3.102  option to use a set of shifted case alphabetic
//              characters ch$$a ... ch$$$.
//      c3.103  conditional assembly features are introduced into
//              minimal on account of the above.
//              see minimal documentation section for details
//              of above changes.
//      c3.104  lch and sch may use an x register first
//              operand as alternative to a w register.
//      c3.105  spitbol statement numbers in the listing may
//              optionally be padded to 6 or 8 chars instead of 5
//              by defining conditional assembly symbols
//              .csn6 or .csn8 .
//      c3.106  to fix bug 3.101. at moderate cost,
//              opcode irz (branch if integer divide remainder
//              zero) introduced.
//      c3.107  to handle possible machine dependency in string
//              hashing, chs (complete hashing of string) opcode
//              is introduced. probably a no-op on most machines
//              - not on the dec10.
//      c3.108  procedures patin,tfind,trace have been
//              modified to conform to the minimal standard
//              call and return regime.
//      c3.109  sysfc interface revised slightly to permit
//              osint to return a pointer to a privately
//              allocated fcblk which spitbol will return on
//              subsequent i/o - see sysfc doc.
//      c3.110  to remove inconsistencies in calling sequences,
//              all sys routines having access to a possible
//              fcblk have fcblk ptr or zero in reg. wa on entry.
//              change affects sysef, sysen, sysil, sysin,
//              sysou, sysrw.
//      c3.111  syspp bit allocated to provide
//               -noexec option on entry to spitbol.
        //b ||ejc|||||1007
        
//
//      documentation revisions
//      -----------------------
//
//      d3.101  need to preserve registers in syspi, syspr,
//              sysrd calls was overstated.
        //b ||ejc|||||1014
        
//      version 3.0 to 3.1 (mar 77)
//      ---------------------------
//
//      bugs fixed
//      ----------
//
//      b3.001  replace() could fail during pre-evaluation.
//              spitbol now signals an error for null or
//              unequally long 2nd and 3rd arguments.
//      b3.002  negative second arguments to dupl, lpad, rpad
//              caused spitbol to signal an error. now causes
//              return of null string or first arg respectively.
//      b3.003  brn-s used instead of ppm-s in s$sub.
//      b3.004  err used instead of erb after cmp30.
//      b3.005  b$pfc, s$cnv, s$def, arith and arref kept
//              information illegally above the stack top.
//      b3.006  pre-evaluation of constant parts of
//              complex gotos was erroneous.
//      b3.007  incorrect handling of labels compiled by code().
//      b3.008  the single use of trc (in s$rpl) was not in
//              accord with its definition. some translations of
//              trc may need revision now that the use
//              has been brought into line with definition.
//
//      changes
//      -------
//
//      a debate on a few weaknesses in minimal design has
//      been resolved by introducing 4 new opcodes.
//
//      c3.001  new minimal opcodes bmp and dim introduced
//              to augment inc and dec which are applicable
//              only to addresses.
//      c3.002  the opcode szc (store zero characters) had
//              a restricted applicability. it has been
//              replaced by the more general zer (zeroise).
//      c3.003  fcblks may be optionally allocated as xrblk-s or
//              xnblk-s  - see sysfc for vital information.
//      c3.004  control card processing has been recoded.
//              -inxxx allows specification of standard input
//              file record lengths other than 72 or 80, see also
//              sysrl. -sequ is ignored unless -in80 is in effect
//      c3.005  to enable efficient buffering of chars on
//              machines without char. handling orders, the
//              csc (complete store characters) instruction
//              is introduced. current implementations can
//              translate it as a no-op if it is of no benefit.
//      c3.006  integers 0,1,2 are treated specially.
//              icblks in static are used instead of
//              allocating space in dynamic.
        //b ||ejc|||||1065
        
//
//      version 2.7 (june 76) to 3.0 (jan 77)
//      -------------------------------------
//
//      bugs fixed
//      ----------
//
//      b2.701  goes illegal if timed out during processing of
//              dump() call.
//      b2.702  goes illegal if spitbol error detected in args of
//              code() or eval(). bug fixed so that user now gets
//              a spitbol error report (trappable by setexit)
//              before statement failure.
//      b2.703  goes illegal in some circumstances when
//              multiple compilation errors occur in a statement
//      b2.704  goes illegal if garbage collector runs out of
//              stack space.
//      b2.705  control card processing incorrect for cdc 6400.
//      b2.706  incorrect handling of multiple occurrences of
//              chars in replace 2nd and 3rd args.
//      b2.707  stack overflow in pre-evaluation of replace in
//              cdc 6400 version.
//      b2.708  an explicit call of sysmw was coded in s$dat
//              instead of the mvw opcode.
//      b2.709  call of garbage collector whilst dumping
//              caused havoc.
//      b2.710  size restriction on spitbol objects (size must be
//              numerically less than lowest dynamic address)
//              was not enforced, with potential for catastrophe.
//      b2.711  deferred expressions involving alternation or
//              negation were incorrectly translated.
//      b2.712  listing of a compilation error at the end of a
//              long line could cause compiler to go illegal.
//      b2.713  incorrect -nofail code with success goto.
        //b ||ejc|||||1100
        
//
//
//      changes
//      -------
//
//      (it is not anticipated that major revisions on this
//      scale will be frequent).
//
//      c2.701  default value of anchor keyword is set to 1. this
//              conflicts with snobol4 practice but is a
//              preferable default for most applications.
//      c2.702  if errtype is out of range the string in keyword
//              errtext is printed as the error message.
//      c2.703  if stlimit is exceeded, up to 10 more statements
//              may be obeyed to permit setexit trap to gain
//              control.
//      c2.704  the concept of an interactive channel is
//              introduced for implementations where an online
//              terminal may be used for spitbol. the standard
//              print file may be specified as interactive in
//              which case shorter title lines are output.
//              alternatively copies of compilation and
//              execution errors only may be sent to this channel
//      c2.705  printing of compilation statistics may be
//              suppressed.
//      c2.706  printing of execution statistics may be
//              suppressed.
//      c2.707  extended or compact listing format may be
//              selected.
//      c2.708  an initial -nolist option may be specified
//              before compilation starts.
//      c2.709  to specify choices implied by c2.704 to c2.708
//              syspp interface is revised and syspi is defined.
//      c2.710  compilation and execution time statistics
//              messages have been shortened.
//      c2.711  the exit function as in sitbol is introduced
//              to permit saving load modules - see sysxi, s$ext.
//      c2.712  diagnostic routines sysgb and sysgd have been
//              removed. they were useful in the early debugging
//              days but have fallen into disuse now.
//      c2.713  szc may have an operand of type opn instead of
//              type opw
//      c2.714  input/output association interface has been
//              revised. sysif,sysof have been consolidated into
//              the new system routine, sysio, and the
//              specification of sysfc has been slightly changed.
//      c2.715  configuration parameter mxlen has been withdrawn
//              and the maximum size of a spitbol object which
//              was formerly fixed at spitbol compile time by
//              reference to it may now be specified as a run
//              time option by placing a value in wc before entry
//              to spitbol. (see comment on dynamic area in
//              basic information section).
//      c2.716  a function, host, is introduced which yields
//              information about the host machine - see syshs
//              and s$hst.
        //b ||ejc|||||1157
        
//
//      documentation revisions
//      -----------------------
//
//      d2.701  the description of mvc has been revised to
//              reflect the fact that some spitbol code sequences
//              rely on mvc not destroying wb. minor changes
//              have been made to mwb and mvw descriptions to
//              emphasise similarities in the implicit loops of
//              these orders.
//      d2.702  descriptions of dvi and rmi have been clarified.
//      d2.703  implementation of rsx,lsx,ceq,cge,cgt,chi,clo,clt
//              is optional at present since they are currently
//              unused. their use in later versions is not
//              excluded.
//      d2.704  impossibility of using stack for return links of
//              n type procedures is emphasised.
//      d2.705  notation (xl),(wc) etc in language description is
//              clarified.
//      d2.706  documentation of sysfc, sysio has been improved.
//      d2.707  opcode descriptions are cross referenced from
//              the alphabetical opcode list.
//      d2.708  general description of compiler has been moved to
//              the start of the compiler proper.
//      d2.709  definitions of environment parameters have been
//              put near the front of the definitions section.
        //b ||ttl|27,minimal -- machine independent macro assembly lang.||||1184
        /* minimal -- machine independent macro assembly lang.*/
        //b ||ejc|||||1185
        
        //b ||ttl|27,s p i t b o l  -- basic information||||1186
        /* s p i t b o l  -- basic information*/
        //b ||ejc|||||1187
        
//      general structure
//      -----------------
//      this program is a translator for a version of the snobol4
//      programming language. language details are contained in
//      the manual macro spitbol by dewar and mccann, technical
//      report 90, university of leeds 1976.
//      the implementation is discussed in dewar and mccann,
//      macro spitbol - a snobol4 compiler, software practice and
//      experience, 7, 95-113, 1977.
//      the language is as implemented by the btl translator
//      (griswold, poage and polonsky, prentice hall, 1971)
//      with the following principal exceptions.
//      1)   redefinition of standard system functions and
//           operators is not permitted.
//      2)   the value function is not provided.
//      3)   access tracing is provided in addition to the
//           other standard trace modes.
//      4)   the keyword stfcount is not provided.
//      5)   the keyword fullscan is not provided and all pattern
//           matching takes place in fullscan mode (i.e. with no
//           heuristics applied).
//      6)   a series of expressions separated by commas may
//           be grouped within parentheses to provide a selection
//           capability. the semantics are that the selection
//           assumes the value of the first expression within it
//           which succeeds as they are evaluated from the left.
//           if no expression succeeds the entire statement fails
//      7)   an explicit pattern matching operator is provided.
//           this is the binary query (see gimpel sigplan oct 74)
//      8)   the assignment operator is introduced as in the
//           gimpel reference.
//      9)   the exit function is provided for generating load
//           modules - cf. gimpels sitbol.
//      the method used in this program is to translate the
//      source code into an internal pseudo-code (see following
//      section). an interpretor is then used to execute this
//      generated pseudo-code. the nature of the snobol4 language
//      is such that the latter task is much more complex than
//      the actual translation phase. accordingly, nearly all the
//      code in the program section is concerned with the actual
//      execution of the snobol4 program.
        //b ||ejc|||||1242
        
//      interpretive code format
//      ------------------------
//      the interpretive pseudo-code consists of a series of
//      address pointers. the exact format of the code is
//      described in connection with the cdblk format. the
//      purpose of this section is to give general insight into
//      the interpretive approach involved.
//      the basic form of the code is related to reverse polish.
//      in other words, the operands precede the operators which
//      are zero address operators. there are some exceptions to
//      these rules, notably the unary not operator and the
//      selection construction which clearly require advance
//      knowledge of the operator involved.
//      the operands are moved to the top of the main stack and
//      the operators are applied to the top stack entries. like
//      other versions of spitbol, this processor depends on
//      knowing whether operands are required by name or by value
//      and moves the appropriate object to the stack. thus no
//      name/value checks are included in the operator circuits.
//      the actual pointers in the code point to a block whose
//      first word is the address of the interpretor routine
//      to be executed for the code word.
//      in the case of operators, the pointer is to a word which
//      contains the address of the operator to be executed. in
//      the case of operands such as constants, the pointer is to
//      the operand itself. accordingly, all operands contain
//      a field which points to the routine to load the value of
//      the operand onto the stack. in the case of a variable,
//      there are three such pointers. one to load the value,
//      one to store the value and a third to jump to the label.
//      the handling of failure returns deserves special comment.
//      the location flptr contains the pointer to the location
//      on the main stack which contains the failure return
//      which is in the form of a byte offset in the current
//      code block (cdblk or exblk). when a failure occurs, the
//      stack is popped as indicated by the setting of flptr and
//      control is passed to the appropriate location in the
//      current code block with the stack pointer pointing to the
//      failure offset on the stack and flptr unchanged.
        //b ||ejc|||||1289
        
//      internal data representations
//      -----------------------------
//      representation of values
//      a value is represented by a pointer to a block which
//      describes the type and particulars of the data value.
//      in general, a variable is a location containing such a
//      pointer (although in the case of trace associations this
//      is modified, see description of trblk).
//      the following is a list of possible datatypes showing the
//      type of block used to hold the value. the details of
//      each block format are given later.
//      datatype              block type
//      --------              ----------
//      array                 arblk or vcblk
//      code                  cdblk
//      expression            exblk or seblk
//      integer               icblk
//      name                  nmblk
//      pattern               p0blk or p1blk or p2blk
//      real                  rcblk
//      string                scblk
//      table                 tbblk
//      program datatype      pdblk
        //b ||ejc|||||1328
        
//      representation of variables
//      ---------------------------
//      during the course of evaluating expressions, it is
//      necessary to generate names of variables (for example
//      on the left side of a binary equals operator). these are
//      not to be confused with objects of datatype name which
//      are in fact values.
//      from a logical point of view, such names could be simply
//      represented by a pointer to the appropriate value cell.
//      however in the case of arrays and program defined
//      datatypes, this would violate the rule that there must be
//      no pointers into the middle of a block in dynamic store.
//      accordingly, a name is always represented by a base and
//      offset. the base points to the start of the block
//      containing the variable value and the offset is the
//      offset within this block in bytes. thus the address
//      of the actual variable is determined by adding the base
//      and offset values.
//      the following are the instances of variables represented
//      in this manner.
//      1)   natural variable base is ptr to vrblk
//                            offset is *vrval
//      2)   table element    base is ptr to teblk
//                            offset is *teval
//      3)   array element    base is ptr to arblk
//                            offset is offset to element
//      4)   vector element   base is ptr to vcblk
//                            offset is offset to element
//      5)   prog def dtp     base is ptr to pdblk
//                            offset is offset to field value
//      in addition there are two cases of objects which are
//      like variables but cannot be handled in this manner.
//      these are called pseudo-variables and are represented
//      with a special base pointer as follows=
//      expression variable   ptr to evblk (see evblk)
//      keyword variable      ptr to kvblk (see kvblk)
//      pseudo-variables are handled as special cases by the
//      access procedure (acess) and the assignment procedure
//      (asign). see these two procedures for details.
        //b ||ejc|||||1381
        
//      organization of data area
//      -------------------------
//      the data area is divided into two regions.
//      static area
//      the static area builds up from the bottom and contains
//      data areas which are allocated dynamically but are never
//      deleted or moved around. the macro-program itself
//      uses the static area for the following.
//      1)   all variable blocks (vrblk).
//      2)   the hash table for variable blocks.
//      3)   miscellaneous buffers and work areas (see program
//           initialization section).
//      in addition, the system procedures may use this area for
//      input/output buffers, external functions etc. space in
//      the static region is allocated by calling procedure alost
//      the following global variables define the current
//      location and size of the static area.
//      statb                 address of start of static area
//      state                 address+1 of last word in area.
//      the minimum size of static is given approximately by
//           12 + *e_hnb + *e_sts + space for alphabet string
//           and standard print buffer.
        //b ||ejc|||||1415
        
//      dynamic area
//      the dynamic area is built upwards in memory after the
//      static region. data in this area must all be in standard
//      block formats so that it can be processed by the garbage
//      collector (procedure gbcol). gbcol compacts blocks down
//      in this region as required by space exhaustion and can
//      also move all blocks up to allow for expansion of the
//      static region.
//      with the exception of tables and arrays, no spitbol
//      object once built in dynamic memory is ever subsequently
//      modified. observing this rule necessitates a copying
//      action during string and pattern concatenation.
//      garbage collection is fundamental to the allocation of
//      space for values. spitbol uses a very efficient garbage
//      collector which insists that pointers into dynamic store
//      should be identifiable without use of bit tables,
//      marker bits etc. to satisfy this requirement, dynamic
//      memory must not start at too low an address and lengths
//      of arrays, tables, strings, code and expression blocks
//      may not exceed the numerical value of the lowest dynamic
//      address.
//      to avoid either penalizing users with modest
//      requirements or restricting those with greater needs on
//      host systems where dynamic memory is allocated in low
//      addresses, the minimum dynamic address may be specified
//      sufficiently high to permit arbitrarily large spitbol
//      objects to be created (with the possibility in extreme
//      cases of wasting large amounts of memory below the
//      start address). this minimum value is made available
//      in variable mxlen by a system routine, sysmx.
//      alternatively sysmx may indicate that a
//      default may be used in which dynamic is placed
//      at the lowest possible address following static.
//      the following global work cells define the location and
//      length of the dynamic area.
//      dnamb                 start of dynamic area
//      dnamp                 next available location
//      dname                 last available location + 1
//      dnamb is always higher than state since the alost
//      procedure maintains some expansion space above state.
//      *** dnamb must never be permitted to have a value less
//      than that in mxlen ***
//      space in the dynamic region is allocated by the alloc
//      procedure. the dynamic region may be used by system
//      procedures provided that all the rules are obeyed.
//      some of the rules are subtle so it is preferable for
//      osint to manage its own memory needs. spitbol procs
//      obey rules to ensure that no action can cause a garbage
//      collection except at such times as contents of xl, xr
//      and the stack are +clean+ (see comment before utility
//      procedures and in gbcol for more detail). note
//      that calls of alost may cause garbage collection (shift
//      of memory to free space). spitbol procs which call
//      system routines assume that they cannot precipitate
//      collection and this must be respected.
        //b ||ejc|||||1478
        
//      register usage
//      --------------
//      (cp)                  code pointer register. used to
//                            hold a pointer to the current
//                            location in the interpretive pseudo
//                            code (i.e. ptr into a cdblk).
//      (xl,xr)               general index registers. usually
//                            used to hold pointers to blocks in
//                            dynamic storage. an important
//                            restriction is that the value in
//                            xl must be collectable for
//                            a garbage collect call. a value
//                            is collectable if it either points
//                            outside the dynamic area, or if it
//                            points to the start of a block in
//                            the dynamic area.
//      (xs)                  stack pointer. used to point to
//                            the stack front. the stack may
//                            build up or down and is used
//                            to stack subroutine return points
//                            and other recursively saved data.
//      (xt)                  an alternative name for xl during
//                            its use in accessing stacked items.
//      (wa,wb,wc)            general work registers. cannot be
//                            used for indexing, but may hold
//                            various types of data.
//      (ia)                  used for all signed integer
//                            arithmetic, both that used by the
//                            translator and that arising from
//                            use of snobol4 arithmetic operators
//      (ra)                  real accumulator. used for all
//                            floating point arithmetic.
        //b ||ejc|||||1519
        
//      spitbol conditional assembly symbols
//      ------------------------------------
//      in the spitbol translator, the following conditional
//      assembly symbols are referred to. to incorporate the
//      features referred to, the minimal source should be
//      prefaced by suitable conditional assembly symbol
//      definitions.
//      in all cases it is permissible to default the definitions
//      in which case the additional features will be omitted
//      from the target code.
//      .caex                 define to allow up arrow for expon.
//      .caht                 define to include horizontal tab
//      .casl                 define to include 26 shifted lettrs
//      .cavt                 define to include vertical tab
//      .cbyt                 define for statistics in bytes
//      .ccmc                 define to include syscm function
//      .ccmk                 define to include compare keyword
//      .cepp                 define if entrys have odd parity
//      .cera                 define to include sysea function
//      .cexp                 define if spitbol pops sysex args
//      .cgbc                 define to include sysgc function
//      .cicc                 define to ignore bad control cards
//      .cinc                 define to add -include control card
//      .ciod                 define to not use default delimiter
//                              in processing 3rd arg of input()
//                              and output()
//      .cmth                 define to include math functions
//      .cnbf                 define to omit buffer extension
//      .cnbt                 define to omit batch initialisation
//      .cnci                 define to enable sysci routine
//      .cncr                 define to enable syscr routine
//      .cnex                 define to omit exit() code.
//      .cnld                 define to omit load() code.
//      .cnlf                 define to add file type for load()
//      .cnpf                 define to omit profile stuff
//      .cnra                 define to omit all real arithmetic
//      .cnsc                 define to no numeric-string compare
//      .cnsr                 define to omit sort, rsort
//      .cpol                 define if interface polling desired
//      .crel                 define to include reloc routines
//      .crpp                 define if returns have odd parity
//      .cs16                 define to initialize stlim to 32767
//      .cs32                 define to init stlim to 2147483647
//                            omit to take default of 50000
//      .csax                 define if sysax is to be called
//      .csed                 define to use sediment in gbcol
//      .csfn                 define to track source file names
//      .csln                 define if line number in code block
//      .csou                 define if output, terminal to sysou
//      .ctet                 define to table entry trace wanted
//      .ctmd                 define if systm unit is decisecond
//      .cucf                 define to include cfp_u
//      .cuej                 define to suppress needless ejects
//      .culk                 define to include &l/ucase keywords
//      .culc                 define to include &case (lc names)
//                            if cucl defined, must support
//                            minimal op flc wreg that folds
//                            argument to lower case
//      .cust                 define to include set() code
//                            conditional options
//                            since .undef not allowed if symbol
//                            not defined, a full comment line
//                            indicates symbol initially not
//                            defined.
//	The following options are enabled for the linux implementationss.
// copyright 1987-2012 robert b. k. dewar and mark emmer.
//
// copyright 2012-2015 david shields
//
// this file is part of macro spitbol.
//
//     macro spitbol is free software: you can redistribute it and/or modify
//     it under the terms of the gnu general public license as published by
//     the free software foundation, either version 2 of the license, or
//     (at your option) any later version.
//
//     macro spitbol is distributed in the hope that it will be useful,
//     but without any warranty; without even the implied warranty of
//     merchantability or fitness for a particular purpose.  see the
//     gnu general public license for more details.
//
//     you should have received a copy of the gnu general public license
//     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.
//
//      spitbol conditional assembly symbols for use by token.spt
//      ---------------------------------------------------------
//
//      this file of conditional symbols will override the conditional
//      definitions contained in the spitbol minimal file.   in addition,
//      lines beginning with ">" are treated as spitbol statements and
//      immediately executed.
//
//      in the spitbol translator, the following conditional
//      assembly symbols are referred to. to incorporate the
//      features referred to, the minimal source should be
//      prefaced by suitable conditional assembly symbol
//      definitions.
//      in all cases it is permissible to default the definitions
//      in which case the additional features will be omitted
//      from the target code.
//
//
//                            conditional options
//                            since .undef not allowed if symbol not
//                            defined, a full comment line indicates
//                            symbol initially not defined.
//
//	The following options are set for the linux implementations
//      .caex                 define to allow up arrow for exponentiation
//      .cavt                 define to include vertical tab
//      .ccmc                 define to include syscm function
//      .ceng                 define to include engine features
//      .cnci                 define to enable sysci routine
//      .cncr                 define to enable syscr routine
//      .cnex                 define to omit exit() code.
//      .cnld                 define to omit load() code.
//      .cnpf                 define to omit profile stuff
//def   .cnra                 define to omit all real arithmetic
//      .cnsr                 define to omit sort, rsort
//      .crpp                 define if return points have odd parity
//      .cs16                 define to initialize stlim to 32767
//      .culc                 define to include &case (lc names)
//      .cust                 define to include set() code
//      .cusr                 define to have set() use real values
//                             (must also #define setreal 1 in systype.h)
//
//      force definition of .ccmk if .ccmc is defined
        //b ||ttl|27,s p i t b o l -- procedures section||||1690
        /* s p i t b o l -- procedures section*/
//      this section starts with descriptions of the operating
//      system dependent procedures which are used by the spitbol
//      translator. all such procedures have five letter names
//      beginning with sys. they are listed in alphabetical
//      order.
//      all procedures have a  specification consisting of a
//      model call, preceded by a possibly empty list of register
//      contents giving parameters available to the procedure and
//      followed by a possibly empty list of register contents
//      required on return from the call or which may have had
//      their contents destroyed. only those registers explicitly
//      mentioned in the list after the call may have their
//      values changed.
//      the segment of code providing the external procedures is
//      conveniently referred to as osint (operating system
//      interface). the sysxx procedures it contains provide
//      facilities not usually available as primitives in
//      assembly languages. for particular target machines,
//      implementors may choose for some minimal opcodes which
//      do not have reasonably direct translations, to use calls
//      of additional procedures which they provide in osint.
//      e.g. mwb or trc might be translated as jsr sysmb,
//      jsr systc in some implementations.
//      in the descriptions, reference is made to --blk
//      formats (-- = a pair of letters). see the spitbol
//      definitions section for detailed descriptions of all
//      such block formats except fcblk for which sysfc should
//      be consulted.
//      section 0 contains inp,inr specifications of internal
//      procedures,routines. this gives a single pass translator
//      information making it easy to generate alternative calls
//      in the translation of jsr-s for procedures of different
//      types if this proves necessary.
        //b ||sec||||start of procedures section|1728
        /*-------------------------------------------------------------------- sec01 --------*/
        // procedure declarations
        //b ||ejc|||||1730
        
//      sysax -- after execution
//      if the conditional assembly symbol .csax is defined,
//      this routine is called immediately after execution and
//      before printing of execution statistics or dump output.
//      purpose of call is for implementor to determine and
//      if the call is not required it will be omitted if .csax
//      is undefined. in this case sysax need not be coded.
//      jsr  sysax            call after execution
        //b ||ejc|||||1746
        
//      sysbs -- backspace file
//      sysbs is used to implement the snobol4 function backspace
//      if the conditional assembly symbol .cbsp is defined.
//      the meaning is system dependent.  in general, backspace
//      repositions the file one record closer to the beginning
//      of file, such that a subsequent read or write will
//      operate on the previous record.
//      (wa)                  ptr to fcblk or zero
//      (xr)                  backspace argument (scblk ptr)
//      jsr  sysbs            call to backspace
//      ppm  loc              return here if file does not exist
//      ppm  loc              return here if backspace not allowed
//      ppm  loc              return here if i/o error
//      (wa,wb)               destroyed
//      the second error return is used for files for which
//      backspace is not permitted. for example, it may be expected
//      files on character devices are in this category.
        //b ||ejc|||||1771
        
//      sysbx -- before execution
//      called after initial spitbol compilation and before
//      commencing execution in case osint needs
//      to assign files or perform other necessary services.
//      osint may also choose to send a message to online
//      terminal (if any) indicating that execution is starting.
//      jsr  sysbx            call before execution starts
        //b ||ejc|||||1785
        
//      sysdc -- date check
//      sysdc is called to check that the expiry date for a trial
//      version of spitbol is unexpired.
//      jsr  sysdc            call to check date
//      return only if date is ok
        //b ||ejc|||||1886
        
//      sysdm  -- dump core
//      sysdm is called by a spitbol program call of dump(n) with
//      n ge 4.  its purpose is to provide a core dump.
//      n could hold an encoding of the start adrs for dump and
//      amount to be dumped e.g.  n = 256*a + s , s = start adrs
//      in kilowords,  a = kilowords to dump
//      (xr)                  parameter n of call dump(n)
//      jsr  sysdm            call to enter routine
        //b ||ejc|||||1900
        
//      sysdt -- get current date
//      sysdt is used to obtain the current date. the date is
//      returned as a character string in any format appropriate
//      to the operating system in use. it may also contain the
//      current time of day. sysdt is used to implement the
//      snobol4 function date().
//      (xr)                  parameter n of call date(n)
//      jsr  sysdt            call to get date
//      (xl)                  pointer to block containing date
//      the format of the block is like an scblk except that
//      the first word need not be set. the result is copied
//      into spitbol dynamic memory on return.
        //b ||ejc|||||1920
        
//      sysea -- inform osint of compilation and runtime errors
//      provides means for interface to take special actions on
//      errors
//      (wa)                  error code
//      (wb)                  line number
//      (wc)                  column number
//      (xr)                  system stage
//      (xl)                  file name (scblk)
//      jsr  sysea            call to sysea function
//      ppm  loc              suppress printing of error message
//      (xr)                  message to print (scblk) or 0
//      sysea may not return if interface chooses to retain
//      control.  closing files via the fcb chain will be the
//      responsibility of the interface.
//      all registers preserved
        //b ||ejc|||||1946
        
//      sysef -- eject file
//      sysef is used to write a page eject to a named file. it
//      may only be used for files where this concept makes
//      sense. note that sysef is not normally used for the
//      standard output file (see sysep).
//      (wa)                  ptr to fcblk or zero
//      (xr)                  eject argument (scblk ptr)
//      jsr  sysef            call to eject file
//      ppm  loc              return here if file does not exist
//      ppm  loc              return here if inappropriate file
//      ppm  loc              return here if i/o error
        //b ||ejc|||||1963
        
//      sysej -- end of job
//      sysej is called once at the end of execution to
//      terminate the run. the significance of the abend and
//      code values is system dependent. in general, the code
//      value should be made available for testing, and the
//      abend value should cause some post-mortem action such as
//      a dump. note that sysej does not return to its caller.
//      see sysxi for details of fcblk chain
//      (wa)                  value of abend keyword
//      (wb)                  value of code keyword
//      (xl)                  o or ptr to head of fcblk chain
//      jsr  sysej            call to end job
//      the following special values are used as codes in (wb)
//      999  execution suppressed
//      998  standard output file full or unavailable in a sysxi
//           load module. in these cases (wa) contains the number
//           of the statement causing premature termination.
        //b ||ejc|||||1987
        
//      sysem -- get error message text
//      sysem is used to obtain the text of err, erb calls in the
//      source program given the error code number. it is allowed
//      to return a null string if this facility is unavailable.
//      (wa)                  error code number
//      jsr  sysem            call to get text
//      (xr)                  text of message
//      the returned value is a pointer to a block in scblk
//      format except that the first word need not be set. the
//      string is copied into dynamic memory on return.
//      if the null string is returned either because sysem does
//      not provide error message texts or because wa is out of
//      range, spitbol will print the string stored in errtext
//      keyword.
        //b ||ejc|||||2008
        
//      sysen -- endfile
//      sysen is used to implement the snobol4 function endfile.
//      the meaning is system dependent. in general, endfile
//      implies that no further i/o operations will be performed,
//      but does not guarantee this to be the case. the file
//      should be closed after the call, a subsequent read
//      or write may reopen the file at the start or it may be
//      necessary to reopen the file via sysio.
//      (wa)                  ptr to fcblk or zero
//      (xr)                  endfile argument (scblk ptr)
//      jsr  sysen            call to endfile
//      ppm  loc              return here if file does not exist
//      ppm  loc              return here if endfile not allowed
//      ppm  loc              return here if i/o error
//      (wa,wb)               destroyed
//      the second error return is used for files for which
//      endfile is not permitted. for example, it may be expected
//      that the standard input and output files are in this
//      category.
        //b ||ejc|||||2034
        
//      sysep -- eject printer page
//      sysep is called to perform a page eject on the standard
//      printer output file (corresponding to syspr output).
//      jsr  sysep            call to eject printer output
        //b ||ejc|||||2044
        
//      sysex -- call external function
//      sysex is called to pass control to an external function
//      previously loaded with a call to sysld.
//      (xs)                  pointer to arguments on stack
//      (xl)                  pointer to control block (efblk)
//      (wa)                  number of arguments on stack
//      jsr  sysex            call to pass control to function
//      ppm  loc              return here if function call fails
//      ppm  loc              return here if insufficient memory
//      ppm  loc              return here if bad argument type
//      (xr)                  result returned
//      the arguments are stored on the stack with
//      the last argument at 0(xs). on return, xs
//      is popped past the arguments.
//      the form of the arguments as passed is that used in the
//      spitbol translator (see definitions and data structures
//      section). the control block format is also described
//      (under efblk) in this section.
//      there are two ways of returning a result.
//      1)   return a pointer to a block in dynamic storage. this
//           block must be in exactly correct format, including
//           the first word. only functions written with intimate
//           knowledge of the system will return in this way.
//      2)   string, integer and real results may be returned by
//           pointing to a pseudo-block outside dynamic memory.
//           this block is in icblk, rcblk or scblk format except
//           that the first word will be overwritten
//           by a type word on return and so need not
//           be correctly set. such a result is
//           copied into main storage before proceeding.
//           unconverted results may similarly be returned in a
//           pseudo-block which is in correct format including
//           type word recognisable by garbage collector since
//           block is copied into dynamic memory.
        //b ||ejc|||||2093
        
//      sysfc -- file control block routine
//      see also sysio
//      input and output have 3 arguments referred to as shown
//           input(variable name,file arg1,file arg2)
//           output(variable name,file arg1,file arg2)
//      file arg1 may be an integer or string used to identify
//      an i/o channel. it is converted to a string for checking.
//      the exact significance of file arg2
//      is not rigorously prescribed but to improve portability,
//      the scheme described in the spitbol user manual
//      should be adopted when possible. the preferred form is
//      a string _f_,r_r_,c_c_,i_i_,...,z_z_  where
//      _f_ is an optional file name which is placed first.
//       remaining items may be omitted or included in any order.
//      _r_ is maximum record length
//      _c_ is a carriage control character or character string
//      _i_ is some form of channel identification used in the
//         absence of _f_ to associate the variable
//         with a file allocated dynamically by jcl commands at
//         spitbol load time.
//      ,...,z_z_ are additional fields.
//      if , (comma) cannot be used as a delimiter, .ciod
//      should be defined to introduce by conditional assembly
//      another delimiter (see
//        iodel  equ  *
//      early in definitions section).
//      sysfc is called when a variable is input or output
//      associated to check file arg1 and file arg2 and
//      to  report whether an fcblk (file control
//      block) is necessary and if so what size it should be.
//      this makes it possible for spitbol rather than osint to
//      allocate such a block in dynamic memory if required
//      or alternatively in static memory.
//      the significance of an fcblk , if one is requested, is
//      entirely up to the system interface. the only restriction
//      is that if the fcblk should appear to lie in dynamic
//      memory, pointers to it should be proper pointers to
//      the start of a recognisable and garbage collectable
//      block (this condition will be met if sysfc requests
//      spitbol to provide an fcblk).
//      an option is provided for osint to return a pointer in
//      xl to an fcblk which it privately allocated. this ptr
//      will be made available when i/o occurs later.
//      private fcblks may have arbitrary contents and spitbol
//      stores nothing in them.
        //b ||ejc|||||2143
        
//      the requested size for an fcblk in dynamic memory
//      should allow a 2 word overhead for block type and
//      length fields. information subsequently stored in the
//      remaining words may be arbitrary if an xnblk (external
//      non-relocatable block) is requested. if the request is
//      for an xrblk (external relocatable block) the
//      contents of words should be collectable (i.e. any
//      apparent pointers into dynamic should be genuine block
//      pointers). these restrictions do not apply if an fcblk
//      is allocated outside dynamic or is not allocated at all.
//      if an fcblk is requested, its fields will be initialised
//      to zero before entry to sysio with the exception of
//      words 0 and 1 in which the block type and length
//      fields are placed for fcblks in dynamic memory only.
//      for the possible use of sysej and sysxi, if fcblks
//      are used, a chain is built so that they may all be
//      found - see sysxi for details.
//      if both file arg1 and file arg2 are null, calls of sysfc
//      and sysio are omitted.
//      if file arg1 is null (standard input/output file), sysfc
//      is called to check non-null file arg2 but any request
//      for an fcblk will be ignored, since spitbol handles the
//      standard files specially and cannot readily keep fcblk
//      pointers for them.
//      filearg1 is type checked by spitbol so further checking
//      may be unneccessary in many implementations.
//      file arg2 is passed so that sysfc may analyse and
//      check it. however to assist in this, spitbol also passes
//      on the stack the components of this argument with
//      file name, _f_ (otherwise null) extracted and stacked
//      first.
//      the other fields, if any, are extracted as substrings,
//      pointers to them are stacked and a count of all items
//      stacked is placed in wc. if an fcblk was earlier
//      allocated and pointed to via file arg1, sysfc is also
//      passed a pointer to this fcblk.
//      (xl)                  file arg1 scblk ptr (2nd arg)
//      (xr)                  filearg2 (3rd arg) or null
//      -(xs)...-(xs)         scblks for _f_,_r_,_c_,...
//      (wc)                  no. of stacked scblks above
//      (wa)                  existing file arg1 fcblk ptr or 0
//      (wb)                  0/3 for input/output assocn
//      jsr  sysfc            call to check need for fcblk
//      ppm  loc              invalid file argument
//      ppm  loc              fcblk already in use
//      (xs)                  popped (wc) times
//      (wa non zero)         byte size of requested fcblk
//      (wa=0,xl non zero)    private fcblk ptr in xl
//      (wa=xl=0)             no fcblk wanted, no private fcblk
//      (wc)                  0/1/2 request alloc of xrblk/xnblk
//                            /static block for use as fcblk
//      (wb)                  destroyed
        //b ||ejc|||||2198
        
//      sysgc -- inform interface of garbage collections
//      provides means for interface to take special actions
//      prior to and after a garbage collection.
//      possible usages-
//      1. provide visible screen icon of garbage collection
//         in progress
//      2. inform virtual memory manager to ignore page access
//         patterns during garbage collection.  such accesses
//         typically destroy the page working set accumulated
//         by the program.
//      3. inform virtual memory manager that contents of memory
//         freed by garbage collection can be discarded.
//      (xr)                  non-zero if beginning gc
//                            =0 if completing gc
//      (wa)                  dnamb=start of dynamic area
//      (wb)                  dnamp=next available location
//      (wc)                  dname=last available location + 1
//      jsr  sysgc            call to sysgc function
//      all registers preserved
        //b ||ejc|||||2226
        
//      syshs -- give access to host computer features
//      provides means for implementing special features
//      on different host computers. the only defined entry is
//      that where all arguments are null in which case syshs
//      returns an scblk containing name of computer,
//      name of operating system and name of site separated by
//      colons. the scblk need not have a correct first field
//      as this is supplied on copying string to dynamic memory.
//      spitbol does no argument checking but does provide a
//      single error return for arguments checked as erroneous
//      by osint. it also provides a single execution error
//      return. if these are inadequate, use may be made of the
//      minimal error section direct as described in minimal
//      documentation, section 10.
//      several non-error returns are provided. the first
//      corresponds to the defined entry or, for implementation
//      defined entries, any string may be returned. the others
//      permit respectively,  return a null result, return with a
//      result to be stacked which is pointed at by xr, and a
//      return causing spitbol statement failure. if a returned
//      result is in dynamic memory it must obey garbage
//      collector rules. the only results copied on return
//      are strings returned via ppm loc3 return.
//      (wa)                  argument 1
//      (xl)                  argument 2
//      (xr)                  argument 3
//      (wb)                  argument 4
//      (wc)                  argument 5
//      jsr  syshs            call to get host information
//      ppm  loc1             erroneous arg
//      ppm  loc2             execution error
//      ppm  loc3             scblk ptr in xl or 0 if unavailable
//      ppm  loc4             return a null result
//      ppm  loc5             return result in xr
//      ppm  loc6             cause statement failure
//      ppm  loc7             return string at xl, length wa
//      ppm  loc8             return copy of result in xr
        //b ||ejc|||||2269
        
//      sysid -- return system identification
//      this routine should return strings to head the standard
//      printer output. the first string will be appended to
//      a heading line of the form
//           macro spitbol version v.v
//      supplied by spitbol itself. v.v are digits giving the
//      major version number and generally at least a minor
//      version number relating to osint should be supplied to
//      give say
//           macro spitbol version v.v(m.m)
//      the second string should identify at least the machine
//      and operating system.  preferably it should include
//      the date and time of the run.
//      optionally the strings may include site name of the
//      the implementor and/or machine on which run takes place,
//      unique site or copy number and other information as
//      appropriate without making it so long as to be a
//      nuisance to users.
//      the first words of the scblks pointed at need not be
//      correctly set.
//      jsr  sysid            call for system identification
//      (xr)                  scblk ptr for addition to header
//      (xl)                  scblk ptr for second header
        //b ||ejc|||||2298
        
//      sysif -- switch to new include file
//      sysif is used for include file processing, both to inform
//      the interface when a new include file is desired, and
//      when the end of file of an include file has been reached
//      and it is desired to return to reading from the previous
//      nested file.
//      it is the responsibility of sysif to remember the file
//      access path to the present input file before switching to
//      the new include file.
//      (xl)                  ptr to scblk or zero
//      (xr)                  ptr to vacant scblk of length cswin
//                            (xr not used if xl is zero)
//      jsr  sysif            call to change files
//      ppm  loc              unable to open file
//      (xr)                  scblk with full path name of file
//                            (xr not used if input xl is zero)
//      register xl points to an scblk containing the name of the
//      include file to which the interface should switch.  data
//      is fetched from the file upon the next call to sysrd.
//      sysif may have the ability to search multiple libraries
//      for the include file named in (xl).  it is therefore
//      required that the full path name of the file where the
//      file was finally located be returned in (xr).  it is this
//      name that is recorded along with the source statements,
//      and will accompany subsequent error messages.
//      register xl is zero to mark conclusion of use of an
//      include file.
        //b ||ejc|||||2336
        
//      sysil -- get input record length
//      sysil is used to get the length of the next input record
//      from a file previously input associated with a sysio
//      call. the length returned is used to establish a buffer
//      for a subsequent sysin call.  sysil also indicates to the
//      caller if this is a binary or text file.
//      (wa)                  ptr to fcblk or zero
//      jsr  sysil            call to get record length
//      (wa)                  length or zero if file closed
//      (wc)                  zero if binary, non-zero if text
//      no harm is done if the value returned is too long since
//      unused space will be reclaimed after the sysin call.
//      note that it is the sysil call (not the sysio call) which
//      causes the file to be opened as required for the first
//      record input from the file.
        //b ||ejc|||||2360
        
//      sysin -- read input record
//      sysin is used to read a record from the file which was
//      referenced in a prior call to sysil (i.e. these calls
//      always occur in pairs). the buffer provided is an
//      scblk for a string of length set from the sysil call.
//      if the actual length read is less than this, the length
//      field of the scblk must be modified before returning
//      unless buffer is right padded with zeroes.
//      it is also permissible to take any of the alternative
//      returns after scblk length has been modified.
//      (wa)                  ptr to fcblk or zero
//      (xr)                  pointer to buffer (scblk ptr)
//      jsr  sysin            call to read record
//      ppm  loc              endfile or no i/p file after sysxi
//      ppm  loc              return here if i/o error
//      ppm  loc              return here if record format error
//      (wa,wb,wc)            destroyed
        //b ||ejc|||||2383
        
//      sysio -- input/output file association
//      see also sysfc.
//      sysio is called in response to a snobol4 input or output
//      function call except when file arg1 and file arg2
//      are both null.
//      its call always follows immediately after a call
//      of sysfc. if sysfc requested allocation
//      of an fcblk, its address will be in wa.
//      for input files, non-zero values of _r_ should be
//      copied to wc for use in allocating input buffers. if _r_
//      is defaulted or not implemented, wc should be zeroised.
//      once a file has been opened, subsequent input(),output()
//      calls in which the second argument is identical with that
//      in a previous call, merely associate the additional
//      variable name (first argument) to the file and do not
//      result in re-opening the file.
//      in subsequent associated accesses to the file a pointer
//      to any fcblk allocated will be made available.
//      (xl)                  file arg1 scblk ptr (2nd arg)
//      (xr)                  file arg2 scblk ptr (3rd arg)
//      (wa)                  fcblk ptr (0 if none)
//      (wb)                  0 for input, 3 for output
//      jsr  sysio            call to associate file
//      ppm  loc              return here if file does not exist
//      ppm  loc              return if input/output not allowed
//      (xl)                  fcblk pointer (0 if none)
//      (wc)                  0 (for default) or max record lngth
//      (wa,wb)               destroyed
//      the second error return is used if the file named exists
//      but input/output from the file is not allowed. for
//      example, the standard output file may be in this category
//      as regards input association.
        //b ||ejc|||||2422
        
//      sysld -- load external function
//      sysld is called in response to the use of the snobol4
//      load function. the named function is loaded (whatever
//      this means), and a pointer is returned. the pointer will
//      be used on subsequent calls to the function (see sysex).
//      (xr)                  pointer to function name (scblk)
//      (xl)                  pointer to library name (scblk)
//      jsr  sysld            call to load function
//      ppm  loc              return here if func does not exist
//      ppm  loc              return here if i/o error
//      ppm  loc              return here if insufficient memory
//      (xr)                  pointer to loaded code
//      the significance of the pointer returned is up to the
//      system interface routine. the only restriction is that
//      if the pointer is within dynamic storage, it must be
//      a proper block pointer.
        //b ||ejc|||||2445
        
//      sysmm -- get more memory
//      sysmm is called in an attempt to allocate more dynamic
//      memory. this memory must be allocated contiguously with
//      the current dynamic data area.
//      the amount allocated is up to the system to decide. any
//      value is acceptable including zero if allocation is
//      impossible.
//      jsr  sysmm            call to get more memory
//      (xr)                  number of additional words obtained
        //b ||ejc|||||2461
        
//      sysmx -- supply mxlen
//      because of the method of garbage collection, no spitbol
//      object is allowed to occupy more bytes of memory than
//      the integer giving the lowest address of dynamic
//      (garbage collectable) memory. mxlen is the name used to
//      refer to this maximum length of an object and for most
//      users of most implementations, provided dynamic memory
//      starts at an address of at least a few thousand words,
//      there is no problem.
//      if the default starting address is less than say 10000 or
//      20000, then a load time option should be provided where a
//      user can request that he be able to create larger
//      objects. this routine informs spitbol of this request if
//      any. the value returned is either an integer
//      representing the desired value of mxlen (and hence the
//      minimum dynamic store address which may result in
//      non-use of some store) or zero if a default is acceptable
//      in which mxlen is set to the lowest address allocated
//      to dynamic store before compilation starts.
//      if a non-zero value is returned, this is used for keyword
//      maxlngth. otherwise the initial low address of dynamic
//      memory is used for this keyword.
//      jsr  sysmx            call to get mxlen
//      (wa)                  either mxlen or 0 for default
        //b ||ejc|||||2491
        
//      sysou -- output record
//      sysou is used to write a record to a file previously
//      associated with a sysio call.
//      (wa)                  ptr to fcblk
//                            or 0 for terminal or 1 for output
//      (xr)                  record to be written (scblk)
//      jsr  sysou            call to output record
//      ppm  loc              file full or no file after sysxi
//      ppm  loc              return here if i/o error
//      (wa,wb,wc)            destroyed
//      note that it is the sysou call (not the sysio call) which
//      causes the file to be opened as required for the first
//      record output to the file.
        //b ||ejc|||||2517
        
//      syspi -- print on interactive channel
//      if spitbol is run from an online terminal, osint can
//      request that messages such as copies of compilation
//      errors be sent to the terminal (see syspp). if relevant
//      reply was made by syspp then syspi is called to send such
//      messages to the interactive channel.
//      syspi is also used for sending output to the terminal
//      through the special variable name, terminal.
//      (xr)                  ptr to line buffer (scblk)
//      (wa)                  line length
//      jsr  syspi            call to print line
//      ppm  loc              failure return
//      (wa,wb)               destroyed
        //b ||ejc|||||2537
        
//      syspl -- provide interactive control of spitbol
//      provides means for interface to take special actions,
//      such as interrupting execution, breakpointing, stepping,
//      and expression evaluation.  these last three options are
//      not presently implemented by the code calling syspl.
//      (wa)                  opcode as follows-
//                            =0 poll to allow osint to interrupt
//                            =1 breakpoint hit
//                            =2 completion of statement stepping
//                            =3 expression evaluation result
//      (wb)                  statement number
//      r_fcb                 o or ptr to head of fcblk chain
//      jsr  syspl            call to syspl function
//      ppm  loc              user interruption
//      ppm  loc              step one statement
//      ppm  loc              evaluate expression
//      ---                   resume execution
//                            (wa) = new polling interval
        //b ||ejc|||||2564
        
//      syspp -- obtain print parameters
//      syspp is called once during compilation to obtain
//      parameters required for correct printed output format
//      and to select other options. it may also be called again
//      after sysxi when a load module is resumed. in this
//      case the value returned in wa may be less than or equal
//      to that returned in initial call but may not be
//      greater.
//      the information returned is -
//      1.   line length in chars for standard print file
//      2.   no of lines/page. 0 is preferable for a non-paged
//           device (e.g. online terminal) in which case listing
//           page throws are suppressed and page headers
//           resulting from -title,-stitl lines are kept short.
//      3.   an initial -nolist option to suppress listing unless
//           the program contains an explicit -list.
//      4.   options to suppress listing of compilation and/or
//           execution stats (useful for established programs) -
//           combined with 3. gives possibility of listing
//           file never being opened.
//      5.   option to have copies of errors sent to an
//           interactive channel in addition to standard printer.
//      6.   option to keep page headers short (e.g. if listing
//           to an online terminal).
//      7.   an option to choose extended or compact listing
//           format. in the former a page eject and in the latter
//           a few line feeds precede the printing of each
//           of-- listing, compilation statistics, execution
//           output and execution statistics.
//      8.   an option to suppress execution as though a
//           -noexecute card were supplied.
//      9.   an option to request that name /terminal/  be pre-
//           associated to an online terminal via syspi and sysri
//      10.  an intermediate (standard) listing option requiring
//           that page ejects occur in source listings. redundant
//           if extended option chosen but partially extends
//           compact option.
//      11.  option to suppress sysid identification.
//      jsr  syspp            call to get print parameters
//      (wa)                  print line length in chars
//      (wb)                  number of lines/page
//      (wc)                  bits value ...mlkjihgfedcba where
//                            a = 1 to send error copy to int.ch.
//                            b = 1 means std printer is int. ch.
//                            c = 1 for -nolist option
//                            d = 1 to suppress compiln. stats
//                            e = 1 to suppress execn. stats
//                            f = 1/0 for extnded/compact listing
//                            g = 1 for -noexecute
//                            h = 1 pre-associate /terminal/
//                            i = 1 for standard listing option.
//                            j = 1 suppresses listing header
//                            k = 1 for -print
//                            l = 1 for -noerrors
        //b ||ejc|||||2630
        
//      syspr -- print line on standard output file
//      syspr is used to print a single line on the standard
//      output file.
//      (xr)                  pointer to line buffer (scblk)
//      (wa)                  line length
//      jsr  syspr            call to print line
//      ppm  loc              too much o/p or no file after sysxi
//      (wa,wb)               destroyed
//      the buffer pointed to is the length obtained from the
//      syspp call and is filled out with trailing blanks. the
//      value in wa is the actual line length which may be less
//      than the maximum line length possible. there is no space
//      control associated with the line, all lines are printed
//      single spaced. note that null lines (wa=0) are possible
//      in which case a blank line is to be printed.
//      the error exit is used for systems which limit the amount
//      of printed output. if possible, printing should be
//      permitted after this condition has been signalled once to
//      allow for dump and other diagnostic information.
//      assuming this to be possible, spitbol may make more syspr
//      calls. if the error return occurs another time, execution
//      is terminated by a call of sysej with ending code 998.
        //b ||ejc|||||2660
        
//      sysrd -- read record from standard input file
//      sysrd is used to read a record from the standard input
//      file. the buffer provided is an scblk for a string the
//      length of which in characters is given in wc, this
//      corresponding to the maximum length of string which
//      spitbol is prepared to receive. at compile time it
//      corresponds to xxx in the most recent -inxxx card
//      (default 72) and at execution time to the most recent
//      ,r_r_ (record length) in the third arg of an input()
//      statement for the standard input file (default 80).
//      if fewer than (wc) characters are read, the length
//      field of the scblk must be adjusted before returning
//      unless the buffer is right padded with zeroes.
//      it is also permissible to take the alternative return
//      after such an adjustment has been made.
//      spitbol may continue to make calls after an endfile
//      return so this routine should be prepared to make
//      repeated endfile returns.
//      (xr)                  pointer to buffer (scblk ptr)
//      (wc)                  length of buffer in characters
//      jsr  sysrd            call to read line
//      ppm  loc              endfile or no i/p file after sysxi
//                            or input file name change.  if
//                            the former, scblk length is zero.
//                            if input file name change, length
//                            is non-zero. caller should re-issue
//                            sysrd to obtain input record.
//      (wa,wb,wc)            destroyed
        //b ||ejc|||||2696
        
//      sysri -- read record from interactive channel
//      reads a record from online terminal for spitbol variable,
//      terminal. if online terminal is unavailable then code the
//      endfile return only.
//      the buffer provided is of length 258 characters. sysri
//      should replace the count in the second word of the scblk
//      by the actual character count unless buffer is right
//      padded with zeroes.
//      it is also permissible to take the alternative
//      return after adjusting the count.
//      the end of file return may be used if this makes
//      sense on the target machine (e.g. if there is an
//      eof character.)
//      (xr)                  ptr to 258 char buffer (scblk ptr)
//      jsr  sysri            call to read line from terminal
//      ppm  loc              end of file return
//      (wa,wb,wc)            may be destroyed
        //b ||ejc|||||2719
        
//      sysrw -- rewind file
//      sysrw is used to rewind a file i.e. reposition the file
//      at the start before the first record. the file should be
//      closed and the next read or write call will open the
//      file at the start.
//      (wa)                  ptr to fcblk or zero
//      (xr)                  rewind arg (scblk ptr)
//      jsr  sysrw            call to rewind file
//      ppm  loc              return here if file does not exist
//      ppm  loc              return here if rewind not allowed
//      ppm  loc              return here if i/o error
        //b ||ejc|||||2736
        
//      systm -- get execution time so far
//      systm is used to obtain the amount of execution time
//      used so far since spitbol was given control. the units
//      are described as microseconds in the spitbol output, but
//      the exact meaning is system dependent. where appropriate,
//      this value should relate to processor rather than clock
//      timing values.
//      if the symbol .ctmd is defined, the units are described
//      as deciseconds (0.1 second).
//      jsr  systm            call to get timer value
//      (ia)                  time so far in micliseconds
//                            (deciseconds if .ctmd defined)
        //b ||ejc|||||2777
        
//      systt -- trace toggle
//      called by spitbol function trace() with no args to
//      toggle the system trace switch.  this permits tracing of
//      labels in spitbol code to be turned on or off.
//      jsr  systt            call to toggle trace switch
        //b ||ejc|||||2788
        
//      sysul -- unload external function
//      sysul is used to unload a function previously
//      loaded with a call to sysld.
//      (xr)                  ptr to control block (efblk)
//      jsr  sysul            call to unload function
//      the function cannot be called following a sysul call
//      until another sysld call is made for the same function.
//      the efblk contains the function code pointer and also a
//      pointer to the vrblk containing the function name (see
//      definitions and data structures section).
        //b ||ejc|||||2808
        
//      sysxi -- exit to produce load module
//      when sysxi is called, xl contains either a string pointer
//      or zero. in the former case, the string gives the
//      character name of a program. the intention is that
//      spitbol execution should be terminated forthwith and
//      the named program loaded and executed. this type of chain
//      execution is very system dependent and implementors may
//      choose to omit it or find it impossible to provide.
//      if (xl) is zero,ia contains one of the following integers
//      -1, -2, -3, -4
//           create if possible a load module containing only the
//           impure area of memory which needs to be loaded with
//           a compatible pure segment for subsequent executions.
//           version numbers to check compatibility should be
//           kept in both segments and checked on loading.
//           to assist with this check, (xr) on entry is a
//           pointer to an scblk containing the spitbol major
//           version number v.v (see sysid).  the file thus
//           created is called a save file.
//      0    if possible, return control to job control
//           command level. the effect if available will be
//           system dependent.
//      +1, +2, +3, +4
//           create if possible a load module from all of
//           memory. it should be possible to load and execute
//           this module directly.
//      in the case of saved load modules, the status of open
//      files is not preserved and implementors may choose to
//      offer means of attaching files before execution of load
//      modules starts or leave it to the user to include
//      suitable input(), output() calls in his program.
//      sysxi should make a note that no i/o channels,
//      including standard files, have files attached so that
//      calls of sysin, sysou, syspr, sysrd should fail unless
//      new associations are made for the load module.
//      at least in the case of the standard output file, it is
//      recommended that either the user be required to attach
//      a file or that a default file is attached, since the
//      problem of error messages generated by the load module
//      is otherwise severe. as a last resort, if spitbol
//      attempts to write to the standard output file and gets a
//      reply indicating that such ouput is unacceptable it stops
//      by using an entry to sysej with ending code 998.
//      as described below, passing of some arguments makes it
//      clear that load module will use a standard output file.
//      if use is made of fcblks for i/o association, spitbol
//      builds a chain so that those in use may be found in sysxi
//      and sysej. the nodes are 4 words long. third word
//      contains link to next node or 0, fourth word contains
//      fcblk pointer.
        //b ||ejc|||||2868
        
//      sysxi (continued)
//      (xl)                  zero or scblk ptr to first argument
//      (xr)                  ptr to v.v scblk
//      (ia)                  signed integer argument
//      (wa)                  scblk ptr to second argument
//      (wb)                  0 or ptr to head of fcblk chain
//      jsr  sysxi            call to exit
//      ppm  loc              requested action not possible
//      ppm  loc              action caused irrecoverable error
//      (wb,wc,ia,xr,xl,cp)   should be preserved over call
//      (wa)                  0 in all cases except sucessful
//                            performance of exit(4) or exit(-4),
//                            in which case 1 should be returned.
//      loading and running the load module or returning from
//      jcl command level causes execution to resume at the point
//      after the error returns which follow the call of sysxi.
//      the value passed as exit argument is used to indicate
//      options required on resumption of load module.
//      +1 or -1 require that on resumption, sysid and syspp be
//      called and a heading printed on the standard output file.
//      +2 or -2 indicate that syspp will be called but not sysid
//      and no heading will be put on standard output file.
//      above options have the obvious implication that a
//      standard o/p file must be provided for the load module.
//      +3, +4, -3 or -4 indicate calls of neither sysid nor
//      syspp and no heading will be placed on standard output
//      file.
//      +4 or -4 indicate that execution is to continue after
//      creation of the save file or load module, although all
//      files will be closed by the sysxi action.  this permits
//      the user to checkpoint long-running programs while
//      continuing execution.
//      no return from sysxi is possible if another program
//      is loaded and entered.
        //b ||ejc|||||2908
        
//      introduce the internal procedures.
        //b |acess|inp|25,r|1,1|||2912
        //b |acomp|inp|25,n|1,5|||2913
        //b |alloc|inp|25,e|1,0|||2914
        //b |alocs|inp|25,e|1,0|||2919
        //b |alost|inp|25,e|1,0|||2920
        //b |arith|inp|25,n|1,3|||2928
        //b |asign|inp|25,r|1,1|||2930
        //b |asinp|inp|25,r|1,1|||2931
        //b |blkln|inp|25,e|1,0|||2932
        //b |cdgcg|inp|25,e|1,0|||2933
        //b |cdgex|inp|25,r|1,0|||2934
        //b |cdgnm|inp|25,r|1,0|||2935
        //b |cdgvl|inp|25,r|1,0|||2936
        //b |cdwrd|inp|25,e|1,0|||2937
        //b |cmgen|inp|25,r|1,0|||2938
        //b |cmpil|inp|25,e|1,0|||2939
        //b |cncrd|inp|25,e|1,0|||2940
        //b |copyb|inp|25,n|1,1|||2941
        //b |dffnc|inp|25,e|1,0|||2942
        //b |dtach|inp|25,e|1,0|||2943
        //b |dtype|inp|25,e|1,0|||2944
        //b |dumpr|inp|25,e|1,0|||2945
        //b |ermsg|inp|25,e|1,0|||2950
        //b |ertex|inp|25,e|1,0|||2951
        //b |evali|inp|25,r|1,4|||2952
        //b |evalp|inp|25,r|1,1|||2953
        //b |evals|inp|25,r|1,3|||2954
        //b |evalx|inp|25,r|1,1|||2955
        //b |exbld|inp|25,e|1,0|||2956
        //b |expan|inp|25,e|1,0|||2957
        //b |expap|inp|25,e|1,1|||2958
        //b |expdm|inp|25,n|1,0|||2959
        //b |expop|inp|25,n|1,0|||2960
        //b |filnm|inp|25,e|1,0|||2962
        //b |gbcol|inp|25,e|1,0|||2967
        //b |gbcpf|inp|25,e|1,0|||2968
        //b |gtarr|inp|25,e|1,2|||2969
        //b ||ejc|||||2970
        
        //b |gtcod|inp|25,e|1,1|||2971
        //b |gtexp|inp|25,e|1,1|||2972
        //b |gtint|inp|25,e|1,1|||2973
        //b |gtnum|inp|25,e|1,1|||2974
        //b |gtnvr|inp|25,e|1,1|||2975
        //b |gtpat|inp|25,e|1,1|||2976
        //b |gtrea|inp|25,e|1,1|||2979
        //b |gtsmi|inp|25,n|1,2|||2981
        //b |gtstg|inp|25,n|1,1|||2986
        //b |gtvar|inp|25,e|1,1|||2987
        //b |hashs|inp|25,e|1,0|||2988
        //b |icbld|inp|25,e|1,0|||2989
        //b |ident|inp|25,e|1,1|||2990
        //b |inout|inp|25,e|1,0|||2991
        //b |insta|inp|25,e|1,0|||2996
        //b |iofcb|inp|25,n|1,3|||2997
        //b |ioppf|inp|25,n|1,0|||2998
        //b |ioput|inp|25,n|1,7|||2999
        //b |ktrex|inp|25,r|1,0|||3000
        //b |kwnam|inp|25,n|1,0|||3001
        //b |lcomp|inp|25,n|1,5|||3002
        //b |listr|inp|25,e|1,0|||3003
        //b |listt|inp|25,e|1,0|||3004
        //b |newfn|inp|25,e|1,0|||3006
        //b |nexts|inp|25,e|1,0|||3008
        //b |patin|inp|25,n|1,2|||3009
        //b |patst|inp|25,n|1,1|||3010
        //b |pbild|inp|25,e|1,0|||3011
        //b |pconc|inp|25,e|1,0|||3012
        //b |pcopy|inp|25,n|1,0|||3013
        //b |prflr|inp|25,e|1,0|||3016
        //b |prflu|inp|25,e|1,0|||3017
        //b |prpar|inp|25,e|1,0|||3019
        //b |prtch|inp|25,e|1,0|||3020
        //b |prtic|inp|25,e|1,0|||3021
        //b |prtis|inp|25,e|1,0|||3022
        //b |prtin|inp|25,e|1,0|||3023
        //b |prtmi|inp|25,e|1,0|||3024
        //b |prtmm|inp|25,e|1,0|||3025
        //b |prtmx|inp|25,e|1,0|||3026
        //b |prtnl|inp|25,r|1,0|||3027
        //b |prtnm|inp|25,r|1,0|||3028
        //b |prtnv|inp|25,e|1,0|||3029
        //b |prtpg|inp|25,e|1,0|||3030
        //b |prtps|inp|25,e|1,0|||3031
        //b |prtsn|inp|25,e|1,0|||3032
        //b |prtst|inp|25,r|1,0|||3033
        //b ||ejc|||||3034
        
//      introduce the internal routines
        //b ||ttl|27,s p i t b o l -- definitions and data structures||||3105
        /* s p i t b o l -- definitions and data structures*/
//      this section contains all symbol definitions and also
//      pictures of all data structures used in the system.
        //b ||sec||||start of definitions section|3109
        /*-------------------------------------------------------------------- sec02 --------*/
        // definitions
//      definitions of machine parameters
//      the minimal translator should supply appropriate values
//      for the particular target machine for all the
//      equ  *
//      definitions given at the start of this section.
//      note that even if conditional assembly is used to omit
//      some feature (e.g. real arithmetic) a full set of cfp_-
//      values must be supplied. use dummy values if genuine
//      ones are not needed.
//                            scblk. see scblk format.
//      the following definitions require the supply of either
//      a single parameter if real arithmetic is omitted or
//      three parameters if real arithmetic is included.
//      max space for real (for +0.e+) needs five more places
//      the following definition for cfp_u supplies a realistic
//      upper bound on the size of the alphabet.  cfp_u is used
//      to save space in the scane bsw-iff-esw table and to ease
//      translation storage requirements.
        //b ||ejc|||||3177
        
//      environment parameters
//      the spitbol program is essentially independent of
//      the definitions of these parameters. however, the
//      efficiency of the system may be affected. consequently,
//      these parameters may require tuning for a given version
//      the values given in comments have been successfully used.
//      e_srs is the number of words to reserve at the end of
//      storage for end of run processing. it should be
//      set as small as possible without causing memory overflow
//      in critical situations (e.g. memory overflow termination)
//      and should thus reserve sufficient space at least for
//      an scblk containing say 30 characters.
//      e_sts is the number of words grabbed in a chunk when
//      storage is allocated in the static region. the minimum
//      permitted value is 256/cfp_b. larger values will lead
//      to increased efficiency at the cost of wasting memory.
//      e_cbs is the size of code block allocated initially and
//      the expansion increment if overflow occurs. if this value
//      is too small or too large, excessive garbage collections
//      will occur during compilation and memory may be lost
//      in the case of a too large value.
//      e_hnb is the number of bucket headers in the variable
//      hash table. it should always be odd. larger values will
//      speed up compilation and indirect references at the
//      expense of additional storage for the hash table itself.
//      e_hnw is the maximum number of words of a string
//      name which participate in the string hash algorithm.
//      larger values give a better hash at the expense of taking
//      longer to compute the hash. there is some optimal value.
//      e_fsp.  if the amount of free space left after a garbage
//      collection is small compared to the total amount of space
//      in use garbage collector thrashing is likely to occur as
//      this space is used up.  e_fsp is a measure of the
//      minimum percentage of dynamic memory left as free space
//      before the system routine sysmm is called to try to
//      obtain more memory.
//      e_sed.  if the amount of free space left in the sediment
//      after a garbage collection is a significant fraction of
//      the new sediment size, the sediment is marked for
//      collection on the next call to the garbage collector.
        //b ||ejc|||||3243
        
//      definitions of codes for letters
//      definitions of codes for digits
        //b ||ejc|||||3286
        
//      definitions of codes for special characters
//      the names of these characters are related to their
//      original representation in the ebcdic set corresponding
//      to the description in standard snobol4 manuals and texts.
        //b ||ejc|||||3322
        
//      remaining chars are optional additions to the standards.
//      tab characters - syntactically equivalent to blank
//      upper case or shifted case alphabetic chars
//      if a delimiter other than ch_cm must be used in
//      the third argument of input(),output() then .ciod should
//      be defined and a parameter supplied for iodel.
        //b ||ejc|||||3380
        
//      data block formats and definitions
//      the following sections describe the detailed format of
//      all possible data blocks in static and dynamic memory.
//      every block has a name of the form xxblk where xx is a
//      unique two character identifier. the first word of every
//      block must contain a pointer to a program location in the
//      interpretor which is immediately preceded by an address
//      constant containing the value bl_xx where xx is the block
//      identifier. this provides a uniform mechanism for
//      distinguishing between the various block types.
//      in some cases, the contents of the first word is constant
//      for a given block type and merely serves as a pointer
//      to the identifying address constant. however, in other
//      cases there are several possibilities for the first
//      word in which case each of the several program entry
//      points must be preceded by the appropriate constant.
//      in each block, some of the fields are relocatable. this
//      means that they may contain a pointer to another block
//      in the dynamic area. (to be more precise, if they contain
//      a pointer within the dynamic area, then it is a pointer
//      to a block). such fields must be modified by the garbage
//      collector (procedure gbcol) whenever blocks are compacted
//      in the dynamic region. the garbage collector (actually
//      procedure gbcpf) requires that all such relocatable
//      fields in a block must be contiguous.
        //b ||ejc|||||3411
        
//      the description format uses the following scheme.
//      1)   block title and two character identifier
//      2)   description of basic use of block and indication
//           of circumstances under which it is constructed.
//      3)   picture of the block format. in these pictures low
//           memory addresses are at the top of the page. fixed
//           length fields are surrounded by i (letter i). fields
//           which are fixed length but whose length is dependent
//           on a configuration parameter are surrounded by *
//           (asterisk). variable length fields are surrounded
//           by / (slash).
//      4)   definition of symbolic offsets to fields in
//           block and of the size of the block if fixed length
//           or of the size of the fixed length fields if the
//           block is variable length.
//           note that some routines such as gbcpf assume
//           certain offsets are equal. the definitions
//           given here enforce this.  make changes to
//           them only with due care.
//      definitions of common offsets
//      5)   detailed comments on the significance and formats
//           of the various fields.
//      the order is alphabetical by identification code.
        //b ||ejc|||||3447
        
//      definitions of block codes
//      this table provides a unique identification code for
//      each separate block type. the first word of a block in
//      the dynamic area always contains the address of a program
//      entry point. the block code is used as the entry point id
//      the order of these codes dictates the order of the table
//      used by the datatype function (scnmt in the constant sec)
//      block codes for accessible datatypes
//      note that real and buffer types are always included, even
//      if they are conditionally excluded elsewhere.  this main-
//      tains block type codes across all versions of spitbol,
//      providing consistancy for external functions.  but note
//      that the bcblk is out of alphabetic order, placed at the
//      end of the list so as not to change the block type
//      ordering in use in existing external functions.
//      other block codes
        //b ||ejc|||||3506
        
//      field references
//      references to the fields of data blocks are symbolic
//      (i.e. use the symbolic offsets) with the following
//      exceptions.
//      1)   references to the first word are usually not
//           symbolic since they use the (x) operand format.
//      2)   the code which constructs a block is often not
//           symbolic and should be changed if the corresponding
//           block format is modified.
//      3)   the plc and psc instructions imply an offset
//           corresponding to the definition of cfp_f.
//      4)   there are non-symbolic references (easily changed)
//           in the garbage collector (procedures gbcpf, blkln).
//      5)   the fields idval, fargs appear in several blocks
//           and any changes must be made in parallel to all
//           blocks containing the fields. the actual references
//           to these fields are symbolic with the above
//           listed exceptions.
//      6)   several spots in the code assume that the
//           definitions of the fields vrval, teval, trnxt are
//           the same (these are sections of code which search
//           out along a trblk chain from a variable).
//      7)   references to the fields of an array block in the
//           array reference routine arref are non-symbolic.
//      apart from the exceptions listed, references are symbolic
//      as far as possible and modifying the order or number
//      of fields will not require changes.
        //b ||ejc|||||3544
        
//      common fields for function blocks
//      blocks which represent callable functions have two
//      common fields at the start of the block as follows.
//           +------------------------------------+
//           i                fcode               i
//           +------------------------------------+
//           i                fargs               i
//           +------------------------------------+
//           /                                    /
//           /       rest of function block       /
//           /                                    /
//           +------------------------------------+
//      fcode is a pointer to the location in the interpretor
//      program which processes this type of function call.
//      fargs is the expected number of arguments. the actual
//      number of arguments is adjusted to this amount by
//      deleting extra arguments or supplying trailing nulls
//      for missing ones before transferring though fcode.
//      a value of 999 may be used in this field to indicate a
//      variable number of arguments (see svblk field svnar).
//      the block types which follow this scheme are.
//      ffblk                 field function
//      dfblk                 datatype function
//      pfblk                 program defined function
//      efblk                 external loaded function
        //b ||ejc|||||3580
        
//      identification field
//      id   field
//      certain program accessible objects (those which contain
//      other data values and can be copied) are given a unique
//      identification number (see exsid). this id value is an
//      address integer value which is always stored in word two.
//      the blocks containing an idval field are.
//      arblk                 array
//      pdblk                 program defined datatype
//      tbblk                 table
//      vcblk                 vector block (array)
//      note that a zero idval means that the block is only
//      half built and should not be dumped (see dumpr).
        //b ||ejc|||||3607
        
//      array block (arblk)
//      an array block represents an array value other than one
//      with one dimension whose lower bound is one (see vcblk).
//      an arblk is built with a call to the functions convert
//      (s_cnv) or array (s_arr).
//           +------------------------------------+
//           i                artyp               i
//           +------------------------------------+
//           i                idval               i
//           +------------------------------------+
//           i                arlen               i
//           +------------------------------------+
//           i                arofs               i
//           +------------------------------------+
//           i                arndm               i
//           +------------------------------------+
//           *                arlbd               *
//           +------------------------------------+
//           *                ardim               *
//           +------------------------------------+
//           *                                    *
//           * above 2 flds repeated for each dim *
//           *                                    *
//           +------------------------------------+
//           i                arpro               i
//           +------------------------------------+
//           /                                    /
//           /                arvls               /
//           /                                    /
//           +------------------------------------+
        //b ||ejc|||||3641
        
//      array block (continued)
//      the bounds and dimension fields are signed integer
//      values and each occupy cfp_i words in the arblk.
//      the length of an arblk in bytes may not exceed mxlen.
//      this is required to keep name offsets garbage collectable
//      the actual values are arranged in row-wise order and
//      can contain a data pointer or a pointer to a trblk.
        //b ||ejc|||||3744
        
//      code construction block (ccblk)
//      at any one moment there is at most one ccblk into
//      which the compiler is currently storing code (cdwrd).
//           +------------------------------------+
//           i                cctyp               i
//           +------------------------------------+
//           i                cclen               i
//           +------------------------------------+
//           i                ccsln               i
//           +------------------------------------+
//           i                ccuse               i
//           +------------------------------------+
//           /                                    /
//           /                cccod               /
//           /                                    /
//           +------------------------------------+
//      the reason that the ccblk is a separate block type from
//      the usual cdblk is that the garbage collector must
//      only process those fields which have been set (see gbcpf)
        //b ||ejc|||||3780
        
//      code block (cdblk)
//      a code block is built for each statement compiled during
//      the initial compilation or by subsequent calls to code.
//           +------------------------------------+
//           i                cdjmp               i
//           +------------------------------------+
//           i                cdstm               i
//           +------------------------------------+
//           i                cdsln               i
//           +------------------------------------+
//           i                cdlen               i
//           +------------------------------------+
//           i                cdfal               i
//           +------------------------------------+
//           /                                    /
//           /                cdcod               /
//           /                                    /
//           +------------------------------------+
//      cdstm is the statement number of the current statement.
//      cdjmp, cdfal are set as follows.
//      1)   if the failure exit is the next statement
//           cdjmp = b_cds
//           cdfal = ptr to cdblk for next statement
//      2)   if the failure exit is a simple label name
//           cdjmp = b_cds
//           cdfal is a ptr to the vrtra field of the vrblk
//      3)   if there is no failure exit (-nofail mode)
//           cdjmp = b_cds
//           cdfal = o_unf
//      4)   if the failure exit is complex or direct
//           cdjmp = b_cdc
//           cdfal is the offset to the o_gof word
        //b ||ejc|||||3841
        
//      code block (continued)
//      cdcod is the start of the actual code. first we describe
//      the code generated for an expression. in an expression,
//      elements are fetched by name or by value. for example,
//      the binary equal operator fetches its left argument
//      by name and its right argument by value. these two
//      cases generate quite different code and are described
//      separately. first we consider the code by value case.
//      generation of code by value for expressions elements.
//      expression            pointer to exblk or seblk
//      integer constant      pointer to icblk
//      null constant         pointer to nulls
//      pattern               (resulting from preevaluation)
//                            =o_lpt
//                            pointer to p0blk,p1blk or p2blk
//      real constant         pointer to rcblk
//      string constant       pointer to scblk
//      variable              pointer to vrget field of vrblk
//      addition              value code for left operand
//                            value code for right operand
//                            =o_add
//      affirmation           value code for operand
//                            =o_aff
//      alternation           value code for left operand
//                            value code for right operand
//                            =o_alt
//      array reference       (case of one subscript)
//                            value code for array operand
//                            value code for subscript operand
//                            =o_aov
//                            (case of more than one subscript)
//                            value code for array operand
//                            value code for first subscript
//                            value code for second subscript
//                            ...
//                            value code for last subscript
//                            =o_amv
//                            number of subscripts
        //b ||ejc|||||3895
        
//      code block (continued)
//      assignment            (to natural variable)
//                            value code for right operand
//                            pointer to vrsto field of vrblk
//                            (to any other variable)
//                            name code for left operand
//                            value code for right operand
//                            =o_ass
//      compile error         =o_cer
//      complementation       value code for operand
//                            =o_com
//      concatenation         (case of pred func left operand)
//                            value code for left operand
//                            =o_pop
//                            value code for right operand
//                            (all other cases)
//                            value code for left operand
//                            value code for right operand
//                            =o_cnc
//      cursor assignment     name code for operand
//                            =o_cas
//      division              value code for left operand
//                            value code for right operand
//                            =o_dvd
//      exponentiation        value code for left operand
//                            value code for right operand
//                            =o_exp
//      function call         (case of call to system function)
//                            value code for first argument
//                            value code for second argument
//                            ...
//                            value code for last argument
//                            pointer to svfnc field of svblk
        //b ||ejc|||||3942
        
//      code block (continued)
//      function call         (case of non-system function 1 arg)
//                            value code for argument
//                            =o_fns
//                            pointer to vrblk for function
//                            (non-system function, gt 1 arg)
//                            value code for first argument
//                            value code for second argument
//                            ...
//                            value code for last argument
//                            =o_fnc
//                            number of arguments
//                            pointer to vrblk for function
//      immediate assignment  value code for left operand
//                            name code for right operand
//                            =o_ima
//      indirection           value code for operand
//                            =o_inv
//      interrogation         value code for operand
//                            =o_int
//      keyword reference     name code for operand
//                            =o_kwv
//      multiplication        value code for left operand
//                            value code for right operand
//                            =o_mlt
//      name reference        (natural variable case)
//                            pointer to nmblk for name
//                            (all other cases)
//                            name code for operand
//                            =o_nam
//      negation              =o_nta
//                            cdblk offset of o_ntc word
//                            value code for operand
//                            =o_ntb
//                            =o_ntc
        //b ||ejc|||||3989
        
//      code block (continued)
//      pattern assignment    value code for left operand
//                            name code for right operand
//                            =o_pas
//      pattern match         value code for left operand
//                            value code for right operand
//                            =o_pmv
//      pattern replacement   name code for subject
//                            value code for pattern
//                            =o_pmn
//                            value code for replacement
//                            =o_rpl
//      selection             (for first alternative)
//                            =o_sla
//                            cdblk offset to next o_slc word
//                            value code for first alternative
//                            =o_slb
//                            cdblk offset past alternatives
//                            (for subsequent alternatives)
//                            =o_slc
//                            cdblk offset to next o_slc,o_sld
//                            value code for alternative
//                            =o_slb
//                            offset in cdblk past alternatives
//                            (for last alternative)
//                            =o_sld
//                            value code for last alternative
//      subtraction           value code for left operand
//                            value code for right operand
//                            =o_sub
        //b ||ejc|||||4028
        
//      code block (continued)
//      generation of code by name for expression elements.
//      variable              =o_lvn
//                            pointer to vrblk
//      expression            (case of *natural variable)
//                            =o_lvn
//                            pointer to vrblk
//                            (all other cases)
//                            =o_lex
//                            pointer to exblk
//      array reference       (case of one subscript)
//                            value code for array operand
//                            value code for subscript operand
//                            =o_aon
//                            (case of more than one subscript)
//                            value code for array operand
//                            value code for first subscript
//                            value code for second subscript
//                            ...
//                            value code for last subscript
//                            =o_amn
//                            number of subscripts
//      compile error         =o_cer
//      function call         (same code as for value call)
//                            =o_fne
//      indirection           value code for operand
//                            =o_inn
//      keyword reference     name code for operand
//                            =o_kwn
//      any other operand is an error in a name position
//      note that in this description, =o_xxx refers to the
//      generation of a word containing the address of another
//      word which contains the entry point address o_xxx.
        //b ||ejc|||||4076
        
//      code block (continued)
//      now we consider the overall structure of the code block
//      for a statement with possible goto fields.
//      first comes the code for the statement body.
//      the statement body is an expression to be evaluated
//      by value although the value is not actually required.
//      normal value code is generated for the body of the
//      statement except in the case of a pattern match by
//      value, in which case the following is generated.
//                            value code for left operand
//                            value code for right operand
//                            =o_pms
//      next we have the code for the success goto. there are
//      several cases as follows.
//      1)   no success goto  ptr to cdblk for next statement
//      2)   simple label     ptr to vrtra field of vrblk
//      3)   complex goto     (code by name for goto operand)
//                            =o_goc
//      4)   direct goto      (code by value for goto operand)
//                            =o_god
//      following this we generate code for the failure goto if
//      it is direct or if it is complex, simple failure gotos
//      having been handled by an appropriate setting of the
//      cdfal field of the cdblk. the generated code is one
//      of the following.
//      1)   complex fgoto    =o_fif
//                            =o_gof
//                            name code for goto operand
//                            =o_goc
//      2)   direct fgoto     =o_fif
//                            =o_gof
//                            value code for goto operand
//                            =o_god
//      an optimization occurs if the success and failure gotos
//      are identical and either complex or direct. in this case,
//      no code is generated for the success goto and control
//      is allowed to fall into the failure goto on success.
        //b ||ejc|||||4127
        
//      compiler block (cmblk)
//      a compiler block (cmblk) is built by expan to represent
//      one node of a tree structured expression representation.
//           +------------------------------------+
//           i                cmidn               i
//           +------------------------------------+
//           i                cmlen               i
//           +------------------------------------+
//           i                cmtyp               i
//           +------------------------------------+
//           i                cmopn               i
//           +------------------------------------+
//           /           cmvls or cmrop           /
//           /                                    /
//           /                cmlop               /
//           /                                    /
//           +------------------------------------+
//      the cmopn and cmvls fields are set as follows
//      array reference       cmopn = ptr to array operand
//                            cmvls = ptrs to subscript operands
//      function call         cmopn = ptr to vrblk for function
//                            cmvls = ptrs to argument operands
//      selection             cmopn = zero
//                            cmvls = ptrs to alternate operands
//      unary operator        cmopn = ptr to operator dvblk
//                            cmrop = ptr to operand
//      binary operator       cmopn = ptr to operator dvblk
//                            cmrop = ptr to right operand
//                            cmlop = ptr to left operand
        //b ||ejc|||||4178
        
//      cmtyp is set to indicate the type of expression element
//      as shown by the following table of definitions.
//      the remaining types indicate expression elements which
//      can only be evaluated by value (not by name).
        //b ||ejc|||||4211
        
//      character table block (ctblk)
//      a character table block is used to hold logical character
//      tables for use with any,notany,span,break,breakx
//      patterns. each character table can be used to store
//      cfp_n distinct tables as bit columns. a bit column
//      allocated for each argument of more than one character
//      in length to one of the above listed pattern primitives.
//           +------------------------------------+
//           i                cttyp               i
//           +------------------------------------+
//           *                                    *
//           *                                    *
//           *                ctchs               *
//           *                                    *
//           *                                    *
//           +------------------------------------+
//      ctchs is cfp_a words long and consists of a one word
//      bit string value for each possible character in the
//      internal alphabet. each of the cfp_n possible bits in
//      a bitstring is used to form a column of bit indicators.
//      a bit is set on if the character is in the table and off
//      if the character is not present.
        //b ||ejc|||||4242
        
//      datatype function block (dfblk)
//      a datatype function is used to control the construction
//      of a program defined datatype object. a call to the
//      system function data builds a dfblk for the datatype name
//      note that these blocks are built in static because pdblk
//      length is got from dflen field.  if dfblk was in dynamic
//      store this would cause trouble during pass two of garbage
//      collection.  scblk referred to by dfnam field is also put
//      in static so that there are no reloc. fields. this cuts
//      garbage collection task appreciably for pdblks which are
//      likely to be present in large numbers.
//           +------------------------------------+
//           i                fcode               i
//           +------------------------------------+
//           i                fargs               i
//           +------------------------------------+
//           i                dflen               i
//           +------------------------------------+
//           i                dfpdl               i
//           +------------------------------------+
//           i                dfnam               i
//           +------------------------------------+
//           /                                    /
//           /                dffld               /
//           /                                    /
//           +------------------------------------+
//      the fcode field points to the routine b_dfc
//      fargs (the number of arguments) is the number of fields.
        //b ||ejc|||||4284
        
//      dope vector block (dvblk)
//      a dope vector is assembled for each possible operator in
//      the snobol4 language as part of the constant section.
//           +------------------------------------+
//           i                dvopn               i
//           +------------------------------------+
//           i                dvtyp               i
//           +------------------------------------+
//           i                dvlpr               i
//           +------------------------------------+
//           i                dvrpr               i
//           +------------------------------------+
//      the contents of the dvtyp field is copied into the cmtyp
//      field of the cmblk for the operator if it is used.
//      the cmopn field of an operator cmblk points to the dvblk
//      itself, providing the required entry address pointer ptr.
//      for normally undefined operators, the dvopn (and cmopn)
//      fields contain a word offset from r_uba of the function
//      block pointer for the operator (instead of o_xxx ptr).
//      for certain special operators, the dvopn field is not
//      required at all and is assembled as zero.
//      the left precedence is used in comparing an operator to
//      the left of some other operator. it therefore governs the
//      precedence of the operator towards its right operand.
//      the right precedence is used in comparing an operator to
//      the right of some other operator. it therefore governs
//      the precedence of the operator towards its left operand.
//      higher precedence values correspond to a tighter binding
//      capability. thus we have the left precedence lower
//      (higher) than the right precedence for right (left)
//      associative binary operators.
//      the left precedence of unary operators is set to an
//      arbitrary high value. the right value is not required and
//      consequently the dvrpr field is omitted for unary ops.
        //b ||ejc|||||4337
        
//      table of operator precedence values
//      precedences are the same as in btl snobol4 with the
//      following exceptions.
//      1)   binary question mark is lowered and made left assoc-
//           iative to reflect its new use for pattern matching.
//      2)   alternation and concatenation are made right
//           associative for greater efficiency in pattern
//           construction and matching respectively. this change
//           is transparent to the snobol4 programmer.
//      3)   the equal sign has been added as a low precedence
//           operator which is right associative to reflect its
//           more general usage in this version of snobol4.
        //b ||ejc|||||4385
        
//      external function block (efblk)
//      an external function block is used to control the calling
//      of an external function. it is built by a call to load.
//           +------------------------------------+
//           i                fcode               i
//           +------------------------------------+
//           i                fargs               i
//           +------------------------------------+
//           i                eflen               i
//           +------------------------------------+
//           i                efuse               i
//           +------------------------------------+
//           i                efcod               i
//           +------------------------------------+
//           i                efvar               i
//           +------------------------------------+
//           i                efrsl               i
//           +------------------------------------+
//           /                                    /
//           /                eftar               /
//           /                                    /
//           +------------------------------------+
//      the fcode field points to the routine b_efc.
//      efuse is used to keep track of multiple use when opsyn
//      is employed. the function is automatically unloaded
//      when there are no more references to the function.
//      efrsl and eftar are type codes as follows.
//           0                type is unconverted
//           1                type is string
//           2                type is integer
//           3                type is real
//           4                type is file
        //b ||ejc|||||4441
        
//      expression variable block (evblk)
//      in this version of spitbol, an expression can be used in
//      any position which would normally expect a name (for
//      example on the left side of equals or as the right
//      argument of binary dot). this corresponds to the creation
//      of a pseudo-variable which is represented by a pointer to
//      an expression variable block as follows.
//           +------------------------------------+
//           i                evtyp               i
//           +------------------------------------+
//           i                evexp               i
//           +------------------------------------+
//           i                evvar               i
//           +------------------------------------+
//      the name of an expression variable is represented by a
//      base pointer to the evblk and an offset of evvar. this
//      value appears to be trapped by the dummy trbev block.
//      note that there is no need to allow for the case of an
//      expression variable which references an seblk since a
//      variable which is of the form *var is equivalent to var.
        //b ||ejc|||||4472
        
//      expression block (exblk)
//      an expression block is built for each expression
//      referenced in a program or created by eval or convert
//      during execution of a program.
//           +------------------------------------+
//           i                extyp               i
//           +------------------------------------+
//           i                exstm               i
//           +------------------------------------+
//           i                exsln               i
//           +------------------------------------+
//           i                exlen               i
//           +------------------------------------+
//           i                exflc               i
//           +------------------------------------+
//           /                                    /
//           /                excod               /
//           /                                    /
//           +------------------------------------+
//      there are two cases for excod depending on whether the
//      expression can be evaluated by name (see description
//      of cdblk for details of code for expressions).
//      if the expression can be evaluated by name we have.
//                            (code for expr by name)
//                            =o_rnm
//      if the expression can only be evaluated by value.
//                            (code for expr by value)
//                            =o_rvl
        //b ||ejc|||||4523
        
//      field function block (ffblk)
//      a field function block is used to control the selection
//      of a field from a program defined datatype block.
//      a call to data creates an ffblk for each field.
//           +------------------------------------+
//           i                fcode               i
//           +------------------------------------+
//           i                fargs               i
//           +------------------------------------+
//           i                ffdfp               i
//           +------------------------------------+
//           i                ffnxt               i
//           +------------------------------------+
//           i                ffofs               i
//           +------------------------------------+
//      the fcode field points to the routine b_ffc.
//      fargs always contains one.
//      ffdfp is used to verify that the correct program defined
//      datatype is being accessed by this call.
//      ffdfp is non-reloc. because dfblk is in static
//      ffofs is used to select the appropriate field. note that
//      it is an actual offset (not a field number)
//      ffnxt is used to point to the next ffblk of the same name
//      in the case where there are several fields of the same
//      name for different datatypes. zero marks the end of chain
        //b ||ejc|||||4562
        
//      integer constant block (icblk)
//      an icblk is created for every integer referenced or
//      created by a program. note however that certain internal
//      integer values are stored as addresses (e.g. the length
//      field in a string constant block)
//           +------------------------------------+
//           i                icget               i
//           +------------------------------------+
//           *                icval               *
//           +------------------------------------+
//      the length of the icval field is cfp_i.
        //b ||ejc|||||4582
        
//      keyword variable block (kvblk)
//      a kvblk is used to represent a keyword pseudo-variable.
//      a kvblk is built for each keyword reference (kwnam).
//           +------------------------------------+
//           i                kvtyp               i
//           +------------------------------------+
//           i                kvvar               i
//           +------------------------------------+
//           i                kvnum               i
//           +------------------------------------+
//      the name of a keyword variable is represented by a
//      base pointer to the kvblk and an offset of kvvar. the
//      value appears to be trapped by the pointer to trbkv.
        //b ||ejc|||||4605
        
//      name block (nmblk)
//      a name block is used wherever a name must be stored as
//      a value following use of the unary dot operator.
//           +------------------------------------+
//           i                nmtyp               i
//           +------------------------------------+
//           i                nmbas               i
//           +------------------------------------+
//           i                nmofs               i
//           +------------------------------------+
//      the actual field representing the contents of the name
//      is found nmofs bytes past the address in nmbas.
//      the name is split into base and offset form to avoid
//      creation of a pointer into the middle of a block which
//      could not be handled properly by the garbage collector.
//      a name may be built for any variable (see section on
//      representations of variables) this includes the
//      cases of pseudo-variables.
        //b ||ejc|||||4635
        
//      pattern block, no parameters (p0blk)
//      a p0blk is used to represent pattern nodes which do
//      not require the use of any parameter values.
//           +------------------------------------+
//           i                pcode               i
//           +------------------------------------+
//           i                pthen               i
//           +------------------------------------+
//      pthen points to the pattern block for the subsequent
//      node to be matched. this is a pointer to the pattern
//      block ndnth if there is no subsequent (end of pattern)
//      pcode is a pointer to the match routine for the node.
        //b ||ejc|||||4657
        
//      pattern block (one parameter)
//      a p1blk is used to represent pattern nodes which
//      require one parameter value.
//           +------------------------------------+
//           i                pcode               i
//           +------------------------------------+
//           i                pthen               i
//           +------------------------------------+
//           i                parm1               i
//           +------------------------------------+
//      see p0blk for definitions of pcode, pthen
//      parm1 contains a parameter value used in matching the
//      node. for example, in a len pattern, it is the integer
//      argument to len. the details of the use of the parameter
//      field are included in the description of the individual
//      match routines. parm1 is always an address pointer which
//      is processed by the garbage collector.
        //b ||ejc|||||4683
        
//      pattern block (two parameters)
//      a p2blk is used to represent pattern nodes which
//      require two parameter values.
//           +------------------------------------+
//           i                pcode               i
//           +------------------------------------+
//           i                pthen               i
//           +------------------------------------+
//           i                parm1               i
//           +------------------------------------+
//           i                parm2               i
//           +------------------------------------+
//      see p1blk for definitions of pcode, pthen, parm1
//      parm2 is a parameter which performs the same sort of
//      function as parm1 (see description of p1blk).
//      parm2 is a non-relocatable field and is not
//      processed by the garbage collector. accordingly, it may
//      not contain a pointer to a block in dynamic memory.
        //b ||ejc|||||4711
        
//      program-defined datatype block
//      a pdblk represents the data item formed by a call to a
//      datatype function as defined by the system function data.
//           +------------------------------------+
//           i                pdtyp               i
//           +------------------------------------+
//           i                idval               i
//           +------------------------------------+
//           i                pddfp               i
//           +------------------------------------+
//           /                                    /
//           /                pdfld               /
//           /                                    /
//           +------------------------------------+
//      the pddfp pointer may be used to determine the datatype
//      and the names of the fields if required. the dfblk also
//      contains the length of the pdblk in bytes (field dfpdl).
//      pddfp is non-reloc. because dfblk is in static
//      pdfld values are stored in order from left to right.
//      they contain values or pointers to trblk chains.
        //b ||ejc|||||4744
        
//      program defined function block (pfblk)
//      a pfblk is created for each call to the define function
//      and a pointer to the pfblk placed in the proper vrblk.
//           +------------------------------------+
//           i                fcode               i
//           +------------------------------------+
//           i                fargs               i
//           +------------------------------------+
//           i                pflen               i
//           +------------------------------------+
//           i                pfvbl               i
//           +------------------------------------+
//           i                pfnlo               i
//           +------------------------------------+
//           i                pfcod               i
//           +------------------------------------+
//           i                pfctr               i
//           +------------------------------------+
//           i                pfrtr               i
//           +------------------------------------+
//           /                                    /
//           /                pfarg               /
//           /                                    /
//           +------------------------------------+
//      the fcode field points to the routine b_pfc.
//      pfarg is stored in the following order.
//           arguments (left to right)
//           locals (left to right)
        //b ||ejc|||||4791
        
//      real constant block (rcblk)
//      an rcblk is created for every real referenced or
//      created by a program.
//           +------------------------------------+
//           i                rcget               i
//           +------------------------------------+
//           *                rcval               *
//           +------------------------------------+
//      the length of the rcval field is cfp_r.
        //b ||ejc|||||4810
        
//      string constant block (scblk)
//      an scblk is built for every string referenced or created
//      by a program.
//           +------------------------------------+
//           i                scget               i
//           +------------------------------------+
//           i                sclen               i
//           +------------------------------------+
//           /                                    /
//           /                schar               /
//           /                                    /
//           +------------------------------------+
//      the characters of the string are stored left justified.
//      the final word is padded on the right with zeros.
//      (i.e. the character whose internal code is zero).
//      the value of sclen may not exceed mxlen. this ensures
//      that character offsets (e.g. the pattern match cursor)
//      can be correctly processed by the garbage collector.
//      note that the offset to the characters of the string
//      is given in bytes by cfp_f and that this value is
//      automatically allowed for in plc, psc.
//      note that for a spitbol scblk, the value of cfp_f
//      is given by cfp_b*schar.
        //b ||ejc|||||4845
        
//      simple expression block (seblk)
//      an seblk is used to represent an expression of the form
//      *(natural variable). all other expressions are exblks.
//           +------------------------------------+
//           i                setyp               i
//           +------------------------------------+
//           i                sevar               i
//           +------------------------------------+
        //b ||ejc|||||4861
        
//      standard variable block (svblk)
//      an svblk is assembled in the constant section for each
//      variable which satisfies one of the following conditions.
//      1)   it is the name of a system function
//      2)   it has an initial value
//      3)   it has a keyword association
//      4)   it has a standard i/o association
//      6)   it has a standard label association
//      if vrblks are constructed for any of these variables,
//      then the vrsvp field points to the svblk (see vrblk)
//           +------------------------------------+
//           i                svbit               i
//           +------------------------------------+
//           i                svlen               i
//           +------------------------------------+
//           /                svchs               /
//           +------------------------------------+
//           i                svknm               i
//           +------------------------------------+
//           i                svfnc               i
//           +------------------------------------+
//           i                svnar               i
//           +------------------------------------+
//           i                svlbl               i
//           +------------------------------------+
//           i                svval               i
//           +------------------------------------+
        //b ||ejc|||||4894
        
//      standard variable block (continued)
//      note that the last five bits correspond in order
//      to the fields which are present (see procedure gtnvr).
//      the following definitions are used in the svblk table
//      the svpre bit allows the compiler to preevaluate a call
//      to the associated system function if all the arguments
//      are themselves constants. functions in this category
//      must have no side effects and must never cause failure.
//      the call may generate an error condition.
//      the svffc bit allows the compiler to generate the special
//      fast call after adjusting the number of arguments. only
//      the item and apply functions fall outside this category.
//      the svckw bit is set if the associated keyword value is
//      a constant, thus allowing preevaluation for a value call.
//      the svprd bit is set on for all predicate functions to
//      enable the special concatenation code optimization.
        //b ||ejc|||||4944
        
//      svblk (continued)
//      svknm                 keyword number
//           svknm is present only for a standard keyword assoc.
//           it contains a keyword number as defined by the
//           keyword number table given later on.
//      svfnc                 system function pointer
//           svfnc is present only for a system function assoc.
//           it is a pointer to the actual code for the system
//           function. the generated code for a fast call is a
//           pointer to the svfnc field of the svblk for the
//           function. the vrfnc field of the vrblk points to
//           this same field, in which case, it serves as the
//           fcode field for the function call.
//      svnar                 number of function arguments
//           svnar is present only for a system function assoc.
//           it is the number of arguments required for a call
//           to the system function. the compiler uses this
//           value to adjust the number of arguments in a fast
//           call and in the case of a function called through
//           the vrfnc field of the vrblk, the svnar field
//           serves as the fargs field for o_fnc. a special
//           case occurs if this value is set to 999. this is
//           used to indicate that the function has a variable
//           number of arguments and causes o_fnc to pass control
//           without adjusting the argument count. the only
//           predefined functions using this are apply and item.
//      svlbl                 system label pointer
//           svlbl is present only for a standard label assoc.
//           it is a pointer to a system label routine (l_xxx).
//           the vrlbl field of the corresponding vrblk points to
//           the svlbl field of the svblk.
//      svval                 system value pointer
//           svval is present only for a standard value.
//           it is a pointer to the pattern node (ndxxx) which
//           is the standard initial value of the variable.
//           this value is copied to the vrval field of the vrblk
        //b ||ejc|||||4992
        
//      svblk (continued)
//      keyword number table
//      the following table gives symbolic names for keyword
//      numbers. these values are stored in the svknm field of
//      svblks and in the kvnum field of kvblks. see also
//      procedures asign, acess and kwnam.
//      unprotected keywords with one word integer values
//      protected keywords with one word integer values
//      keywords with constant pattern values
        //b ||ejc|||||5055
        
//      keyword number table (continued)
//      special keywords
//      relative offsets of special keywords
//      symbols used in asign and acess procedures
        //b ||ejc|||||5101
        
//      format of a table block (tbblk)
//      a table block is used to represent a table value.
//      it is built by a call to the table or convert functions.
//           +------------------------------------+
//           i                tbtyp               i
//           +------------------------------------+
//           i                idval               i
//           +------------------------------------+
//           i                tblen               i
//           +------------------------------------+
//           i                tbinv               i
//           +------------------------------------+
//           /                                    /
//           /                tbbuk               /
//           /                                    /
//           +------------------------------------+
//      the table block is a hash table which points to chains
//      of table element blocks representing the elements
//      in the table which hash into the same bucket.
//      tbbuk entries either point to the first teblk on the
//      chain or they point to the tbblk itself to indicate the
//      end of the chain.
        //b ||ejc|||||5136
        
//      table element block (teblk)
//      a table element is used to represent a single entry in
//      a table (see description of tbblk format for hash table)
//           +------------------------------------+
//           i                tetyp               i
//           +------------------------------------+
//           i                tesub               i
//           +------------------------------------+
//           i                teval               i
//           +------------------------------------+
//           i                tenxt               i
//           +------------------------------------+
//      see s_cnv where relation is assumed with tenxt and tbbuk
//      tenxt points to the next teblk on the hash chain from the
//      tbbuk chain for this hash index. at the end of the chain,
//      tenxt points back to the start of the tbblk.
//      teval contains a data pointer or a trblk pointer.
//      tesub contains a data pointer.
        //b ||ejc|||||5167
        
//      trap block (trblk)
//      a trap block is used to represent a trace or input or
//      output association in response to a call to the trace
//      input or output system functions. see below for details
//           +------------------------------------+
//           i                tridn               i
//           +------------------------------------+
//           i                trtyp               i
//           +------------------------------------+
//           i  trval or trlbl or trnxt or trkvr  i
//           +------------------------------------+
//           i       trtag or trter or trtrf      i
//           +------------------------------------+
//           i            trfnc or trfpt          i
//           +------------------------------------+
        //b ||ejc|||||5205
        
//      trap block (continued)
//      variable input association
//           the value field of the variable points to a trblk
//           instead of containing the data value. in the case
//           of a natural variable, the vrget and vrsto fields
//           contain =b_vra and =b_vrv to activate the check.
//           trtyp is set to trtin
//           trnxt points to next trblk or trval has variable val
//           trter is a pointer to svblk if association is
//           for input, terminal, else it is null.
//           trtrf points to the trap block which in turn points
//           to an fcblk used for i/o association.
//           trfpt is the fcblk ptr returned by sysio.
//      variable access trace association
//           the value field of the variable points to a trblk
//           instead of containing the data value. in the case
//           of a natural variable, the vrget and vrsto fields
//           contain =b_vra and =b_vrv to activate the check.
//           trtyp is set to trtac
//           trnxt points to next trblk or trval has variable val
//           trtag is the trace tag (0 if none)
//           trfnc is the trace function vrblk ptr (0 if none)
//      variable value trace association
//           the value field of the variable points to a trblk
//           instead of containing the data value. in the case
//           of a natural variable, the vrget and vrsto fields
//           contain =b_vra and =b_vrv to activate the check.
//           trtyp is set to trtvl
//           trnxt points to next trblk or trval has variable val
//           trtag is the trace tag (0 if none)
//           trfnc is the trace function vrblk ptr (0 if none)
        //b ||ejc|||||5247
        
//      trap block (continued)
//      variable output association
//           the value field of the variable points to a trblk
//           instead of containing the data value. in the case
//           of a natural variable, the vrget and vrsto fields
//           contain =b_vra and =b_vrv to activate the check.
//           trtyp is set to trtou
//           trnxt points to next trblk or trval has variable val
//           trter is a pointer to svblk if association is
//           for output, terminal, else it is null.
//           trtrf points to the trap block which in turn points
//           to an fcblk used for i/o association.
//           trfpt is the fcblk ptr returned by sysio.
//      function call trace
//           the pfctr field of the corresponding pfblk is set
//           to point to a trblk.
//           trtyp is set to trtin
//           trnxt is zero
//           trtag is the trace tag (0 if none)
//           trfnc is the trace function vrblk ptr (0 if none)
//      function return trace
//           the pfrtr field of the corresponding pfblk is set
//           to point to a trblk
//           trtyp is set to trtin
//           trnxt is zero
//           trtag is the trace tag (0 if none)
//           trfnc is the trace function vrblk ptr (0 if none)
//      label trace
//           the vrlbl of the vrblk for the label is
//           changed to point to a trblk and the vrtra field is
//           set to b_vrt to activate the check.
//           trtyp is set to trtin
//           trlbl points to the actual label (cdblk) value
//           trtag is the trace tag (0 if none)
//           trfnc is the trace function vrblk ptr (0 if none)
        //b ||ejc|||||5295
        
//      trap block (continued)
//      keyword trace
//           keywords which can be traced possess a unique
//           location which is zero if there is no trace and
//           points to a trblk if there is a trace. the locations
//           are as follows.
//           r_ert            errtype
//           r_fnc            fnclevel
//           r_stc            stcount
//           the format of the trblk is as follows.
//           trtyp is set to trtin
//           trkvr is a pointer to the vrblk for the keyword
//           trtag is the trace tag (0 if none)
//           trfnc is the trace function vrblk ptr (0 if none)
//      input/output file arg1 trap block
//           the value field of the variable points to a trblk
//           instead of containing the data value. in the case of
//           a natural variable, the vrget and vrsto fields
//           contain =b_vra and =b_vrv. this trap block is used
//           to hold a pointer to the fcblk which an
//           implementation may request to hold information
//           about a file.
//           trtyp is set to trtfc
//           trnext points to next trblk or trval is variable val
//           trfnm is 0
//           trfpt is the fcblk pointer.
//      note that when multiple traps are set on a variable
//      the order is in ascending value of trtyp field.
//      input association (if present)
//      access trace (if present)
//      value trace (if present)
//      output association (if present)
//      the actual value of the variable is stored in the trval
//      field of the last trblk on the chain.
//      this implementation does not permit trace or i/o
//      associations to any of the pseudo-variables.
        //b ||ejc|||||5345
        
//      vector block (vcblk)
//      a vcblk is used to represent an array value which has
//      one dimension whose lower bound is one. all other arrays
//      are represented by arblks. a vcblk is created by the
//      system function array (s_arr) when passed an integer arg.
//           +------------------------------------+
//           i                vctyp               i
//           +------------------------------------+
//           i                idval               i
//           +------------------------------------+
//           i                vclen               i
//           +------------------------------------+
//           i                vcvls               i
//           +------------------------------------+
//      vcvls are either data pointers or trblk pointers
//      the dimension can be deduced from vclen.
        //b ||ejc|||||5374
        
//      variable block (vrblk)
//      a variable block is built in the static memory area
//      for every variable referenced or created by a program.
//      the order of fields is assumed in the model vrblk stnvr.
//      note that since these blocks only occur in the static
//      region, it is permissible to point to any word in
//      the block and this is used to provide three distinct
//      access points from the generated code as follows.
//      1)   point to vrget (first word of vrblk) to load the
//           value of the variable onto the main stack.
//      2)   point to vrsto (second word of vrblk) to store the
//           top stack element as the value of the variable.
//      3)   point to vrtra (fourth word of vrblk) to jump to
//           the label associated with the variable name.
//           +------------------------------------+
//           i                vrget               i
//           +------------------------------------+
//           i                vrsto               i
//           +------------------------------------+
//           i                vrval               i
//           +------------------------------------+
//           i                vrtra               i
//           +------------------------------------+
//           i                vrlbl               i
//           +------------------------------------+
//           i                vrfnc               i
//           +------------------------------------+
//           i                vrnxt               i
//           +------------------------------------+
//           i                vrlen               i
//           +------------------------------------+
//           /                                    /
//           /            vrchs = vrsvp           /
//           /                                    /
//           +------------------------------------+
        //b ||ejc|||||5417
        
//      variable block (continued)
//      vrget = b_vrl if not input associated or access traced
//      vrget = b_vra if input associated or access traced
//      vrsto = b_vrs if not output associated or value traced
//      vrsto = b_vrv if output associated or value traced
//      vrsto = b_vre if value is protected pattern value
//      vrval points to the appropriate value unless the
//      variable is i/o/trace associated in which case, vrval
//      points to an appropriate trblk (trap block) chain.
//      vrtra = b_vrg if the label is not traced
//      vrtra = b_vrt if the label is traced
//      vrlbl points to a cdblk if there is a label
//      vrlbl points to the svblk svlbl field for a system label
//      vrlbl points to stndl for an undefined label
//      vrlbl points to a trblk if the label is traced
//      vrfnc points to a ffblk for a field function
//      vrfnc points to a dfblk for a datatype function
//      vrfnc points to a pfblk for a program defined function
//      vrfnc points to a efblk for an external loaded function
//      vrfnc points to svfnc (svblk) for a system function
//      vrfnc points to stndf if the function is undefined
//      vrnxt points to the next vrblk on this chain unless
//      this is the end of the chain in which case it is zero.
//      vrlen is the name length for a non-system variable.
//      vrlen is zero for a system variable.
//      vrchs is the name (ljrz) if vrlen is non-zero.
//      vrsvp is a ptr to the svblk if vrlen is zero.
        //b ||ejc|||||5471
        
//      format of a non-relocatable external block (xnblk)
//      an xnblk is a block representing an unknown (external)
//      data value. the block contains no pointers to other
//      relocatable blocks. an xnblk is used by external function
//      processing or possibly for system i/o routines etc.
//      the macro-system itself does not use xnblks.
//      this type of block may be used as a file control block.
//      see sysfc,sysin,sysou,s_inp,s_oup for details.
//           +------------------------------------+
//           i                xntyp               i
//           +------------------------------------+
//           i                xnlen               i
//           +------------------------------------+
//           /                                    /
//           /                xndta               /
//           /                                    /
//           +------------------------------------+
//      note that the term non-relocatable refers to the contents
//      and not the block itself. an xnblk can be moved around if
//      it is built in the dynamic memory area.
        //b ||ejc|||||5501
        
//      relocatable external block (xrblk)
//      an xrblk is a block representing an unknown (external)
//      data value. the data area in this block consists only
//      of address values and any addresses pointing into the
//      dynamic memory area must point to the start of other
//      data blocks. see also description of xnblk.
//      this type of block may be used as a file control block.
//      see sysfc,sysin,sysou,s_inp,s_oup for details.
//           +------------------------------------+
//           i                xrtyp               i
//           +------------------------------------+
//           i                xrlen               i
//           +------------------------------------+
//           /                                    /
//           /                xrptr               /
//           /                                    /
//           +------------------------------------+
        //b ||ejc|||||5527
        
//      s_cnv (convert) function switch constants.  the values
//      are tied to the order of the entries in the svctb table
//      and hence to the branch table in s_cnv.
//      input image length
//      minimum value for keyword maxlngth
//      should be larger than iniln
//      in general, meaningful mnemonics should be used for
//      offsets. however for small integers used often in
//      literals the following general definitions are provided.
        //b ||ejc|||||5580
        
//      numbers of undefined spitbol operators
//      offsets used in prtsn, prtmi and acess
//      codes for stages of processing
        //b ||ejc|||||5604
        
//      statement number pad count for listr
//      syntax type codes
//      these codes are returned from the scane procedure.
//      they are spaced 3 apart for the benefit of expan.
//      the following definitions are used only in the goto field
//      the above codes are grouped so that codes for elements
//      which can legitimately immediately precede a unary
//      operator come first to facilitate operator syntax check.
        //b ||ejc|||||5640
        
//      definitions of values for expan jump table
        //b ||ejc|||||5682
        
//       definition of offsets used in control card processing
        //b ||ejc|||||5742
        
//      definitions of stack offsets used in cmpil procedure
//      see description at start of cmpil procedure for details
//      of use of these locations on the stack.
//      a few constants used by the profiler
        //b ||ejc|||||5772
        
//      definition of limits and adjustments that are built by
//      relcr for use by the routines that relocate pointers
//      after a save file is reloaded.  see reloc etc. for usage.
//      a block of information is built that is used in
//      relocating pointers.  there are rnsi_ instances
//      of a rssi_ word structure.  each instance corresponds
//      to one of the regions that a pointer might point into.
//      each structure takes the form:
//           +------------------------------------+
//           i    address past end of section     i
//           +------------------------------------+
//           i  adjustment from old to new adrs   i
//           +------------------------------------+
//           i    address of start of section     i
//           +------------------------------------+
//      the instances are ordered thusly:
//           +------------------------------------+
//           i           dynamic storage          i
//           +------------------------------------+
//           i           static storage           i
//           +------------------------------------+
//           i       working section globals      i
//           +------------------------------------+
//           i          constant section          i
//           +------------------------------------+
//           i            code section            i
//           +------------------------------------+
//      symbolic names for these locations as offsets from
//      the first entry are provided here.
//      definitions within a section
//      overall definitions of all structures
        //b ||ttl|27,s p i t b o l -- constant section||||5838
        /* s p i t b o l -- constant section*/
//      this section consists entirely of assembled constants.
//      all label names are five letters. the order is
//      approximately alphabetical, but in some cases (always
//      documented), constants must be placed in some special
//      order which must not be disturbed.
//      it must also be remembered that there is a requirement
//      for no forward references which also disturbs the
//      alphabetical order in some cases.
        //b ||sec||||start of constant section|5851
        /*-------------------------------------------------------------------- sec03 --------*/
        // constants
        const struct spitbol_constants c = {
//      start of constant section
        //b |c_aaa|dac|1,0|||first location of constant section|5855
        .c_aaa 		= 0,				// first location of constant section
//      free store percentage (used by alloc)
        //b |alfsp|dac|2,e_fsp|||free store percentage|5859
        .alfsp 		= E_FSP,				// free store percentage
//      bit constants for general use
        //b |bits0|dbc|1,0|||all zero bits|5863
        .bits0 		= 0,				// all zero bits
        //b |bits1|dbc|1,1|||one bit in low order position|5864
        .bits1 		= 1,				// one bit in low order position
        //b |bits2|dbc|1,2|||bit in position 2|5865
        .bits2 		= 2,				// bit in position 2
        //b |bits3|dbc|1,4|||bit in position 3|5866
        .bits3 		= 4,				// bit in position 3
        //b |bits4|dbc|1,8|||bit in position 4|5867
        .bits4 		= 8,				// bit in position 4
        //b |bits5|dbc|1,16|||bit in position 5|5868
        .bits5 		= 16,				// bit in position 5
        //b |bits6|dbc|1,32|||bit in position 6|5869
        .bits6 		= 32,				// bit in position 6
        //b |bits7|dbc|1,64|||bit in position 7|5870
        .bits7 		= 64,				// bit in position 7
        //b |bits8|dbc|1,128|||bit in position 8|5871
        .bits8 		= 128,				// bit in position 8
        //b |bits9|dbc|1,256|||bit in position 9|5872
        .bits9 		= 256,				// bit in position 9
        //b |bit10|dbc|1,512|||bit in position 10|5873
        .bit10 		= 512,				// bit in position 10
        //b |bit11|dbc|1,1024|||bit in position 11|5874
        .bit11 		= 1024,				// bit in position 11
        //b |bit12|dbc|1,2048|||bit in position 12|5875
        .bit12 		= 2048,				// bit in position 12
//bitsm  dbc  cfp_m            mask for max integer
        //b |bitsm|dbc|1,0|||mask for max integer (value filled in at runtime)|5877
        .bitsm 		= 0,				// mask for max integer (value filled in at runtime)
//      bit constants for svblk (svbit field) tests
        //b |btfnc|dbc|2,svfnc|||bit to test for function|5881
        .btfnc 		= SVFNC,				// bit to test for function
        //b |btknm|dbc|2,svknm|||bit to test for keyword number|5882
        .btknm 		= SVKNM,				// bit to test for keyword number
        //b |btlbl|dbc|2,svlbl|||bit to test for label|5883
        .btlbl 		= SVLBL,				// bit to test for label
        //b |btffc|dbc|2,svffc|||bit to test for fast call|5884
        .btffc 		= SVFFC,				// bit to test for fast call
        //b |btckw|dbc|2,svckw|||bit to test for constant keyword|5885
        .btckw 		= SVCKW,				// bit to test for constant keyword
        //b |btkwv|dbc|2,svkwv|||bits to test for keword with value|5886
        .btkwv 		= SVKWV,				// bits to test for keword with value
        //b |btprd|dbc|2,svprd|||bit to test for predicate function|5887
        .btprd 		= SVPRD,				// bit to test for predicate function
        //b |btpre|dbc|2,svpre|||bit to test for preevaluation|5888
        .btpre 		= SVPRE,				// bit to test for preevaluation
        //b |btval|dbc|2,svval|||bit to test for value|5889
        .btval 		= SVVAL,				// bit to test for value
        //b ||ejc|||||5890
        
//      list of names used for control card processing
        //b |ccnms|dtc|27,/doub/||||5898
        .ccnms = 'd',
        .ccnms__pos__1 = 'o',
        .ccnms__pos__2 = 'u',
        .ccnms__pos__3 = 'b',
        .ccnms__pos__4 = 0,
        .ccnms__pos__5 = 0,
        .ccnms__pos__6 = 0,
        .ccnms__pos__7 = 0,
        //b ||dtc|27,/comp/||||5901
        .ccnms__pos__8 = 'c',
        .ccnms__pos__9 = 'o',
        .ccnms__pos__10 = 'm',
        .ccnms__pos__11 = 'p',
        .ccnms__pos__12 = 0,
        .ccnms__pos__13 = 0,
        .ccnms__pos__14 = 0,
        .ccnms__pos__15 = 0,
        //b ||dtc|27,/dump/||||5903
        .ccnms__pos__16 = 'd',
        .ccnms__pos__17 = 'u',
        .ccnms__pos__18 = 'm',
        .ccnms__pos__19 = 'p',
        .ccnms__pos__20 = 0,
        .ccnms__pos__21 = 0,
        .ccnms__pos__22 = 0,
        .ccnms__pos__23 = 0,
        //b ||dtc|27,/copy/||||5905
        .ccnms__pos__24 = 'c',
        .ccnms__pos__25 = 'o',
        .ccnms__pos__26 = 'p',
        .ccnms__pos__27 = 'y',
        .ccnms__pos__28 = 0,
        .ccnms__pos__29 = 0,
        .ccnms__pos__30 = 0,
        .ccnms__pos__31 = 0,
        //b ||dtc|27,/ejec/||||5907
        .ccnms__pos__32 = 'e',
        .ccnms__pos__33 = 'j',
        .ccnms__pos__34 = 'e',
        .ccnms__pos__35 = 'c',
        .ccnms__pos__36 = 0,
        .ccnms__pos__37 = 0,
        .ccnms__pos__38 = 0,
        .ccnms__pos__39 = 0,
        //b ||dtc|27,/erro/||||5908
        .ccnms__pos__40 = 'e',
        .ccnms__pos__41 = 'r',
        .ccnms__pos__42 = 'r',
        .ccnms__pos__43 = 'o',
        .ccnms__pos__44 = 0,
        .ccnms__pos__45 = 0,
        .ccnms__pos__46 = 0,
        .ccnms__pos__47 = 0,
        //b ||dtc|27,/exec/||||5909
        .ccnms__pos__48 = 'e',
        .ccnms__pos__49 = 'x',
        .ccnms__pos__50 = 'e',
        .ccnms__pos__51 = 'c',
        .ccnms__pos__52 = 0,
        .ccnms__pos__53 = 0,
        .ccnms__pos__54 = 0,
        .ccnms__pos__55 = 0,
        //b ||dtc|27,/fail/||||5910
        .ccnms__pos__56 = 'f',
        .ccnms__pos__57 = 'a',
        .ccnms__pos__58 = 'i',
        .ccnms__pos__59 = 'l',
        .ccnms__pos__60 = 0,
        .ccnms__pos__61 = 0,
        .ccnms__pos__62 = 0,
        .ccnms__pos__63 = 0,
        //b ||dtc|27,/incl/||||5912
        .ccnms__pos__64 = 'i',
        .ccnms__pos__65 = 'n',
        .ccnms__pos__66 = 'c',
        .ccnms__pos__67 = 'l',
        .ccnms__pos__68 = 0,
        .ccnms__pos__69 = 0,
        .ccnms__pos__70 = 0,
        .ccnms__pos__71 = 0,
        //b ||dtc|27,/line/||||5915
        .ccnms__pos__72 = 'l',
        .ccnms__pos__73 = 'i',
        .ccnms__pos__74 = 'n',
        .ccnms__pos__75 = 'e',
        .ccnms__pos__76 = 0,
        .ccnms__pos__77 = 0,
        .ccnms__pos__78 = 0,
        .ccnms__pos__79 = 0,
        //b ||dtc|27,/list/||||5917
        .ccnms__pos__80 = 'l',
        .ccnms__pos__81 = 'i',
        .ccnms__pos__82 = 's',
        .ccnms__pos__83 = 't',
        .ccnms__pos__84 = 0,
        .ccnms__pos__85 = 0,
        .ccnms__pos__86 = 0,
        .ccnms__pos__87 = 0,
        //b ||dtc|27,/noer/||||5918
        .ccnms__pos__88 = 'n',
        .ccnms__pos__89 = 'o',
        .ccnms__pos__90 = 'e',
        .ccnms__pos__91 = 'r',
        .ccnms__pos__92 = 0,
        .ccnms__pos__93 = 0,
        .ccnms__pos__94 = 0,
        .ccnms__pos__95 = 0,
        //b ||dtc|27,/noex/||||5919
        .ccnms__pos__96 = 'n',
        .ccnms__pos__97 = 'o',
        .ccnms__pos__98 = 'e',
        .ccnms__pos__99 = 'x',
        .ccnms__pos__100 = 0,
        .ccnms__pos__101 = 0,
        .ccnms__pos__102 = 0,
        .ccnms__pos__103 = 0,
        //b ||dtc|27,/nofa/||||5920
        .ccnms__pos__104 = 'n',
        .ccnms__pos__105 = 'o',
        .ccnms__pos__106 = 'f',
        .ccnms__pos__107 = 'a',
        .ccnms__pos__108 = 0,
        .ccnms__pos__109 = 0,
        .ccnms__pos__110 = 0,
        .ccnms__pos__111 = 0,
        //b ||dtc|27,/noli/||||5921
        .ccnms__pos__112 = 'n',
        .ccnms__pos__113 = 'o',
        .ccnms__pos__114 = 'l',
        .ccnms__pos__115 = 'i',
        .ccnms__pos__116 = 0,
        .ccnms__pos__117 = 0,
        .ccnms__pos__118 = 0,
        .ccnms__pos__119 = 0,
        //b ||dtc|27,/noop/||||5922
        .ccnms__pos__120 = 'n',
        .ccnms__pos__121 = 'o',
        .ccnms__pos__122 = 'o',
        .ccnms__pos__123 = 'p',
        .ccnms__pos__124 = 0,
        .ccnms__pos__125 = 0,
        .ccnms__pos__126 = 0,
        .ccnms__pos__127 = 0,
        //b ||dtc|27,/nopr/||||5923
        .ccnms__pos__128 = 'n',
        .ccnms__pos__129 = 'o',
        .ccnms__pos__130 = 'p',
        .ccnms__pos__131 = 'r',
        .ccnms__pos__132 = 0,
        .ccnms__pos__133 = 0,
        .ccnms__pos__134 = 0,
        .ccnms__pos__135 = 0,
        //b ||dtc|27,/opti/||||5924
        .ccnms__pos__136 = 'o',
        .ccnms__pos__137 = 'p',
        .ccnms__pos__138 = 't',
        .ccnms__pos__139 = 'i',
        .ccnms__pos__140 = 0,
        .ccnms__pos__141 = 0,
        .ccnms__pos__142 = 0,
        .ccnms__pos__143 = 0,
        //b ||dtc|27,/prin/||||5925
        .ccnms__pos__144 = 'p',
        .ccnms__pos__145 = 'r',
        .ccnms__pos__146 = 'i',
        .ccnms__pos__147 = 'n',
        .ccnms__pos__148 = 0,
        .ccnms__pos__149 = 0,
        .ccnms__pos__150 = 0,
        .ccnms__pos__151 = 0,
        //b ||dtc|27,/sing/||||5926
        .ccnms__pos__152 = 's',
        .ccnms__pos__153 = 'i',
        .ccnms__pos__154 = 'n',
        .ccnms__pos__155 = 'g',
        .ccnms__pos__156 = 0,
        .ccnms__pos__157 = 0,
        .ccnms__pos__158 = 0,
        .ccnms__pos__159 = 0,
        //b ||dtc|27,/spac/||||5927
        .ccnms__pos__160 = 's',
        .ccnms__pos__161 = 'p',
        .ccnms__pos__162 = 'a',
        .ccnms__pos__163 = 'c',
        .ccnms__pos__164 = 0,
        .ccnms__pos__165 = 0,
        .ccnms__pos__166 = 0,
        .ccnms__pos__167 = 0,
        //b ||dtc|27,/stit/||||5928
        .ccnms__pos__168 = 's',
        .ccnms__pos__169 = 't',
        .ccnms__pos__170 = 'i',
        .ccnms__pos__171 = 't',
        .ccnms__pos__172 = 0,
        .ccnms__pos__173 = 0,
        .ccnms__pos__174 = 0,
        .ccnms__pos__175 = 0,
        //b ||dtc|27,/titl/||||5929
        .ccnms__pos__176 = 't',
        .ccnms__pos__177 = 'i',
        .ccnms__pos__178 = 't',
        .ccnms__pos__179 = 'l',
        .ccnms__pos__180 = 0,
        .ccnms__pos__181 = 0,
        .ccnms__pos__182 = 0,
        .ccnms__pos__183 = 0,
        //b ||dtc|27,/trac/||||5930
        .ccnms__pos__184 = 't',
        .ccnms__pos__185 = 'r',
        .ccnms__pos__186 = 'a',
        .ccnms__pos__187 = 'c',
        .ccnms__pos__188 = 0,
        .ccnms__pos__189 = 0,
        .ccnms__pos__190 = 0,
        .ccnms__pos__191 = 0,
//      header messages for dumpr procedure (scblk format)
        //b |dmhdk|dac|6,b_scl|||dump of keyword values|5934
        .dmhdk 		= (word)(b_scl),				// dump of keyword values
        //b ||dac|1,22||||5935
        .dmhdk__pos__1 		= 22,
        //b ||dtc|27,/dump of keyword values/||||5936
        .dmhdk__pos__2 = 'd',
        .dmhdk__pos__3 = 'u',
        .dmhdk__pos__4 = 'm',
        .dmhdk__pos__5 = 'p',
        .dmhdk__pos__6 = ' ',
        .dmhdk__pos__7 = 'o',
        .dmhdk__pos__8 = 'f',
        .dmhdk__pos__9 = ' ',
        .dmhdk__pos__10 = 'k',
        .dmhdk__pos__11 = 'e',
        .dmhdk__pos__12 = 'y',
        .dmhdk__pos__13 = 'w',
        .dmhdk__pos__14 = 'o',
        .dmhdk__pos__15 = 'r',
        .dmhdk__pos__16 = 'd',
        .dmhdk__pos__17 = ' ',
        .dmhdk__pos__18 = 'v',
        .dmhdk__pos__19 = 'a',
        .dmhdk__pos__20 = 'l',
        .dmhdk__pos__21 = 'u',
        .dmhdk__pos__22 = 'e',
        .dmhdk__pos__23 = 's',
        .dmhdk__pos__24 = 0,
        .dmhdk__pos__25 = 0,
        //b |dmhdv|dac|6,b_scl|||dump of natural variables|5938
        .dmhdv 		= (word)(b_scl),				// dump of natural variables
        //b ||dac|1,25||||5939
        .dmhdv__pos__1 		= 25,
        //b ||dtc|27,/dump of natural variables/||||5940
        .dmhdv__pos__2 = 'd',
        .dmhdv__pos__3 = 'u',
        .dmhdv__pos__4 = 'm',
        .dmhdv__pos__5 = 'p',
        .dmhdv__pos__6 = ' ',
        .dmhdv__pos__7 = 'o',
        .dmhdv__pos__8 = 'f',
        .dmhdv__pos__9 = ' ',
        .dmhdv__pos__10 = 'n',
        .dmhdv__pos__11 = 'a',
        .dmhdv__pos__12 = 't',
        .dmhdv__pos__13 = 'u',
        .dmhdv__pos__14 = 'r',
        .dmhdv__pos__15 = 'a',
        .dmhdv__pos__16 = 'l',
        .dmhdv__pos__17 = ' ',
        .dmhdv__pos__18 = 'v',
        .dmhdv__pos__19 = 'a',
        .dmhdv__pos__20 = 'r',
        .dmhdv__pos__21 = 'i',
        .dmhdv__pos__22 = 'a',
        .dmhdv__pos__23 = 'b',
        .dmhdv__pos__24 = 'l',
        .dmhdv__pos__25 = 'e',
        .dmhdv__pos__26 = 's',
        .dmhdv__pos__27 = 0,
        .dmhdv__pos__28 = 0,
        .dmhdv__pos__29 = 0,
        .dmhdv__pos__30 = 0,
        .dmhdv__pos__31 = 0,
        .dmhdv__pos__32 = 0,
        .dmhdv__pos__33 = 0,
        //b ||ejc|||||5941
        
//      message text for compilation statistics
        //b |encm1|dac|6,b_scl||||5945
        .encm1 		= (word)(b_scl),
        //b ||dac|1,19||||5947
        .encm1__pos__1 		= 19,
        //b ||dtc|27,/memory used (bytes)/||||5948
        .encm1__pos__2 = 'm',
        .encm1__pos__3 = 'e',
        .encm1__pos__4 = 'm',
        .encm1__pos__5 = 'o',
        .encm1__pos__6 = 'r',
        .encm1__pos__7 = 'y',
        .encm1__pos__8 = ' ',
        .encm1__pos__9 = 'u',
        .encm1__pos__10 = 's',
        .encm1__pos__11 = 'e',
        .encm1__pos__12 = 'd',
        .encm1__pos__13 = ' ',
        .encm1__pos__14 = '(',
        .encm1__pos__15 = 'b',
        .encm1__pos__16 = 'y',
        .encm1__pos__17 = 't',
        .encm1__pos__18 = 'e',
        .encm1__pos__19 = 's',
        .encm1__pos__20 = ')',
        .encm1__pos__21 = 0,
        .encm1__pos__22 = 0,
        .encm1__pos__23 = 0,
        .encm1__pos__24 = 0,
        .encm1__pos__25 = 0,
        //b |encm2|dac|6,b_scl||||5950
        .encm2 		= (word)(b_scl),
        //b ||dac|1,19||||5951
        .encm2__pos__1 		= 19,
        //b ||dtc|27,/memory left (bytes)/||||5952
        .encm2__pos__2 = 'm',
        .encm2__pos__3 = 'e',
        .encm2__pos__4 = 'm',
        .encm2__pos__5 = 'o',
        .encm2__pos__6 = 'r',
        .encm2__pos__7 = 'y',
        .encm2__pos__8 = ' ',
        .encm2__pos__9 = 'l',
        .encm2__pos__10 = 'e',
        .encm2__pos__11 = 'f',
        .encm2__pos__12 = 't',
        .encm2__pos__13 = ' ',
        .encm2__pos__14 = '(',
        .encm2__pos__15 = 'b',
        .encm2__pos__16 = 'y',
        .encm2__pos__17 = 't',
        .encm2__pos__18 = 'e',
        .encm2__pos__19 = 's',
        .encm2__pos__20 = ')',
        .encm2__pos__21 = 0,
        .encm2__pos__22 = 0,
        .encm2__pos__23 = 0,
        .encm2__pos__24 = 0,
        .encm2__pos__25 = 0,
        //b |encm3|dac|6,b_scl||||5962
        .encm3 		= (word)(b_scl),
        //b ||dac|1,11||||5963
        .encm3__pos__1 		= 11,
        //b ||dtc|27,/comp errors/||||5964
        .encm3__pos__2 = 'c',
        .encm3__pos__3 = 'o',
        .encm3__pos__4 = 'm',
        .encm3__pos__5 = 'p',
        .encm3__pos__6 = ' ',
        .encm3__pos__7 = 'e',
        .encm3__pos__8 = 'r',
        .encm3__pos__9 = 'r',
        .encm3__pos__10 = 'o',
        .encm3__pos__11 = 'r',
        .encm3__pos__12 = 's',
        .encm3__pos__13 = 0,
        .encm3__pos__14 = 0,
        .encm3__pos__15 = 0,
        .encm3__pos__16 = 0,
        .encm3__pos__17 = 0,
        //b |encm4|dac|6,b_scl||||5966
        .encm4 		= (word)(b_scl),
        //b ||dac|1,20||||5971
        .encm4__pos__1 		= 20,
        //b ||dtc|27,/comp time (microsec)/||||5972
        .encm4__pos__2 = 'c',
        .encm4__pos__3 = 'o',
        .encm4__pos__4 = 'm',
        .encm4__pos__5 = 'p',
        .encm4__pos__6 = ' ',
        .encm4__pos__7 = 't',
        .encm4__pos__8 = 'i',
        .encm4__pos__9 = 'm',
        .encm4__pos__10 = 'e',
        .encm4__pos__11 = ' ',
        .encm4__pos__12 = '(',
        .encm4__pos__13 = 'm',
        .encm4__pos__14 = 'i',
        .encm4__pos__15 = 'c',
        .encm4__pos__16 = 'r',
        .encm4__pos__17 = 'o',
        .encm4__pos__18 = 's',
        .encm4__pos__19 = 'e',
        .encm4__pos__20 = 'c',
        .encm4__pos__21 = ')',
        .encm4__pos__22 = 0,
        .encm4__pos__23 = 0,
        .encm4__pos__24 = 0,
        .encm4__pos__25 = 0,
        //b |encm5|dac|6,b_scl|||execution suppressed|5975
        .encm5 		= (word)(b_scl),				// execution suppressed
        //b ||dac|1,20||||5976
        .encm5__pos__1 		= 20,
        //b ||dtc|27,/execution suppressed/||||5977
        .encm5__pos__2 = 'e',
        .encm5__pos__3 = 'x',
        .encm5__pos__4 = 'e',
        .encm5__pos__5 = 'c',
        .encm5__pos__6 = 'u',
        .encm5__pos__7 = 't',
        .encm5__pos__8 = 'i',
        .encm5__pos__9 = 'o',
        .encm5__pos__10 = 'n',
        .encm5__pos__11 = ' ',
        .encm5__pos__12 = 's',
        .encm5__pos__13 = 'u',
        .encm5__pos__14 = 'p',
        .encm5__pos__15 = 'p',
        .encm5__pos__16 = 'r',
        .encm5__pos__17 = 'e',
        .encm5__pos__18 = 's',
        .encm5__pos__19 = 's',
        .encm5__pos__20 = 'e',
        .encm5__pos__21 = 'd',
        .encm5__pos__22 = 0,
        .encm5__pos__23 = 0,
        .encm5__pos__24 = 0,
        .encm5__pos__25 = 0,
//      string constant for abnormal end
        //b |endab|dac|6,b_scl||||5981
        .endab 		= (word)(b_scl),
        //b ||dac|1,12||||5982
        .endab__pos__1 		= 12,
        //b ||dtc|27,/abnormal end/||||5983
        .endab__pos__2 = 'a',
        .endab__pos__3 = 'b',
        .endab__pos__4 = 'n',
        .endab__pos__5 = 'o',
        .endab__pos__6 = 'r',
        .endab__pos__7 = 'm',
        .endab__pos__8 = 'a',
        .endab__pos__9 = 'l',
        .endab__pos__10 = ' ',
        .endab__pos__11 = 'e',
        .endab__pos__12 = 'n',
        .endab__pos__13 = 'd',
        .endab__pos__14 = 0,
        .endab__pos__15 = 0,
        .endab__pos__16 = 0,
        .endab__pos__17 = 0,
        //b ||ejc|||||5984
        
//      memory overflow during initialisation
        //b |endmo|dac|6,b_scl||||5988
        .endmo 		= (word)(b_scl),
        //b |endml|dac|1,15||||5989
        .endml 		= 15,
        //b ||dtc|27,/memory overflow/||||5990
        .endml__pos__1 = 'm',
        .endml__pos__2 = 'e',
        .endml__pos__3 = 'm',
        .endml__pos__4 = 'o',
        .endml__pos__5 = 'r',
        .endml__pos__6 = 'y',
        .endml__pos__7 = ' ',
        .endml__pos__8 = 'o',
        .endml__pos__9 = 'v',
        .endml__pos__10 = 'e',
        .endml__pos__11 = 'r',
        .endml__pos__12 = 'f',
        .endml__pos__13 = 'l',
        .endml__pos__14 = 'o',
        .endml__pos__15 = 'w',
        .endml__pos__16 = 0,
//      string constant for message issued by l_end
        //b |endms|dac|6,b_scl||||5994
        .endms 		= (word)(b_scl),
        //b ||dac|1,10||||5995
        .endms__pos__1 		= 10,
        //b ||dtc|27,/normal end/||||5996
        .endms__pos__2 = 'n',
        .endms__pos__3 = 'o',
        .endms__pos__4 = 'r',
        .endms__pos__5 = 'm',
        .endms__pos__6 = 'a',
        .endms__pos__7 = 'l',
        .endms__pos__8 = ' ',
        .endms__pos__9 = 'e',
        .endms__pos__10 = 'n',
        .endms__pos__11 = 'd',
        .endms__pos__12 = 0,
        .endms__pos__13 = 0,
        .endms__pos__14 = 0,
        .endms__pos__15 = 0,
        .endms__pos__16 = 0,
        .endms__pos__17 = 0,
//      fail message for stack fail section
        //b |endso|dac|6,b_scl|||stack overflow in garbage collector|6000
        .endso 		= (word)(b_scl),				// stack overflow in garbage collector
        //b ||dac|1,36||||6001
        .endso__pos__1 		= 36,
        //b ||dtc|27,/stack overflow in garbage collection/||||6002
        .endso__pos__2 = 's',
        .endso__pos__3 = 't',
        .endso__pos__4 = 'a',
        .endso__pos__5 = 'c',
        .endso__pos__6 = 'k',
        .endso__pos__7 = ' ',
        .endso__pos__8 = 'o',
        .endso__pos__9 = 'v',
        .endso__pos__10 = 'e',
        .endso__pos__11 = 'r',
        .endso__pos__12 = 'f',
        .endso__pos__13 = 'l',
        .endso__pos__14 = 'o',
        .endso__pos__15 = 'w',
        .endso__pos__16 = ' ',
        .endso__pos__17 = 'i',
        .endso__pos__18 = 'n',
        .endso__pos__19 = ' ',
        .endso__pos__20 = 'g',
        .endso__pos__21 = 'a',
        .endso__pos__22 = 'r',
        .endso__pos__23 = 'b',
        .endso__pos__24 = 'a',
        .endso__pos__25 = 'g',
        .endso__pos__26 = 'e',
        .endso__pos__27 = ' ',
        .endso__pos__28 = 'c',
        .endso__pos__29 = 'o',
        .endso__pos__30 = 'l',
        .endso__pos__31 = 'l',
        .endso__pos__32 = 'e',
        .endso__pos__33 = 'c',
        .endso__pos__34 = 't',
        .endso__pos__35 = 'i',
        .endso__pos__36 = 'o',
        .endso__pos__37 = 'n',
        .endso__pos__38 = 0,
        .endso__pos__39 = 0,
        .endso__pos__40 = 0,
        .endso__pos__41 = 0,
//      string constant for time up
        //b |endtu|dac|6,b_scl||||6006
        .endtu 		= (word)(b_scl),
        //b ||dac|1,15||||6007
        .endtu__pos__1 		= 15,
        //b ||dtc|27,/error - time up/||||6008
        .endtu__pos__2 = 'e',
        .endtu__pos__3 = 'r',
        .endtu__pos__4 = 'r',
        .endtu__pos__5 = 'o',
        .endtu__pos__6 = 'r',
        .endtu__pos__7 = ' ',
        .endtu__pos__8 = '-',
        .endtu__pos__9 = ' ',
        .endtu__pos__10 = 't',
        .endtu__pos__11 = 'i',
        .endtu__pos__12 = 'm',
        .endtu__pos__13 = 'e',
        .endtu__pos__14 = ' ',
        .endtu__pos__15 = 'u',
        .endtu__pos__16 = 'p',
        .endtu__pos__17 = 0,
        //b ||ejc|||||6009
        
//      string constant for error message (error section)
        //b |ermms|dac|6,b_scl|||error|6013
        .ermms 		= (word)(b_scl),				// error
        //b ||dac|1,5||||6014
        .ermms__pos__1 		= 5,
        //b ||dtc|27,/error/||||6015
        .ermms__pos__2 = 'e',
        .ermms__pos__3 = 'r',
        .ermms__pos__4 = 'r',
        .ermms__pos__5 = 'o',
        .ermms__pos__6 = 'r',
        .ermms__pos__7 = 0,
        .ermms__pos__8 = 0,
        .ermms__pos__9 = 0,
        //b |ermns|dac|6,b_scl|||string / -- /|6017
        .ermns 		= (word)(b_scl),				// string / -- /
        //b ||dac|1,4||||6018
        .ermns__pos__1 		= 4,
        //b ||dtc|27,/ -- /||||6019
        .ermns__pos__2 = ' ',
        .ermns__pos__3 = '-',
        .ermns__pos__4 = '-',
        .ermns__pos__5 = ' ',
        .ermns__pos__6 = 0,
        .ermns__pos__7 = 0,
        .ermns__pos__8 = 0,
        .ermns__pos__9 = 0,
//      string constant for page numbering
        //b |lstms|dac|6,b_scl|||page|6023
        .lstms 		= (word)(b_scl),				// page
        //b ||dac|1,5||||6024
        .lstms__pos__1 		= 5,
        //b ||dtc|27,/page /||||6025
        .lstms__pos__2 = 'p',
        .lstms__pos__3 = 'a',
        .lstms__pos__4 = 'g',
        .lstms__pos__5 = 'e',
        .lstms__pos__6 = ' ',
        .lstms__pos__7 = 0,
        .lstms__pos__8 = 0,
        .lstms__pos__9 = 0,
//      listing header message
        //b |headr|dac|6,b_scl||||6029
        .headr 		= (word)(b_scl),
        //b ||dac|1,25||||6030
        .headr__pos__1 		= 25,
        //b ||dtc|27,/macro spitbol version 4.0/||||6031
        .headr__pos__2 = 'm',
        .headr__pos__3 = 'a',
        .headr__pos__4 = 'c',
        .headr__pos__5 = 'r',
        .headr__pos__6 = 'o',
        .headr__pos__7 = ' ',
        .headr__pos__8 = 's',
        .headr__pos__9 = 'p',
        .headr__pos__10 = 'i',
        .headr__pos__11 = 't',
        .headr__pos__12 = 'b',
        .headr__pos__13 = 'o',
        .headr__pos__14 = 'l',
        .headr__pos__15 = ' ',
        .headr__pos__16 = 'v',
        .headr__pos__17 = 'e',
        .headr__pos__18 = 'r',
        .headr__pos__19 = 's',
        .headr__pos__20 = 'i',
        .headr__pos__21 = 'o',
        .headr__pos__22 = 'n',
        .headr__pos__23 = ' ',
        .headr__pos__24 = '4',
        .headr__pos__25 = '.',
        .headr__pos__26 = '0',
        .headr__pos__27 = 0,
        .headr__pos__28 = 0,
        .headr__pos__29 = 0,
        .headr__pos__30 = 0,
        .headr__pos__31 = 0,
        .headr__pos__32 = 0,
        .headr__pos__33 = 0,
        //b |headv|dac|6,b_scl|||for exit() version no. check|6033
        .headv 		= (word)(b_scl),				// for exit() version no. check
        //b ||dac|1,5||||6034
        .headv__pos__1 		= 5,
        //b ||dtc|27,/15.01/||||6035
        .headv__pos__2 = '1',
        .headv__pos__3 = '5',
        .headv__pos__4 = '.',
        .headv__pos__5 = '0',
        .headv__pos__6 = '1',
        .headv__pos__7 = 0,
        .headv__pos__8 = 0,
        .headv__pos__9 = 0,
//      free store percentage (used by gbcol)
        //b |gbsdp|dac|2,e_sed|||sediment percentage|6039
        .gbsdp 		= E_SED,				// sediment percentage
//      integer constants for general use
//      icbld optimisation uses the first three.
        //b |int_r|dac|6,b_icl||||6045
        .int_r 		= (word)(b_icl),
        //b |intv0|dic|16,+0|||0|6046
        .intv0 		= +0,				// 0
        //b |inton|dac|6,b_icl||||6047
        .inton 		= (word)(b_icl),
        //b |intv1|dic|16,+1|||1|6048
        .intv1 		= +1,				// 1
        //b |inttw|dac|6,b_icl||||6049
        .inttw 		= (word)(b_icl),
        //b |intv2|dic|16,+2|||2|6050
        .intv2 		= +2,				// 2
        //b |intvt|dic|16,+10|||10|6051
        .intvt 		= +10,				// 10
        //b |intvh|dic|16,+100|||100|6052
        .intvh 		= +100,				// 100
        //b |intth|dic|16,+1000|||1000|6053
        .intth 		= +1000,				// 1000
//      table used in icbld optimisation
        //b |intab|dac|4,int_r|||pointer to 0|6057
        .intab 		= (word)(&c.int_r),				// pointer to 0
        //b ||dac|4,inton|||pointer to 1|6058
        .intab__pos__1 		= (word)(&c.inton),				// pointer to 1
        //b ||dac|4,inttw|||pointer to 2|6059
        .intab__pos__2 		= (word)(&c.inttw),				// pointer to 2
        //b ||ejc|||||6060
        
//      special pattern nodes. the following pattern nodes
//      consist simply of a pcode pointer, see match routines
//      (p_xxx) for full details of their use and format).
        //b |ndabb|dac|6,p_abb|||arbno|6066
        .ndabb 		= (word)(p_abb),				// arbno
        //b |ndabd|dac|6,p_abd|||arbno|6067
        .ndabd 		= (word)(p_abd),				// arbno
        //b |ndarc|dac|6,p_arc|||arb|6068
        .ndarc 		= (word)(p_arc),				// arb
        //b |ndexb|dac|6,p_exb|||expression|6069
        .ndexb 		= (word)(p_exb),				// expression
        //b |ndfnb|dac|6,p_fnb|||fence()|6070
        .ndfnb 		= (word)(p_fnb),				// fence()
        //b |ndfnd|dac|6,p_fnd|||fence()|6071
        .ndfnd 		= (word)(p_fnd),				// fence()
        //b |ndexc|dac|6,p_exc|||expression|6072
        .ndexc 		= (word)(p_exc),				// expression
        //b |ndimb|dac|6,p_imb|||immediate assignment|6073
        .ndimb 		= (word)(p_imb),				// immediate assignment
        //b |ndimd|dac|6,p_imd|||immediate assignment|6074
        .ndimd 		= (word)(p_imd),				// immediate assignment
        //b |ndnth|dac|6,p_nth|||pattern end (null pattern)|6075
        .ndnth 		= (word)(p_nth),				// pattern end (null pattern)
        //b |ndpab|dac|6,p_pab|||pattern assignment|6076
        .ndpab 		= (word)(p_pab),				// pattern assignment
        //b |ndpad|dac|6,p_pad|||pattern assignment|6077
        .ndpad 		= (word)(p_pad),				// pattern assignment
        //b |nduna|dac|6,p_una|||anchor point movement|6078
        .nduna 		= (word)(p_una),				// anchor point movement
//      keyword constant pattern nodes. the following nodes are
//      used as the values of pattern keywords and the initial
//      values of the corresponding natural variables. all
//      nodes are in p0blk format and the order is tied to the
//      definitions of corresponding k_xxx symbols.
        //b |ndabo|dac|6,p_abo|||abort|6086
        .ndabo 		= (word)(p_abo),				// abort
        //b ||dac|4,ndnth||||6087
        .ndabo__pos__1 		= (word)(&c.ndnth),
        //b |ndarb|dac|6,p_arb|||arb|6088
        .ndarb 		= (word)(p_arb),				// arb
        //b ||dac|4,ndnth||||6089
        .ndarb__pos__1 		= (word)(&c.ndnth),
        //b |ndbal|dac|6,p_bal|||bal|6090
        .ndbal 		= (word)(p_bal),				// bal
        //b ||dac|4,ndnth||||6091
        .ndbal__pos__1 		= (word)(&c.ndnth),
        //b |ndfal|dac|6,p_fal|||fail|6092
        .ndfal 		= (word)(p_fal),				// fail
        //b ||dac|4,ndnth||||6093
        .ndfal__pos__1 		= (word)(&c.ndnth),
        //b |ndfen|dac|6,p_fen|||fence|6094
        .ndfen 		= (word)(p_fen),				// fence
        //b ||dac|4,ndnth||||6095
        .ndfen__pos__1 		= (word)(&c.ndnth),
        //b |ndrem|dac|6,p_rem|||rem|6096
        .ndrem 		= (word)(p_rem),				// rem
        //b ||dac|4,ndnth||||6097
        .ndrem__pos__1 		= (word)(&c.ndnth),
        //b |ndsuc|dac|6,p_suc|||succeed|6098
        .ndsuc 		= (word)(p_suc),				// succeed
        //b ||dac|4,ndnth||||6099
        .ndsuc__pos__1 		= (word)(&c.ndnth),
//      null string. all null values point to this string. the
//      svchs field contains a blank to provide for easy default
//      processing in trace, stoptr, lpad and rpad.
//      nullw contains 10 blanks which ensures an all blank word
//      but for very exceptional machines.
        //b |nulls|dac|6,b_scl|||null string value|6107
        .nulls 		= (word)(b_scl),				// null string value
        //b ||dac|1,0|||sclen = 0|6108
        .nulls__pos__1 		= 0,				// sclen = 0
        //b |nullw|dtc|27,/          /||||6109
        .nullw = ' ',
        .nullw__pos__1 = ' ',
        .nullw__pos__2 = ' ',
        .nullw__pos__3 = ' ',
        .nullw__pos__4 = ' ',
        .nullw__pos__5 = ' ',
        .nullw__pos__6 = ' ',
        .nullw__pos__7 = ' ',
        .nullw__pos__8 = ' ',
        .nullw__pos__9 = ' ',
        .nullw__pos__10 = 0,
        .nullw__pos__11 = 0,
        .nullw__pos__12 = 0,
        .nullw__pos__13 = 0,
        .nullw__pos__14 = 0,
        .nullw__pos__15 = 0,
//      constant strings for lcase and ucase keywords
        //b |lcase|dac|6,b_scl||||6115
        .lcase 		= (word)(b_scl),
        //b ||dac|1,26||||6116
        .lcase__pos__1 		= 26,
        //b ||dtc|27,/abcdefghijklmnopqrstuvwxyz/||||6117
        .lcase__pos__2 = 'a',
        .lcase__pos__3 = 'b',
        .lcase__pos__4 = 'c',
        .lcase__pos__5 = 'd',
        .lcase__pos__6 = 'e',
        .lcase__pos__7 = 'f',
        .lcase__pos__8 = 'g',
        .lcase__pos__9 = 'h',
        .lcase__pos__10 = 'i',
        .lcase__pos__11 = 'j',
        .lcase__pos__12 = 'k',
        .lcase__pos__13 = 'l',
        .lcase__pos__14 = 'm',
        .lcase__pos__15 = 'n',
        .lcase__pos__16 = 'o',
        .lcase__pos__17 = 'p',
        .lcase__pos__18 = 'q',
        .lcase__pos__19 = 'r',
        .lcase__pos__20 = 's',
        .lcase__pos__21 = 't',
        .lcase__pos__22 = 'u',
        .lcase__pos__23 = 'v',
        .lcase__pos__24 = 'w',
        .lcase__pos__25 = 'x',
        .lcase__pos__26 = 'y',
        .lcase__pos__27 = 'z',
        .lcase__pos__28 = 0,
        .lcase__pos__29 = 0,
        .lcase__pos__30 = 0,
        .lcase__pos__31 = 0,
        .lcase__pos__32 = 0,
        .lcase__pos__33 = 0,
        //b |ucase|dac|6,b_scl||||6119
        .ucase 		= (word)(b_scl),
        //b ||dac|1,26||||6120
        .ucase__pos__1 		= 26,
        //b ||dtc|27,/ABCDEFGHIJKLMNOPQRSTUVWXYZ/||||6121
        .ucase__pos__2 = 'A',
        .ucase__pos__3 = 'B',
        .ucase__pos__4 = 'C',
        .ucase__pos__5 = 'D',
        .ucase__pos__6 = 'E',
        .ucase__pos__7 = 'F',
        .ucase__pos__8 = 'G',
        .ucase__pos__9 = 'H',
        .ucase__pos__10 = 'I',
        .ucase__pos__11 = 'J',
        .ucase__pos__12 = 'K',
        .ucase__pos__13 = 'L',
        .ucase__pos__14 = 'M',
        .ucase__pos__15 = 'N',
        .ucase__pos__16 = 'O',
        .ucase__pos__17 = 'P',
        .ucase__pos__18 = 'Q',
        .ucase__pos__19 = 'R',
        .ucase__pos__20 = 'S',
        .ucase__pos__21 = 'T',
        .ucase__pos__22 = 'U',
        .ucase__pos__23 = 'V',
        .ucase__pos__24 = 'W',
        .ucase__pos__25 = 'X',
        .ucase__pos__26 = 'Y',
        .ucase__pos__27 = 'Z',
        .ucase__pos__28 = 0,
        .ucase__pos__29 = 0,
        .ucase__pos__30 = 0,
        .ucase__pos__31 = 0,
        .ucase__pos__32 = 0,
        .ucase__pos__33 = 0,
        //b ||ejc|||||6123
        
//      operator dope vectors (see dvblk format)
        //b |opdvc|dac|6,o_cnc|||concatenation|6127
        .opdvc 		= (word)(o_cnc),				// concatenation
        //b ||dac|2,c_cnc||||6128
        .opdvc__pos__1 		= C_CNC,
        //b ||dac|2,llcnc||||6129
        .opdvc__pos__2 		= LLCNC,
        //b ||dac|2,rrcnc||||6130
        .opdvc__pos__3 		= RRCNC,
//      opdvs is used when scanning below the top level to
//      insure that the concatenation will not be later
//      mistaken for pattern matching
        //b |opdvp|dac|6,o_cnc|||concatenation - not pattern match|6136
        .opdvp 		= (word)(o_cnc),				// concatenation - not pattern match
        //b ||dac|2,c_cnp||||6137
        .opdvp__pos__1 		= C_CNP,
        //b ||dac|2,llcnc||||6138
        .opdvp__pos__2 		= LLCNC,
        //b ||dac|2,rrcnc||||6139
        .opdvp__pos__3 		= RRCNC,
//      note that the order of the remaining entries is tied to
//      the order of the coding in the scane procedure.
        //b |opdvs|dac|6,o_ass|||assignment|6144
        .opdvs 		= (word)(o_ass),				// assignment
        //b ||dac|2,c_ass||||6145
        .opdvs__pos__1 		= C_ASS,
        //b ||dac|2,llass||||6146
        .opdvs__pos__2 		= LLASS,
        //b ||dac|2,rrass||||6147
        .opdvs__pos__3 		= RRASS,
        //b ||dac|1,6|||unary equal|6149
        .opdvs__pos__4 		= 6,				// unary equal
        //b ||dac|2,c_uuo||||6150
        .opdvs__pos__5 		= C_UUO,
        //b ||dac|2,lluno||||6151
        .opdvs__pos__6 		= LLUNO,
        //b ||dac|6,o_pmv|||pattern match|6153
        .opdvs__pos__7 		= (word)(o_pmv),				// pattern match
        //b ||dac|2,c_pmt||||6154
        .opdvs__pos__8 		= C_PMT,
        //b ||dac|2,llpmt||||6155
        .opdvs__pos__9 		= LLPMT,
        //b ||dac|2,rrpmt||||6156
        .opdvs__pos__10 		= RRPMT,
        //b ||dac|6,o_int|||interrogation|6158
        .opdvs__pos__11 		= (word)(o_int),				// interrogation
        //b ||dac|2,c_uvl||||6159
        .opdvs__pos__12 		= C_UVL,
        //b ||dac|2,lluno||||6160
        .opdvs__pos__13 		= LLUNO,
        //b ||dac|1,1|||binary ampersand|6162
        .opdvs__pos__14 		= 1,				// binary ampersand
        //b ||dac|2,c_ubo||||6163
        .opdvs__pos__15 		= C_UBO,
        //b ||dac|2,llamp||||6164
        .opdvs__pos__16 		= LLAMP,
        //b ||dac|2,rramp||||6165
        .opdvs__pos__17 		= RRAMP,
        //b ||dac|6,o_kwv|||keyword reference|6167
        .opdvs__pos__18 		= (word)(o_kwv),				// keyword reference
        //b ||dac|2,c_key||||6168
        .opdvs__pos__19 		= C_KEY,
        //b ||dac|2,lluno||||6169
        .opdvs__pos__20 		= LLUNO,
        //b ||dac|6,o_alt|||alternation|6171
        .opdvs__pos__21 		= (word)(o_alt),				// alternation
        //b ||dac|2,c_alt||||6172
        .opdvs__pos__22 		= C_ALT,
        //b ||dac|2,llalt||||6173
        .opdvs__pos__23 		= LLALT,
        //b ||dac|2,rralt||||6174
        .opdvs__pos__24 		= RRALT,
        //b ||ejc|||||6175
        
//      operator dope vectors (continued)
        //b ||dac|1,5|||unary vertical bar|6179
        .opdvs__pos__25 		= 5,				// unary vertical bar
        //b ||dac|2,c_uuo||||6180
        .opdvs__pos__26 		= C_UUO,
        //b ||dac|2,lluno||||6181
        .opdvs__pos__27 		= LLUNO,
        //b ||dac|1,0|||binary at|6183
        .opdvs__pos__28 		= 0,				// binary at
        //b ||dac|2,c_ubo||||6184
        .opdvs__pos__29 		= C_UBO,
        //b ||dac|2,llats||||6185
        .opdvs__pos__30 		= LLATS,
        //b ||dac|2,rrats||||6186
        .opdvs__pos__31 		= RRATS,
        //b ||dac|6,o_cas|||cursor assignment|6188
        .opdvs__pos__32 		= (word)(o_cas),				// cursor assignment
        //b ||dac|2,c_unm||||6189
        .opdvs__pos__33 		= C_UNM,
        //b ||dac|2,lluno||||6190
        .opdvs__pos__34 		= LLUNO,
        //b ||dac|1,2|||binary number sign|6192
        .opdvs__pos__35 		= 2,				// binary number sign
        //b ||dac|2,c_ubo||||6193
        .opdvs__pos__36 		= C_UBO,
        //b ||dac|2,llnum||||6194
        .opdvs__pos__37 		= LLNUM,
        //b ||dac|2,rrnum||||6195
        .opdvs__pos__38 		= RRNUM,
        //b ||dac|1,7|||unary number sign|6197
        .opdvs__pos__39 		= 7,				// unary number sign
        //b ||dac|2,c_uuo||||6198
        .opdvs__pos__40 		= C_UUO,
        //b ||dac|2,lluno||||6199
        .opdvs__pos__41 		= LLUNO,
        //b ||dac|6,o_dvd|||division|6201
        .opdvs__pos__42 		= (word)(o_dvd),				// division
        //b ||dac|2,c_bvl||||6202
        .opdvs__pos__43 		= C_BVL,
        //b ||dac|2,lldvd||||6203
        .opdvs__pos__44 		= LLDVD,
        //b ||dac|2,rrdvd||||6204
        .opdvs__pos__45 		= RRDVD,
        //b ||dac|1,9|||unary slash|6206
        .opdvs__pos__46 		= 9,				// unary slash
        //b ||dac|2,c_uuo||||6207
        .opdvs__pos__47 		= C_UUO,
        //b ||dac|2,lluno||||6208
        .opdvs__pos__48 		= LLUNO,
        //b ||dac|6,o_mlt|||multiplication|6210
        .opdvs__pos__49 		= (word)(o_mlt),				// multiplication
        //b ||dac|2,c_bvl||||6211
        .opdvs__pos__50 		= C_BVL,
        //b ||dac|2,llmlt||||6212
        .opdvs__pos__51 		= LLMLT,
        //b ||dac|2,rrmlt||||6213
        .opdvs__pos__52 		= RRMLT,
        //b ||ejc|||||6214
        
//      operator dope vectors (continued)
        //b ||dac|1,0|||deferred expression|6218
        .opdvs__pos__53 		= 0,				// deferred expression
        //b ||dac|2,c_def||||6219
        .opdvs__pos__54 		= C_DEF,
        //b ||dac|2,lluno||||6220
        .opdvs__pos__55 		= LLUNO,
        //b ||dac|1,3|||binary percent|6222
        .opdvs__pos__56 		= 3,				// binary percent
        //b ||dac|2,c_ubo||||6223
        .opdvs__pos__57 		= C_UBO,
        //b ||dac|2,llpct||||6224
        .opdvs__pos__58 		= LLPCT,
        //b ||dac|2,rrpct||||6225
        .opdvs__pos__59 		= RRPCT,
        //b ||dac|1,8|||unary percent|6227
        .opdvs__pos__60 		= 8,				// unary percent
        //b ||dac|2,c_uuo||||6228
        .opdvs__pos__61 		= C_UUO,
        //b ||dac|2,lluno||||6229
        .opdvs__pos__62 		= LLUNO,
        //b ||dac|6,o_exp|||exponentiation|6231
        .opdvs__pos__63 		= (word)(o_exp),				// exponentiation
        //b ||dac|2,c_bvl||||6232
        .opdvs__pos__64 		= C_BVL,
        //b ||dac|2,llexp||||6233
        .opdvs__pos__65 		= LLEXP,
        //b ||dac|2,rrexp||||6234
        .opdvs__pos__66 		= RREXP,
        //b ||dac|1,10|||unary exclamation|6236
        .opdvs__pos__67 		= 10,				// unary exclamation
        //b ||dac|2,c_uuo||||6237
        .opdvs__pos__68 		= C_UUO,
        //b ||dac|2,lluno||||6238
        .opdvs__pos__69 		= LLUNO,
        //b ||dac|6,o_ima|||immediate assignment|6240
        .opdvs__pos__70 		= (word)(o_ima),				// immediate assignment
        //b ||dac|2,c_bvn||||6241
        .opdvs__pos__71 		= C_BVN,
        //b ||dac|2,lldld||||6242
        .opdvs__pos__72 		= LLDLD,
        //b ||dac|2,rrdld||||6243
        .opdvs__pos__73 		= RRDLD,
        //b ||dac|6,o_inv|||indirection|6245
        .opdvs__pos__74 		= (word)(o_inv),				// indirection
        //b ||dac|2,c_ind||||6246
        .opdvs__pos__75 		= C_IND,
        //b ||dac|2,lluno||||6247
        .opdvs__pos__76 		= LLUNO,
        //b ||dac|1,4|||binary not|6249
        .opdvs__pos__77 		= 4,				// binary not
        //b ||dac|2,c_ubo||||6250
        .opdvs__pos__78 		= C_UBO,
        //b ||dac|2,llnot||||6251
        .opdvs__pos__79 		= LLNOT,
        //b ||dac|2,rrnot||||6252
        .opdvs__pos__80 		= RRNOT,
        //b ||dac|1,0|||negation|6254
        .opdvs__pos__81 		= 0,				// negation
        //b ||dac|2,c_neg||||6255
        .opdvs__pos__82 		= C_NEG,
        //b ||dac|2,lluno||||6256
        .opdvs__pos__83 		= LLUNO,
        //b ||ejc|||||6257
        
//      operator dope vectors (continued)
        //b ||dac|6,o_sub|||subtraction|6261
        .opdvs__pos__84 		= (word)(o_sub),				// subtraction
        //b ||dac|2,c_bvl||||6262
        .opdvs__pos__85 		= C_BVL,
        //b ||dac|2,llplm||||6263
        .opdvs__pos__86 		= LLPLM,
        //b ||dac|2,rrplm||||6264
        .opdvs__pos__87 		= RRPLM,
        //b ||dac|6,o_com|||complementation|6266
        .opdvs__pos__88 		= (word)(o_com),				// complementation
        //b ||dac|2,c_uvl||||6267
        .opdvs__pos__89 		= C_UVL,
        //b ||dac|2,lluno||||6268
        .opdvs__pos__90 		= LLUNO,
        //b ||dac|6,o_add|||addition|6270
        .opdvs__pos__91 		= (word)(o_add),				// addition
        //b ||dac|2,c_bvl||||6271
        .opdvs__pos__92 		= C_BVL,
        //b ||dac|2,llplm||||6272
        .opdvs__pos__93 		= LLPLM,
        //b ||dac|2,rrplm||||6273
        .opdvs__pos__94 		= RRPLM,
        //b ||dac|6,o_aff|||affirmation|6275
        .opdvs__pos__95 		= (word)(o_aff),				// affirmation
        //b ||dac|2,c_uvl||||6276
        .opdvs__pos__96 		= C_UVL,
        //b ||dac|2,lluno||||6277
        .opdvs__pos__97 		= LLUNO,
        //b ||dac|6,o_pas|||pattern assignment|6279
        .opdvs__pos__98 		= (word)(o_pas),				// pattern assignment
        //b ||dac|2,c_bvn||||6280
        .opdvs__pos__99 		= C_BVN,
        //b ||dac|2,lldld||||6281
        .opdvs__pos__100 		= LLDLD,
        //b ||dac|2,rrdld||||6282
        .opdvs__pos__101 		= RRDLD,
        //b ||dac|6,o_nam|||name reference|6284
        .opdvs__pos__102 		= (word)(o_nam),				// name reference
        //b ||dac|2,c_unm||||6285
        .opdvs__pos__103 		= C_UNM,
        //b ||dac|2,lluno||||6286
        .opdvs__pos__104 		= LLUNO,
//      special dvs for goto operators (see procedure scngf)
        //b |opdvd|dac|6,o_god|||direct goto|6290
        .opdvd 		= (word)(o_god),				// direct goto
        //b ||dac|2,c_uvl||||6291
        .opdvd__pos__1 		= C_UVL,
        //b ||dac|2,lluno||||6292
        .opdvd__pos__2 		= LLUNO,
        //b |opdvn|dac|6,o_goc|||complex normal goto|6294
        .opdvn 		= (word)(o_goc),				// complex normal goto
        //b ||dac|2,c_unm||||6295
        .opdvn__pos__1 		= C_UNM,
        //b ||dac|2,lluno||||6296
        .opdvn__pos__2 		= LLUNO,
        //b ||ejc|||||6297
        
//      operator entry address pointers, used in code
        //b |oamn_|dac|6,o_amn|||array ref (multi-subs by value)|6301
        .oamn_ 		= (word)(o_amn),				// array ref (multi-subs by value)
        //b |oamv_|dac|6,o_amv|||array ref (multi-subs by value)|6302
        .oamv_ 		= (word)(o_amv),				// array ref (multi-subs by value)
        //b |oaon_|dac|6,o_aon|||array ref (one sub by name)|6303
        .oaon_ 		= (word)(o_aon),				// array ref (one sub by name)
        //b |oaov_|dac|6,o_aov|||array ref (one sub by value)|6304
        .oaov_ 		= (word)(o_aov),				// array ref (one sub by value)
        //b |ocer_|dac|6,o_cer|||compilation error|6305
        .ocer_ 		= (word)(o_cer),				// compilation error
        //b |ofex_|dac|6,o_fex|||failure in expression evaluation|6306
        .ofex_ 		= (word)(o_fex),				// failure in expression evaluation
        //b |ofif_|dac|6,o_fif|||failure during goto evaluation|6307
        .ofif_ 		= (word)(o_fif),				// failure during goto evaluation
        //b |ofnc_|dac|6,o_fnc|||function call (more than one arg)|6308
        .ofnc_ 		= (word)(o_fnc),				// function call (more than one arg)
        //b |ofne_|dac|6,o_fne|||function name error|6309
        .ofne_ 		= (word)(o_fne),				// function name error
        //b |ofns_|dac|6,o_fns|||function call (single argument)|6310
        .ofns_ 		= (word)(o_fns),				// function call (single argument)
        //b |ogof_|dac|6,o_gof|||set goto failure trap|6311
        .ogof_ 		= (word)(o_gof),				// set goto failure trap
        //b |oinn_|dac|6,o_inn|||indirection by name|6312
        .oinn_ 		= (word)(o_inn),				// indirection by name
        //b |okwn_|dac|6,o_kwn|||keyword reference by name|6313
        .okwn_ 		= (word)(o_kwn),				// keyword reference by name
        //b |olex_|dac|6,o_lex|||load expression by name|6314
        .olex_ 		= (word)(o_lex),				// load expression by name
        //b |olpt_|dac|6,o_lpt|||load pattern|6315
        .olpt_ 		= (word)(o_lpt),				// load pattern
        //b |olvn_|dac|6,o_lvn|||load variable name|6316
        .olvn_ 		= (word)(o_lvn),				// load variable name
        //b |onta_|dac|6,o_nta|||negation, first entry|6317
        .onta_ 		= (word)(o_nta),				// negation, first entry
        //b |ontb_|dac|6,o_ntb|||negation, second entry|6318
        .ontb_ 		= (word)(o_ntb),				// negation, second entry
        //b |ontc_|dac|6,o_ntc|||negation, third entry|6319
        .ontc_ 		= (word)(o_ntc),				// negation, third entry
        //b |opmn_|dac|6,o_pmn|||pattern match by name|6320
        .opmn_ 		= (word)(o_pmn),				// pattern match by name
        //b |opms_|dac|6,o_pms|||pattern match (statement)|6321
        .opms_ 		= (word)(o_pms),				// pattern match (statement)
        //b |opop_|dac|6,o_pop|||pop top stack item|6322
        .opop_ 		= (word)(o_pop),				// pop top stack item
        //b |ornm_|dac|6,o_rnm|||return name from expression|6323
        .ornm_ 		= (word)(o_rnm),				// return name from expression
        //b |orpl_|dac|6,o_rpl|||pattern replacement|6324
        .orpl_ 		= (word)(o_rpl),				// pattern replacement
        //b |orvl_|dac|6,o_rvl|||return value from expression|6325
        .orvl_ 		= (word)(o_rvl),				// return value from expression
        //b |osla_|dac|6,o_sla|||selection, first entry|6326
        .osla_ 		= (word)(o_sla),				// selection, first entry
        //b |oslb_|dac|6,o_slb|||selection, second entry|6327
        .oslb_ 		= (word)(o_slb),				// selection, second entry
        //b |oslc_|dac|6,o_slc|||selection, third entry|6328
        .oslc_ 		= (word)(o_slc),				// selection, third entry
        //b |osld_|dac|6,o_sld|||selection, fourth entry|6329
        .osld_ 		= (word)(o_sld),				// selection, fourth entry
        //b |ostp_|dac|6,o_stp|||stop execution|6330
        .ostp_ 		= (word)(o_stp),				// stop execution
        //b |ounf_|dac|6,o_unf|||unexpected failure|6331
        .ounf_ 		= (word)(o_unf),				// unexpected failure
        //b ||ejc|||||6332
        
//      table of names of undefined binary operators for opsyn
        //b |opsnb|dac|2,ch_at|||at|6336
        .opsnb 		= CH_AT,				// at
        //b ||dac|2,ch_am|||ampersand|6337
        .opsnb__pos__1 		= CH_AM,				// ampersand
        //b ||dac|2,ch_nm|||number|6338
        .opsnb__pos__2 		= CH_NM,				// number
        //b ||dac|2,ch_pc|||percent|6339
        .opsnb__pos__3 		= CH_PC,				// percent
        //b ||dac|2,ch_nt|||not|6340
        .opsnb__pos__4 		= CH_NT,				// not
//      table of names of undefined unary operators for opsyn
        //b |opnsu|dac|2,ch_br|||vertical bar|6344
        .opnsu 		= CH_BR,				// vertical bar
        //b ||dac|2,ch_eq|||equal|6345
        .opnsu__pos__1 		= CH_EQ,				// equal
        //b ||dac|2,ch_nm|||number|6346
        .opnsu__pos__2 		= CH_NM,				// number
        //b ||dac|2,ch_pc|||percent|6347
        .opnsu__pos__3 		= CH_PC,				// percent
        //b ||dac|2,ch_sl|||slash|6348
        .opnsu__pos__4 		= CH_SL,				// slash
        //b ||dac|2,ch_ex|||exclamation|6349
        .opnsu__pos__5 		= CH_EX,				// exclamation
//      address const containing profile table entry size
        //b |pfi2a|dac|2,pf_i2||||6355
        .pfi2a 		= PF_I2,
//      profiler message strings
        //b |pfms1|dac|6,b_scl||||6359
        .pfms1 		= (word)(b_scl),
        //b ||dac|1,15||||6360
        .pfms1__pos__1 		= 15,
        //b ||dtc|27,/program profile/||||6361
        .pfms1__pos__2 = 'p',
        .pfms1__pos__3 = 'r',
        .pfms1__pos__4 = 'o',
        .pfms1__pos__5 = 'g',
        .pfms1__pos__6 = 'r',
        .pfms1__pos__7 = 'a',
        .pfms1__pos__8 = 'm',
        .pfms1__pos__9 = ' ',
        .pfms1__pos__10 = 'p',
        .pfms1__pos__11 = 'r',
        .pfms1__pos__12 = 'o',
        .pfms1__pos__13 = 'f',
        .pfms1__pos__14 = 'i',
        .pfms1__pos__15 = 'l',
        .pfms1__pos__16 = 'e',
        .pfms1__pos__17 = 0,
        //b |pfms2|dac|6,b_scl||||6362
        .pfms2 		= (word)(b_scl),
        //b ||dac|1,42||||6363
        .pfms2__pos__1 		= 42,
        //b ||dtc|27,/stmt    number of     -- execution time --/||||6364
        .pfms2__pos__2 = 's',
        .pfms2__pos__3 = 't',
        .pfms2__pos__4 = 'm',
        .pfms2__pos__5 = 't',
        .pfms2__pos__6 = ' ',
        .pfms2__pos__7 = ' ',
        .pfms2__pos__8 = ' ',
        .pfms2__pos__9 = ' ',
        .pfms2__pos__10 = 'n',
        .pfms2__pos__11 = 'u',
        .pfms2__pos__12 = 'm',
        .pfms2__pos__13 = 'b',
        .pfms2__pos__14 = 'e',
        .pfms2__pos__15 = 'r',
        .pfms2__pos__16 = ' ',
        .pfms2__pos__17 = 'o',
        .pfms2__pos__18 = 'f',
        .pfms2__pos__19 = ' ',
        .pfms2__pos__20 = ' ',
        .pfms2__pos__21 = ' ',
        .pfms2__pos__22 = ' ',
        .pfms2__pos__23 = ' ',
        .pfms2__pos__24 = '-',
        .pfms2__pos__25 = '-',
        .pfms2__pos__26 = ' ',
        .pfms2__pos__27 = 'e',
        .pfms2__pos__28 = 'x',
        .pfms2__pos__29 = 'e',
        .pfms2__pos__30 = 'c',
        .pfms2__pos__31 = 'u',
        .pfms2__pos__32 = 't',
        .pfms2__pos__33 = 'i',
        .pfms2__pos__34 = 'o',
        .pfms2__pos__35 = 'n',
        .pfms2__pos__36 = ' ',
        .pfms2__pos__37 = 't',
        .pfms2__pos__38 = 'i',
        .pfms2__pos__39 = 'm',
        .pfms2__pos__40 = 'e',
        .pfms2__pos__41 = ' ',
        .pfms2__pos__42 = '-',
        .pfms2__pos__43 = '-',
        .pfms2__pos__44 = 0,
        .pfms2__pos__45 = 0,
        .pfms2__pos__46 = 0,
        .pfms2__pos__47 = 0,
        .pfms2__pos__48 = 0,
        .pfms2__pos__49 = 0,
        //b |pfms3|dac|6,b_scl||||6365
        .pfms3 		= (word)(b_scl),
        //b ||dac|1,47||||6366
        .pfms3__pos__1 		= 47,
        //b ||dtc|27,/number  executions  total(msec) per excn(mcsec)/||||6367
        .pfms3__pos__2 = 'n',
        .pfms3__pos__3 = 'u',
        .pfms3__pos__4 = 'm',
        .pfms3__pos__5 = 'b',
        .pfms3__pos__6 = 'e',
        .pfms3__pos__7 = 'r',
        .pfms3__pos__8 = ' ',
        .pfms3__pos__9 = ' ',
        .pfms3__pos__10 = 'e',
        .pfms3__pos__11 = 'x',
        .pfms3__pos__12 = 'e',
        .pfms3__pos__13 = 'c',
        .pfms3__pos__14 = 'u',
        .pfms3__pos__15 = 't',
        .pfms3__pos__16 = 'i',
        .pfms3__pos__17 = 'o',
        .pfms3__pos__18 = 'n',
        .pfms3__pos__19 = 's',
        .pfms3__pos__20 = ' ',
        .pfms3__pos__21 = ' ',
        .pfms3__pos__22 = 't',
        .pfms3__pos__23 = 'o',
        .pfms3__pos__24 = 't',
        .pfms3__pos__25 = 'a',
        .pfms3__pos__26 = 'l',
        .pfms3__pos__27 = '(',
        .pfms3__pos__28 = 'm',
        .pfms3__pos__29 = 's',
        .pfms3__pos__30 = 'e',
        .pfms3__pos__31 = 'c',
        .pfms3__pos__32 = ')',
        .pfms3__pos__33 = ' ',
        .pfms3__pos__34 = 'p',
        .pfms3__pos__35 = 'e',
        .pfms3__pos__36 = 'r',
        .pfms3__pos__37 = ' ',
        .pfms3__pos__38 = 'e',
        .pfms3__pos__39 = 'x',
        .pfms3__pos__40 = 'c',
        .pfms3__pos__41 = 'n',
        .pfms3__pos__42 = '(',
        .pfms3__pos__43 = 'm',
        .pfms3__pos__44 = 'c',
        .pfms3__pos__45 = 's',
        .pfms3__pos__46 = 'e',
        .pfms3__pos__47 = 'c',
        .pfms3__pos__48 = ')',
        .pfms3__pos__49 = 0,
//      real constants for general use. note that the constants
//      starting at reav1 form a powers of ten table (used in
//      gtnum and gtstg)
        //b |reav0|drc|17,+0.0|||0.0|6377
        .reav0 		= (double)+0.0,				// 0.0
        //b |reap1|drc|17,+0.1|||0.1|6380
        .reap1 		= (double)+0.1,				// 0.1
        //b |reap5|drc|17,+0.5|||0.5|6381
        .reap5 		= (double)+0.5,				// 0.5
        //b |reav1|drc|17,+1.0|||10**0|6383
        .reav1 		= (double)+1.0,				// 10**0
        //b |reavt|drc|17,+1.0e+1|||10**1|6384
        .reavt 		= (double)+1.0e+1,				// 10**1
        //b ||drc|17,+1.0e+2|||10**2|6385
        .reavt__pos__1 		= (double)+1.0e+2,				// 10**2
        //b ||drc|17,+1.0e+3|||10**3|6386
        .reavt__pos__2 		= (double)+1.0e+3,				// 10**3
        //b ||drc|17,+1.0e+4|||10**4|6387
        .reavt__pos__3 		= (double)+1.0e+4,				// 10**4
        //b ||drc|17,+1.0e+5|||10**5|6388
        .reavt__pos__4 		= (double)+1.0e+5,				// 10**5
        //b ||drc|17,+1.0e+6|||10**6|6389
        .reavt__pos__5 		= (double)+1.0e+6,				// 10**6
        //b ||drc|17,+1.0e+7|||10**7|6390
        .reavt__pos__6 		= (double)+1.0e+7,				// 10**7
        //b ||drc|17,+1.0e+8|||10**8|6391
        .reavt__pos__7 		= (double)+1.0e+8,				// 10**8
        //b ||drc|17,+1.0e+9|||10**9|6392
        .reavt__pos__8 		= (double)+1.0e+9,				// 10**9
        //b |reatt|drc|17,+1.0e+10|||10**10|6393
        .reatt 		= (double)+1.0e+10,				// 10**10
        //b ||ejc|||||6395
        
//      string constants (scblk format) for dtype procedure
        //b |scarr|dac|6,b_scl|||array|6399
        .scarr 		= (word)(b_scl),				// array
        //b ||dac|1,5||||6400
        .scarr__pos__1 		= 5,
        //b ||dtc|27,/array/||||6401
        .scarr__pos__2 = 'a',
        .scarr__pos__3 = 'r',
        .scarr__pos__4 = 'r',
        .scarr__pos__5 = 'a',
        .scarr__pos__6 = 'y',
        .scarr__pos__7 = 0,
        .scarr__pos__8 = 0,
        .scarr__pos__9 = 0,
        //b |sccod|dac|6,b_scl|||code|6410
        .sccod 		= (word)(b_scl),				// code
        //b ||dac|1,4||||6411
        .sccod__pos__1 		= 4,
        //b ||dtc|27,/code/||||6412
        .sccod__pos__2 = 'c',
        .sccod__pos__3 = 'o',
        .sccod__pos__4 = 'd',
        .sccod__pos__5 = 'e',
        .sccod__pos__6 = 0,
        .sccod__pos__7 = 0,
        .sccod__pos__8 = 0,
        .sccod__pos__9 = 0,
        //b |scexp|dac|6,b_scl|||expression|6414
        .scexp 		= (word)(b_scl),				// expression
        //b ||dac|1,10||||6415
        .scexp__pos__1 		= 10,
        //b ||dtc|27,/expression/||||6416
        .scexp__pos__2 = 'e',
        .scexp__pos__3 = 'x',
        .scexp__pos__4 = 'p',
        .scexp__pos__5 = 'r',
        .scexp__pos__6 = 'e',
        .scexp__pos__7 = 's',
        .scexp__pos__8 = 's',
        .scexp__pos__9 = 'i',
        .scexp__pos__10 = 'o',
        .scexp__pos__11 = 'n',
        .scexp__pos__12 = 0,
        .scexp__pos__13 = 0,
        .scexp__pos__14 = 0,
        .scexp__pos__15 = 0,
        .scexp__pos__16 = 0,
        .scexp__pos__17 = 0,
        //b |scext|dac|6,b_scl|||external|6418
        .scext 		= (word)(b_scl),				// external
        //b ||dac|1,8||||6419
        .scext__pos__1 		= 8,
        //b ||dtc|27,/external/||||6420
        .scext__pos__2 = 'e',
        .scext__pos__3 = 'x',
        .scext__pos__4 = 't',
        .scext__pos__5 = 'e',
        .scext__pos__6 = 'r',
        .scext__pos__7 = 'n',
        .scext__pos__8 = 'a',
        .scext__pos__9 = 'l',
        .scext__pos__10 = 0,
        .scext__pos__11 = 0,
        .scext__pos__12 = 0,
        .scext__pos__13 = 0,
        .scext__pos__14 = 0,
        .scext__pos__15 = 0,
        .scext__pos__16 = 0,
        .scext__pos__17 = 0,
        //b |scint|dac|6,b_scl|||integer|6422
        .scint 		= (word)(b_scl),				// integer
        //b ||dac|1,7||||6423
        .scint__pos__1 		= 7,
        //b ||dtc|27,/integer/||||6424
        .scint__pos__2 = 'i',
        .scint__pos__3 = 'n',
        .scint__pos__4 = 't',
        .scint__pos__5 = 'e',
        .scint__pos__6 = 'g',
        .scint__pos__7 = 'e',
        .scint__pos__8 = 'r',
        .scint__pos__9 = 0,
        //b |scnam|dac|6,b_scl|||name|6426
        .scnam 		= (word)(b_scl),				// name
        //b ||dac|1,4||||6427
        .scnam__pos__1 		= 4,
        //b ||dtc|27,/name/||||6428
        .scnam__pos__2 = 'n',
        .scnam__pos__3 = 'a',
        .scnam__pos__4 = 'm',
        .scnam__pos__5 = 'e',
        .scnam__pos__6 = 0,
        .scnam__pos__7 = 0,
        .scnam__pos__8 = 0,
        .scnam__pos__9 = 0,
        //b |scnum|dac|6,b_scl|||numeric|6430
        .scnum 		= (word)(b_scl),				// numeric
        //b ||dac|1,7||||6431
        .scnum__pos__1 		= 7,
        //b ||dtc|27,/numeric/||||6432
        .scnum__pos__2 = 'n',
        .scnum__pos__3 = 'u',
        .scnum__pos__4 = 'm',
        .scnum__pos__5 = 'e',
        .scnum__pos__6 = 'r',
        .scnum__pos__7 = 'i',
        .scnum__pos__8 = 'c',
        .scnum__pos__9 = 0,
        //b |scpat|dac|6,b_scl|||pattern|6434
        .scpat 		= (word)(b_scl),				// pattern
        //b ||dac|1,7||||6435
        .scpat__pos__1 		= 7,
        //b ||dtc|27,/pattern/||||6436
        .scpat__pos__2 = 'p',
        .scpat__pos__3 = 'a',
        .scpat__pos__4 = 't',
        .scpat__pos__5 = 't',
        .scpat__pos__6 = 'e',
        .scpat__pos__7 = 'r',
        .scpat__pos__8 = 'n',
        .scpat__pos__9 = 0,
        //b |screa|dac|6,b_scl|||real|6440
        .screa 		= (word)(b_scl),				// real
        //b ||dac|1,4||||6441
        .screa__pos__1 		= 4,
        //b ||dtc|27,/real/||||6442
        .screa__pos__2 = 'r',
        .screa__pos__3 = 'e',
        .screa__pos__4 = 'a',
        .screa__pos__5 = 'l',
        .screa__pos__6 = 0,
        .screa__pos__7 = 0,
        .screa__pos__8 = 0,
        .screa__pos__9 = 0,
        //b |scstr|dac|6,b_scl|||string|6445
        .scstr 		= (word)(b_scl),				// string
        //b ||dac|1,6||||6446
        .scstr__pos__1 		= 6,
        //b ||dtc|27,/string/||||6447
        .scstr__pos__2 = 's',
        .scstr__pos__3 = 't',
        .scstr__pos__4 = 'r',
        .scstr__pos__5 = 'i',
        .scstr__pos__6 = 'n',
        .scstr__pos__7 = 'g',
        .scstr__pos__8 = 0,
        .scstr__pos__9 = 0,
        //b |sctab|dac|6,b_scl|||table|6449
        .sctab 		= (word)(b_scl),				// table
        //b ||dac|1,5||||6450
        .sctab__pos__1 		= 5,
        //b ||dtc|27,/table/||||6451
        .sctab__pos__2 = 't',
        .sctab__pos__3 = 'a',
        .sctab__pos__4 = 'b',
        .sctab__pos__5 = 'l',
        .sctab__pos__6 = 'e',
        .sctab__pos__7 = 0,
        .sctab__pos__8 = 0,
        .sctab__pos__9 = 0,
        //b |scfil|dac|6,b_scl|||file (for extended load arguments)|6453
        .scfil 		= (word)(b_scl),				// file (for extended load arguments)
        //b ||dac|1,4||||6454
        .scfil__pos__1 		= 4,
        //b ||dtc|27,/file/||||6455
        .scfil__pos__2 = 'f',
        .scfil__pos__3 = 'i',
        .scfil__pos__4 = 'l',
        .scfil__pos__5 = 'e',
        .scfil__pos__6 = 0,
        .scfil__pos__7 = 0,
        .scfil__pos__8 = 0,
        .scfil__pos__9 = 0,
        //b ||ejc|||||6457
        
//      string constants (scblk format) for kvrtn (see retrn)
        //b |scfrt|dac|6,b_scl|||freturn|6461
        .scfrt 		= (word)(b_scl),				// freturn
        //b ||dac|1,7||||6462
        .scfrt__pos__1 		= 7,
        //b ||dtc|27,/freturn/||||6463
        .scfrt__pos__2 = 'f',
        .scfrt__pos__3 = 'r',
        .scfrt__pos__4 = 'e',
        .scfrt__pos__5 = 't',
        .scfrt__pos__6 = 'u',
        .scfrt__pos__7 = 'r',
        .scfrt__pos__8 = 'n',
        .scfrt__pos__9 = 0,
        //b |scnrt|dac|6,b_scl|||nreturn|6465
        .scnrt 		= (word)(b_scl),				// nreturn
        //b ||dac|1,7||||6466
        .scnrt__pos__1 		= 7,
        //b ||dtc|27,/nreturn/||||6467
        .scnrt__pos__2 = 'n',
        .scnrt__pos__3 = 'r',
        .scnrt__pos__4 = 'e',
        .scnrt__pos__5 = 't',
        .scnrt__pos__6 = 'u',
        .scnrt__pos__7 = 'r',
        .scnrt__pos__8 = 'n',
        .scnrt__pos__9 = 0,
        //b |scrtn|dac|6,b_scl|||return|6469
        .scrtn 		= (word)(b_scl),				// return
        //b ||dac|1,6||||6470
        .scrtn__pos__1 		= 6,
        //b ||dtc|27,/return/||||6471
        .scrtn__pos__2 = 'r',
        .scrtn__pos__3 = 'e',
        .scrtn__pos__4 = 't',
        .scrtn__pos__5 = 'u',
        .scrtn__pos__6 = 'r',
        .scrtn__pos__7 = 'n',
        .scrtn__pos__8 = 0,
        .scrtn__pos__9 = 0,
//      datatype name table for dtype procedure. the order of
//      these entries is tied to the b_xxx definitions for blocks
//      note that slots for buffer and real data types are filled
//      even if these data types are conditionalized out of the
//      implementation.  this is done so that the block numbering
//      at bl_ar etc. remains constant in all versions.
        //b |scnmt|dac|4,scarr|||arblk     array|6481
        .scnmt 		= (word)(&c.scarr),				// arblk     array
        //b ||dac|4,sccod|||cdblk     code|6482
        .scnmt__pos__1 		= (word)(&c.sccod),				// cdblk     code
        //b ||dac|4,scexp|||exblk     expression|6483
        .scnmt__pos__2 		= (word)(&c.scexp),				// exblk     expression
        //b ||dac|4,scint|||icblk     integer|6484
        .scnmt__pos__3 		= (word)(&c.scint),				// icblk     integer
        //b ||dac|4,scnam|||nmblk     name|6485
        .scnmt__pos__4 		= (word)(&c.scnam),				// nmblk     name
        //b ||dac|4,scpat|||p0blk     pattern|6486
        .scnmt__pos__5 		= (word)(&c.scpat),				// p0blk     pattern
        //b ||dac|4,scpat|||p1blk     pattern|6487
        .scnmt__pos__6 		= (word)(&c.scpat),				// p1blk     pattern
        //b ||dac|4,scpat|||p2blk     pattern|6488
        .scnmt__pos__7 		= (word)(&c.scpat),				// p2blk     pattern
        //b ||dac|4,screa|||rcblk     real|6493
        .scnmt__pos__8 		= (word)(&c.screa),				// rcblk     real
        //b ||dac|4,scstr|||scblk     string|6495
        .scnmt__pos__9 		= (word)(&c.scstr),				// scblk     string
        //b ||dac|4,scexp|||seblk     expression|6496
        .scnmt__pos__10 		= (word)(&c.scexp),				// seblk     expression
        //b ||dac|4,sctab|||tbblk     table|6497
        .scnmt__pos__11 		= (word)(&c.sctab),				// tbblk     table
        //b ||dac|4,scarr|||vcblk     array|6498
        .scnmt__pos__12 		= (word)(&c.scarr),				// vcblk     array
        //b ||dac|4,scext|||xnblk     external|6499
        .scnmt__pos__13 		= (word)(&c.scext),				// xnblk     external
        //b ||dac|4,scext|||xrblk     external|6500
        .scnmt__pos__14 		= (word)(&c.scext),				// xrblk     external
        //b ||dac|4,nulls|||bfblk     no buffer in this version|6502
        .scnmt__pos__15 		= (word)(&c.nulls),				// bfblk     no buffer in this version
//      string constant for real zero
        //b |scre0|dac|6,b_scl||||6511
        .scre0 		= (word)(b_scl),
        //b ||dac|1,2||||6512
        .scre0__pos__1 		= 2,
        //b ||dtc|27,/0./||||6513
        .scre0__pos__2 = '0',
        .scre0__pos__3 = '.',
        .scre0__pos__4 = 0,
        .scre0__pos__5 = 0,
        .scre0__pos__6 = 0,
        .scre0__pos__7 = 0,
        .scre0__pos__8 = 0,
        .scre0__pos__9 = 0,
        //b ||ejc|||||6515
        
//      used to re-initialise kvstl
        //b |stlim|dic|16,+2147483647|||default statement limit|6523
        .stlim 		= +2147483647,				// default statement limit
//      dummy function block used for undefined functions
        //b |stndf|dac|6,o_fun|||ptr to undefined function err call|6531
        .stndf 		= (word)(o_fun),				// ptr to undefined function err call
        //b ||dac|1,0|||dummy fargs count for call circuit|6532
        .stndf__pos__1 		= 0,				// dummy fargs count for call circuit
//      dummy code block used for undefined labels
        //b |stndl|dac|6,l_und|||code ptr points to undefined lbl|6536
        .stndl 		= (word)(l_und),				// code ptr points to undefined lbl
//      dummy operator block used for undefined operators
        //b |stndo|dac|6,o_oun|||ptr to undefined operator err call|6540
        .stndo 		= (word)(o_oun),				// ptr to undefined operator err call
        //b ||dac|1,0|||dummy fargs count for call circuit|6541
        .stndo__pos__1 		= 0,				// dummy fargs count for call circuit
//      standard variable block. this block is used to initialize
//      the first seven fields of a newly constructed vrblk.
//      its format is tied to the vrblk definitions (see gtnvr).
        //b |stnvr|dac|6,b_vrl|||vrget|6547
        .stnvr 		= (word)(b_vrl),				// vrget
        //b ||dac|6,b_vrs|||vrsto|6548
        .stnvr__pos__1 		= (word)(b_vrs),				// vrsto
        //b ||dac|4,nulls|||vrval|6549
        .stnvr__pos__2 		= (word)(&c.nulls),				// vrval
        //b ||dac|6,b_vrg|||vrtra|6550
        .stnvr__pos__3 		= (word)(b_vrg),				// vrtra
        //b ||dac|4,stndl|||vrlbl|6551
        .stnvr__pos__4 		= (word)(&c.stndl),				// vrlbl
        //b ||dac|4,stndf|||vrfnc|6552
        .stnvr__pos__5 		= (word)(&c.stndf),				// vrfnc
        //b ||dac|1,0|||vrnxt|6553
        .stnvr__pos__6 		= 0,				// vrnxt
        //b ||ejc|||||6554
        
//      messages used in end of run processing (stopr)
        //b |stpm1|dac|6,b_scl|||in statement|6558
        .stpm1 		= (word)(b_scl),				// in statement
        //b ||dac|1,12||||6559
        .stpm1__pos__1 		= 12,
        //b ||dtc|27,/in statement/||||6560
        .stpm1__pos__2 = 'i',
        .stpm1__pos__3 = 'n',
        .stpm1__pos__4 = ' ',
        .stpm1__pos__5 = 's',
        .stpm1__pos__6 = 't',
        .stpm1__pos__7 = 'a',
        .stpm1__pos__8 = 't',
        .stpm1__pos__9 = 'e',
        .stpm1__pos__10 = 'm',
        .stpm1__pos__11 = 'e',
        .stpm1__pos__12 = 'n',
        .stpm1__pos__13 = 't',
        .stpm1__pos__14 = 0,
        .stpm1__pos__15 = 0,
        .stpm1__pos__16 = 0,
        .stpm1__pos__17 = 0,
        //b |stpm2|dac|6,b_scl||||6562
        .stpm2 		= (word)(b_scl),
        //b ||dac|1,14||||6563
        .stpm2__pos__1 		= 14,
        //b ||dtc|27,/stmts executed/||||6564
        .stpm2__pos__2 = 's',
        .stpm2__pos__3 = 't',
        .stpm2__pos__4 = 'm',
        .stpm2__pos__5 = 't',
        .stpm2__pos__6 = 's',
        .stpm2__pos__7 = ' ',
        .stpm2__pos__8 = 'e',
        .stpm2__pos__9 = 'x',
        .stpm2__pos__10 = 'e',
        .stpm2__pos__11 = 'c',
        .stpm2__pos__12 = 'u',
        .stpm2__pos__13 = 't',
        .stpm2__pos__14 = 'e',
        .stpm2__pos__15 = 'd',
        .stpm2__pos__16 = 0,
        .stpm2__pos__17 = 0,
        //b |stpm3|dac|6,b_scl||||6566
        .stpm3 		= (word)(b_scl),
        //b ||dac|1,20||||6567
        .stpm3__pos__1 		= 20,
        //b ||dtc|27,/execution time msec /||||6568
        .stpm3__pos__2 = 'e',
        .stpm3__pos__3 = 'x',
        .stpm3__pos__4 = 'e',
        .stpm3__pos__5 = 'c',
        .stpm3__pos__6 = 'u',
        .stpm3__pos__7 = 't',
        .stpm3__pos__8 = 'i',
        .stpm3__pos__9 = 'o',
        .stpm3__pos__10 = 'n',
        .stpm3__pos__11 = ' ',
        .stpm3__pos__12 = 't',
        .stpm3__pos__13 = 'i',
        .stpm3__pos__14 = 'm',
        .stpm3__pos__15 = 'e',
        .stpm3__pos__16 = ' ',
        .stpm3__pos__17 = 'm',
        .stpm3__pos__18 = 's',
        .stpm3__pos__19 = 'e',
        .stpm3__pos__20 = 'c',
        .stpm3__pos__21 = ' ',
        .stpm3__pos__22 = 0,
        .stpm3__pos__23 = 0,
        .stpm3__pos__24 = 0,
        .stpm3__pos__25 = 0,
        //b |stpm4|dac|6,b_scl|||in line|6571
        .stpm4 		= (word)(b_scl),				// in line
        //b ||dac|1,7||||6572
        .stpm4__pos__1 		= 7,
        //b ||dtc|27,/in line/||||6573
        .stpm4__pos__2 = 'i',
        .stpm4__pos__3 = 'n',
        .stpm4__pos__4 = ' ',
        .stpm4__pos__5 = 'l',
        .stpm4__pos__6 = 'i',
        .stpm4__pos__7 = 'n',
        .stpm4__pos__8 = 'e',
        .stpm4__pos__9 = 0,
        //b |stpm5|dac|6,b_scl||||6576
        .stpm5 		= (word)(b_scl),
        //b ||dac|1,13||||6577
        .stpm5__pos__1 		= 13,
        //b ||dtc|27,/regenerations/||||6578
        .stpm5__pos__2 = 'r',
        .stpm5__pos__3 = 'e',
        .stpm5__pos__4 = 'g',
        .stpm5__pos__5 = 'e',
        .stpm5__pos__6 = 'n',
        .stpm5__pos__7 = 'e',
        .stpm5__pos__8 = 'r',
        .stpm5__pos__9 = 'a',
        .stpm5__pos__10 = 't',
        .stpm5__pos__11 = 'i',
        .stpm5__pos__12 = 'o',
        .stpm5__pos__13 = 'n',
        .stpm5__pos__14 = 's',
        .stpm5__pos__15 = 0,
        .stpm5__pos__16 = 0,
        .stpm5__pos__17 = 0,
        //b |stpm6|dac|6,b_scl|||in file|6581
        .stpm6 		= (word)(b_scl),				// in file
        //b ||dac|1,7||||6582
        .stpm6__pos__1 		= 7,
        //b ||dtc|27,/in file/||||6583
        .stpm6__pos__2 = 'i',
        .stpm6__pos__3 = 'n',
        .stpm6__pos__4 = ' ',
        .stpm6__pos__5 = 'f',
        .stpm6__pos__6 = 'i',
        .stpm6__pos__7 = 'l',
        .stpm6__pos__8 = 'e',
        .stpm6__pos__9 = 0,
        //b |stpm7|dac|6,b_scl||||6586
        .stpm7 		= (word)(b_scl),
        //b ||dac|1,15||||6587
        .stpm7__pos__1 		= 15,
        //b ||dtc|27,_stmt / microsec_||||6588
        .stpm7__pos__2 = 's',
        .stpm7__pos__3 = 't',
        .stpm7__pos__4 = 'm',
        .stpm7__pos__5 = 't',
        .stpm7__pos__6 = ' ',
        .stpm7__pos__7 = '/',
        .stpm7__pos__8 = ' ',
        .stpm7__pos__9 = 'm',
        .stpm7__pos__10 = 'i',
        .stpm7__pos__11 = 'c',
        .stpm7__pos__12 = 'r',
        .stpm7__pos__13 = 'o',
        .stpm7__pos__14 = 's',
        .stpm7__pos__15 = 'e',
        .stpm7__pos__16 = 'c',
        .stpm7__pos__17 = 0,
        //b |stpm8|dac|6,b_scl||||6590
        .stpm8 		= (word)(b_scl),
        //b ||dac|1,15||||6591
        .stpm8__pos__1 		= 15,
        //b ||dtc|27,_stmt / millisec_||||6592
        .stpm8__pos__2 = 's',
        .stpm8__pos__3 = 't',
        .stpm8__pos__4 = 'm',
        .stpm8__pos__5 = 't',
        .stpm8__pos__6 = ' ',
        .stpm8__pos__7 = '/',
        .stpm8__pos__8 = ' ',
        .stpm8__pos__9 = 'm',
        .stpm8__pos__10 = 'i',
        .stpm8__pos__11 = 'l',
        .stpm8__pos__12 = 'l',
        .stpm8__pos__13 = 'i',
        .stpm8__pos__14 = 's',
        .stpm8__pos__15 = 'e',
        .stpm8__pos__16 = 'c',
        .stpm8__pos__17 = 0,
        //b |stpm9|dac|6,b_scl||||6594
        .stpm9 		= (word)(b_scl),
        //b ||dac|1,13||||6595
        .stpm9__pos__1 		= 13,
        //b ||dtc|27,_stmt / second_||||6596
        .stpm9__pos__2 = 's',
        .stpm9__pos__3 = 't',
        .stpm9__pos__4 = 'm',
        .stpm9__pos__5 = 't',
        .stpm9__pos__6 = ' ',
        .stpm9__pos__7 = '/',
        .stpm9__pos__8 = ' ',
        .stpm9__pos__9 = 's',
        .stpm9__pos__10 = 'e',
        .stpm9__pos__11 = 'c',
        .stpm9__pos__12 = 'o',
        .stpm9__pos__13 = 'n',
        .stpm9__pos__14 = 'd',
        .stpm9__pos__15 = 0,
        .stpm9__pos__16 = 0,
        .stpm9__pos__17 = 0,
//      chars for /tu/ ending code
        //b |strtu|dtc|27,/tu/||||6600
        .strtu = 't',
        .strtu__pos__1 = 'u',
        .strtu__pos__2 = 0,
        .strtu__pos__3 = 0,
        .strtu__pos__4 = 0,
        .strtu__pos__5 = 0,
        .strtu__pos__6 = 0,
        .strtu__pos__7 = 0,
//      table used by convert function to check datatype name
//      the entries are ordered to correspond to branch table
//      in s_cnv
        //b |svctb|dac|4,scstr|||string|6606
        .svctb 		= (word)(&c.scstr),				// string
        //b ||dac|4,scint|||integer|6607
        .svctb__pos__1 		= (word)(&c.scint),				// integer
        //b ||dac|4,scnam|||name|6608
        .svctb__pos__2 		= (word)(&c.scnam),				// name
        //b ||dac|4,scpat|||pattern|6609
        .svctb__pos__3 		= (word)(&c.scpat),				// pattern
        //b ||dac|4,scarr|||array|6610
        .svctb__pos__4 		= (word)(&c.scarr),				// array
        //b ||dac|4,sctab|||table|6611
        .svctb__pos__5 		= (word)(&c.sctab),				// table
        //b ||dac|4,scexp|||expression|6612
        .svctb__pos__6 		= (word)(&c.scexp),				// expression
        //b ||dac|4,sccod|||code|6613
        .svctb__pos__7 		= (word)(&c.sccod),				// code
        //b ||dac|4,scnum|||numeric|6614
        .svctb__pos__8 		= (word)(&c.scnum),				// numeric
        //b ||dac|4,screa|||real|6617
        .svctb__pos__9 		= (word)(&c.screa),				// real
        //b ||dac|1,0|||zero marks end of list|6623
        .svctb__pos__10 		= 0,				// zero marks end of list
        //b ||ejc|||||6624
        
//      messages (scblk format) used by trace procedures
        //b |tmasb|dac|6,b_scl|||asterisks for trace statement no|6629
        .tmasb 		= (word)(b_scl),				// asterisks for trace statement no
        //b ||dac|1,13||||6630
        .tmasb__pos__1 		= 13,
        //b ||dtc|27,/************ /||||6631
        .tmasb__pos__2 = '*',
        .tmasb__pos__3 = '*',
        .tmasb__pos__4 = '*',
        .tmasb__pos__5 = '*',
        .tmasb__pos__6 = '*',
        .tmasb__pos__7 = '*',
        .tmasb__pos__8 = '*',
        .tmasb__pos__9 = '*',
        .tmasb__pos__10 = '*',
        .tmasb__pos__11 = '*',
        .tmasb__pos__12 = '*',
        .tmasb__pos__13 = '*',
        .tmasb__pos__14 = ' ',
        .tmasb__pos__15 = 0,
        .tmasb__pos__16 = 0,
        .tmasb__pos__17 = 0,
        //b |tmbeb|dac|6,b_scl|||blank-equal-blank|6634
        .tmbeb 		= (word)(b_scl),				// blank-equal-blank
        //b ||dac|1,3||||6635
        .tmbeb__pos__1 		= 3,
        //b ||dtc|27,/ = /||||6636
        .tmbeb__pos__2 = ' ',
        .tmbeb__pos__3 = '=',
        .tmbeb__pos__4 = ' ',
        .tmbeb__pos__5 = 0,
        .tmbeb__pos__6 = 0,
        .tmbeb__pos__7 = 0,
        .tmbeb__pos__8 = 0,
        .tmbeb__pos__9 = 0,
//      dummy trblk for expression variable
        //b |trbev|dac|6,b_trt|||dummy trblk|6640
        .trbev 		= (word)(b_trt),				// dummy trblk
//      dummy trblk for keyword variable
        //b |trbkv|dac|6,b_trt|||dummy trblk|6644
        .trbkv 		= (word)(b_trt),				// dummy trblk
//      dummy code block to return control to trxeq procedure
        //b |trxdr|dac|6,o_txr|||block points to return routine|6648
        .trxdr 		= (word)(o_txr),				// block points to return routine
        //b |trxdc|dac|4,trxdr|||pointer to block|6649
        .trxdc 		= (word)(&c.trxdr),				// pointer to block
        //b ||ejc|||||6650
        
//      standard variable blocks
//      see svblk format for full details of the format. the
//      vrblks are ordered by length and within each length the
//      order is alphabetical by name of the variable.
        //b |v_eqf|dbc|2,svfpr|||eq|6658
        .v_eqf 		= SVFPR,				// eq
        //b ||dac|1,2||||6659
        .v_eqf__pos__1 		= 2,
        //b ||dtc|27,/eq/||||6660
        .v_eqf__pos__2 = 'e',
        .v_eqf__pos__3 = 'q',
        .v_eqf__pos__4 = 0,
        .v_eqf__pos__5 = 0,
        .v_eqf__pos__6 = 0,
        .v_eqf__pos__7 = 0,
        .v_eqf__pos__8 = 0,
        .v_eqf__pos__9 = 0,
        //b ||dac|6,s_eqf||||6661
        .v_eqf__pos__10 		= (word)(s_eqf),
        //b ||dac|1,2||||6662
        .v_eqf__pos__11 		= 2,
        //b |v_gef|dbc|2,svfpr|||ge|6664
        .v_gef 		= SVFPR,				// ge
        //b ||dac|1,2||||6665
        .v_gef__pos__1 		= 2,
        //b ||dtc|27,/ge/||||6666
        .v_gef__pos__2 = 'g',
        .v_gef__pos__3 = 'e',
        .v_gef__pos__4 = 0,
        .v_gef__pos__5 = 0,
        .v_gef__pos__6 = 0,
        .v_gef__pos__7 = 0,
        .v_gef__pos__8 = 0,
        .v_gef__pos__9 = 0,
        //b ||dac|6,s_gef||||6667
        .v_gef__pos__10 		= (word)(s_gef),
        //b ||dac|1,2||||6668
        .v_gef__pos__11 		= 2,
        //b |v_gtf|dbc|2,svfpr|||gt|6670
        .v_gtf 		= SVFPR,				// gt
        //b ||dac|1,2||||6671
        .v_gtf__pos__1 		= 2,
        //b ||dtc|27,/gt/||||6672
        .v_gtf__pos__2 = 'g',
        .v_gtf__pos__3 = 't',
        .v_gtf__pos__4 = 0,
        .v_gtf__pos__5 = 0,
        .v_gtf__pos__6 = 0,
        .v_gtf__pos__7 = 0,
        .v_gtf__pos__8 = 0,
        .v_gtf__pos__9 = 0,
        //b ||dac|6,s_gtf||||6673
        .v_gtf__pos__10 		= (word)(s_gtf),
        //b ||dac|1,2||||6674
        .v_gtf__pos__11 		= 2,
        //b |v_lef|dbc|2,svfpr|||le|6676
        .v_lef 		= SVFPR,				// le
        //b ||dac|1,2||||6677
        .v_lef__pos__1 		= 2,
        //b ||dtc|27,/le/||||6678
        .v_lef__pos__2 = 'l',
        .v_lef__pos__3 = 'e',
        .v_lef__pos__4 = 0,
        .v_lef__pos__5 = 0,
        .v_lef__pos__6 = 0,
        .v_lef__pos__7 = 0,
        .v_lef__pos__8 = 0,
        .v_lef__pos__9 = 0,
        //b ||dac|6,s_lef||||6679
        .v_lef__pos__10 		= (word)(s_lef),
        //b ||dac|1,2||||6680
        .v_lef__pos__11 		= 2,
        //b |v_lnf|dbc|2,svfnp|||ln|6683
        .v_lnf 		= SVFNP,				// ln
        //b ||dac|1,2||||6684
        .v_lnf__pos__1 		= 2,
        //b ||dtc|27,/ln/||||6685
        .v_lnf__pos__2 = 'l',
        .v_lnf__pos__3 = 'n',
        .v_lnf__pos__4 = 0,
        .v_lnf__pos__5 = 0,
        .v_lnf__pos__6 = 0,
        .v_lnf__pos__7 = 0,
        .v_lnf__pos__8 = 0,
        .v_lnf__pos__9 = 0,
        //b ||dac|6,s_lnf||||6686
        .v_lnf__pos__10 		= (word)(s_lnf),
        //b ||dac|1,1||||6687
        .v_lnf__pos__11 		= 1,
        //b |v_ltf|dbc|2,svfpr|||lt|6690
        .v_ltf 		= SVFPR,				// lt
        //b ||dac|1,2||||6691
        .v_ltf__pos__1 		= 2,
        //b ||dtc|27,/lt/||||6692
        .v_ltf__pos__2 = 'l',
        .v_ltf__pos__3 = 't',
        .v_ltf__pos__4 = 0,
        .v_ltf__pos__5 = 0,
        .v_ltf__pos__6 = 0,
        .v_ltf__pos__7 = 0,
        .v_ltf__pos__8 = 0,
        .v_ltf__pos__9 = 0,
        //b ||dac|6,s_ltf||||6693
        .v_ltf__pos__10 		= (word)(s_ltf),
        //b ||dac|1,2||||6694
        .v_ltf__pos__11 		= 2,
        //b |v_nef|dbc|2,svfpr|||ne|6696
        .v_nef 		= SVFPR,				// ne
        //b ||dac|1,2||||6697
        .v_nef__pos__1 		= 2,
        //b ||dtc|27,/ne/||||6698
        .v_nef__pos__2 = 'n',
        .v_nef__pos__3 = 'e',
        .v_nef__pos__4 = 0,
        .v_nef__pos__5 = 0,
        .v_nef__pos__6 = 0,
        .v_nef__pos__7 = 0,
        .v_nef__pos__8 = 0,
        .v_nef__pos__9 = 0,
        //b ||dac|6,s_nef||||6699
        .v_nef__pos__10 		= (word)(s_nef),
        //b ||dac|1,2||||6700
        .v_nef__pos__11 		= 2,
        //b |v_any|dbc|2,svfnp|||any|6726
        .v_any 		= SVFNP,				// any
        //b ||dac|1,3||||6727
        .v_any__pos__1 		= 3,
        //b ||dtc|27,/any/||||6728
        .v_any__pos__2 = 'a',
        .v_any__pos__3 = 'n',
        .v_any__pos__4 = 'y',
        .v_any__pos__5 = 0,
        .v_any__pos__6 = 0,
        .v_any__pos__7 = 0,
        .v_any__pos__8 = 0,
        .v_any__pos__9 = 0,
        //b ||dac|6,s_any||||6729
        .v_any__pos__10 		= (word)(s_any),
        //b ||dac|1,1||||6730
        .v_any__pos__11 		= 1,
        //b |v_arb|dbc|2,svkvc|||arb|6732
        .v_arb 		= SVKVC,				// arb
        //b ||dac|1,3||||6733
        .v_arb__pos__1 		= 3,
        //b ||dtc|27,/arb/||||6734
        .v_arb__pos__2 = 'a',
        .v_arb__pos__3 = 'r',
        .v_arb__pos__4 = 'b',
        .v_arb__pos__5 = 0,
        .v_arb__pos__6 = 0,
        .v_arb__pos__7 = 0,
        .v_arb__pos__8 = 0,
        .v_arb__pos__9 = 0,
        //b ||dac|2,k_arb||||6735
        .v_arb__pos__10 		= K_ARB,
        //b ||dac|4,ndarb||||6736
        .v_arb__pos__11 		= (word)(&c.ndarb),
        //b ||ejc|||||6737
        
//      standard variable blocks (continued)
        //b |v_arg|dbc|2,svfnn|||arg|6741
        .v_arg 		= SVFNN,				// arg
        //b ||dac|1,3||||6742
        .v_arg__pos__1 		= 3,
        //b ||dtc|27,/arg/||||6743
        .v_arg__pos__2 = 'a',
        .v_arg__pos__3 = 'r',
        .v_arg__pos__4 = 'g',
        .v_arg__pos__5 = 0,
        .v_arg__pos__6 = 0,
        .v_arg__pos__7 = 0,
        .v_arg__pos__8 = 0,
        .v_arg__pos__9 = 0,
        //b ||dac|6,s_arg||||6744
        .v_arg__pos__10 		= (word)(s_arg),
        //b ||dac|1,2||||6745
        .v_arg__pos__11 		= 2,
        //b |v_bal|dbc|2,svkvc|||bal|6747
        .v_bal 		= SVKVC,				// bal
        //b ||dac|1,3||||6748
        .v_bal__pos__1 		= 3,
        //b ||dtc|27,/bal/||||6749
        .v_bal__pos__2 = 'b',
        .v_bal__pos__3 = 'a',
        .v_bal__pos__4 = 'l',
        .v_bal__pos__5 = 0,
        .v_bal__pos__6 = 0,
        .v_bal__pos__7 = 0,
        .v_bal__pos__8 = 0,
        .v_bal__pos__9 = 0,
        //b ||dac|2,k_bal||||6750
        .v_bal__pos__10 		= K_BAL,
        //b ||dac|4,ndbal||||6751
        .v_bal__pos__11 		= (word)(&c.ndbal),
        //b |v_cos|dbc|2,svfnp|||cos|6754
        .v_cos 		= SVFNP,				// cos
        //b ||dac|1,3||||6755
        .v_cos__pos__1 		= 3,
        //b ||dtc|27,/cos/||||6756
        .v_cos__pos__2 = 'c',
        .v_cos__pos__3 = 'o',
        .v_cos__pos__4 = 's',
        .v_cos__pos__5 = 0,
        .v_cos__pos__6 = 0,
        .v_cos__pos__7 = 0,
        .v_cos__pos__8 = 0,
        .v_cos__pos__9 = 0,
        //b ||dac|6,s_cos||||6757
        .v_cos__pos__10 		= (word)(s_cos),
        //b ||dac|1,1||||6758
        .v_cos__pos__11 		= 1,
        //b |v_end|dbc|2,svlbl|||end|6761
        .v_end 		= SVLBL,				// end
        //b ||dac|1,3||||6762
        .v_end__pos__1 		= 3,
        //b ||dtc|27,/end/||||6763
        .v_end__pos__2 = 'e',
        .v_end__pos__3 = 'n',
        .v_end__pos__4 = 'd',
        .v_end__pos__5 = 0,
        .v_end__pos__6 = 0,
        .v_end__pos__7 = 0,
        .v_end__pos__8 = 0,
        .v_end__pos__9 = 0,
        //b ||dac|6,l_end||||6764
        .v_end__pos__10 		= (word)(l_end),
        //b |v_exp|dbc|2,svfnp|||exp|6767
        .v_exp 		= SVFNP,				// exp
        //b ||dac|1,3||||6768
        .v_exp__pos__1 		= 3,
        //b ||dtc|27,/exp/||||6769
        .v_exp__pos__2 = 'e',
        .v_exp__pos__3 = 'x',
        .v_exp__pos__4 = 'p',
        .v_exp__pos__5 = 0,
        .v_exp__pos__6 = 0,
        .v_exp__pos__7 = 0,
        .v_exp__pos__8 = 0,
        .v_exp__pos__9 = 0,
        //b ||dac|6,s_exp||||6770
        .v_exp__pos__10 		= (word)(s_exp),
        //b ||dac|1,1||||6771
        .v_exp__pos__11 		= 1,
        //b |v_len|dbc|2,svfnp|||len|6774
        .v_len 		= SVFNP,				// len
        //b ||dac|1,3||||6775
        .v_len__pos__1 		= 3,
        //b ||dtc|27,/len/||||6776
        .v_len__pos__2 = 'l',
        .v_len__pos__3 = 'e',
        .v_len__pos__4 = 'n',
        .v_len__pos__5 = 0,
        .v_len__pos__6 = 0,
        .v_len__pos__7 = 0,
        .v_len__pos__8 = 0,
        .v_len__pos__9 = 0,
        //b ||dac|6,s_len||||6777
        .v_len__pos__10 		= (word)(s_len),
        //b ||dac|1,1||||6778
        .v_len__pos__11 		= 1,
        //b |v_leq|dbc|2,svfpr|||leq|6780
        .v_leq 		= SVFPR,				// leq
        //b ||dac|1,3||||6781
        .v_leq__pos__1 		= 3,
        //b ||dtc|27,/leq/||||6782
        .v_leq__pos__2 = 'l',
        .v_leq__pos__3 = 'e',
        .v_leq__pos__4 = 'q',
        .v_leq__pos__5 = 0,
        .v_leq__pos__6 = 0,
        .v_leq__pos__7 = 0,
        .v_leq__pos__8 = 0,
        .v_leq__pos__9 = 0,
        //b ||dac|6,s_leq||||6783
        .v_leq__pos__10 		= (word)(s_leq),
        //b ||dac|1,2||||6784
        .v_leq__pos__11 		= 2,
        //b |v_lge|dbc|2,svfpr|||lge|6786
        .v_lge 		= SVFPR,				// lge
        //b ||dac|1,3||||6787
        .v_lge__pos__1 		= 3,
        //b ||dtc|27,/lge/||||6788
        .v_lge__pos__2 = 'l',
        .v_lge__pos__3 = 'g',
        .v_lge__pos__4 = 'e',
        .v_lge__pos__5 = 0,
        .v_lge__pos__6 = 0,
        .v_lge__pos__7 = 0,
        .v_lge__pos__8 = 0,
        .v_lge__pos__9 = 0,
        //b ||dac|6,s_lge||||6789
        .v_lge__pos__10 		= (word)(s_lge),
        //b ||dac|1,2||||6790
        .v_lge__pos__11 		= 2,
        //b |v_lgt|dbc|2,svfpr|||lgt|6792
        .v_lgt 		= SVFPR,				// lgt
        //b ||dac|1,3||||6793
        .v_lgt__pos__1 		= 3,
        //b ||dtc|27,/lgt/||||6794
        .v_lgt__pos__2 = 'l',
        .v_lgt__pos__3 = 'g',
        .v_lgt__pos__4 = 't',
        .v_lgt__pos__5 = 0,
        .v_lgt__pos__6 = 0,
        .v_lgt__pos__7 = 0,
        .v_lgt__pos__8 = 0,
        .v_lgt__pos__9 = 0,
        //b ||dac|6,s_lgt||||6795
        .v_lgt__pos__10 		= (word)(s_lgt),
        //b ||dac|1,2||||6796
        .v_lgt__pos__11 		= 2,
        //b |v_lle|dbc|2,svfpr|||lle|6798
        .v_lle 		= SVFPR,				// lle
        //b ||dac|1,3||||6799
        .v_lle__pos__1 		= 3,
        //b ||dtc|27,/lle/||||6800
        .v_lle__pos__2 = 'l',
        .v_lle__pos__3 = 'l',
        .v_lle__pos__4 = 'e',
        .v_lle__pos__5 = 0,
        .v_lle__pos__6 = 0,
        .v_lle__pos__7 = 0,
        .v_lle__pos__8 = 0,
        .v_lle__pos__9 = 0,
        //b ||dac|6,s_lle||||6801
        .v_lle__pos__10 		= (word)(s_lle),
        //b ||dac|1,2||||6802
        .v_lle__pos__11 		= 2,
        //b ||ejc|||||6803
        
//      standard variable blocks (continued)
        //b |v_llt|dbc|2,svfpr|||llt|6807
        .v_llt 		= SVFPR,				// llt
        //b ||dac|1,3||||6808
        .v_llt__pos__1 		= 3,
        //b ||dtc|27,/llt/||||6809
        .v_llt__pos__2 = 'l',
        .v_llt__pos__3 = 'l',
        .v_llt__pos__4 = 't',
        .v_llt__pos__5 = 0,
        .v_llt__pos__6 = 0,
        .v_llt__pos__7 = 0,
        .v_llt__pos__8 = 0,
        .v_llt__pos__9 = 0,
        //b ||dac|6,s_llt||||6810
        .v_llt__pos__10 		= (word)(s_llt),
        //b ||dac|1,2||||6811
        .v_llt__pos__11 		= 2,
        //b |v_lne|dbc|2,svfpr|||lne|6813
        .v_lne 		= SVFPR,				// lne
        //b ||dac|1,3||||6814
        .v_lne__pos__1 		= 3,
        //b ||dtc|27,/lne/||||6815
        .v_lne__pos__2 = 'l',
        .v_lne__pos__3 = 'n',
        .v_lne__pos__4 = 'e',
        .v_lne__pos__5 = 0,
        .v_lne__pos__6 = 0,
        .v_lne__pos__7 = 0,
        .v_lne__pos__8 = 0,
        .v_lne__pos__9 = 0,
        //b ||dac|6,s_lne||||6816
        .v_lne__pos__10 		= (word)(s_lne),
        //b ||dac|1,2||||6817
        .v_lne__pos__11 		= 2,
        //b |v_pos|dbc|2,svfnp|||pos|6819
        .v_pos 		= SVFNP,				// pos
        //b ||dac|1,3||||6820
        .v_pos__pos__1 		= 3,
        //b ||dtc|27,/pos/||||6821
        .v_pos__pos__2 = 'p',
        .v_pos__pos__3 = 'o',
        .v_pos__pos__4 = 's',
        .v_pos__pos__5 = 0,
        .v_pos__pos__6 = 0,
        .v_pos__pos__7 = 0,
        .v_pos__pos__8 = 0,
        .v_pos__pos__9 = 0,
        //b ||dac|6,s_pos||||6822
        .v_pos__pos__10 		= (word)(s_pos),
        //b ||dac|1,1||||6823
        .v_pos__pos__11 		= 1,
        //b |v_rem|dbc|2,svkvc|||rem|6825
        .v_rem 		= SVKVC,				// rem
        //b ||dac|1,3||||6826
        .v_rem__pos__1 		= 3,
        //b ||dtc|27,/rem/||||6827
        .v_rem__pos__2 = 'r',
        .v_rem__pos__3 = 'e',
        .v_rem__pos__4 = 'm',
        .v_rem__pos__5 = 0,
        .v_rem__pos__6 = 0,
        .v_rem__pos__7 = 0,
        .v_rem__pos__8 = 0,
        .v_rem__pos__9 = 0,
        //b ||dac|2,k_rem||||6828
        .v_rem__pos__10 		= K_REM,
        //b ||dac|4,ndrem||||6829
        .v_rem__pos__11 		= (word)(&c.ndrem),
        //b |v_sin|dbc|2,svfnp|||sin|6840
        .v_sin 		= SVFNP,				// sin
        //b ||dac|1,3||||6841
        .v_sin__pos__1 		= 3,
        //b ||dtc|27,/sin/||||6842
        .v_sin__pos__2 = 's',
        .v_sin__pos__3 = 'i',
        .v_sin__pos__4 = 'n',
        .v_sin__pos__5 = 0,
        .v_sin__pos__6 = 0,
        .v_sin__pos__7 = 0,
        .v_sin__pos__8 = 0,
        .v_sin__pos__9 = 0,
        //b ||dac|6,s_sin||||6843
        .v_sin__pos__10 		= (word)(s_sin),
        //b ||dac|1,1||||6844
        .v_sin__pos__11 		= 1,
        //b |v_tab|dbc|2,svfnp|||tab|6847
        .v_tab 		= SVFNP,				// tab
        //b ||dac|1,3||||6848
        .v_tab__pos__1 		= 3,
        //b ||dtc|27,/tab/||||6849
        .v_tab__pos__2 = 't',
        .v_tab__pos__3 = 'a',
        .v_tab__pos__4 = 'b',
        .v_tab__pos__5 = 0,
        .v_tab__pos__6 = 0,
        .v_tab__pos__7 = 0,
        .v_tab__pos__8 = 0,
        .v_tab__pos__9 = 0,
        //b ||dac|6,s_tab||||6850
        .v_tab__pos__10 		= (word)(s_tab),
        //b ||dac|1,1||||6851
        .v_tab__pos__11 		= 1,
        //b |v_tan|dbc|2,svfnp|||tan|6854
        .v_tan 		= SVFNP,				// tan
        //b ||dac|1,3||||6855
        .v_tan__pos__1 		= 3,
        //b ||dtc|27,/tan/||||6856
        .v_tan__pos__2 = 't',
        .v_tan__pos__3 = 'a',
        .v_tan__pos__4 = 'n',
        .v_tan__pos__5 = 0,
        .v_tan__pos__6 = 0,
        .v_tan__pos__7 = 0,
        .v_tan__pos__8 = 0,
        .v_tan__pos__9 = 0,
        //b ||dac|6,s_tan||||6857
        .v_tan__pos__10 		= (word)(s_tan),
        //b ||dac|1,1||||6858
        .v_tan__pos__11 		= 1,
        //b |v_atn|dbc|2,svfnp|||atan|6870
        .v_atn 		= SVFNP,				// atan
        //b ||dac|1,4||||6871
        .v_atn__pos__1 		= 4,
        //b ||dtc|27,/atan/||||6872
        .v_atn__pos__2 = 'a',
        .v_atn__pos__3 = 't',
        .v_atn__pos__4 = 'a',
        .v_atn__pos__5 = 'n',
        .v_atn__pos__6 = 0,
        .v_atn__pos__7 = 0,
        .v_atn__pos__8 = 0,
        .v_atn__pos__9 = 0,
        //b ||dac|6,s_atn||||6873
        .v_atn__pos__10 		= (word)(s_atn),
        //b ||dac|1,1||||6874
        .v_atn__pos__11 		= 1,
        //b |v_chr|dbc|2,svfnp|||char|6884
        .v_chr 		= SVFNP,				// char
        //b ||dac|1,4||||6885
        .v_chr__pos__1 		= 4,
        //b ||dtc|27,/char/||||6886
        .v_chr__pos__2 = 'c',
        .v_chr__pos__3 = 'h',
        .v_chr__pos__4 = 'a',
        .v_chr__pos__5 = 'r',
        .v_chr__pos__6 = 0,
        .v_chr__pos__7 = 0,
        .v_chr__pos__8 = 0,
        .v_chr__pos__9 = 0,
        //b ||dac|6,s_chr||||6887
        .v_chr__pos__10 		= (word)(s_chr),
        //b ||dac|1,1||||6888
        .v_chr__pos__11 		= 1,
        //b |v_chp|dbc|2,svfnp|||chop|6892
        .v_chp 		= SVFNP,				// chop
        //b ||dac|1,4||||6893
        .v_chp__pos__1 		= 4,
        //b ||dtc|27,/chop/||||6894
        .v_chp__pos__2 = 'c',
        .v_chp__pos__3 = 'h',
        .v_chp__pos__4 = 'o',
        .v_chp__pos__5 = 'p',
        .v_chp__pos__6 = 0,
        .v_chp__pos__7 = 0,
        .v_chp__pos__8 = 0,
        .v_chp__pos__9 = 0,
        //b ||dac|6,s_chp||||6895
        .v_chp__pos__10 		= (word)(s_chp),
        //b ||dac|1,1||||6896
        .v_chp__pos__11 		= 1,
        //b |v_cod|dbc|2,svfnk|||code|6898
        .v_cod 		= SVFNK,				// code
        //b ||dac|1,4||||6899
        .v_cod__pos__1 		= 4,
        //b ||dtc|27,/code/||||6900
        .v_cod__pos__2 = 'c',
        .v_cod__pos__3 = 'o',
        .v_cod__pos__4 = 'd',
        .v_cod__pos__5 = 'e',
        .v_cod__pos__6 = 0,
        .v_cod__pos__7 = 0,
        .v_cod__pos__8 = 0,
        .v_cod__pos__9 = 0,
        //b ||dac|2,k_cod||||6901
        .v_cod__pos__10 		= K_COD,
        //b ||dac|6,s_cod||||6902
        .v_cod__pos__11 		= (word)(s_cod),
        //b ||dac|1,1||||6903
        .v_cod__pos__12 		= 1,
        //b |v_cop|dbc|2,svfnn|||copy|6905
        .v_cop 		= SVFNN,				// copy
        //b ||dac|1,4||||6906
        .v_cop__pos__1 		= 4,
        //b ||dtc|27,/copy/||||6907
        .v_cop__pos__2 = 'c',
        .v_cop__pos__3 = 'o',
        .v_cop__pos__4 = 'p',
        .v_cop__pos__5 = 'y',
        .v_cop__pos__6 = 0,
        .v_cop__pos__7 = 0,
        .v_cop__pos__8 = 0,
        .v_cop__pos__9 = 0,
        //b ||dac|6,s_cop||||6908
        .v_cop__pos__10 		= (word)(s_cop),
        //b ||dac|1,1||||6909
        .v_cop__pos__11 		= 1,
        //b ||ejc|||||6910
        
//      standard variable blocks (continued)
        //b |v_dat|dbc|2,svfnn|||data|6914
        .v_dat 		= SVFNN,				// data
        //b ||dac|1,4||||6915
        .v_dat__pos__1 		= 4,
        //b ||dtc|27,/data/||||6916
        .v_dat__pos__2 = 'd',
        .v_dat__pos__3 = 'a',
        .v_dat__pos__4 = 't',
        .v_dat__pos__5 = 'a',
        .v_dat__pos__6 = 0,
        .v_dat__pos__7 = 0,
        .v_dat__pos__8 = 0,
        .v_dat__pos__9 = 0,
        //b ||dac|6,s_dat||||6917
        .v_dat__pos__10 		= (word)(s_dat),
        //b ||dac|1,1||||6918
        .v_dat__pos__11 		= 1,
        //b |v_dte|dbc|2,svfnn|||date|6920
        .v_dte 		= SVFNN,				// date
        //b ||dac|1,4||||6921
        .v_dte__pos__1 		= 4,
        //b ||dtc|27,/date/||||6922
        .v_dte__pos__2 = 'd',
        .v_dte__pos__3 = 'a',
        .v_dte__pos__4 = 't',
        .v_dte__pos__5 = 'e',
        .v_dte__pos__6 = 0,
        .v_dte__pos__7 = 0,
        .v_dte__pos__8 = 0,
        .v_dte__pos__9 = 0,
        //b ||dac|6,s_dte||||6923
        .v_dte__pos__10 		= (word)(s_dte),
        //b ||dac|1,1||||6924
        .v_dte__pos__11 		= 1,
        //b |v_dmp|dbc|2,svfnk|||dump|6926
        .v_dmp 		= SVFNK,				// dump
        //b ||dac|1,4||||6927
        .v_dmp__pos__1 		= 4,
        //b ||dtc|27,/dump/||||6928
        .v_dmp__pos__2 = 'd',
        .v_dmp__pos__3 = 'u',
        .v_dmp__pos__4 = 'm',
        .v_dmp__pos__5 = 'p',
        .v_dmp__pos__6 = 0,
        .v_dmp__pos__7 = 0,
        .v_dmp__pos__8 = 0,
        .v_dmp__pos__9 = 0,
        //b ||dac|2,k_dmp||||6929
        .v_dmp__pos__10 		= K_DMP,
        //b ||dac|6,s_dmp||||6930
        .v_dmp__pos__11 		= (word)(s_dmp),
        //b ||dac|1,1||||6931
        .v_dmp__pos__12 		= 1,
        //b |v_dup|dbc|2,svfnn|||dupl|6933
        .v_dup 		= SVFNN,				// dupl
        //b ||dac|1,4||||6934
        .v_dup__pos__1 		= 4,
        //b ||dtc|27,/dupl/||||6935
        .v_dup__pos__2 = 'd',
        .v_dup__pos__3 = 'u',
        .v_dup__pos__4 = 'p',
        .v_dup__pos__5 = 'l',
        .v_dup__pos__6 = 0,
        .v_dup__pos__7 = 0,
        .v_dup__pos__8 = 0,
        .v_dup__pos__9 = 0,
        //b ||dac|6,s_dup||||6936
        .v_dup__pos__10 		= (word)(s_dup),
        //b ||dac|1,2||||6937
        .v_dup__pos__11 		= 2,
        //b |v_evl|dbc|2,svfnn|||eval|6939
        .v_evl 		= SVFNN,				// eval
        //b ||dac|1,4||||6940
        .v_evl__pos__1 		= 4,
        //b ||dtc|27,/eval/||||6941
        .v_evl__pos__2 = 'e',
        .v_evl__pos__3 = 'v',
        .v_evl__pos__4 = 'a',
        .v_evl__pos__5 = 'l',
        .v_evl__pos__6 = 0,
        .v_evl__pos__7 = 0,
        .v_evl__pos__8 = 0,
        .v_evl__pos__9 = 0,
        //b ||dac|6,s_evl||||6942
        .v_evl__pos__10 		= (word)(s_evl),
        //b ||dac|1,1||||6943
        .v_evl__pos__11 		= 1,
        //b |v_ext|dbc|2,svfnn|||exit|6947
        .v_ext 		= SVFNN,				// exit
        //b ||dac|1,4||||6948
        .v_ext__pos__1 		= 4,
        //b ||dtc|27,/exit/||||6949
        .v_ext__pos__2 = 'e',
        .v_ext__pos__3 = 'x',
        .v_ext__pos__4 = 'i',
        .v_ext__pos__5 = 't',
        .v_ext__pos__6 = 0,
        .v_ext__pos__7 = 0,
        .v_ext__pos__8 = 0,
        .v_ext__pos__9 = 0,
        //b ||dac|6,s_ext||||6950
        .v_ext__pos__10 		= (word)(s_ext),
        //b ||dac|1,2||||6951
        .v_ext__pos__11 		= 2,
        //b |v_fal|dbc|2,svkvc|||fail|6954
        .v_fal 		= SVKVC,				// fail
        //b ||dac|1,4||||6955
        .v_fal__pos__1 		= 4,
        //b ||dtc|27,/fail/||||6956
        .v_fal__pos__2 = 'f',
        .v_fal__pos__3 = 'a',
        .v_fal__pos__4 = 'i',
        .v_fal__pos__5 = 'l',
        .v_fal__pos__6 = 0,
        .v_fal__pos__7 = 0,
        .v_fal__pos__8 = 0,
        .v_fal__pos__9 = 0,
        //b ||dac|2,k_fal||||6957
        .v_fal__pos__10 		= K_FAL,
        //b ||dac|4,ndfal||||6958
        .v_fal__pos__11 		= (word)(&c.ndfal),
        //b |v_fil|dbc|2,svknm|||file|6961
        .v_fil 		= SVKNM,				// file
        //b ||dac|1,4||||6962
        .v_fil__pos__1 		= 4,
        //b ||dtc|27,/file/||||6963
        .v_fil__pos__2 = 'f',
        .v_fil__pos__3 = 'i',
        .v_fil__pos__4 = 'l',
        .v_fil__pos__5 = 'e',
        .v_fil__pos__6 = 0,
        .v_fil__pos__7 = 0,
        .v_fil__pos__8 = 0,
        .v_fil__pos__9 = 0,
        //b ||dac|2,k_fil||||6964
        .v_fil__pos__10 		= K_FIL,
        //b |v_hst|dbc|2,svfnn|||host|6967
        .v_hst 		= SVFNN,				// host
        //b ||dac|1,4||||6968
        .v_hst__pos__1 		= 4,
        //b ||dtc|27,/host/||||6969
        .v_hst__pos__2 = 'h',
        .v_hst__pos__3 = 'o',
        .v_hst__pos__4 = 's',
        .v_hst__pos__5 = 't',
        .v_hst__pos__6 = 0,
        .v_hst__pos__7 = 0,
        .v_hst__pos__8 = 0,
        .v_hst__pos__9 = 0,
        //b ||dac|6,s_hst||||6970
        .v_hst__pos__10 		= (word)(s_hst),
        //b ||dac|1,5||||6971
        .v_hst__pos__11 		= 5,
        //b ||ejc|||||6972
        
//      standard variable blocks (continued)
        //b |v_itm|dbc|2,svfnf|||item|6976
        .v_itm 		= SVFNF,				// item
        //b ||dac|1,4||||6977
        .v_itm__pos__1 		= 4,
        //b ||dtc|27,/item/||||6978
        .v_itm__pos__2 = 'i',
        .v_itm__pos__3 = 't',
        .v_itm__pos__4 = 'e',
        .v_itm__pos__5 = 'm',
        .v_itm__pos__6 = 0,
        .v_itm__pos__7 = 0,
        .v_itm__pos__8 = 0,
        .v_itm__pos__9 = 0,
        //b ||dac|6,s_itm||||6979
        .v_itm__pos__10 		= (word)(s_itm),
        //b ||dac|1,999||||6980
        .v_itm__pos__11 		= 999,
        //b |v_lin|dbc|2,svknm|||line|6983
        .v_lin 		= SVKNM,				// line
        //b ||dac|1,4||||6984
        .v_lin__pos__1 		= 4,
        //b ||dtc|27,/line/||||6985
        .v_lin__pos__2 = 'l',
        .v_lin__pos__3 = 'i',
        .v_lin__pos__4 = 'n',
        .v_lin__pos__5 = 'e',
        .v_lin__pos__6 = 0,
        .v_lin__pos__7 = 0,
        .v_lin__pos__8 = 0,
        .v_lin__pos__9 = 0,
        //b ||dac|2,k_lin||||6986
        .v_lin__pos__10 		= K_LIN,
        //b |v_lod|dbc|2,svfnn|||load|6991
        .v_lod 		= SVFNN,				// load
        //b ||dac|1,4||||6992
        .v_lod__pos__1 		= 4,
        //b ||dtc|27,/load/||||6993
        .v_lod__pos__2 = 'l',
        .v_lod__pos__3 = 'o',
        .v_lod__pos__4 = 'a',
        .v_lod__pos__5 = 'd',
        .v_lod__pos__6 = 0,
        .v_lod__pos__7 = 0,
        .v_lod__pos__8 = 0,
        .v_lod__pos__9 = 0,
        //b ||dac|6,s_lod||||6994
        .v_lod__pos__10 		= (word)(s_lod),
        //b ||dac|1,2||||6995
        .v_lod__pos__11 		= 2,
        //b |v_lpd|dbc|2,svfnp|||lpad|6998
        .v_lpd 		= SVFNP,				// lpad
        //b ||dac|1,4||||6999
        .v_lpd__pos__1 		= 4,
        //b ||dtc|27,/lpad/||||7000
        .v_lpd__pos__2 = 'l',
        .v_lpd__pos__3 = 'p',
        .v_lpd__pos__4 = 'a',
        .v_lpd__pos__5 = 'd',
        .v_lpd__pos__6 = 0,
        .v_lpd__pos__7 = 0,
        .v_lpd__pos__8 = 0,
        .v_lpd__pos__9 = 0,
        //b ||dac|6,s_lpd||||7001
        .v_lpd__pos__10 		= (word)(s_lpd),
        //b ||dac|1,3||||7002
        .v_lpd__pos__11 		= 3,
        //b |v_rpd|dbc|2,svfnp|||rpad|7004
        .v_rpd 		= SVFNP,				// rpad
        //b ||dac|1,4||||7005
        .v_rpd__pos__1 		= 4,
        //b ||dtc|27,/rpad/||||7006
        .v_rpd__pos__2 = 'r',
        .v_rpd__pos__3 = 'p',
        .v_rpd__pos__4 = 'a',
        .v_rpd__pos__5 = 'd',
        .v_rpd__pos__6 = 0,
        .v_rpd__pos__7 = 0,
        .v_rpd__pos__8 = 0,
        .v_rpd__pos__9 = 0,
        //b ||dac|6,s_rpd||||7007
        .v_rpd__pos__10 		= (word)(s_rpd),
        //b ||dac|1,3||||7008
        .v_rpd__pos__11 		= 3,
        //b |v_rps|dbc|2,svfnp|||rpos|7010
        .v_rps 		= SVFNP,				// rpos
        //b ||dac|1,4||||7011
        .v_rps__pos__1 		= 4,
        //b ||dtc|27,/rpos/||||7012
        .v_rps__pos__2 = 'r',
        .v_rps__pos__3 = 'p',
        .v_rps__pos__4 = 'o',
        .v_rps__pos__5 = 's',
        .v_rps__pos__6 = 0,
        .v_rps__pos__7 = 0,
        .v_rps__pos__8 = 0,
        .v_rps__pos__9 = 0,
        //b ||dac|6,s_rps||||7013
        .v_rps__pos__10 		= (word)(s_rps),
        //b ||dac|1,1||||7014
        .v_rps__pos__11 		= 1,
        //b |v_rtb|dbc|2,svfnp|||rtab|7016
        .v_rtb 		= SVFNP,				// rtab
        //b ||dac|1,4||||7017
        .v_rtb__pos__1 		= 4,
        //b ||dtc|27,/rtab/||||7018
        .v_rtb__pos__2 = 'r',
        .v_rtb__pos__3 = 't',
        .v_rtb__pos__4 = 'a',
        .v_rtb__pos__5 = 'b',
        .v_rtb__pos__6 = 0,
        .v_rtb__pos__7 = 0,
        .v_rtb__pos__8 = 0,
        .v_rtb__pos__9 = 0,
        //b ||dac|6,s_rtb||||7019
        .v_rtb__pos__10 		= (word)(s_rtb),
        //b ||dac|1,1||||7020
        .v_rtb__pos__11 		= 1,
        //b |v_si_|dbc|2,svfnp|||size|7022
        .v_si_ 		= SVFNP,				// size
        //b ||dac|1,4||||7023
        .v_si___pos__1 		= 4,
        //b ||dtc|27,/size/||||7024
        .v_si___pos__2 = 's',
        .v_si___pos__3 = 'i',
        .v_si___pos__4 = 'z',
        .v_si___pos__5 = 'e',
        .v_si___pos__6 = 0,
        .v_si___pos__7 = 0,
        .v_si___pos__8 = 0,
        .v_si___pos__9 = 0,
        //b ||dac|6,s_si_||||7025
        .v_si___pos__10 		= (word)(s_si_),
        //b ||dac|1,1||||7026
        .v_si___pos__11 		= 1,
        //b |v_srt|dbc|2,svfnn|||sort|7031
        .v_srt 		= SVFNN,				// sort
        //b ||dac|1,4||||7032
        .v_srt__pos__1 		= 4,
        //b ||dtc|27,/sort/||||7033
        .v_srt__pos__2 = 's',
        .v_srt__pos__3 = 'o',
        .v_srt__pos__4 = 'r',
        .v_srt__pos__5 = 't',
        .v_srt__pos__6 = 0,
        .v_srt__pos__7 = 0,
        .v_srt__pos__8 = 0,
        .v_srt__pos__9 = 0,
        //b ||dac|6,s_srt||||7034
        .v_srt__pos__10 		= (word)(s_srt),
        //b ||dac|1,2||||7035
        .v_srt__pos__11 		= 2,
        //b |v_spn|dbc|2,svfnp|||span|7037
        .v_spn 		= SVFNP,				// span
        //b ||dac|1,4||||7038
        .v_spn__pos__1 		= 4,
        //b ||dtc|27,/span/||||7039
        .v_spn__pos__2 = 's',
        .v_spn__pos__3 = 'p',
        .v_spn__pos__4 = 'a',
        .v_spn__pos__5 = 'n',
        .v_spn__pos__6 = 0,
        .v_spn__pos__7 = 0,
        .v_spn__pos__8 = 0,
        .v_spn__pos__9 = 0,
        //b ||dac|6,s_spn||||7040
        .v_spn__pos__10 		= (word)(s_spn),
        //b ||dac|1,1||||7041
        .v_spn__pos__11 		= 1,
        //b ||ejc|||||7042
        
//      standard variable blocks (continued)
        //b |v_sqr|dbc|2,svfnp|||sqrt|7048
        .v_sqr 		= SVFNP,				// sqrt
        //b ||dac|1,4||||7049
        .v_sqr__pos__1 		= 4,
        //b ||dtc|27,/sqrt/||||7050
        .v_sqr__pos__2 = 's',
        .v_sqr__pos__3 = 'q',
        .v_sqr__pos__4 = 'r',
        .v_sqr__pos__5 = 't',
        .v_sqr__pos__6 = 0,
        .v_sqr__pos__7 = 0,
        .v_sqr__pos__8 = 0,
        .v_sqr__pos__9 = 0,
        //b ||dac|6,s_sqr||||7051
        .v_sqr__pos__10 		= (word)(s_sqr),
        //b ||dac|1,1||||7052
        .v_sqr__pos__11 		= 1,
        //b |v_stn|dbc|2,svknm|||stno|7054
        .v_stn 		= SVKNM,				// stno
        //b ||dac|1,4||||7055
        .v_stn__pos__1 		= 4,
        //b ||dtc|27,/stno/||||7056
        .v_stn__pos__2 = 's',
        .v_stn__pos__3 = 't',
        .v_stn__pos__4 = 'n',
        .v_stn__pos__5 = 'o',
        .v_stn__pos__6 = 0,
        .v_stn__pos__7 = 0,
        .v_stn__pos__8 = 0,
        .v_stn__pos__9 = 0,
        //b ||dac|2,k_stn||||7057
        .v_stn__pos__10 		= K_STN,
        //b |v_tim|dbc|2,svfnn|||time|7059
        .v_tim 		= SVFNN,				// time
        //b ||dac|1,4||||7060
        .v_tim__pos__1 		= 4,
        //b ||dtc|27,/time/||||7061
        .v_tim__pos__2 = 't',
        .v_tim__pos__3 = 'i',
        .v_tim__pos__4 = 'm',
        .v_tim__pos__5 = 'e',
        .v_tim__pos__6 = 0,
        .v_tim__pos__7 = 0,
        .v_tim__pos__8 = 0,
        .v_tim__pos__9 = 0,
        //b ||dac|6,s_tim||||7062
        .v_tim__pos__10 		= (word)(s_tim),
        //b ||dac|1,0||||7063
        .v_tim__pos__11 		= 0,
        //b |v_trm|dbc|2,svfnk|||trim|7065
        .v_trm 		= SVFNK,				// trim
        //b ||dac|1,4||||7066
        .v_trm__pos__1 		= 4,
        //b ||dtc|27,/trim/||||7067
        .v_trm__pos__2 = 't',
        .v_trm__pos__3 = 'r',
        .v_trm__pos__4 = 'i',
        .v_trm__pos__5 = 'm',
        .v_trm__pos__6 = 0,
        .v_trm__pos__7 = 0,
        .v_trm__pos__8 = 0,
        .v_trm__pos__9 = 0,
        //b ||dac|2,k_trm||||7068
        .v_trm__pos__10 		= K_TRM,
        //b ||dac|6,s_trm||||7069
        .v_trm__pos__11 		= (word)(s_trm),
        //b ||dac|1,1||||7070
        .v_trm__pos__12 		= 1,
        //b |v_abe|dbc|2,svknm|||abend|7072
        .v_abe 		= SVKNM,				// abend
        //b ||dac|1,5||||7073
        .v_abe__pos__1 		= 5,
        //b ||dtc|27,/abend/||||7074
        .v_abe__pos__2 = 'a',
        .v_abe__pos__3 = 'b',
        .v_abe__pos__4 = 'e',
        .v_abe__pos__5 = 'n',
        .v_abe__pos__6 = 'd',
        .v_abe__pos__7 = 0,
        .v_abe__pos__8 = 0,
        .v_abe__pos__9 = 0,
        //b ||dac|2,k_abe||||7075
        .v_abe__pos__10 		= K_ABE,
        //b |v_abo|dbc|2,svkvl|||abort|7077
        .v_abo 		= SVKVL,				// abort
        //b ||dac|1,5||||7078
        .v_abo__pos__1 		= 5,
        //b ||dtc|27,/abort/||||7079
        .v_abo__pos__2 = 'a',
        .v_abo__pos__3 = 'b',
        .v_abo__pos__4 = 'o',
        .v_abo__pos__5 = 'r',
        .v_abo__pos__6 = 't',
        .v_abo__pos__7 = 0,
        .v_abo__pos__8 = 0,
        .v_abo__pos__9 = 0,
        //b ||dac|2,k_abo||||7080
        .v_abo__pos__10 		= K_ABO,
        //b ||dac|6,l_abo||||7081
        .v_abo__pos__11 		= (word)(l_abo),
        //b ||dac|4,ndabo||||7082
        .v_abo__pos__12 		= (word)(&c.ndabo),
        //b |v_app|dbc|2,svfnf|||apply|7084
        .v_app 		= SVFNF,				// apply
        //b ||dac|1,5||||7085
        .v_app__pos__1 		= 5,
        //b ||dtc|27,/apply/||||7086
        .v_app__pos__2 = 'a',
        .v_app__pos__3 = 'p',
        .v_app__pos__4 = 'p',
        .v_app__pos__5 = 'l',
        .v_app__pos__6 = 'y',
        .v_app__pos__7 = 0,
        .v_app__pos__8 = 0,
        .v_app__pos__9 = 0,
        //b ||dac|6,s_app||||7087
        .v_app__pos__10 		= (word)(s_app),
        //b ||dac|1,999||||7088
        .v_app__pos__11 		= 999,
        //b |v_abn|dbc|2,svfnp|||arbno|7090
        .v_abn 		= SVFNP,				// arbno
        //b ||dac|1,5||||7091
        .v_abn__pos__1 		= 5,
        //b ||dtc|27,/arbno/||||7092
        .v_abn__pos__2 = 'a',
        .v_abn__pos__3 = 'r',
        .v_abn__pos__4 = 'b',
        .v_abn__pos__5 = 'n',
        .v_abn__pos__6 = 'o',
        .v_abn__pos__7 = 0,
        .v_abn__pos__8 = 0,
        .v_abn__pos__9 = 0,
        //b ||dac|6,s_abn||||7093
        .v_abn__pos__10 		= (word)(s_abn),
        //b ||dac|1,1||||7094
        .v_abn__pos__11 		= 1,
        //b |v_arr|dbc|2,svfnn|||array|7096
        .v_arr 		= SVFNN,				// array
        //b ||dac|1,5||||7097
        .v_arr__pos__1 		= 5,
        //b ||dtc|27,/array/||||7098
        .v_arr__pos__2 = 'a',
        .v_arr__pos__3 = 'r',
        .v_arr__pos__4 = 'r',
        .v_arr__pos__5 = 'a',
        .v_arr__pos__6 = 'y',
        .v_arr__pos__7 = 0,
        .v_arr__pos__8 = 0,
        .v_arr__pos__9 = 0,
        //b ||dac|6,s_arr||||7099
        .v_arr__pos__10 		= (word)(s_arr),
        //b ||dac|1,2||||7100
        .v_arr__pos__11 		= 2,
        //b ||ejc|||||7101
        
//      standard variable blocks (continued)
        //b |v_brk|dbc|2,svfnp|||break|7105
        .v_brk 		= SVFNP,				// break
        //b ||dac|1,5||||7106
        .v_brk__pos__1 		= 5,
        //b ||dtc|27,/break/||||7107
        .v_brk__pos__2 = 'b',
        .v_brk__pos__3 = 'r',
        .v_brk__pos__4 = 'e',
        .v_brk__pos__5 = 'a',
        .v_brk__pos__6 = 'k',
        .v_brk__pos__7 = 0,
        .v_brk__pos__8 = 0,
        .v_brk__pos__9 = 0,
        //b ||dac|6,s_brk||||7108
        .v_brk__pos__10 		= (word)(s_brk),
        //b ||dac|1,1||||7109
        .v_brk__pos__11 		= 1,
        //b |v_clr|dbc|2,svfnn|||clear|7111
        .v_clr 		= SVFNN,				// clear
        //b ||dac|1,5||||7112
        .v_clr__pos__1 		= 5,
        //b ||dtc|27,/clear/||||7113
        .v_clr__pos__2 = 'c',
        .v_clr__pos__3 = 'l',
        .v_clr__pos__4 = 'e',
        .v_clr__pos__5 = 'a',
        .v_clr__pos__6 = 'r',
        .v_clr__pos__7 = 0,
        .v_clr__pos__8 = 0,
        .v_clr__pos__9 = 0,
        //b ||dac|6,s_clr||||7114
        .v_clr__pos__10 		= (word)(s_clr),
        //b ||dac|1,1||||7115
        .v_clr__pos__11 		= 1,
        //b |v_ejc|dbc|2,svfnn|||eject|7125
        .v_ejc 		= SVFNN,				// eject
        //b ||dac|1,5||||7126
        .v_ejc__pos__1 		= 5,
        //b ||dtc|27,/eject/||||7127
        .v_ejc__pos__2 = 'e',
        .v_ejc__pos__3 = 'j',
        .v_ejc__pos__4 = 'e',
        .v_ejc__pos__5 = 'c',
        .v_ejc__pos__6 = 't',
        .v_ejc__pos__7 = 0,
        .v_ejc__pos__8 = 0,
        .v_ejc__pos__9 = 0,
        //b ||dac|6,s_ejc||||7128
        .v_ejc__pos__10 		= (word)(s_ejc),
        //b ||dac|1,1||||7129
        .v_ejc__pos__11 		= 1,
        //b |v_fen|dbc|2,svfpk|||fence|7131
        .v_fen 		= SVFPK,				// fence
        //b ||dac|1,5||||7132
        .v_fen__pos__1 		= 5,
        //b ||dtc|27,/fence/||||7133
        .v_fen__pos__2 = 'f',
        .v_fen__pos__3 = 'e',
        .v_fen__pos__4 = 'n',
        .v_fen__pos__5 = 'c',
        .v_fen__pos__6 = 'e',
        .v_fen__pos__7 = 0,
        .v_fen__pos__8 = 0,
        .v_fen__pos__9 = 0,
        //b ||dac|2,k_fen||||7134
        .v_fen__pos__10 		= K_FEN,
        //b ||dac|6,s_fnc||||7135
        .v_fen__pos__11 		= (word)(s_fnc),
        //b ||dac|1,1||||7136
        .v_fen__pos__12 		= 1,
        //b ||dac|4,ndfen||||7137
        .v_fen__pos__13 		= (word)(&c.ndfen),
        //b |v_fld|dbc|2,svfnn|||field|7139
        .v_fld 		= SVFNN,				// field
        //b ||dac|1,5||||7140
        .v_fld__pos__1 		= 5,
        //b ||dtc|27,/field/||||7141
        .v_fld__pos__2 = 'f',
        .v_fld__pos__3 = 'i',
        .v_fld__pos__4 = 'e',
        .v_fld__pos__5 = 'l',
        .v_fld__pos__6 = 'd',
        .v_fld__pos__7 = 0,
        .v_fld__pos__8 = 0,
        .v_fld__pos__9 = 0,
        //b ||dac|6,s_fld||||7142
        .v_fld__pos__10 		= (word)(s_fld),
        //b ||dac|1,2||||7143
        .v_fld__pos__11 		= 2,
        //b |v_idn|dbc|2,svfpr|||ident|7145
        .v_idn 		= SVFPR,				// ident
        //b ||dac|1,5||||7146
        .v_idn__pos__1 		= 5,
        //b ||dtc|27,/ident/||||7147
        .v_idn__pos__2 = 'i',
        .v_idn__pos__3 = 'd',
        .v_idn__pos__4 = 'e',
        .v_idn__pos__5 = 'n',
        .v_idn__pos__6 = 't',
        .v_idn__pos__7 = 0,
        .v_idn__pos__8 = 0,
        .v_idn__pos__9 = 0,
        //b ||dac|6,s_idn||||7148
        .v_idn__pos__10 		= (word)(s_idn),
        //b ||dac|1,2||||7149
        .v_idn__pos__11 		= 2,
        //b |v_inp|dbc|2,svfnk|||input|7151
        .v_inp 		= SVFNK,				// input
        //b ||dac|1,5||||7152
        .v_inp__pos__1 		= 5,
        //b ||dtc|27,/input/||||7153
        .v_inp__pos__2 = 'i',
        .v_inp__pos__3 = 'n',
        .v_inp__pos__4 = 'p',
        .v_inp__pos__5 = 'u',
        .v_inp__pos__6 = 't',
        .v_inp__pos__7 = 0,
        .v_inp__pos__8 = 0,
        .v_inp__pos__9 = 0,
        //b ||dac|2,k_inp||||7154
        .v_inp__pos__10 		= K_INP,
        //b ||dac|6,s_inp||||7155
        .v_inp__pos__11 		= (word)(s_inp),
        //b ||dac|1,3||||7156
        .v_inp__pos__12 		= 3,
        //b |v_lcs|dbc|2,svkwc|||lcase|7159
        .v_lcs 		= SVKWC,				// lcase
        //b ||dac|1,5||||7160
        .v_lcs__pos__1 		= 5,
        //b ||dtc|27,/lcase/||||7161
        .v_lcs__pos__2 = 'l',
        .v_lcs__pos__3 = 'c',
        .v_lcs__pos__4 = 'a',
        .v_lcs__pos__5 = 's',
        .v_lcs__pos__6 = 'e',
        .v_lcs__pos__7 = 0,
        .v_lcs__pos__8 = 0,
        .v_lcs__pos__9 = 0,
        //b ||dac|2,k_lcs||||7162
        .v_lcs__pos__10 		= K_LCS,
        //b |v_loc|dbc|2,svfnn|||local|7165
        .v_loc 		= SVFNN,				// local
        //b ||dac|1,5||||7166
        .v_loc__pos__1 		= 5,
        //b ||dtc|27,/local/||||7167
        .v_loc__pos__2 = 'l',
        .v_loc__pos__3 = 'o',
        .v_loc__pos__4 = 'c',
        .v_loc__pos__5 = 'a',
        .v_loc__pos__6 = 'l',
        .v_loc__pos__7 = 0,
        .v_loc__pos__8 = 0,
        .v_loc__pos__9 = 0,
        //b ||dac|6,s_loc||||7168
        .v_loc__pos__10 		= (word)(s_loc),
        //b ||dac|1,2||||7169
        .v_loc__pos__11 		= 2,
        //b ||ejc|||||7170
        
//      standard variable blocks (continued)
        //b |v_ops|dbc|2,svfnn|||opsyn|7174
        .v_ops 		= SVFNN,				// opsyn
        //b ||dac|1,5||||7175
        .v_ops__pos__1 		= 5,
        //b ||dtc|27,/opsyn/||||7176
        .v_ops__pos__2 = 'o',
        .v_ops__pos__3 = 'p',
        .v_ops__pos__4 = 's',
        .v_ops__pos__5 = 'y',
        .v_ops__pos__6 = 'n',
        .v_ops__pos__7 = 0,
        .v_ops__pos__8 = 0,
        .v_ops__pos__9 = 0,
        //b ||dac|6,s_ops||||7177
        .v_ops__pos__10 		= (word)(s_ops),
        //b ||dac|1,3||||7178
        .v_ops__pos__11 		= 3,
        //b |v_rmd|dbc|2,svfnp|||remdr|7180
        .v_rmd 		= SVFNP,				// remdr
        //b ||dac|1,5||||7181
        .v_rmd__pos__1 		= 5,
        //b ||dtc|27,/remdr/||||7182
        .v_rmd__pos__2 = 'r',
        .v_rmd__pos__3 = 'e',
        .v_rmd__pos__4 = 'm',
        .v_rmd__pos__5 = 'd',
        .v_rmd__pos__6 = 'r',
        .v_rmd__pos__7 = 0,
        .v_rmd__pos__8 = 0,
        .v_rmd__pos__9 = 0,
        //b ||dac|6,s_rmd||||7183
        .v_rmd__pos__10 		= (word)(s_rmd),
        //b ||dac|1,2||||7184
        .v_rmd__pos__11 		= 2,
        //b |v_rsr|dbc|2,svfnn|||rsort|7188
        .v_rsr 		= SVFNN,				// rsort
        //b ||dac|1,5||||7189
        .v_rsr__pos__1 		= 5,
        //b ||dtc|27,/rsort/||||7190
        .v_rsr__pos__2 = 'r',
        .v_rsr__pos__3 = 's',
        .v_rsr__pos__4 = 'o',
        .v_rsr__pos__5 = 'r',
        .v_rsr__pos__6 = 't',
        .v_rsr__pos__7 = 0,
        .v_rsr__pos__8 = 0,
        .v_rsr__pos__9 = 0,
        //b ||dac|6,s_rsr||||7191
        .v_rsr__pos__10 		= (word)(s_rsr),
        //b ||dac|1,2||||7192
        .v_rsr__pos__11 		= 2,
        //b |v_tbl|dbc|2,svfnn|||table|7195
        .v_tbl 		= SVFNN,				// table
        //b ||dac|1,5||||7196
        .v_tbl__pos__1 		= 5,
        //b ||dtc|27,/table/||||7197
        .v_tbl__pos__2 = 't',
        .v_tbl__pos__3 = 'a',
        .v_tbl__pos__4 = 'b',
        .v_tbl__pos__5 = 'l',
        .v_tbl__pos__6 = 'e',
        .v_tbl__pos__7 = 0,
        .v_tbl__pos__8 = 0,
        .v_tbl__pos__9 = 0,
        //b ||dac|6,s_tbl||||7198
        .v_tbl__pos__10 		= (word)(s_tbl),
        //b ||dac|1,3||||7199
        .v_tbl__pos__11 		= 3,
        //b |v_tra|dbc|2,svfnk|||trace|7201
        .v_tra 		= SVFNK,				// trace
        //b ||dac|1,5||||7202
        .v_tra__pos__1 		= 5,
        //b ||dtc|27,/trace/||||7203
        .v_tra__pos__2 = 't',
        .v_tra__pos__3 = 'r',
        .v_tra__pos__4 = 'a',
        .v_tra__pos__5 = 'c',
        .v_tra__pos__6 = 'e',
        .v_tra__pos__7 = 0,
        .v_tra__pos__8 = 0,
        .v_tra__pos__9 = 0,
        //b ||dac|2,k_tra||||7204
        .v_tra__pos__10 		= K_TRA,
        //b ||dac|6,s_tra||||7205
        .v_tra__pos__11 		= (word)(s_tra),
        //b ||dac|1,4||||7206
        .v_tra__pos__12 		= 4,
        //b |v_ucs|dbc|2,svkwc|||ucase|7209
        .v_ucs 		= SVKWC,				// ucase
        //b ||dac|1,5||||7210
        .v_ucs__pos__1 		= 5,
        //b ||dtc|27,/ucase/||||7211
        .v_ucs__pos__2 = 'u',
        .v_ucs__pos__3 = 'c',
        .v_ucs__pos__4 = 'a',
        .v_ucs__pos__5 = 's',
        .v_ucs__pos__6 = 'e',
        .v_ucs__pos__7 = 0,
        .v_ucs__pos__8 = 0,
        .v_ucs__pos__9 = 0,
        //b ||dac|2,k_ucs||||7212
        .v_ucs__pos__10 		= K_UCS,
        //b |v_anc|dbc|2,svknm|||anchor|7215
        .v_anc 		= SVKNM,				// anchor
        //b ||dac|1,6||||7216
        .v_anc__pos__1 		= 6,
        //b ||dtc|27,/anchor/||||7217
        .v_anc__pos__2 = 'a',
        .v_anc__pos__3 = 'n',
        .v_anc__pos__4 = 'c',
        .v_anc__pos__5 = 'h',
        .v_anc__pos__6 = 'o',
        .v_anc__pos__7 = 'r',
        .v_anc__pos__8 = 0,
        .v_anc__pos__9 = 0,
        //b ||dac|2,k_anc||||7218
        .v_anc__pos__10 		= K_ANC,
        //b |v_bkx|dbc|2,svfnp|||breakx|7229
        .v_bkx 		= SVFNP,				// breakx
        //b ||dac|1,6||||7230
        .v_bkx__pos__1 		= 6,
        //b ||dtc|27,/breakx/||||7231
        .v_bkx__pos__2 = 'b',
        .v_bkx__pos__3 = 'r',
        .v_bkx__pos__4 = 'e',
        .v_bkx__pos__5 = 'a',
        .v_bkx__pos__6 = 'k',
        .v_bkx__pos__7 = 'x',
        .v_bkx__pos__8 = 0,
        .v_bkx__pos__9 = 0,
        //b ||dac|6,s_bkx||||7232
        .v_bkx__pos__10 		= (word)(s_bkx),
        //b ||dac|1,1||||7233
        .v_bkx__pos__11 		= 1,
        //b |v_def|dbc|2,svfnn|||define|7244
        .v_def 		= SVFNN,				// define
        //b ||dac|1,6||||7245
        .v_def__pos__1 		= 6,
        //b ||dtc|27,/define/||||7246
        .v_def__pos__2 = 'd',
        .v_def__pos__3 = 'e',
        .v_def__pos__4 = 'f',
        .v_def__pos__5 = 'i',
        .v_def__pos__6 = 'n',
        .v_def__pos__7 = 'e',
        .v_def__pos__8 = 0,
        .v_def__pos__9 = 0,
        //b ||dac|6,s_def||||7247
        .v_def__pos__10 		= (word)(s_def),
        //b ||dac|1,2||||7248
        .v_def__pos__11 		= 2,
        //b |v_det|dbc|2,svfnn|||detach|7250
        .v_det 		= SVFNN,				// detach
        //b ||dac|1,6||||7251
        .v_det__pos__1 		= 6,
        //b ||dtc|27,/detach/||||7252
        .v_det__pos__2 = 'd',
        .v_det__pos__3 = 'e',
        .v_det__pos__4 = 't',
        .v_det__pos__5 = 'a',
        .v_det__pos__6 = 'c',
        .v_det__pos__7 = 'h',
        .v_det__pos__8 = 0,
        .v_det__pos__9 = 0,
        //b ||dac|6,s_det||||7253
        .v_det__pos__10 		= (word)(s_det),
        //b ||dac|1,1||||7254
        .v_det__pos__11 		= 1,
        //b ||ejc|||||7255
        
//      standard variable blocks (continued)
        //b |v_dif|dbc|2,svfpr|||differ|7259
        .v_dif 		= SVFPR,				// differ
        //b ||dac|1,6||||7260
        .v_dif__pos__1 		= 6,
        //b ||dtc|27,/differ/||||7261
        .v_dif__pos__2 = 'd',
        .v_dif__pos__3 = 'i',
        .v_dif__pos__4 = 'f',
        .v_dif__pos__5 = 'f',
        .v_dif__pos__6 = 'e',
        .v_dif__pos__7 = 'r',
        .v_dif__pos__8 = 0,
        .v_dif__pos__9 = 0,
        //b ||dac|6,s_dif||||7262
        .v_dif__pos__10 		= (word)(s_dif),
        //b ||dac|1,2||||7263
        .v_dif__pos__11 		= 2,
        //b |v_ftr|dbc|2,svknm|||ftrace|7265
        .v_ftr 		= SVKNM,				// ftrace
        //b ||dac|1,6||||7266
        .v_ftr__pos__1 		= 6,
        //b ||dtc|27,/ftrace/||||7267
        .v_ftr__pos__2 = 'f',
        .v_ftr__pos__3 = 't',
        .v_ftr__pos__4 = 'r',
        .v_ftr__pos__5 = 'a',
        .v_ftr__pos__6 = 'c',
        .v_ftr__pos__7 = 'e',
        .v_ftr__pos__8 = 0,
        .v_ftr__pos__9 = 0,
        //b ||dac|2,k_ftr||||7268
        .v_ftr__pos__10 		= K_FTR,
        //b |v_lst|dbc|2,svknm|||lastno|7279
        .v_lst 		= SVKNM,				// lastno
        //b ||dac|1,6||||7280
        .v_lst__pos__1 		= 6,
        //b ||dtc|27,/lastno/||||7281
        .v_lst__pos__2 = 'l',
        .v_lst__pos__3 = 'a',
        .v_lst__pos__4 = 's',
        .v_lst__pos__5 = 't',
        .v_lst__pos__6 = 'n',
        .v_lst__pos__7 = 'o',
        .v_lst__pos__8 = 0,
        .v_lst__pos__9 = 0,
        //b ||dac|2,k_lst||||7282
        .v_lst__pos__10 		= K_LST,
        //b |v_nay|dbc|2,svfnp|||notany|7284
        .v_nay 		= SVFNP,				// notany
        //b ||dac|1,6||||7285
        .v_nay__pos__1 		= 6,
        //b ||dtc|27,/notany/||||7286
        .v_nay__pos__2 = 'n',
        .v_nay__pos__3 = 'o',
        .v_nay__pos__4 = 't',
        .v_nay__pos__5 = 'a',
        .v_nay__pos__6 = 'n',
        .v_nay__pos__7 = 'y',
        .v_nay__pos__8 = 0,
        .v_nay__pos__9 = 0,
        //b ||dac|6,s_nay||||7287
        .v_nay__pos__10 		= (word)(s_nay),
        //b ||dac|1,1||||7288
        .v_nay__pos__11 		= 1,
        //b |v_oup|dbc|2,svfnk|||output|7290
        .v_oup 		= SVFNK,				// output
        //b ||dac|1,6||||7291
        .v_oup__pos__1 		= 6,
        //b ||dtc|27,/output/||||7292
        .v_oup__pos__2 = 'o',
        .v_oup__pos__3 = 'u',
        .v_oup__pos__4 = 't',
        .v_oup__pos__5 = 'p',
        .v_oup__pos__6 = 'u',
        .v_oup__pos__7 = 't',
        .v_oup__pos__8 = 0,
        .v_oup__pos__9 = 0,
        //b ||dac|2,k_oup||||7293
        .v_oup__pos__10 		= K_OUP,
        //b ||dac|6,s_oup||||7294
        .v_oup__pos__11 		= (word)(s_oup),
        //b ||dac|1,3||||7295
        .v_oup__pos__12 		= 3,
        //b |v_ret|dbc|2,svlbl|||return|7297
        .v_ret 		= SVLBL,				// return
        //b ||dac|1,6||||7298
        .v_ret__pos__1 		= 6,
        //b ||dtc|27,/return/||||7299
        .v_ret__pos__2 = 'r',
        .v_ret__pos__3 = 'e',
        .v_ret__pos__4 = 't',
        .v_ret__pos__5 = 'u',
        .v_ret__pos__6 = 'r',
        .v_ret__pos__7 = 'n',
        .v_ret__pos__8 = 0,
        .v_ret__pos__9 = 0,
        //b ||dac|6,l_rtn||||7300
        .v_ret__pos__10 		= (word)(l_rtn),
        //b |v_rew|dbc|2,svfnn|||rewind|7302
        .v_rew 		= SVFNN,				// rewind
        //b ||dac|1,6||||7303
        .v_rew__pos__1 		= 6,
        //b ||dtc|27,/rewind/||||7304
        .v_rew__pos__2 = 'r',
        .v_rew__pos__3 = 'e',
        .v_rew__pos__4 = 'w',
        .v_rew__pos__5 = 'i',
        .v_rew__pos__6 = 'n',
        .v_rew__pos__7 = 'd',
        .v_rew__pos__8 = 0,
        .v_rew__pos__9 = 0,
        //b ||dac|6,s_rew||||7305
        .v_rew__pos__10 		= (word)(s_rew),
        //b ||dac|1,1||||7306
        .v_rew__pos__11 		= 1,
        //b |v_stt|dbc|2,svfnn|||stoptr|7308
        .v_stt 		= SVFNN,				// stoptr
        //b ||dac|1,6||||7309
        .v_stt__pos__1 		= 6,
        //b ||dtc|27,/stoptr/||||7310
        .v_stt__pos__2 = 's',
        .v_stt__pos__3 = 't',
        .v_stt__pos__4 = 'o',
        .v_stt__pos__5 = 'p',
        .v_stt__pos__6 = 't',
        .v_stt__pos__7 = 'r',
        .v_stt__pos__8 = 0,
        .v_stt__pos__9 = 0,
        //b ||dac|6,s_stt||||7311
        .v_stt__pos__10 		= (word)(s_stt),
        //b ||dac|1,2||||7312
        .v_stt__pos__11 		= 2,
        //b ||ejc|||||7313
        
//      standard variable blocks (continued)
        //b |v_sub|dbc|2,svfnn|||substr|7317
        .v_sub 		= SVFNN,				// substr
        //b ||dac|1,6||||7318
        .v_sub__pos__1 		= 6,
        //b ||dtc|27,/substr/||||7319
        .v_sub__pos__2 = 's',
        .v_sub__pos__3 = 'u',
        .v_sub__pos__4 = 'b',
        .v_sub__pos__5 = 's',
        .v_sub__pos__6 = 't',
        .v_sub__pos__7 = 'r',
        .v_sub__pos__8 = 0,
        .v_sub__pos__9 = 0,
        //b ||dac|6,s_sub||||7320
        .v_sub__pos__10 		= (word)(s_sub),
        //b ||dac|1,3||||7321
        .v_sub__pos__11 		= 3,
        //b |v_unl|dbc|2,svfnn|||unload|7323
        .v_unl 		= SVFNN,				// unload
        //b ||dac|1,6||||7324
        .v_unl__pos__1 		= 6,
        //b ||dtc|27,/unload/||||7325
        .v_unl__pos__2 = 'u',
        .v_unl__pos__3 = 'n',
        .v_unl__pos__4 = 'l',
        .v_unl__pos__5 = 'o',
        .v_unl__pos__6 = 'a',
        .v_unl__pos__7 = 'd',
        .v_unl__pos__8 = 0,
        .v_unl__pos__9 = 0,
        //b ||dac|6,s_unl||||7326
        .v_unl__pos__10 		= (word)(s_unl),
        //b ||dac|1,1||||7327
        .v_unl__pos__11 		= 1,
        //b |v_col|dbc|2,svfnn|||collect|7329
        .v_col 		= SVFNN,				// collect
        //b ||dac|1,7||||7330
        .v_col__pos__1 		= 7,
        //b ||dtc|27,/collect/||||7331
        .v_col__pos__2 = 'c',
        .v_col__pos__3 = 'o',
        .v_col__pos__4 = 'l',
        .v_col__pos__5 = 'l',
        .v_col__pos__6 = 'e',
        .v_col__pos__7 = 'c',
        .v_col__pos__8 = 't',
        .v_col__pos__9 = 0,
        //b ||dac|6,s_col||||7332
        .v_col__pos__10 		= (word)(s_col),
        //b ||dac|1,1||||7333
        .v_col__pos__11 		= 1,
        //b |v_com|dbc|2,svknm|||compare|7336
        .v_com 		= SVKNM,				// compare
        //b ||dac|1,7||||7337
        .v_com__pos__1 		= 7,
        //b ||dtc|27,/compare/||||7338
        .v_com__pos__2 = 'c',
        .v_com__pos__3 = 'o',
        .v_com__pos__4 = 'm',
        .v_com__pos__5 = 'p',
        .v_com__pos__6 = 'a',
        .v_com__pos__7 = 'r',
        .v_com__pos__8 = 'e',
        .v_com__pos__9 = 0,
        //b ||dac|2,k_com||||7339
        .v_com__pos__10 		= K_COM,
        //b |v_cnv|dbc|2,svfnn|||convert|7342
        .v_cnv 		= SVFNN,				// convert
        //b ||dac|1,7||||7343
        .v_cnv__pos__1 		= 7,
        //b ||dtc|27,/convert/||||7344
        .v_cnv__pos__2 = 'c',
        .v_cnv__pos__3 = 'o',
        .v_cnv__pos__4 = 'n',
        .v_cnv__pos__5 = 'v',
        .v_cnv__pos__6 = 'e',
        .v_cnv__pos__7 = 'r',
        .v_cnv__pos__8 = 't',
        .v_cnv__pos__9 = 0,
        //b ||dac|6,s_cnv||||7345
        .v_cnv__pos__10 		= (word)(s_cnv),
        //b ||dac|1,2||||7346
        .v_cnv__pos__11 		= 2,
        //b |v_enf|dbc|2,svfnn|||endfile|7348
        .v_enf 		= SVFNN,				// endfile
        //b ||dac|1,7||||7349
        .v_enf__pos__1 		= 7,
        //b ||dtc|27,/endfile/||||7350
        .v_enf__pos__2 = 'e',
        .v_enf__pos__3 = 'n',
        .v_enf__pos__4 = 'd',
        .v_enf__pos__5 = 'f',
        .v_enf__pos__6 = 'i',
        .v_enf__pos__7 = 'l',
        .v_enf__pos__8 = 'e',
        .v_enf__pos__9 = 0,
        //b ||dac|6,s_enf||||7351
        .v_enf__pos__10 		= (word)(s_enf),
        //b ||dac|1,1||||7352
        .v_enf__pos__11 		= 1,
        //b |v_etx|dbc|2,svknm|||errtext|7354
        .v_etx 		= SVKNM,				// errtext
        //b ||dac|1,7||||7355
        .v_etx__pos__1 		= 7,
        //b ||dtc|27,/errtext/||||7356
        .v_etx__pos__2 = 'e',
        .v_etx__pos__3 = 'r',
        .v_etx__pos__4 = 'r',
        .v_etx__pos__5 = 't',
        .v_etx__pos__6 = 'e',
        .v_etx__pos__7 = 'x',
        .v_etx__pos__8 = 't',
        .v_etx__pos__9 = 0,
        //b ||dac|2,k_etx||||7357
        .v_etx__pos__10 		= K_ETX,
        //b |v_ert|dbc|2,svknm|||errtype|7359
        .v_ert 		= SVKNM,				// errtype
        //b ||dac|1,7||||7360
        .v_ert__pos__1 		= 7,
        //b ||dtc|27,/errtype/||||7361
        .v_ert__pos__2 = 'e',
        .v_ert__pos__3 = 'r',
        .v_ert__pos__4 = 'r',
        .v_ert__pos__5 = 't',
        .v_ert__pos__6 = 'y',
        .v_ert__pos__7 = 'p',
        .v_ert__pos__8 = 'e',
        .v_ert__pos__9 = 0,
        //b ||dac|2,k_ert||||7362
        .v_ert__pos__10 		= K_ERT,
        //b |v_frt|dbc|2,svlbl|||freturn|7364
        .v_frt 		= SVLBL,				// freturn
        //b ||dac|1,7||||7365
        .v_frt__pos__1 		= 7,
        //b ||dtc|27,/freturn/||||7366
        .v_frt__pos__2 = 'f',
        .v_frt__pos__3 = 'r',
        .v_frt__pos__4 = 'e',
        .v_frt__pos__5 = 't',
        .v_frt__pos__6 = 'u',
        .v_frt__pos__7 = 'r',
        .v_frt__pos__8 = 'n',
        .v_frt__pos__9 = 0,
        //b ||dac|6,l_frt||||7367
        .v_frt__pos__10 		= (word)(l_frt),
        //b |v_int|dbc|2,svfpr|||integer|7369
        .v_int 		= SVFPR,				// integer
        //b ||dac|1,7||||7370
        .v_int__pos__1 		= 7,
        //b ||dtc|27,/integer/||||7371
        .v_int__pos__2 = 'i',
        .v_int__pos__3 = 'n',
        .v_int__pos__4 = 't',
        .v_int__pos__5 = 'e',
        .v_int__pos__6 = 'g',
        .v_int__pos__7 = 'e',
        .v_int__pos__8 = 'r',
        .v_int__pos__9 = 0,
        //b ||dac|6,s_int||||7372
        .v_int__pos__10 		= (word)(s_int),
        //b ||dac|1,1||||7373
        .v_int__pos__11 		= 1,
        //b |v_nrt|dbc|2,svlbl|||nreturn|7375
        .v_nrt 		= SVLBL,				// nreturn
        //b ||dac|1,7||||7376
        .v_nrt__pos__1 		= 7,
        //b ||dtc|27,/nreturn/||||7377
        .v_nrt__pos__2 = 'n',
        .v_nrt__pos__3 = 'r',
        .v_nrt__pos__4 = 'e',
        .v_nrt__pos__5 = 't',
        .v_nrt__pos__6 = 'u',
        .v_nrt__pos__7 = 'r',
        .v_nrt__pos__8 = 'n',
        .v_nrt__pos__9 = 0,
        //b ||dac|6,l_nrt||||7378
        .v_nrt__pos__10 		= (word)(l_nrt),
        //b ||ejc|||||7379
        
//      standard variable blocks (continued)
        //b |v_pfl|dbc|2,svknm|||profile|7386
        .v_pfl 		= SVKNM,				// profile
        //b ||dac|1,7||||7387
        .v_pfl__pos__1 		= 7,
        //b ||dtc|27,/profile/||||7388
        .v_pfl__pos__2 = 'p',
        .v_pfl__pos__3 = 'r',
        .v_pfl__pos__4 = 'o',
        .v_pfl__pos__5 = 'f',
        .v_pfl__pos__6 = 'i',
        .v_pfl__pos__7 = 'l',
        .v_pfl__pos__8 = 'e',
        .v_pfl__pos__9 = 0,
        //b ||dac|2,k_pfl||||7389
        .v_pfl__pos__10 		= K_PFL,
        //b |v_rpl|dbc|2,svfnp|||replace|7392
        .v_rpl 		= SVFNP,				// replace
        //b ||dac|1,7||||7393
        .v_rpl__pos__1 		= 7,
        //b ||dtc|27,/replace/||||7394
        .v_rpl__pos__2 = 'r',
        .v_rpl__pos__3 = 'e',
        .v_rpl__pos__4 = 'p',
        .v_rpl__pos__5 = 'l',
        .v_rpl__pos__6 = 'a',
        .v_rpl__pos__7 = 'c',
        .v_rpl__pos__8 = 'e',
        .v_rpl__pos__9 = 0,
        //b ||dac|6,s_rpl||||7395
        .v_rpl__pos__10 		= (word)(s_rpl),
        //b ||dac|1,3||||7396
        .v_rpl__pos__11 		= 3,
        //b |v_rvs|dbc|2,svfnp|||reverse|7398
        .v_rvs 		= SVFNP,				// reverse
        //b ||dac|1,7||||7399
        .v_rvs__pos__1 		= 7,
        //b ||dtc|27,/reverse/||||7400
        .v_rvs__pos__2 = 'r',
        .v_rvs__pos__3 = 'e',
        .v_rvs__pos__4 = 'v',
        .v_rvs__pos__5 = 'e',
        .v_rvs__pos__6 = 'r',
        .v_rvs__pos__7 = 's',
        .v_rvs__pos__8 = 'e',
        .v_rvs__pos__9 = 0,
        //b ||dac|6,s_rvs||||7401
        .v_rvs__pos__10 		= (word)(s_rvs),
        //b ||dac|1,1||||7402
        .v_rvs__pos__11 		= 1,
        //b |v_rtn|dbc|2,svknm|||rtntype|7404
        .v_rtn 		= SVKNM,				// rtntype
        //b ||dac|1,7||||7405
        .v_rtn__pos__1 		= 7,
        //b ||dtc|27,/rtntype/||||7406
        .v_rtn__pos__2 = 'r',
        .v_rtn__pos__3 = 't',
        .v_rtn__pos__4 = 'n',
        .v_rtn__pos__5 = 't',
        .v_rtn__pos__6 = 'y',
        .v_rtn__pos__7 = 'p',
        .v_rtn__pos__8 = 'e',
        .v_rtn__pos__9 = 0,
        //b ||dac|2,k_rtn||||7407
        .v_rtn__pos__10 		= K_RTN,
        //b |v_stx|dbc|2,svfnn|||setexit|7409
        .v_stx 		= SVFNN,				// setexit
        //b ||dac|1,7||||7410
        .v_stx__pos__1 		= 7,
        //b ||dtc|27,/setexit/||||7411
        .v_stx__pos__2 = 's',
        .v_stx__pos__3 = 'e',
        .v_stx__pos__4 = 't',
        .v_stx__pos__5 = 'e',
        .v_stx__pos__6 = 'x',
        .v_stx__pos__7 = 'i',
        .v_stx__pos__8 = 't',
        .v_stx__pos__9 = 0,
        //b ||dac|6,s_stx||||7412
        .v_stx__pos__10 		= (word)(s_stx),
        //b ||dac|1,1||||7413
        .v_stx__pos__11 		= 1,
        //b |v_stc|dbc|2,svknm|||stcount|7415
        .v_stc 		= SVKNM,				// stcount
        //b ||dac|1,7||||7416
        .v_stc__pos__1 		= 7,
        //b ||dtc|27,/stcount/||||7417
        .v_stc__pos__2 = 's',
        .v_stc__pos__3 = 't',
        .v_stc__pos__4 = 'c',
        .v_stc__pos__5 = 'o',
        .v_stc__pos__6 = 'u',
        .v_stc__pos__7 = 'n',
        .v_stc__pos__8 = 't',
        .v_stc__pos__9 = 0,
        //b ||dac|2,k_stc||||7418
        .v_stc__pos__10 		= K_STC,
        //b |v_stl|dbc|2,svknm|||stlimit|7420
        .v_stl 		= SVKNM,				// stlimit
        //b ||dac|1,7||||7421
        .v_stl__pos__1 		= 7,
        //b ||dtc|27,/stlimit/||||7422
        .v_stl__pos__2 = 's',
        .v_stl__pos__3 = 't',
        .v_stl__pos__4 = 'l',
        .v_stl__pos__5 = 'i',
        .v_stl__pos__6 = 'm',
        .v_stl__pos__7 = 'i',
        .v_stl__pos__8 = 't',
        .v_stl__pos__9 = 0,
        //b ||dac|2,k_stl||||7423
        .v_stl__pos__10 		= K_STL,
        //b |v_suc|dbc|2,svkvc|||succeed|7425
        .v_suc 		= SVKVC,				// succeed
        //b ||dac|1,7||||7426
        .v_suc__pos__1 		= 7,
        //b ||dtc|27,/succeed/||||7427
        .v_suc__pos__2 = 's',
        .v_suc__pos__3 = 'u',
        .v_suc__pos__4 = 'c',
        .v_suc__pos__5 = 'c',
        .v_suc__pos__6 = 'e',
        .v_suc__pos__7 = 'e',
        .v_suc__pos__8 = 'd',
        .v_suc__pos__9 = 0,
        //b ||dac|2,k_suc||||7428
        .v_suc__pos__10 		= K_SUC,
        //b ||dac|4,ndsuc||||7429
        .v_suc__pos__11 		= (word)(&c.ndsuc),
        //b |v_alp|dbc|2,svkwc|||alphabet|7431
        .v_alp 		= SVKWC,				// alphabet
        //b ||dac|1,8||||7432
        .v_alp__pos__1 		= 8,
        //b ||dtc|27,/alphabet/||||7433
        .v_alp__pos__2 = 'a',
        .v_alp__pos__3 = 'l',
        .v_alp__pos__4 = 'p',
        .v_alp__pos__5 = 'h',
        .v_alp__pos__6 = 'a',
        .v_alp__pos__7 = 'b',
        .v_alp__pos__8 = 'e',
        .v_alp__pos__9 = 't',
        .v_alp__pos__10 = 0,
        .v_alp__pos__11 = 0,
        .v_alp__pos__12 = 0,
        .v_alp__pos__13 = 0,
        .v_alp__pos__14 = 0,
        .v_alp__pos__15 = 0,
        .v_alp__pos__16 = 0,
        .v_alp__pos__17 = 0,
        //b ||dac|2,k_alp||||7434
        .v_alp__pos__18 		= K_ALP,
        //b |v_cnt|dbc|2,svlbl|||continue|7436
        .v_cnt 		= SVLBL,				// continue
        //b ||dac|1,8||||7437
        .v_cnt__pos__1 		= 8,
        //b ||dtc|27,/continue/||||7438
        .v_cnt__pos__2 = 'c',
        .v_cnt__pos__3 = 'o',
        .v_cnt__pos__4 = 'n',
        .v_cnt__pos__5 = 't',
        .v_cnt__pos__6 = 'i',
        .v_cnt__pos__7 = 'n',
        .v_cnt__pos__8 = 'u',
        .v_cnt__pos__9 = 'e',
        .v_cnt__pos__10 = 0,
        .v_cnt__pos__11 = 0,
        .v_cnt__pos__12 = 0,
        .v_cnt__pos__13 = 0,
        .v_cnt__pos__14 = 0,
        .v_cnt__pos__15 = 0,
        .v_cnt__pos__16 = 0,
        .v_cnt__pos__17 = 0,
        //b ||dac|6,l_cnt||||7439
        .v_cnt__pos__18 		= (word)(l_cnt),
        //b ||ejc|||||7440
        
//      standard variable blocks (continued)
        //b |v_dtp|dbc|2,svfnp|||datatype|7444
        .v_dtp 		= SVFNP,				// datatype
        //b ||dac|1,8||||7445
        .v_dtp__pos__1 		= 8,
        //b ||dtc|27,/datatype/||||7446
        .v_dtp__pos__2 = 'd',
        .v_dtp__pos__3 = 'a',
        .v_dtp__pos__4 = 't',
        .v_dtp__pos__5 = 'a',
        .v_dtp__pos__6 = 't',
        .v_dtp__pos__7 = 'y',
        .v_dtp__pos__8 = 'p',
        .v_dtp__pos__9 = 'e',
        .v_dtp__pos__10 = 0,
        .v_dtp__pos__11 = 0,
        .v_dtp__pos__12 = 0,
        .v_dtp__pos__13 = 0,
        .v_dtp__pos__14 = 0,
        .v_dtp__pos__15 = 0,
        .v_dtp__pos__16 = 0,
        .v_dtp__pos__17 = 0,
        //b ||dac|6,s_dtp||||7447
        .v_dtp__pos__18 		= (word)(s_dtp),
        //b ||dac|1,1||||7448
        .v_dtp__pos__19 		= 1,
        //b |v_erl|dbc|2,svknm|||errlimit|7450
        .v_erl 		= SVKNM,				// errlimit
        //b ||dac|1,8||||7451
        .v_erl__pos__1 		= 8,
        //b ||dtc|27,/errlimit/||||7452
        .v_erl__pos__2 = 'e',
        .v_erl__pos__3 = 'r',
        .v_erl__pos__4 = 'r',
        .v_erl__pos__5 = 'l',
        .v_erl__pos__6 = 'i',
        .v_erl__pos__7 = 'm',
        .v_erl__pos__8 = 'i',
        .v_erl__pos__9 = 't',
        .v_erl__pos__10 = 0,
        .v_erl__pos__11 = 0,
        .v_erl__pos__12 = 0,
        .v_erl__pos__13 = 0,
        .v_erl__pos__14 = 0,
        .v_erl__pos__15 = 0,
        .v_erl__pos__16 = 0,
        .v_erl__pos__17 = 0,
        //b ||dac|2,k_erl||||7453
        .v_erl__pos__18 		= K_ERL,
        //b |v_fnc|dbc|2,svknm|||fnclevel|7455
        .v_fnc 		= SVKNM,				// fnclevel
        //b ||dac|1,8||||7456
        .v_fnc__pos__1 		= 8,
        //b ||dtc|27,/fnclevel/||||7457
        .v_fnc__pos__2 = 'f',
        .v_fnc__pos__3 = 'n',
        .v_fnc__pos__4 = 'c',
        .v_fnc__pos__5 = 'l',
        .v_fnc__pos__6 = 'e',
        .v_fnc__pos__7 = 'v',
        .v_fnc__pos__8 = 'e',
        .v_fnc__pos__9 = 'l',
        .v_fnc__pos__10 = 0,
        .v_fnc__pos__11 = 0,
        .v_fnc__pos__12 = 0,
        .v_fnc__pos__13 = 0,
        .v_fnc__pos__14 = 0,
        .v_fnc__pos__15 = 0,
        .v_fnc__pos__16 = 0,
        .v_fnc__pos__17 = 0,
        //b ||dac|2,k_fnc||||7458
        .v_fnc__pos__18 		= K_FNC,
        //b |v_fls|dbc|2,svknm|||fullscan|7460
        .v_fls 		= SVKNM,				// fullscan
        //b ||dac|1,8||||7461
        .v_fls__pos__1 		= 8,
        //b ||dtc|27,/fullscan/||||7462
        .v_fls__pos__2 = 'f',
        .v_fls__pos__3 = 'u',
        .v_fls__pos__4 = 'l',
        .v_fls__pos__5 = 'l',
        .v_fls__pos__6 = 's',
        .v_fls__pos__7 = 'c',
        .v_fls__pos__8 = 'a',
        .v_fls__pos__9 = 'n',
        .v_fls__pos__10 = 0,
        .v_fls__pos__11 = 0,
        .v_fls__pos__12 = 0,
        .v_fls__pos__13 = 0,
        .v_fls__pos__14 = 0,
        .v_fls__pos__15 = 0,
        .v_fls__pos__16 = 0,
        .v_fls__pos__17 = 0,
        //b ||dac|2,k_fls||||7463
        .v_fls__pos__18 		= K_FLS,
        //b |v_lfl|dbc|2,svknm|||lastfile|7466
        .v_lfl 		= SVKNM,				// lastfile
        //b ||dac|1,8||||7467
        .v_lfl__pos__1 		= 8,
        //b ||dtc|27,/lastfile/||||7468
        .v_lfl__pos__2 = 'l',
        .v_lfl__pos__3 = 'a',
        .v_lfl__pos__4 = 's',
        .v_lfl__pos__5 = 't',
        .v_lfl__pos__6 = 'f',
        .v_lfl__pos__7 = 'i',
        .v_lfl__pos__8 = 'l',
        .v_lfl__pos__9 = 'e',
        .v_lfl__pos__10 = 0,
        .v_lfl__pos__11 = 0,
        .v_lfl__pos__12 = 0,
        .v_lfl__pos__13 = 0,
        .v_lfl__pos__14 = 0,
        .v_lfl__pos__15 = 0,
        .v_lfl__pos__16 = 0,
        .v_lfl__pos__17 = 0,
        //b ||dac|2,k_lfl||||7469
        .v_lfl__pos__18 		= K_LFL,
        //b |v_lln|dbc|2,svknm|||lastline|7473
        .v_lln 		= SVKNM,				// lastline
        //b ||dac|1,8||||7474
        .v_lln__pos__1 		= 8,
        //b ||dtc|27,/lastline/||||7475
        .v_lln__pos__2 = 'l',
        .v_lln__pos__3 = 'a',
        .v_lln__pos__4 = 's',
        .v_lln__pos__5 = 't',
        .v_lln__pos__6 = 'l',
        .v_lln__pos__7 = 'i',
        .v_lln__pos__8 = 'n',
        .v_lln__pos__9 = 'e',
        .v_lln__pos__10 = 0,
        .v_lln__pos__11 = 0,
        .v_lln__pos__12 = 0,
        .v_lln__pos__13 = 0,
        .v_lln__pos__14 = 0,
        .v_lln__pos__15 = 0,
        .v_lln__pos__16 = 0,
        .v_lln__pos__17 = 0,
        //b ||dac|2,k_lln||||7476
        .v_lln__pos__18 		= K_LLN,
        //b |v_mxl|dbc|2,svknm|||maxlngth|7479
        .v_mxl 		= SVKNM,				// maxlngth
        //b ||dac|1,8||||7480
        .v_mxl__pos__1 		= 8,
        //b ||dtc|27,/maxlngth/||||7481
        .v_mxl__pos__2 = 'm',
        .v_mxl__pos__3 = 'a',
        .v_mxl__pos__4 = 'x',
        .v_mxl__pos__5 = 'l',
        .v_mxl__pos__6 = 'n',
        .v_mxl__pos__7 = 'g',
        .v_mxl__pos__8 = 't',
        .v_mxl__pos__9 = 'h',
        .v_mxl__pos__10 = 0,
        .v_mxl__pos__11 = 0,
        .v_mxl__pos__12 = 0,
        .v_mxl__pos__13 = 0,
        .v_mxl__pos__14 = 0,
        .v_mxl__pos__15 = 0,
        .v_mxl__pos__16 = 0,
        .v_mxl__pos__17 = 0,
        //b ||dac|2,k_mxl||||7482
        .v_mxl__pos__18 		= K_MXL,
        //b |v_ter|dbc|1,0|||terminal|7484
        .v_ter 		= 0,				// terminal
        //b ||dac|1,8||||7485
        .v_ter__pos__1 		= 8,
        //b ||dtc|27,/terminal/||||7486
        .v_ter__pos__2 = 't',
        .v_ter__pos__3 = 'e',
        .v_ter__pos__4 = 'r',
        .v_ter__pos__5 = 'm',
        .v_ter__pos__6 = 'i',
        .v_ter__pos__7 = 'n',
        .v_ter__pos__8 = 'a',
        .v_ter__pos__9 = 'l',
        .v_ter__pos__10 = 0,
        .v_ter__pos__11 = 0,
        .v_ter__pos__12 = 0,
        .v_ter__pos__13 = 0,
        .v_ter__pos__14 = 0,
        .v_ter__pos__15 = 0,
        .v_ter__pos__16 = 0,
        .v_ter__pos__17 = 0,
        //b ||dac|1,0||||7487
        .v_ter__pos__18 		= 0,
        //b |v_bsp|dbc|2,svfnn|||backspace|7490
        .v_bsp 		= SVFNN,				// backspace
        //b ||dac|1,9||||7491
        .v_bsp__pos__1 		= 9,
        //b ||dtc|27,/backspace/||||7492
        .v_bsp__pos__2 = 'b',
        .v_bsp__pos__3 = 'a',
        .v_bsp__pos__4 = 'c',
        .v_bsp__pos__5 = 'k',
        .v_bsp__pos__6 = 's',
        .v_bsp__pos__7 = 'p',
        .v_bsp__pos__8 = 'a',
        .v_bsp__pos__9 = 'c',
        .v_bsp__pos__10 = 'e',
        .v_bsp__pos__11 = 0,
        .v_bsp__pos__12 = 0,
        .v_bsp__pos__13 = 0,
        .v_bsp__pos__14 = 0,
        .v_bsp__pos__15 = 0,
        .v_bsp__pos__16 = 0,
        .v_bsp__pos__17 = 0,
        //b ||dac|6,s_bsp||||7493
        .v_bsp__pos__18 		= (word)(s_bsp),
        //b ||dac|1,1||||7494
        .v_bsp__pos__19 		= 1,
        //b |v_pro|dbc|2,svfnn|||prototype|7497
        .v_pro 		= SVFNN,				// prototype
        //b ||dac|1,9||||7498
        .v_pro__pos__1 		= 9,
        //b ||dtc|27,/prototype/||||7499
        .v_pro__pos__2 = 'p',
        .v_pro__pos__3 = 'r',
        .v_pro__pos__4 = 'o',
        .v_pro__pos__5 = 't',
        .v_pro__pos__6 = 'o',
        .v_pro__pos__7 = 't',
        .v_pro__pos__8 = 'y',
        .v_pro__pos__9 = 'p',
        .v_pro__pos__10 = 'e',
        .v_pro__pos__11 = 0,
        .v_pro__pos__12 = 0,
        .v_pro__pos__13 = 0,
        .v_pro__pos__14 = 0,
        .v_pro__pos__15 = 0,
        .v_pro__pos__16 = 0,
        .v_pro__pos__17 = 0,
        //b ||dac|6,s_pro||||7500
        .v_pro__pos__18 		= (word)(s_pro),
        //b ||dac|1,1||||7501
        .v_pro__pos__19 		= 1,
        //b |v_scn|dbc|2,svlbl|||scontinue|7503
        .v_scn 		= SVLBL,				// scontinue
        //b ||dac|1,9||||7504
        .v_scn__pos__1 		= 9,
        //b ||dtc|27,/scontinue/||||7505
        .v_scn__pos__2 = 's',
        .v_scn__pos__3 = 'c',
        .v_scn__pos__4 = 'o',
        .v_scn__pos__5 = 'n',
        .v_scn__pos__6 = 't',
        .v_scn__pos__7 = 'i',
        .v_scn__pos__8 = 'n',
        .v_scn__pos__9 = 'u',
        .v_scn__pos__10 = 'e',
        .v_scn__pos__11 = 0,
        .v_scn__pos__12 = 0,
        .v_scn__pos__13 = 0,
        .v_scn__pos__14 = 0,
        .v_scn__pos__15 = 0,
        .v_scn__pos__16 = 0,
        .v_scn__pos__17 = 0,
        //b ||dac|6,l_scn||||7506
        .v_scn__pos__18 		= (word)(l_scn),
        //b ||dbc|1,0|||dummy entry to end list|7508
        .v_scn__pos__19 		= 0,				// dummy entry to end list
        //b ||dac|1,10|||length gt 9 (scontinue)|7509
        .v_scn__pos__20 		= 10,				// length gt 9 (scontinue)
        //b ||ejc|||||7510
        
//      list of svblk pointers for keywords to be dumped. the
//      list is in the order which appears on the dump output.
        //b |vdmkw|dac|4,v_anc|||anchor|7515
        .vdmkw 		= (word)(&c.v_anc),				// anchor
        //b ||dac|4,v_cod|||code|7519
        .vdmkw__pos__1 		= (word)(&c.v_cod),				// code
        //b ||dac|1,1|||compare not printed|7524
        .vdmkw__pos__2 		= 1,				// compare not printed
        //b ||dac|4,v_dmp|||dump|7527
        .vdmkw__pos__3 		= (word)(&c.v_dmp),				// dump
        //b ||dac|4,v_erl|||errlimit|7528
        .vdmkw__pos__4 		= (word)(&c.v_erl),				// errlimit
        //b ||dac|4,v_etx|||errtext|7529
        .vdmkw__pos__5 		= (word)(&c.v_etx),				// errtext
        //b ||dac|4,v_ert|||errtype|7530
        .vdmkw__pos__6 		= (word)(&c.v_ert),				// errtype
        //b ||dac|4,v_fil|||file|7532
        .vdmkw__pos__7 		= (word)(&c.v_fil),				// file
        //b ||dac|4,v_fnc|||fnclevel|7534
        .vdmkw__pos__8 		= (word)(&c.v_fnc),				// fnclevel
        //b ||dac|4,v_ftr|||ftrace|7535
        .vdmkw__pos__9 		= (word)(&c.v_ftr),				// ftrace
        //b ||dac|4,v_fls|||fullscan|7536
        .vdmkw__pos__10 		= (word)(&c.v_fls),				// fullscan
        //b ||dac|4,v_inp|||input|7537
        .vdmkw__pos__11 		= (word)(&c.v_inp),				// input
        //b ||dac|4,v_lfl|||lastfile|7539
        .vdmkw__pos__12 		= (word)(&c.v_lfl),				// lastfile
        //b ||dac|4,v_lln|||lastline|7542
        .vdmkw__pos__13 		= (word)(&c.v_lln),				// lastline
        //b ||dac|4,v_lst|||lastno|7544
        .vdmkw__pos__14 		= (word)(&c.v_lst),				// lastno
        //b ||dac|4,v_lin|||line|7546
        .vdmkw__pos__15 		= (word)(&c.v_lin),				// line
        //b ||dac|4,v_mxl|||maxlength|7548
        .vdmkw__pos__16 		= (word)(&c.v_mxl),				// maxlength
        //b ||dac|4,v_oup|||output|7549
        .vdmkw__pos__17 		= (word)(&c.v_oup),				// output
        //b ||dac|4,v_pfl|||profile|7552
        .vdmkw__pos__18 		= (word)(&c.v_pfl),				// profile
        //b ||dac|4,v_rtn|||rtntype|7554
        .vdmkw__pos__19 		= (word)(&c.v_rtn),				// rtntype
        //b ||dac|4,v_stc|||stcount|7555
        .vdmkw__pos__20 		= (word)(&c.v_stc),				// stcount
        //b ||dac|4,v_stl|||stlimit|7556
        .vdmkw__pos__21 		= (word)(&c.v_stl),				// stlimit
        //b ||dac|4,v_stn|||stno|7557
        .vdmkw__pos__22 		= (word)(&c.v_stn),				// stno
        //b ||dac|4,v_tra|||trace|7558
        .vdmkw__pos__23 		= (word)(&c.v_tra),				// trace
        //b ||dac|4,v_trm|||trim|7559
        .vdmkw__pos__24 		= (word)(&c.v_trm),				// trim
        //b ||dac|1,0|||end of list|7560
        .vdmkw__pos__25 		= 0,				// end of list
//      table used by gtnvr to search svblk lists
        //b |vsrch|dac|1,0|||dummy entry to get proper indexing|7564
        .vsrch 		= 0,				// dummy entry to get proper indexing
        //b ||dac|4,v_eqf|||start of 1 char variables (none)|7565
        .vsrch__pos__1 		= (word)(&c.v_eqf),				// start of 1 char variables (none)
        //b ||dac|4,v_eqf|||start of 2 char variables|7566
        .vsrch__pos__2 		= (word)(&c.v_eqf),				// start of 2 char variables
        //b ||dac|4,v_any|||start of 3 char variables|7567
        .vsrch__pos__3 		= (word)(&c.v_any),				// start of 3 char variables
        //b ||dac|4,v_atn|||start of 4 char variables|7569
        .vsrch__pos__4 		= (word)(&c.v_atn),				// start of 4 char variables
        //b ||dac|4,v_abe|||start of 5 char variables|7577
        .vsrch__pos__5 		= (word)(&c.v_abe),				// start of 5 char variables
        //b ||dac|4,v_anc|||start of 6 char variables|7578
        .vsrch__pos__6 		= (word)(&c.v_anc),				// start of 6 char variables
        //b ||dac|4,v_col|||start of 7 char variables|7579
        .vsrch__pos__7 		= (word)(&c.v_col),				// start of 7 char variables
        //b ||dac|4,v_alp|||start of 8 char variables|7580
        .vsrch__pos__8 		= (word)(&c.v_alp),				// start of 8 char variables
        //b ||dac|4,v_bsp|||start of 9 char variables|7582
        .vsrch__pos__9 		= (word)(&c.v_bsp),				// start of 9 char variables
//      last location in constant section
        //b |c_yyy|dac|1,0|||last location in constant section|7589
        .c_yyy 		= 0,				// last location in constant section
        //b ||ttl|27,s p i t b o l -- working storage section||||7590
        /* s p i t b o l -- working storage section*/
//      the working storage section contains areas which are
//      changed during execution of the program. the value
//      assembled is the initial value before execution starts.
//      all these areas are fixed length areas. variable length
//      data is stored in the static or dynamic regions of the
//      allocated data areas.
//      the values in this area are described either as work
//      areas or as global values. a work area is used in an
//      ephemeral manner and the value is not saved from one
//      entry into a routine to another. a global value is a
//      less temporary location whose value is saved from one
//      call to another.
//      w_aaa marks the start of the working section whilst
//      w_yyy marks its end.  g_aaa marks the division between
//      temporary and global values.
//      global values are further subdivided to facilitate
//      processing by the garbage collector. r_aaa through
//      r_yyy are global values that may point into dynamic
//      storage and hence must be relocated after each garbage
//      collection.  they also serve as root pointers to all
//      allocated data that must be preserved.  pointers between
//      a_aaa and r_aaa may point into code, static storage,
//      or mark the limits of dynamic memory.  these pointers
//      must be adjusted when the working section is saved to a
//      file and subsequently reloaded at a different address.
//      a general part of the approach in this program is not
//      to overlap work areas between procedures even though a
//      small amount of space could be saved. such overlap is
//      considered a source of program errors and decreases the
//      information left behind after a system crash of any kind.
//      the names of these locations are labels with five letter
//      (a-y,_) names. as far as possible the order is kept
//      alphabetical by these names but in some cases there
//      are slight departures caused by other order requirements.
//      unless otherwise documented, the order of work areas
//      does not affect the execution of the spitbol program.
        //b ||sec||||start of working storage section|7636
        }; /* struct spitbol_constants c */
        /*-------------------------------------------------------------------- esec03 --------*/
        // constants
        /*-------------------------------------------------------------------- sec04 --------*/
        // working variables
        struct spitbol_variables v = {
        //b ||ejc|||||7637
        
//      this area is not cleared by initial code
        //b |cmlab|dac|6,b_scl|||string used to check label legality|7641
        .cmlab 		= (word)(b_scl),				// string used to check label legality
        //b ||dac|1,2||||7642
        .cmlab__pos__1 		= 2,
        //b ||dtc|27,/  /||||7643
        .cmlab__pos__2 = ' ',
        .cmlab__pos__3 = ' ',
        .cmlab__pos__4 = 0,
        .cmlab__pos__5 = 0,
        .cmlab__pos__6 = 0,
        .cmlab__pos__7 = 0,
        .cmlab__pos__8 = 0,
        .cmlab__pos__9 = 0,
//      label to mark start of work area
        //b |w_aaa|dac|1,0||||7647
        .w_aaa 		= 0,
//      work areas for acess procedure
        //b |actrm|dac|1,0|||trim indicator|7651
        .actrm 		= 0,				// trim indicator
//      work areas for alloc procedure
        //b |aldyn|dac|1,0|||amount of dynamic store|7655
        .aldyn 		= 0,				// amount of dynamic store
        //b |allia|dic|16,+0|||dump ia|7656
        .allia 		= +0,				// dump ia
        //b |allsv|dac|1,0|||save wb in alloc|7657
        .allsv 		= 0,				// save wb in alloc
//      work areas for alost procedure
        //b |alsta|dac|1,0|||save wa in alost|7661
        .alsta 		= 0,				// save wa in alost
//      work areas for array function (s_arr)
        //b |arcdm|dac|1,0|||count dimensions|7665
        .arcdm 		= 0,				// count dimensions
        //b |arnel|dic|16,+0|||count elements|7666
        .arnel 		= +0,				// count elements
        //b |arptr|dac|1,0|||offset ptr into arblk|7667
        .arptr 		= 0,				// offset ptr into arblk
        //b |arsvl|dic|16,+0|||save integer low bound|7668
        .arsvl 		= +0,				// save integer low bound
        //b ||ejc|||||7669
        
//      work areas for arref routine
        //b |arfsi|dic|16,+0|||save current evolving subscript|7673
        .arfsi 		= +0,				// save current evolving subscript
        //b |arfxs|dac|1,0|||save base stack pointer|7674
        .arfxs 		= 0,				// save base stack pointer
//      work areas for b_efc block routine
        //b |befof|dac|1,0|||save offset ptr into efblk|7678
        .befof 		= 0,				// save offset ptr into efblk
//      work areas for b_pfc block routine
        //b |bpfpf|dac|1,0|||save pfblk pointer|7682
        .bpfpf 		= 0,				// save pfblk pointer
        //b |bpfsv|dac|1,0|||save old function value|7683
        .bpfsv 		= 0,				// save old function value
        //b |bpfxt|dac|1,0|||pointer to stacked arguments|7684
        .bpfxt 		= 0,				// pointer to stacked arguments
//      work area for collect function (s_col)
        //b |clsvi|dic|16,+0|||save integer argument|7688
        .clsvi 		= +0,				// save integer argument
//      work areas value for cncrd
        //b |cnscc|dac|1,0|||pointer to control card string|7692
        .cnscc 		= 0,				// pointer to control card string
        //b |cnswc|dac|1,0|||word count|7693
        .cnswc 		= 0,				// word count
        //b |cnr_t|dac|1,0|||pointer to r_ttl or r_stl|7694
        .cnr_t 		= 0,				// pointer to r_ttl or r_stl
//      work areas for convert function (s_cnv)
        //b |cnvtp|dac|1,0|||save ptr into scvtb|7698
        .cnvtp 		= 0,				// save ptr into scvtb
//      work areas for data function (s_dat)
        //b |datdv|dac|1,0|||save vrblk ptr for datatype name|7702
        .datdv 		= 0,				// save vrblk ptr for datatype name
        //b |datxs|dac|1,0|||save initial stack pointer|7703
        .datxs 		= 0,				// save initial stack pointer
//      work areas for define function (s_def)
        //b |deflb|dac|1,0|||save vrblk ptr for label|7707
        .deflb 		= 0,				// save vrblk ptr for label
        //b |defna|dac|1,0|||count function arguments|7708
        .defna 		= 0,				// count function arguments
        //b |defvr|dac|1,0|||save vrblk ptr for function name|7709
        .defvr 		= 0,				// save vrblk ptr for function name
        //b |defxs|dac|1,0|||save initial stack pointer|7710
        .defxs 		= 0,				// save initial stack pointer
//      work areas for dumpr procedure
        //b |dmarg|dac|1,0|||dump argument|7714
        .dmarg 		= 0,				// dump argument
        //b |dmpsa|dac|1,0|||preserve wa over prtvl call|7715
        .dmpsa 		= 0,				// preserve wa over prtvl call
        //b |dmpsb|dac|1,0|||preserve wb over syscm call|7717
        .dmpsb 		= 0,				// preserve wb over syscm call
        //b |dmpsv|dac|1,0|||general scratch save|7719
        .dmpsv 		= 0,				// general scratch save
        //b |dmvch|dac|1,0|||chain pointer for variable blocks|7720
        .dmvch 		= 0,				// chain pointer for variable blocks
        //b |dmpch|dac|1,0|||save sorted vrblk chain pointer|7721
        .dmpch 		= 0,				// save sorted vrblk chain pointer
        //b |dmpkb|dac|1,0|||dummy kvblk for use in dumpr|7722
        .dmpkb 		= 0,				// dummy kvblk for use in dumpr
        //b |dmpkt|dac|1,0|||kvvar trblk ptr (must follow dmpkb)|7723
        .dmpkt 		= 0,				// kvvar trblk ptr (must follow dmpkb)
        //b |dmpkn|dac|1,0|||keyword number (must follow dmpkt)|7724
        .dmpkn 		= 0,				// keyword number (must follow dmpkt)
//      work area for dtach
        //b |dtcnb|dac|1,0|||name base|7728
        .dtcnb 		= 0,				// name base
        //b |dtcnm|dac|1,0|||name ptr|7729
        .dtcnm 		= 0,				// name ptr
//      work areas for dupl function (s_dup)
        //b |dupsi|dic|16,+0|||store integer string length|7733
        .dupsi 		= +0,				// store integer string length
//      work area for endfile (s_enf)
        //b |enfch|dac|1,0|||for iochn chain head|7737
        .enfch 		= 0,				// for iochn chain head
        //b ||ejc|||||7738
        
//      work areas for ertex
        //b |ertwa|dac|1,0|||save wa|7742
        .ertwa 		= 0,				// save wa
        //b |ertwb|dac|1,0|||save wb|7743
        .ertwb 		= 0,				// save wb
//      work areas for evali
        //b |evlin|dac|1,0|||dummy pattern block pcode|7747
        .evlin 		= 0,				// dummy pattern block pcode
        //b |evlis|dac|1,0|||then node (must follow evlin)|7748
        .evlis 		= 0,				// then node (must follow evlin)
        //b |evliv|dac|1,0|||value of parm1 (must follow evlis)|7749
        .evliv 		= 0,				// value of parm1 (must follow evlis)
        //b |evlio|dac|1,0|||ptr to original node|7750
        .evlio 		= 0,				// ptr to original node
        //b |evlif|dac|1,0|||flag for simple/complex argument|7751
        .evlif 		= 0,				// flag for simple/complex argument
//      work area for expan
        //b |expsv|dac|1,0|||save op dope vector pointer|7755
        .expsv 		= 0,				// save op dope vector pointer
//      work areas for gbcol procedure
        //b |gbcfl|dac|1,0|||garbage collector active flag|7759
        .gbcfl 		= 0,				// garbage collector active flag
        //b |gbclm|dac|1,0|||pointer to last move block (pass 3)|7760
        .gbclm 		= 0,				// pointer to last move block (pass 3)
        //b |gbcnm|dac|1,0|||dummy first move block|7761
        .gbcnm 		= 0,				// dummy first move block
        //b |gbcns|dac|1,0|||rest of dummy block (follows gbcnm)|7762
        .gbcns 		= 0,				// rest of dummy block (follows gbcnm)
        //b |gbcia|dic|16,+0|||dump ia|7768
        .gbcia 		= +0,				// dump ia
        //b |gbcsd|dac|1,0|||first address beyond sediment|7769
        .gbcsd 		= 0,				// first address beyond sediment
        //b |gbcsf|dac|1,0|||free space within sediment|7770
        .gbcsf 		= 0,				// free space within sediment
        //b |gbsva|dac|1,0|||save wa|7772
        .gbsva 		= 0,				// save wa
        //b |gbsvb|dac|1,0|||save wb|7773
        .gbsvb 		= 0,				// save wb
        //b |gbsvc|dac|1,0|||save wc|7774
        .gbsvc 		= 0,				// save wc
//      work areas for gtnvr procedure
        //b |gnvhe|dac|1,0|||ptr to end of hash chain|7778
        .gnvhe 		= 0,				// ptr to end of hash chain
        //b |gnvnw|dac|1,0|||number of words in string name|7779
        .gnvnw 		= 0,				// number of words in string name
        //b |gnvsa|dac|1,0|||save wa|7780
        .gnvsa 		= 0,				// save wa
        //b |gnvsb|dac|1,0|||save wb|7781
        .gnvsb 		= 0,				// save wb
        //b |gnvsp|dac|1,0|||pointer into vsrch table|7782
        .gnvsp 		= 0,				// pointer into vsrch table
        //b |gnvst|dac|1,0|||pointer to chars of string|7783
        .gnvst 		= 0,				// pointer to chars of string
//      work areas for gtarr
        //b |gtawa|dac|1,0|||save wa|7787
        .gtawa 		= 0,				// save wa
//      work areas for gtint
        //b |gtina|dac|1,0|||save wa|7791
        .gtina 		= 0,				// save wa
        //b |gtinb|dac|1,0|||save wb|7792
        .gtinb 		= 0,				// save wb
        //b ||ejc|||||7793
        
//      work areas for gtnum procedure
        //b |gtnnf|dac|1,0|||zero/nonzero for result +/-|7797
        .gtnnf 		= 0,				// zero/nonzero for result +/-
        //b |gtnsi|dic|16,+0|||general integer save|7798
        .gtnsi 		= +0,				// general integer save
        //b |gtndf|dac|1,0|||0/1 for dec point so far no/yes|7801
        .gtndf 		= 0,				// 0/1 for dec point so far no/yes
        //b |gtnes|dac|1,0|||zero/nonzero exponent +/-|7802
        .gtnes 		= 0,				// zero/nonzero exponent +/-
        //b |gtnex|dic|16,+0|||real exponent|7803
        .gtnex 		= +0,				// real exponent
        //b |gtnsc|dac|1,0|||scale (places after point)|7804
        .gtnsc 		= 0,				// scale (places after point)
        //b |gtnsr|drc|17,+0.0|||general real save|7805
        .gtnsr 		= (double)+0.0,				// general real save
        //b |gtnrd|dac|1,0|||flag for ok real number|7806
        .gtnrd 		= 0,				// flag for ok real number
//      work areas for gtpat procedure
        //b |gtpsb|dac|1,0|||save wb|7811
        .gtpsb 		= 0,				// save wb
//      work areas for gtstg procedure
        //b |gtssf|dac|1,0|||0/1 for result +/-|7815
        .gtssf 		= 0,				// 0/1 for result +/-
        //b |gtsvc|dac|1,0|||save wc|7816
        .gtsvc 		= 0,				// save wc
        //b |gtsvb|dac|1,0|||save wb|7817
        .gtsvb 		= 0,				// save wb
        //b |gtses|dac|1,0|||char + or - for exponent +/-|7822
        .gtses 		= 0,				// char + or - for exponent +/-
        //b |gtsrs|drc|17,+0.0|||general real save|7823
        .gtsrs 		= (double)+0.0,				// general real save
//      work areas for gtvar procedure
        //b |gtvrc|dac|1,0|||save wc|7829
        .gtvrc 		= 0,				// save wc
//      work areas for ioput
        //b |ioptt|dac|1,0|||type of association|7844
        .ioptt 		= 0,				// type of association
//      work areas for load function
        //b |lodfn|dac|1,0|||pointer to vrblk for func name|7850
        .lodfn 		= 0,				// pointer to vrblk for func name
        //b |lodna|dac|1,0|||count number of arguments|7851
        .lodna 		= 0,				// count number of arguments
//      mxint is value of maximum positive integer. it is computed at runtime to allow
//      the compilation of spitbol on a machine with smaller word size the the target.
        //b |mxint|dac|1,0||||7857
        .mxint 		= 0,
//      work area for profiler
        //b |pfsvw|dac|1,0|||to save a w-reg|7863
        .pfsvw 		= 0,				// to save a w-reg
//      work areas for prtnm procedure
        //b |prnsi|dic|16,+0|||scratch integer loc|7868
        .prnsi 		= +0,				// scratch integer loc
//      work areas for prtsn procedure
        //b |prsna|dac|1,0|||save wa|7872
        .prsna 		= 0,				// save wa
//      work areas for prtst procedure
        //b |prsva|dac|1,0|||save wa|7876
        .prsva 		= 0,				// save wa
        //b |prsvb|dac|1,0|||save wb|7877
        .prsvb 		= 0,				// save wb
        //b |prsvc|dac|1,0|||save char counter|7878
        .prsvc 		= 0,				// save char counter
//      work area for prtnl
        //b |prtsa|dac|1,0|||save wa|7882
        .prtsa 		= 0,				// save wa
        //b |prtsb|dac|1,0|||save wb|7883
        .prtsb 		= 0,				// save wb
//      work area for prtvl
        //b |prvsi|dac|1,0|||save idval|7887
        .prvsi 		= 0,				// save idval
//      work areas for pattern match routines
        //b |psave|dac|1,0|||temporary save for current node ptr|7891
        .psave 		= 0,				// temporary save for current node ptr
        //b |psavc|dac|1,0|||save cursor in p_spn, p_str|7892
        .psavc 		= 0,				// save cursor in p_spn, p_str
//      work area for relaj routine
        //b |rlals|dac|1,0|||ptr to list of bounds and adjusts|7897
        .rlals 		= 0,				// ptr to list of bounds and adjusts
//      work area for reldn routine
        //b |rldcd|dac|1,0|||save code adjustment|7901
        .rldcd 		= 0,				// save code adjustment
        //b |rldst|dac|1,0|||save static adjustment|7902
        .rldst 		= 0,				// save static adjustment
        //b |rldls|dac|1,0|||save list pointer|7903
        .rldls 		= 0,				// save list pointer
//      work areas for retrn routine
        //b |rtnbp|dac|1,0|||to save a block pointer|7908
        .rtnbp 		= 0,				// to save a block pointer
        //b |rtnfv|dac|1,0|||new function value (result)|7909
        .rtnfv 		= 0,				// new function value (result)
        //b |rtnsv|dac|1,0|||old function value (saved value)|7910
        .rtnsv 		= 0,				// old function value (saved value)
//      work areas for substr function (s_sub)
        //b |sbssv|dac|1,0|||save third argument|7914
        .sbssv 		= 0,				// save third argument
//      work areas for scan procedure
        //b |scnsa|dac|1,0|||save wa|7918
        .scnsa 		= 0,				// save wa
        //b |scnsb|dac|1,0|||save wb|7919
        .scnsb 		= 0,				// save wb
        //b |scnsc|dac|1,0|||save wc|7920
        .scnsc 		= 0,				// save wc
        //b |scnof|dac|1,0|||save offset|7921
        .scnof 		= 0,				// save offset
        //b ||ejc|||||7924
        
//      work area used by sorta, sortc, sortf, sorth
        //b |srtdf|dac|1,0|||datatype field name|7928
        .srtdf 		= 0,				// datatype field name
        //b |srtfd|dac|1,0|||found dfblk address|7929
        .srtfd 		= 0,				// found dfblk address
        //b |srtff|dac|1,0|||found field name|7930
        .srtff 		= 0,				// found field name
        //b |srtfo|dac|1,0|||offset to field name|7931
        .srtfo 		= 0,				// offset to field name
        //b |srtnr|dac|1,0|||number of rows|7932
        .srtnr 		= 0,				// number of rows
        //b |srtof|dac|1,0|||offset within row to sort key|7933
        .srtof 		= 0,				// offset within row to sort key
        //b |srtrt|dac|1,0|||root offset|7934
        .srtrt 		= 0,				// root offset
        //b |srts1|dac|1,0|||save offset 1|7935
        .srts1 		= 0,				// save offset 1
        //b |srts2|dac|1,0|||save offset 2|7936
        .srts2 		= 0,				// save offset 2
        //b |srtsc|dac|1,0|||save wc|7937
        .srtsc 		= 0,				// save wc
        //b |srtsf|dac|1,0|||sort array first row offset|7938
        .srtsf 		= 0,				// sort array first row offset
        //b |srtsn|dac|1,0|||save n|7939
        .srtsn 		= 0,				// save n
        //b |srtso|dac|1,0|||offset to a(0)|7940
        .srtso 		= 0,				// offset to a(0)
        //b |srtsr|dac|1,0|||0, non-zero for sort, rsort|7941
        .srtsr 		= 0,				// 0, non-zero for sort, rsort
        //b |srtst|dac|1,0|||stride from one row to next|7942
        .srtst 		= 0,				// stride from one row to next
        //b |srtwc|dac|1,0|||dump wc|7943
        .srtwc 		= 0,				// dump wc
//      work areas for stopr routine
        //b |stpsi|dic|16,+0|||save value of stcount|7948
        .stpsi 		= +0,				// save value of stcount
        //b |stpti|dic|16,+0|||save time elapsed|7949
        .stpti 		= +0,				// save time elapsed
//      work areas for tfind procedure
        //b |tfnsi|dic|16,+0|||number of headers|7953
        .tfnsi 		= +0,				// number of headers
//      work areas for xscan procedure
        //b |xscrt|dac|1,0|||save return code|7957
        .xscrt 		= 0,				// save return code
        //b |xscwb|dac|1,0|||save register wb|7958
        .xscwb 		= 0,				// save register wb
//      start of global values in working section
        //b |g_aaa|dac|1,0||||7962
        .g_aaa 		= 0,
//      global value for alloc procedure
        //b |alfsf|dic|16,+0|||factor in free store pcntage check|7966
        .alfsf 		= +0,				// factor in free store pcntage check
//      global values for cmpil procedure
        //b |cmerc|dac|1,0|||count of initial compile errors|7970
        .cmerc 		= 0,				// count of initial compile errors
        //b |cmpln|dac|1,0|||line number of first line of stmt|7971
        .cmpln 		= 0,				// line number of first line of stmt
        //b |cmpxs|dac|1,0|||save stack ptr in case of errors|7972
        .cmpxs 		= 0,				// save stack ptr in case of errors
        //b |cmpsn|dac|1,1|||number of next statement to compile|7973
        .cmpsn 		= 1,				// number of next statement to compile
//      global values for cncrd
        //b |cnsil|dac|1,0|||save scnil during include process.|7978
        .cnsil 		= 0,				// save scnil during include process.
        //b |cnind|dac|1,0|||current include file nest level|7979
        .cnind 		= 0,				// current include file nest level
        //b |cnspt|dac|1,0|||save scnpt during include process.|7980
        .cnspt 		= 0,				// save scnpt during include process.
        //b |cnttl|dac|1,0|||flag for -title, -stitl|7982
        .cnttl 		= 0,				// flag for -title, -stitl
//      global flag for suppression of compilation statistics.
        //b |cpsts|dac|1,0|||suppress comp. stats if non zero|7986
        .cpsts 		= 0,				// suppress comp. stats if non zero
//      global values for control card switches
        //b |cswdb|dac|1,0|||0/1 for -single/-double|7990
        .cswdb 		= 0,				// 0/1 for -single/-double
        //b |cswer|dac|1,0|||0/1 for -errors/-noerrors|7991
        .cswer 		= 0,				// 0/1 for -errors/-noerrors
        //b |cswex|dac|1,0|||0/1 for -execute/-noexecute|7992
        .cswex 		= 0,				// 0/1 for -execute/-noexecute
        //b |cswfl|dac|1,1|||0/1 for -nofail/-fail|7993
        .cswfl 		= 1,				// 0/1 for -nofail/-fail
        //b |cswin|dac|2,iniln|||xxx for -inxxx|7994
        .cswin 		= INILN,				// xxx for -inxxx
        //b |cswls|dac|1,1|||0/1 for -nolist/-list|7995
        .cswls 		= 1,				// 0/1 for -nolist/-list
        //b |cswno|dac|1,0|||0/1 for -optimise/-noopt|7996
        .cswno 		= 0,				// 0/1 for -optimise/-noopt
        //b |cswpr|dac|1,0|||0/1 for -noprint/-print|7997
        .cswpr 		= 0,				// 0/1 for -noprint/-print
//      global location used by patst procedure
        //b |ctmsk|dbc|1,0|||last bit position used in r_ctp|8001
        .ctmsk 		= 0,				// last bit position used in r_ctp
        //b |curid|dac|1,0|||current id value|8002
        .curid 		= 0,				// current id value
        //b ||ejc|||||8003
        
//      global value for cdwrd procedure
        //b |cwcof|dac|1,0|||next word offset in current ccblk|8007
        .cwcof 		= 0,				// next word offset in current ccblk
//      global locations for dynamic storage pointers
        //b |dnams|dac|1,0|||size of sediment in baus|8012
        .dnams 		= 0,				// size of sediment in baus
//      global area for error processing.
        //b |erich|dac|1,0|||copy error reports to int.chan if 1|8017
        .erich 		= 0,				// copy error reports to int.chan if 1
        //b |erlst|dac|1,0|||for listr when errors go to int.ch.|8018
        .erlst 		= 0,				// for listr when errors go to int.ch.
        //b |errft|dac|1,0|||fatal error flag|8019
        .errft 		= 0,				// fatal error flag
        //b |errsp|dac|1,0|||error suppression flag|8020
        .errsp 		= 0,				// error suppression flag
//      global flag for suppression of execution stats
        //b |exsts|dac|1,0|||suppress exec stats if set|8024
        .exsts 		= 0,				// suppress exec stats if set
//      global values for exfal and return
        //b |flprt|dac|1,0|||location of fail offset for return|8028
        .flprt 		= 0,				// location of fail offset for return
        //b |flptr|dac|1,0|||location of failure offset on stack|8029
        .flptr 		= 0,				// location of failure offset on stack
//      global location to count garbage collections (gbcol)
        //b |gbsed|dic|16,+0|||factor in sediment pcntage check|8034
        .gbsed 		= +0,				// factor in sediment pcntage check
        //b |gbcnt|dac|1,0|||count of garbage collections|8036
        .gbcnt 		= 0,				// count of garbage collections
//      global value for gtcod and gtexp
        //b |gtcef|dac|1,0|||save fail ptr in case of error|8040
        .gtcef 		= 0,				// save fail ptr in case of error
//      global locations for gtstg procedure
        //b |gtsrn|drc|17,+0.0|||rounding factor 0.5*10**-cfp_s|8048
        .gtsrn 		= (double)+0.0,				// rounding factor 0.5*10**-cfp_s
        //b |gtssc|drc|17,+0.0|||scaling value 10**cfp_s|8049
        .gtssc 		= (double)+0.0,				// scaling value 10**cfp_s
        //b |gtswk|dac|1,0|||ptr to work area for gtstg|8052
        .gtswk 		= 0,				// ptr to work area for gtstg
//      global flag for header printing
        //b |headp|dac|1,0|||header printed flag|8056
        .headp 		= 0,				// header printed flag
//      global values for variable hash table
        //b |hshnb|dic|16,+0|||number of hash buckets|8060
        .hshnb 		= +0,				// number of hash buckets
//      global areas for init
        //b |initr|dac|1,0|||save terminal flag|8064
        .initr 		= 0,				// save terminal flag
        //b ||ejc|||||8065
        
//      global values for keyword values which are stored as one
//      word integers. these values must be assembled in the
//      following order (as dictated by k_xxx definition values).
        //b |kvabe|dac|1,0|||abend|8071
        .kvabe 		= 0,				// abend
        //b |kvanc|dac|1,1|||anchor|8072
        .kvanc 		= 1,				// anchor
        //b |kvcod|dac|1,0|||code|8076
        .kvcod 		= 0,				// code
        //b |kvcom|dac|1,0|||compare|8078
        .kvcom 		= 0,				// compare
        //b |kvdmp|dac|1,0|||dump|8080
        .kvdmp 		= 0,				// dump
        //b |kverl|dac|1,0|||errlimit|8081
        .kverl 		= 0,				// errlimit
        //b |kvert|dac|1,0|||errtype|8082
        .kvert 		= 0,				// errtype
        //b |kvftr|dac|1,0|||ftrace|8083
        .kvftr 		= 0,				// ftrace
        //b |kvfls|dac|1,1|||fullscan|8084
        .kvfls 		= 1,				// fullscan
        //b |kvinp|dac|1,1|||input|8085
        .kvinp 		= 1,				// input
        //b |kvmxl|dac|1,5000|||maxlength|8086
        .kvmxl 		= 5000,				// maxlength
        //b |kvoup|dac|1,1|||output|8087
        .kvoup 		= 1,				// output
        //b |kvpfl|dac|1,0|||profile|8090
        .kvpfl 		= 0,				// profile
        //b |kvtra|dac|1,0|||trace|8092
        .kvtra 		= 0,				// trace
        //b |kvtrm|dac|1,1|||trim|8093
        .kvtrm 		= 1,				// trim
        //b |kvfnc|dac|1,0|||fnclevel|8094
        .kvfnc 		= 0,				// fnclevel
        //b |kvlst|dac|1,0|||lastno|8095
        .kvlst 		= 0,				// lastno
        //b |kvlln|dac|1,0|||lastline|8097
        .kvlln 		= 0,				// lastline
        //b |kvlin|dac|1,0|||line|8098
        .kvlin 		= 0,				// line
        //b |kvstn|dac|1,0|||stno|8100
        .kvstn 		= 0,				// stno
//      global values for other keywords
        //b |kvalp|dac|1,0|||alphabet|8104
        .kvalp 		= 0,				// alphabet
        //b |kvrtn|dac|4,nulls|||rtntype (scblk pointer)|8105
        .kvrtn 		= (word)(&c.nulls),				// rtntype (scblk pointer)
        //b |kvstl|dic|16,+2147483647|||stlimit|8111
        .kvstl 		= +2147483647,				// stlimit
        //b |kvstc|dic|16,+2147483647|||stcount (counts down from stlimit)|8112
        .kvstc 		= +2147483647,				// stcount (counts down from stlimit)
//      global values for listr procedure
        //b |lstid|dac|1,0|||include depth of current image|8122
        .lstid 		= 0,				// include depth of current image
        //b |lstlc|dac|1,0|||count lines on source list page|8124
        .lstlc 		= 0,				// count lines on source list page
        //b |lstnp|dac|1,0|||max number of lines on page|8125
        .lstnp 		= 0,				// max number of lines on page
        //b |lstpf|dac|1,1|||set nonzero if current image listed|8126
        .lstpf 		= 1,				// set nonzero if current image listed
        //b |lstpg|dac|1,0|||current source list page number|8127
        .lstpg 		= 0,				// current source list page number
        //b |lstpo|dac|1,0|||offset to   page nnn   message|8128
        .lstpo 		= 0,				// offset to   page nnn   message
        //b |lstsn|dac|1,0|||remember last stmnum listed|8129
        .lstsn 		= 0,				// remember last stmnum listed
//      global maximum size of spitbol objects
        //b |mxlen|dac|1,0|||initialised by sysmx call|8133
        .mxlen 		= 0,				// initialised by sysmx call
//      global execution control variable
        //b |noxeq|dac|1,0|||set non-zero to inhibit execution|8137
        .noxeq 		= 0,				// set non-zero to inhibit execution
//      global profiler values locations
        //b |pfdmp|dac|1,0|||set non-0 if &profile set non-0|8143
        .pfdmp 		= 0,				// set non-0 if &profile set non-0
        //b |pffnc|dac|1,0|||set non-0 if funct just entered|8144
        .pffnc 		= 0,				// set non-0 if funct just entered
        //b |pfstm|dic|16,+0|||to store starting time of stmt|8145
        .pfstm 		= +0,				// to store starting time of stmt
        //b |pfetm|dic|16,+0|||to store ending time of stmt|8146
        .pfetm 		= +0,				// to store ending time of stmt
        //b |pfnte|dac|1,0|||nr of table entries|8147
        .pfnte 		= 0,				// nr of table entries
        //b |pfste|dic|16,+0|||gets int rep of table entry size|8148
        .pfste 		= +0,				// gets int rep of table entry size
        //b ||ejc|||||8151
        
//      global values used in pattern match routines
        //b |pmdfl|dac|1,0|||pattern assignment flag|8155
        .pmdfl 		= 0,				// pattern assignment flag
        //b |pmhbs|dac|1,0|||history stack base pointer|8156
        .pmhbs 		= 0,				// history stack base pointer
        //b |pmssl|dac|1,0|||length of subject string in chars|8157
        .pmssl 		= 0,				// length of subject string in chars
//      global values for interface polling (syspl)
        //b |polcs|dac|1,1|||poll interval start value|8162
        .polcs 		= 1,				// poll interval start value
        //b |polct|dac|1,1|||poll interval counter|8163
        .polct 		= 1,				// poll interval counter
//      global flags used for standard file listing options
        //b |prich|dac|1,0|||printer on interactive channel|8168
        .prich 		= 0,				// printer on interactive channel
        //b |prstd|dac|1,0|||tested by prtpg|8169
        .prstd 		= 0,				// tested by prtpg
        //b |prsto|dac|1,0|||standard listing option flag|8170
        .prsto 		= 0,				// standard listing option flag
//      global values for print procedures
        //b |prbuf|dac|1,0|||ptr to print bfr in static|8174
        .prbuf 		= 0,				// ptr to print bfr in static
        //b |precl|dac|1,0|||extended/compact listing flag|8175
        .precl 		= 0,				// extended/compact listing flag
        //b |prlen|dac|1,0|||length of print buffer in chars|8176
        .prlen 		= 0,				// length of print buffer in chars
        //b |prlnw|dac|1,0|||length of print buffer in words|8177
        .prlnw 		= 0,				// length of print buffer in words
        //b |profs|dac|1,0|||offset to next location in prbuf|8178
        .profs 		= 0,				// offset to next location in prbuf
        //b |prtef|dac|1,0|||endfile flag|8179
        .prtef 		= 0,				// endfile flag
        //b ||ejc|||||8180
        
//      global area for readr
        //b |rdcln|dac|1,0|||current statement line number|8184
        .rdcln 		= 0,				// current statement line number
        //b |rdnln|dac|1,0|||next statement line number|8185
        .rdnln 		= 0,				// next statement line number
//      global amount of memory reserved for end of execution
        //b |rsmem|dac|1,0|||reserve memory|8189
        .rsmem 		= 0,				// reserve memory
//      global area for stmgo counters
        //b |stmcs|dac|1,1|||counter startup value|8193
        .stmcs 		= 1,				// counter startup value
        //b |stmct|dac|1,1|||counter active value|8194
        .stmct 		= 1,				// counter active value
//      adjustable global values
//      all the pointers in this section can point to the
//      dynamic or the static region.
//      when a save file is reloaded, these pointers must
//      be adjusted if static or dynamic memory is now
//      at a different address.  see routine reloc for
//      additional information.
//      some values cannot be move here because of adjacency
//      constraints.  they are handled specially by reloc et al.
//      these values are kvrtn,
//      values gtswk, kvalp, and prbuf are reinitialized by
//      procedure insta, and do not need to appear here.
//      values flprt, flptr, gtcef, and stbas point into the
//      stack and are explicitly adjusted by osint's restart
//      procedure.
        //b |a_aaa|dac|1,0|||start of adjustable values|8216
        .a_aaa 		= 0,				// start of adjustable values
        //b |cmpss|dac|1,0|||save subroutine stack ptr|8217
        .cmpss 		= 0,				// save subroutine stack ptr
        //b |dnamb|dac|1,0|||start of dynamic area|8218
        .dnamb 		= 0,				// start of dynamic area
        //b |dnamp|dac|1,0|||next available loc in dynamic area|8219
        .dnamp 		= 0,				// next available loc in dynamic area
        //b |dname|dac|1,0|||end of available dynamic area|8220
        .dname 		= 0,				// end of available dynamic area
        //b |hshtb|dac|1,0|||pointer to start of vrblk hash tabl|8221
        .hshtb 		= 0,				// pointer to start of vrblk hash tabl
        //b |hshte|dac|1,0|||pointer past end of vrblk hash tabl|8222
        .hshte 		= 0,				// pointer past end of vrblk hash tabl
        //b |iniss|dac|1,0|||save subroutine stack ptr|8223
        .iniss 		= 0,				// save subroutine stack ptr
        //b |pftbl|dac|1,0|||gets adrs of (imag) table base|8224
        .pftbl 		= 0,				// gets adrs of (imag) table base
        //b |prnmv|dac|1,0|||vrblk ptr from last name search|8225
        .prnmv 		= 0,				// vrblk ptr from last name search
        //b |statb|dac|1,0|||start of static area|8226
        .statb 		= 0,				// start of static area
        //b |state|dac|1,0|||end of static area|8227
        .state 		= 0,				// end of static area
        //b |stxvr|dac|4,nulls|||vrblk pointer or null|8228
        .stxvr 		= (word)(&c.nulls),				// vrblk pointer or null
//      relocatable global values
//      all the pointers in this section can point to blocks in
//      the dynamic storage area and must be relocated by the
//      garbage collector. they are identified by r_xxx names.
        //b |r_aaa|dac|1,0|||start of relocatable values|8237
        .r_aaa 		= 0,				// start of relocatable values
        //b |r_arf|dac|1,0|||array block pointer for arref|8238
        .r_arf 		= 0,				// array block pointer for arref
        //b |r_ccb|dac|1,0|||ptr to ccblk being built (cdwrd)|8239
        .r_ccb 		= 0,				// ptr to ccblk being built (cdwrd)
        //b |r_cim|dac|1,0|||ptr to current compiler input str|8240
        .r_cim 		= 0,				// ptr to current compiler input str
        //b |r_cmp|dac|1,0|||copy of r_cim used in cmpil|8241
        .r_cmp 		= 0,				// copy of r_cim used in cmpil
        //b |r_cni|dac|1,0|||ptr to next compiler input string|8242
        .r_cni 		= 0,				// ptr to next compiler input string
        //b |r_cnt|dac|1,0|||cdblk pointer for setexit continue|8243
        .r_cnt 		= 0,				// cdblk pointer for setexit continue
        //b |r_cod|dac|1,0|||pointer to current cdblk or exblk|8244
        .r_cod 		= 0,				// pointer to current cdblk or exblk
        //b |r_ctp|dac|1,0|||ptr to current ctblk for patst|8245
        .r_ctp 		= 0,				// ptr to current ctblk for patst
        //b |r_cts|dac|1,0|||ptr to last string scanned by patst|8246
        .r_cts 		= 0,				// ptr to last string scanned by patst
        //b |r_ert|dac|1,0|||trblk pointer for errtype trace|8247
        .r_ert 		= 0,				// trblk pointer for errtype trace
        //b |r_etx|dac|4,nulls|||pointer to errtext string|8248
        .r_etx 		= (word)(&c.nulls),				// pointer to errtext string
        //b |r_exs|dac|1,0|||= save xl in expdm|8249
        .r_exs 		= 0,				// = save xl in expdm
        //b |r_fcb|dac|1,0|||fcblk chain head|8250
        .r_fcb 		= 0,				// fcblk chain head
        //b |r_fnc|dac|1,0|||trblk pointer for fnclevel trace|8251
        .r_fnc 		= 0,				// trblk pointer for fnclevel trace
        //b |r_gtc|dac|1,0|||keep code ptr for gtcod,gtexp|8252
        .r_gtc 		= 0,				// keep code ptr for gtcod,gtexp
        //b |r_ici|dac|1,0|||saved r_cim during include process.|8254
        .r_ici 		= 0,				// saved r_cim during include process.
        //b |r_ifa|dac|1,0|||array of file names by incl. depth|8256
        .r_ifa 		= 0,				// array of file names by incl. depth
        //b |r_ifl|dac|1,0|||array of line nums by include depth|8257
        .r_ifl 		= 0,				// array of line nums by include depth
        //b |r_ifn|dac|1,0|||last include file name|8259
        .r_ifn 		= 0,				// last include file name
        //b |r_inc|dac|1,0|||table of include file names seen|8260
        .r_inc 		= 0,				// table of include file names seen
        //b |r_io1|dac|1,0|||file arg1 for ioput|8262
        .r_io1 		= 0,				// file arg1 for ioput
        //b |r_io2|dac|1,0|||file arg2 for ioput|8263
        .r_io2 		= 0,				// file arg2 for ioput
        //b |r_iof|dac|1,0|||fcblk ptr or 0|8264
        .r_iof 		= 0,				// fcblk ptr or 0
        //b |r_ion|dac|1,0|||name base ptr|8265
        .r_ion 		= 0,				// name base ptr
        //b |r_iop|dac|1,0|||predecessor block ptr for ioput|8266
        .r_iop 		= 0,				// predecessor block ptr for ioput
        //b |r_iot|dac|1,0|||trblk ptr for ioput|8267
        .r_iot 		= 0,				// trblk ptr for ioput
        //b |r_pms|dac|1,0|||subject string ptr in pattern match|8272
        .r_pms 		= 0,				// subject string ptr in pattern match
        //b |r_ra2|dac|1,0|||replace second argument last time|8273
        .r_ra2 		= 0,				// replace second argument last time
        //b |r_ra3|dac|1,0|||replace third argument last time|8274
        .r_ra3 		= 0,				// replace third argument last time
        //b |r_rpt|dac|1,0|||ptr to ctblk replace table last usd|8275
        .r_rpt 		= 0,				// ptr to ctblk replace table last usd
        //b |r_scp|dac|1,0|||save pointer from last scane call|8276
        .r_scp 		= 0,				// save pointer from last scane call
        //b |r_sfc|dac|4,nulls|||current source file name|8278
        .r_sfc 		= (word)(&c.nulls),				// current source file name
        //b |r_sfn|dac|1,0|||ptr to source file name table|8279
        .r_sfn 		= 0,				// ptr to source file name table
        //b |r_sxl|dac|1,0|||preserve xl in sortc|8281
        .r_sxl 		= 0,				// preserve xl in sortc
        //b |r_sxr|dac|1,0|||preserve xr in sorta/sortc|8282
        .r_sxr 		= 0,				// preserve xr in sorta/sortc
        //b |r_stc|dac|1,0|||trblk pointer for stcount trace|8283
        .r_stc 		= 0,				// trblk pointer for stcount trace
        //b |r_stl|dac|1,0|||source listing sub-title|8284
        .r_stl 		= 0,				// source listing sub-title
        //b |r_sxc|dac|1,0|||code (cdblk) ptr for setexit trap|8285
        .r_sxc 		= 0,				// code (cdblk) ptr for setexit trap
        //b |r_ttl|dac|4,nulls|||source listing title|8286
        .r_ttl 		= (word)(&c.nulls),				// source listing title
        //b |r_xsc|dac|1,0|||string pointer for xscan|8287
        .r_xsc 		= 0,				// string pointer for xscan
        //b ||ejc|||||8288
        
//      the remaining pointers in this list are used to point
//      to function blocks for normally undefined operators.
        //b |r_uba|dac|4,stndo|||binary at|8293
        .r_uba 		= (word)(&c.stndo),				// binary at
        //b |r_ubm|dac|4,stndo|||binary ampersand|8294
        .r_ubm 		= (word)(&c.stndo),				// binary ampersand
        //b |r_ubn|dac|4,stndo|||binary number sign|8295
        .r_ubn 		= (word)(&c.stndo),				// binary number sign
        //b |r_ubp|dac|4,stndo|||binary percent|8296
        .r_ubp 		= (word)(&c.stndo),				// binary percent
        //b |r_ubt|dac|4,stndo|||binary not|8297
        .r_ubt 		= (word)(&c.stndo),				// binary not
        //b |r_uub|dac|4,stndo|||unary vertical bar|8298
        .r_uub 		= (word)(&c.stndo),				// unary vertical bar
        //b |r_uue|dac|4,stndo|||unary equal|8299
        .r_uue 		= (word)(&c.stndo),				// unary equal
        //b |r_uun|dac|4,stndo|||unary number sign|8300
        .r_uun 		= (word)(&c.stndo),				// unary number sign
        //b |r_uup|dac|4,stndo|||unary percent|8301
        .r_uup 		= (word)(&c.stndo),				// unary percent
        //b |r_uus|dac|4,stndo|||unary slash|8302
        .r_uus 		= (word)(&c.stndo),				// unary slash
        //b |r_uux|dac|4,stndo|||unary exclamation|8303
        .r_uux 		= (word)(&c.stndo),				// unary exclamation
        //b |r_yyy|dac|1,0|||last relocatable location|8304
        .r_yyy 		= 0,				// last relocatable location
//      global locations used in scan procedure
        //b |scnbl|dac|1,0|||set non-zero if scanned past blanks|8308
        .scnbl 		= 0,				// set non-zero if scanned past blanks
        //b |scncc|dac|1,0|||non-zero to scan control card name|8309
        .scncc 		= 0,				// non-zero to scan control card name
        //b |scngo|dac|1,0|||set non-zero to scan goto field|8310
        .scngo 		= 0,				// set non-zero to scan goto field
        //b |scnil|dac|1,0|||length of current input image|8311
        .scnil 		= 0,				// length of current input image
        //b |scnpt|dac|1,0|||pointer to next location in r_cim|8312
        .scnpt 		= 0,				// pointer to next location in r_cim
        //b |scnrs|dac|1,0|||set non-zero to signal rescan|8313
        .scnrs 		= 0,				// set non-zero to signal rescan
        //b |scnse|dac|1,0|||start of current element|8314
        .scnse 		= 0,				// start of current element
        //b |scntp|dac|1,0|||save syntax type from last call|8315
        .scntp 		= 0,				// save syntax type from last call
//      global value for indicating stage (see error section)
        //b |stage|dac|1,0|||initial value = initial compile|8319
        .stage 		= 0,				// initial value = initial compile
        //b ||ejc|||||8320
        
//      global stack pointer
        //b |stbas|dac|1,0|||pointer past stack base|8324
        .stbas 		= 0,				// pointer past stack base
//      global values for setexit function (s_stx)
        //b |stxoc|dac|1,0|||code pointer offset|8328
        .stxoc 		= 0,				// code pointer offset
        //b |stxof|dac|1,0|||failure offset|8329
        .stxof 		= 0,				// failure offset
//      global value for time keeping
        //b |timsx|dic|16,+0|||time at start of execution|8333
        .timsx 		= +0,				// time at start of execution
        //b |timup|dac|1,0|||set when time up occurs|8334
        .timup 		= 0,				// set when time up occurs
//      global values for xscan and xscni procedures
        //b |xsofs|dac|1,0|||offset to current location in r_xsc|8338
        .xsofs 		= 0,				// offset to current location in r_xsc
//      label to mark end of working section
        //b |w_yyy|dac|1,0||||8342
        .w_yyy 		= 0,
        //b ||ttl|27,s p i t b o l -- minimal code||||8343
        /* s p i t b o l -- minimal code*/
        //b ||sec||||start of program section|8344
        .prc_ = {
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         NULL,
         }, /* non recursive call entry points */
        .lowspmin=0,
        .end_min_data=0,
        }; /* struct spitbol_variables v */
        /*-------------------------------------------------------------------- esec04 --------*/
        /*-------------------------------------------------------------------- sec05 --------*/
        // Main code
        void sec05() {
//	align	2
//	db	bl__i
        //b |s_aaa|ent|2,bl__i|||mark start of code|8345
        C_GOTO(s_aaa);
        } /* sec05 */
        

        void s_aaa() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// mark start of code
        //b ||ttl|27,s p i t b o l -- relocation||||8347
        /* s p i t b o l -- relocation*/
//      relocation
//      the following section provides services to osint to
//      relocate portions of the workspace.  it is used when
//      a saved memory image must be restarted at a different
//      location.
//      relaj -- relocate a list of pointers
//      (wa)                  ptr past last pointer of list
//      (wb)                  ptr to first pointer of list
//      (xl)                  list of boundaries and adjustments
//      jsr  relaj            call to process list of pointers
//      (wb)                  destroyed
// relaj:
        //b |relaj|prc|25,e|1,0||entry point|8363
        C_GOTO(relaj);
        } /* s_aaa */
        

        void relaj() {
        //b ||mov|11,-(xs)|7,xr||save xr|8364
        C_PUSH(xr);				// save xr
        //b ||mov|11,-(xs)|8,wa||save wa|8365
        C_PUSH(wa);				// save wa
        //b ||mov|3,rlals|7,xl||save ptr to list of bounds|8366
        v.rlals= xl;				// save ptr to list of bounds
        //b ||mov|7,xr|8,wb||ptr to first pointer to process|8367
        xr= wb;				// ptr to first pointer to process
//      merge here to check if done
// rlaj0:
        //b |rlaj0|mov|7,xl|3,rlals||restore xl|8371
        C_GOTO(rlaj0);
        } /* relaj */
        

        void rlaj0() {
        xl= v.rlals;				// restore xl
        //b ||bne|7,xr|9,(xs)|6,rlaj1|proceed if more to do|8372
        if ((xr-*(xs_it.wp)) != 0) C_GOTO(rlaj1);				// proceed if more to do
        //b ||mov|8,wa|10,(xs)+||restore wa|8373
        wa= C_POP();				// restore wa
        //b ||mov|7,xr|10,(xs)+||restore xr|8374
        xr= C_POP();				// restore xr
        //b ||exi||||return to caller|8375
        C_EXIT(0);				// return to caller
//      merge here to process next pointer on list
// rlaj1:
        //b |rlaj1|mov|8,wa|9,(xr)||load next pointer on list|8379
        } /* rlaj0 */
        

        void rlaj1() {
        wa= *(xr_it.wp);				// load next pointer on list
        //b ||lct|8,wb|18,=rnsi_||number of sections of adjusters|8380
        wb= RNSI_;				// number of sections of adjusters
//      merge here to process next section of stack list
// rlaj2:
        //b |rlaj2|bgt|8,wa|13,rlend(xl)|6,rlaj3|ok if past end of section|8384
        C_GOTO(rlaj2);
        } /* rlaj1 */
        

        void rlaj2() {
        if ((wa-*((word *)(CFP_B*RLEND + xl))) > 0) C_GOTO(rlaj3);				// ok if past end of section
        //b ||blt|8,wa|13,rlstr(xl)|6,rlaj3|or if before start of section|8385
        if ((wa-*((word *)(CFP_B*RLSTR + xl))) < 0) C_GOTO(rlaj3);				// or if before start of section
        //b ||add|8,wa|13,rladj(xl)||within section, add adjustment|8386
        wa += *((word *)(CFP_B*RLADJ + xl));				// within section, add adjustment
        //b ||mov|9,(xr)|8,wa||return updated ptr to memory|8387
        *(xr_it.wp)= wa;				// return updated ptr to memory
        //b ||brn|6,rlaj4|||done with this pointer|8388
         C_GOTO(rlaj4);				// done with this pointer
//      here if not within section
// rlaj3:
        //b |rlaj3|add|7,xl|19,*rssi_||advance to next section|8392
        } /* rlaj2 */
        

        void rlaj3() {
        xl += CFP_B*RSSI_;				// advance to next section
        //b ||bct|8,wb|6,rlaj2||jump if more to go|8393
        if ((--wb))  C_GOTO(rlaj2);				// jump if more to go
//      here when finished processing one pointer
// rlaj4:
        //b |rlaj4|ica|7,xr|||increment to next ptr on list|8397
        C_GOTO(rlaj4);
        } /* rlaj3 */
        

        void rlaj4() {
        xr += CFP_B;				// increment to next ptr on list
        //b ||brn|6,rlaj0|||jump to check  for completion|8398
         C_GOTO(rlaj0);				// jump to check  for completion
        //b ||ejc|||||8400
        
//      relcr -- create relocation info after save file reload
//      (wa)                  original s_aaa code section adr
//      (wb)                  original c_aaa constant section adr
//      (wc)                  original g_aaa working section adr
//      (xr)                  ptr to start of static region
//      (cp)                  ptr to start of dynamic region
//      (xl)                  ptr to area to receive information
//      jsr  relcr            create relocation information
//      (wa,wb,wc,xr)         destroyed
//      a block of information is built at (xl) that is used
//      in relocating pointers.  there are rnsi_ instances
//      of a rssi_ word structure.  each instance corresponds
//      to one of the regions that a pointer might point into.
//      the layout of this structure is shown in the definitions
//      section, together with symbolic definitions of the
//      entries as offsets from xl.
// relcr:
        //b |relcr|prc|25,e|1,0||entry point|8421
        } /* rlaj4 */
        

        void relcr() {
        //b ||add|7,xl|19,*rlsi_||point past build area|8422
        xl += CFP_B*RLSI_;				// point past build area
        //b ||mov|11,-(xl)|8,wa||save original code address|8423
        *(--xl_it.wp)= wa;				// save original code address
        //b ||mov|8,wa|22,=s_aaa||compute adjustment|8424
        wa= (word)(s_aaa);				// compute adjustment
        //b ||sub|8,wa|9,(xl)||as new s_aaa minus original s_aaa|8425
        wa -= *(xl_it.wp);				// as new s_aaa minus original s_aaa
        //b ||mov|11,-(xl)|8,wa||save code adjustment|8426
        *(--xl_it.wp)= wa;				// save code adjustment
        //b ||mov|8,wa|22,=s_yyy||end of target code section|8427
        wa= (word)(s_yyy);				// end of target code section
        //b ||sub|8,wa|22,=s_aaa||length of code section|8428
        wa -= (word)(s_aaa);				// length of code section
        //b ||add|8,wa|13,num01(xl)||plus original start address|8429
        wa += *((word *)(CFP_B*NUM01 + xl));				// plus original start address
        //b ||mov|11,-(xl)|8,wa||end of original code section|8430
        *(--xl_it.wp)= wa;				// end of original code section
        //b ||mov|11,-(xl)|8,wb||save constant section address|8431
        *(--xl_it.wp)= wb;				// save constant section address
        //b ||mov|8,wb|21,=c_aaa||start of constants section|8432
        wb= (word)(&c.c_aaa);				// start of constants section
        //b ||mov|8,wa|21,=c_yyy||end of constants section|8433
        wa= (word)(&c.c_yyy);				// end of constants section
        //b ||sub|8,wa|8,wb||length of constants section|8434
        wa -= wb;				// length of constants section
        //b ||sub|8,wb|9,(xl)||new c_aaa minus original c_aaa|8435
        wb -= *(xl_it.wp);				// new c_aaa minus original c_aaa
        //b ||mov|11,-(xl)|8,wb||save constant adjustment|8436
        *(--xl_it.wp)= wb;				// save constant adjustment
        //b ||add|8,wa|13,num01(xl)||length plus original start adr|8437
        wa += *((word *)(CFP_B*NUM01 + xl));				// length plus original start adr
        //b ||mov|11,-(xl)|8,wa||save as end of original constants|8438
        *(--xl_it.wp)= wa;				// save as end of original constants
        //b ||mov|11,-(xl)|8,wc||save working globals address|8439
        *(--xl_it.wp)= wc;				// save working globals address
        //b ||mov|8,wc|20,=g_aaa||start of working globals section|8440
        wc= (word)(&v.g_aaa);				// start of working globals section
        //b ||mov|8,wa|20,=w_yyy||end of working section|8441
        wa= (word)(&v.w_yyy);				// end of working section
        //b ||sub|8,wa|8,wc||length of working globals|8442
        wa -= wc;				// length of working globals
        //b ||sub|8,wc|9,(xl)||new g_aaa minus original g_aaa|8443
        wc -= *(xl_it.wp);				// new g_aaa minus original g_aaa
        //b ||mov|11,-(xl)|8,wc||save working globals adjustment|8444
        *(--xl_it.wp)= wc;				// save working globals adjustment
        //b ||add|8,wa|13,num01(xl)||length plus original start adr|8445
        wa += *((word *)(CFP_B*NUM01 + xl));				// length plus original start adr
        //b ||mov|11,-(xl)|8,wa||save as end of working globals|8446
        *(--xl_it.wp)= wa;				// save as end of working globals
        //b ||mov|8,wb|3,statb||old start of static region|8447
        wb= v.statb;				// old start of static region
        //b ||mov|11,-(xl)|8,wb||save|8448
        *(--xl_it.wp)= wb;				// save
        //b ||sub|7,xr|8,wb||compute adjustment|8449
        xr -= wb;				// compute adjustment
        //b ||mov|11,-(xl)|7,xr||save new statb minus old statb|8450
        *(--xl_it.wp)= xr;				// save new statb minus old statb
        //b ||mov|11,-(xl)|3,state||old end of static region|8451
        *(--xl_it.wp)= v.state;				// old end of static region
        //b ||mov|8,wb|3,dnamb||old start of dynamic region|8452
        wb= v.dnamb;				// old start of dynamic region
        //b ||mov|11,-(xl)|8,wb||save|8453
        *(--xl_it.wp)= wb;				// save
        //b ||scp|8,wa|||new start of dynamic|8454
        wa= reg_cp;				// new start of dynamic
        //b ||sub|8,wa|8,wb||compute adjustment|8455
        wa -= wb;				// compute adjustment
        //b ||mov|11,-(xl)|8,wa||save new dnamb minus old dnamb|8456
        *(--xl_it.wp)= wa;				// save new dnamb minus old dnamb
        //b ||mov|8,wc|3,dnamp||old end of dynamic region in use|8457
        wc= v.dnamp;				// old end of dynamic region in use
        //b ||mov|11,-(xl)|8,wc||save as end of old dynamic region|8458
        *(--xl_it.wp)= wc;				// save as end of old dynamic region
        //b ||exi|||||8459
        C_EXIT(0);
        //b ||ejc|||||8461
        
//      reldn -- relocate pointers in the dynamic region
//      (xl)                  list of boundaries and adjustments
//      (xr)                  ptr to first location to process
//      (wc)                  ptr past last location to process
//      jsr  reldn            call to process blocks in dynamic
//      (wa,wb,wc,xr)         destroyed
//      processes all blocks in the dynamic region.  within a
//      block, pointers to the code section, constant section,
//      working globals section, static region, and dynamic
//      region are relocated as needed.
// reldn:
        //b |reldn|prc|25,e|1,0||entry point|8476
        } /* relcr */
        

        void reldn() {
        //b ||mov|3,rldcd|13,rlcda(xl)||save code adjustment|8477
        v.rldcd= *((word *)(CFP_B*RLCDA + xl));				// save code adjustment
        //b ||mov|3,rldst|13,rlsta(xl)||save static adjustment|8478
        v.rldst= *((word *)(CFP_B*RLSTA + xl));				// save static adjustment
        //b ||mov|3,rldls|7,xl||save list pointer|8479
        v.rldls= xl;				// save list pointer
//      merge here to process the next block in dynamic
// rld01:
        //b |rld01|add|9,(xr)|3,rldcd||adjust block type word|8483
        C_GOTO(rld01);
        } /* reldn */
        

        void rld01() {
        *(xr_it.wp) += v.rldcd;				// adjust block type word
        //b ||mov|7,xl|9,(xr)||load block type word|8484
        xl= *(xr_it.wp);				// load block type word
        //b ||lei|7,xl|||load entry point id (bl_xx)|8485
        xl = find_elab(xl);    /* get entry code */				// load entry point id (bl_xx)
//      block type switch. note that blocks with no relocatable
//      fields just return to rld05 to continue to next block.
//      note that dfblks do not appear in dynamic, only in static.
//      ccblks and cmblks are not live when a save file is
//      created, and can be skipped.
//      further note:  static blocks other than vrblks discovered
//      while scanning dynamic must be adjusted at this time.
//      see processing of ffblk for example.
        //b ||ejc|||||8498
        
//      reldn (continued)
        //b ||bsw|7,xl|2,bl___||switch on block type|8502
        extern word _l0344 [];				// switch on block type
        { w0 = ((word *)_l0344)[xl];  C_GOTO(w0_it.callp);}
        }  /* rld01 */
        

        word  _l0344 [] = {
        //b ||iff|2,bl_ar|6,rld03||arblk|8539
        	(word)((word)(rld03)),				// arblk
        //b ||iff|2,bl_cd|6,rld07||cdblk|8539
        	(word)((word)(rld07)),				// cdblk
        //b ||iff|2,bl_ex|6,rld10||exblk|8539
        	(word)((word)(rld10)),				// exblk
        //b ||iff|2,bl_ic|6,rld05||icblk|8539
        	(word)((word)(rld05)),				// icblk
        //b ||iff|2,bl_nm|6,rld13||nmblk|8539
        	(word)((word)(rld13)),				// nmblk
        //b ||iff|2,bl_p0|6,rld13||p0blk|8539
        	(word)((word)(rld13)),				// p0blk
        //b ||iff|2,bl_p1|6,rld14||p1blk|8539
        	(word)((word)(rld14)),				// p1blk
        //b ||iff|2,bl_p2|6,rld14||p2blk|8539
        	(word)((word)(rld14)),				// p2blk
        //b ||iff|2,bl_rc|6,rld05||rcblk|8539
        	(word)((word)(rld05)),				// rcblk
        //b ||iff|2,bl_sc|6,rld05||scblk|8539
        	(word)((word)(rld05)),				// scblk
        //b ||iff|2,bl_se|6,rld13||seblk|8539
        	(word)((word)(rld13)),				// seblk
        //b ||iff|2,bl_tb|6,rld17||tbblk|8539
        	(word)((word)(rld17)),				// tbblk
        //b ||iff|2,bl_vc|6,rld17||vcblk|8539
        	(word)((word)(rld17)),				// vcblk
        //b ||iff|2,bl_xn|6,rld05||xnblk|8539
        	(word)((word)(rld05)),				// xnblk
        //b ||iff|2,bl_xr|6,rld20||xrblk|8539
        	(word)((word)(rld20)),				// xrblk
        //b ||iff|2,bl_bc|6,rld05||bcblk - dummy to fill out iffs|8539
        	(word)((word)(rld05)),				// bcblk - dummy to fill out iffs
        //b ||iff|2,bl_pd|6,rld15||pdblk|8539
        	(word)((word)(rld15)),				// pdblk
        //b ||iff|2,bl_tr|6,rld19||trblk|8539
        	(word)((word)(rld19)),				// trblk
        //b ||iff|2,bl_bf|6,rld05||bfblk|8539
        	(word)((word)(rld05)),				// bfblk
        //b ||iff|2,bl_cc|6,rld05||ccblk|8539
        	(word)((word)(rld05)),				// ccblk
        //b ||iff|2,bl_cm|6,rld05||cmblk|8539
        	(word)((word)(rld05)),				// cmblk
        //b ||iff|2,bl_ct|6,rld05||ctblk|8539
        	(word)((word)(rld05)),				// ctblk
        //b ||iff|2,bl_df|6,rld05||dfblk|8539
        	(word)((word)(rld05)),				// dfblk
        //b ||iff|2,bl_ef|6,rld08||efblk|8539
        	(word)((word)(rld08)),				// efblk
        //b ||iff|2,bl_ev|6,rld09||evblk|8539
        	(word)((word)(rld09)),				// evblk
        //b ||iff|2,bl_ff|6,rld11||ffblk|8539
        	(word)((word)(rld11)),				// ffblk
        //b ||iff|2,bl_kv|6,rld13||kvblk|8539
        	(word)((word)(rld13)),				// kvblk
        //b ||iff|2,bl_pf|6,rld16||pfblk|8539
        	(word)((word)(rld16)),				// pfblk
        //b ||iff|2,bl_te|6,rld18||teblk|8539
        	(word)((word)(rld18)),				// teblk
        //b ||esw||||end of jump table|8539
             }; /* bsw list for _l0344 */				// end of jump table
//      arblk
// rld03:
        //b |rld03|mov|8,wa|13,arlen(xr)||load length|8543
        void rld03() {
        wa= *((word *)(CFP_B*ARLEN + xr));				// load length
        //b ||mov|8,wb|13,arofs(xr)||set offset to 1st reloc fld (arpro)|8544
        wb= *((word *)(CFP_B*AROFS + xr));				// set offset to 1st reloc fld (arpro)
//      merge here to process pointers in a block
//      (xr)                  ptr to current block
//      (wc)                  ptr past last location to process
//      (wa)                  length (reloc flds + flds at start)
//      (wb)                  offset to first reloc field
// rld04:
        //b |rld04|add|8,wa|7,xr||point past last reloc field|8553
        C_GOTO(rld04);
        } /* rld03 */
        

        void rld04() {
        wa += xr;				// point past last reloc field
        //b ||add|8,wb|7,xr||point to first reloc field|8554
        wb += xr;				// point to first reloc field
        //b ||mov|7,xl|3,rldls||point to list of bounds|8555
        xl= v.rldls;				// point to list of bounds
        //b ||jsr|6,relaj|||adjust pointers|8556
        C_JSR(relaj);				// adjust pointers
        //b ||ejc|||||8557
        
//      reldn (continued)
//      merge here to advance to next block
//      (xr)                  ptr to current block
//      (wc)                  ptr past last location to process
// rld05:
        //b |rld05|mov|8,wa|9,(xr)||block type word|8567
        C_GOTO(rld05);
        } /* rld04 */
        

        void rld05() {
        wa= *(xr_it.wp);				// block type word
        //b ||jsr|6,blkln|||get length of block|8568
        C_JSR(blkln);				// get length of block
        //b ||add|7,xr|8,wa||point to next block|8569
        xr += wa;				// point to next block
        //b ||blt|7,xr|8,wc|6,rld01|continue if more to process|8570
        if ((xr-wc) < 0) C_GOTO(rld01);				// continue if more to process
        //b ||mov|7,xl|3,rldls||restore xl|8571
        xl= v.rldls;				// restore xl
        //b ||exi||||return to caller if done|8572
        C_EXIT(0);				// return to caller if done
//      cdblk
// rld07:
        //b |rld07|mov|8,wa|13,cdlen(xr)||load length|8585
        } /* rld05 */
        

        void rld07() {
        wa= *((word *)(CFP_B*CDLEN + xr));				// load length
        //b ||mov|8,wb|19,*cdfal||set offset|8586
        wb= CFP_B*CDFAL;				// set offset
        //b ||bne|9,(xr)|22,=b_cdc|6,rld04|jump back if not complex goto|8587
        if ((*(xr_it.wp)-(word)(b_cdc)) != 0) C_GOTO(rld04);				// jump back if not complex goto
        //b ||mov|8,wb|19,*cdcod||do not process cdfal word|8588
        wb= CFP_B*CDCOD;				// do not process cdfal word
        //b ||brn|6,rld04|||jump back|8589
         C_GOTO(rld04);				// jump back
//      efblk
//      if the efcod word points to an xnblk, the xnblk type
//      word will not be adjusted.  since this is implementation
//      dependent, we will not worry about it.
// rld08:
        //b |rld08|mov|8,wa|19,*efrsl||set length|8597
        } /* rld07 */
        

        void rld08() {
        wa= CFP_B*EFRSL;				// set length
        //b ||mov|8,wb|19,*efcod||and offset|8598
        wb= CFP_B*EFCOD;				// and offset
        //b ||brn|6,rld04|||all set|8599
         C_GOTO(rld04);				// all set
//      evblk
// rld09:
        //b |rld09|mov|8,wa|19,*offs3||point past third field|8603
        } /* rld08 */
        

        void rld09() {
        wa= CFP_B*OFFS3;				// point past third field
        //b ||mov|8,wb|19,*evexp||set offset|8604
        wb= CFP_B*EVEXP;				// set offset
        //b ||brn|6,rld04|||all set|8605
         C_GOTO(rld04);				// all set
//      exblk
// rld10:
        //b |rld10|mov|8,wa|13,exlen(xr)||load length|8609
        } /* rld09 */
        

        void rld10() {
        wa= *((word *)(CFP_B*EXLEN + xr));				// load length
        //b ||mov|8,wb|19,*exflc||set offset|8610
        wb= CFP_B*EXFLC;				// set offset
        //b ||brn|6,rld04|||jump back|8611
         C_GOTO(rld04);				// jump back
        //b ||ejc|||||8612
        
//      reldn (continued)
//      ffblk
//      this block contains a ptr to a dfblk in the static rgn.
//      because there are multiple ffblks pointing to the same
//      dfblk (one for each field name), we only process the
//      dfblk when we encounter the ffblk for the first field.
//      the dfblk in turn contains a pointer to an scblk within
//      static.
// rld11:
        //b |rld11|bne|13,ffofs(xr)|19,*pdfld|6,rld12|skip dfblk if not first field|8626
        } /* rld10 */
        

        void rld11() {
        if ((*((word *)(CFP_B*FFOFS + xr))-CFP_B*PDFLD) != 0) C_GOTO(rld12);				// skip dfblk if not first field
        //b ||mov|11,-(xs)|7,xr||save xr|8627
        C_PUSH(xr);				// save xr
        //b ||mov|7,xr|13,ffdfp(xr)||load old ptr to dfblk|8628
        xr= *((word *)(CFP_B*FFDFP + xr));				// load old ptr to dfblk
        //b ||add|7,xr|3,rldst||current location of dfblk|8629
        xr += v.rldst;				// current location of dfblk
        //b ||add|9,(xr)|3,rldcd||adjust dfblk type word|8630
        *(xr_it.wp) += v.rldcd;				// adjust dfblk type word
        //b ||mov|8,wa|13,dflen(xr)||length of dfblk|8631
        wa= *((word *)(CFP_B*DFLEN + xr));				// length of dfblk
        //b ||mov|8,wb|19,*dfnam||offset to dfnam field|8632
        wb= CFP_B*DFNAM;				// offset to dfnam field
        //b ||add|8,wa|7,xr||point past last reloc field|8633
        wa += xr;				// point past last reloc field
        //b ||add|8,wb|7,xr||point to first reloc field|8634
        wb += xr;				// point to first reloc field
        //b ||mov|7,xl|3,rldls||point to list of bounds|8635
        xl= v.rldls;				// point to list of bounds
        //b ||jsr|6,relaj|||adjust pointers|8636
        C_JSR(relaj);				// adjust pointers
        //b ||mov|7,xr|13,dfnam(xr)||pointer to static scblk|8637
        xr= *((word *)(CFP_B*DFNAM + xr));				// pointer to static scblk
        //b ||add|9,(xr)|3,rldcd||adjust scblk type word|8638
        *(xr_it.wp) += v.rldcd;				// adjust scblk type word
        //b ||mov|7,xr|10,(xs)+||restore ffblk pointer|8639
        xr= C_POP();				// restore ffblk pointer
//      ffblk (continued)
//      merge here to set up for adjustment of ptrs in ffblk
// rld12:
        //b |rld12|mov|8,wa|19,*ffofs||set length|8645
        C_GOTO(rld12);
        } /* rld11 */
        

        void rld12() {
        wa= CFP_B*FFOFS;				// set length
        //b ||mov|8,wb|19,*ffdfp||set offset|8646
        wb= CFP_B*FFDFP;				// set offset
        //b ||brn|6,rld04|||all set|8647
         C_GOTO(rld04);				// all set
//      kvblk, nmblk, p0blk, seblk
// rld13:
        //b |rld13|mov|8,wa|19,*offs2||point past second field|8651
        } /* rld12 */
        

        void rld13() {
        wa= CFP_B*OFFS2;				// point past second field
        //b ||mov|8,wb|19,*offs1||offset is one (only reloc fld is 2)|8652
        wb= CFP_B*OFFS1;				// offset is one (only reloc fld is 2)
        //b ||brn|6,rld04|||all set|8653
         C_GOTO(rld04);				// all set
//      p1blk, p2blk
//      in p2blks, parm2 contains either a bit mask or the
//      name offset of a variable.  it never requires relocation.
// rld14:
        //b |rld14|mov|8,wa|19,*parm2||length (parm2 is non-relocatable)|8660
        } /* rld13 */
        

        void rld14() {
        wa= CFP_B*PARM2;				// length (parm2 is non-relocatable)
        //b ||mov|8,wb|19,*pthen||set offset|8661
        wb= CFP_B*PTHEN;				// set offset
        //b ||brn|6,rld04|||all set|8662
         C_GOTO(rld04);				// all set
//      pdblk
//      note that the dfblk pointed to by this pdblk was
//      processed when the ffblk was encountered.  because
//      the data function will be called before any records are
//      defined, the ffblk is encountered before any
//      corresponding pdblk.
// rld15:
        //b |rld15|mov|7,xl|13,pddfp(xr)||load ptr to dfblk|8672
        } /* rld14 */
        

        void rld15() {
        xl= *((word *)(CFP_B*PDDFP + xr));				// load ptr to dfblk
        //b ||add|7,xl|3,rldst||adjust for static relocation|8673
        xl += v.rldst;				// adjust for static relocation
        //b ||mov|8,wa|13,dfpdl(xl)||get pdblk length|8674
        wa= *((word *)(CFP_B*DFPDL + xl));				// get pdblk length
        //b ||mov|8,wb|19,*pddfp||set offset|8675
        wb= CFP_B*PDDFP;				// set offset
        //b ||brn|6,rld04|||all set|8676
         C_GOTO(rld04);				// all set
        //b ||ejc|||||8677
        
//      reldn (continued)
//      pfblk
// rld16:
        //b |rld16|add|13,pfvbl(xr)|3,rldst||adjust non-contiguous field|8684
        } /* rld15 */
        

        void rld16() {
        *((word *)(CFP_B*PFVBL + xr)) += v.rldst;				// adjust non-contiguous field
        //b ||mov|8,wa|13,pflen(xr)||get pfblk length|8685
        wa= *((word *)(CFP_B*PFLEN + xr));				// get pfblk length
        //b ||mov|8,wb|19,*pfcod||offset to first reloc|8686
        wb= CFP_B*PFCOD;				// offset to first reloc
        //b ||brn|6,rld04|||all set|8687
         C_GOTO(rld04);				// all set
//      tbblk, vcblk
// rld17:
        //b |rld17|mov|8,wa|13,offs2(xr)||load length|8691
        } /* rld16 */
        

        void rld17() {
        wa= *((word *)(CFP_B*OFFS2 + xr));				// load length
        //b ||mov|8,wb|19,*offs3||set offset|8692
        wb= CFP_B*OFFS3;				// set offset
        //b ||brn|6,rld04|||jump back|8693
         C_GOTO(rld04);				// jump back
//      teblk
// rld18:
        //b |rld18|mov|8,wa|19,*tesi_||set length|8697
        } /* rld17 */
        

        void rld18() {
        wa= CFP_B*TESI_;				// set length
        //b ||mov|8,wb|19,*tesub||and offset|8698
        wb= CFP_B*TESUB;				// and offset
        //b ||brn|6,rld04|||all set|8699
         C_GOTO(rld04);				// all set
//      trblk
// rld19:
        //b |rld19|mov|8,wa|19,*trsi_||set length|8703
        } /* rld18 */
        

        void rld19() {
        wa= CFP_B*TRSI_;				// set length
        //b ||mov|8,wb|19,*trval||and offset|8704
        wb= CFP_B*TRVAL;				// and offset
        //b ||brn|6,rld04|||all set|8705
         C_GOTO(rld04);				// all set
//      xrblk
// rld20:
        //b |rld20|mov|8,wa|13,xrlen(xr)||load length|8709
        } /* rld19 */
        

        void rld20() {
        wa= *((word *)(CFP_B*XRLEN + xr));				// load length
        //b ||mov|8,wb|19,*xrptr||set offset|8710
        wb= CFP_B*XRPTR;				// set offset
        //b ||brn|6,rld04|||jump back|8711
         C_GOTO(rld04);				// jump back
        //b ||ejc|||||8713
        
//      reloc -- relocate storage after save file reload
//      (xl)                  list of boundaries and adjustments
//      jsr  reloc            relocate all pointers
//      (wa,wb,wc,xr)         destroyed
//      the list of boundaries and adjustments pointed to by
//      register xl is created by a call to relcr, which should
//      be consulted for information on its structure.
// reloc:
        //b |reloc|prc|25,e|1,0||entry point|8725
        } /* rld20 */
        

        void reloc() {
        //b ||mov|7,xr|13,rldys(xl)||old start of dynamic|8726
        xr= *((word *)(CFP_B*RLDYS + xl));				// old start of dynamic
        //b ||mov|8,wc|13,rldye(xl)||old end of dynamic|8727
        wc= *((word *)(CFP_B*RLDYE + xl));				// old end of dynamic
        //b ||add|7,xr|13,rldya(xl)||create new start of dynamic|8728
        xr += *((word *)(CFP_B*RLDYA + xl));				// create new start of dynamic
        //b ||add|8,wc|13,rldya(xl)||create new end of dynamic|8729
        wc += *((word *)(CFP_B*RLDYA + xl));				// create new end of dynamic
        //b ||jsr|6,reldn|||relocate pointers in dynamic|8730
        C_JSR(reldn);				// relocate pointers in dynamic
        //b ||jsr|6,relws|||relocate pointers in working sect|8731
        C_JSR(relws);				// relocate pointers in working sect
        //b ||jsr|6,relst|||relocate pointers in static|8732
        C_JSR(relst);				// relocate pointers in static
        //b ||exi||||return to caller|8733
        C_EXIT(0);				// return to caller
        //b ||ejc|||||8735
        
//      relst -- relocate pointers in the static region
//      (xl)                  list of boundaries and adjustments
//      jsr  relst            call to process blocks in static
//      (wa,wb,wc,xr)         destroyed
//      only vrblks on the hash chain and any profile block are
//      processed.  other static blocks (dfblks) are processed
//      during processing of dynamic blocks.
//      global work locations will be processed at this point,
//      so pointers there can be relied upon.
// relst:
        //b |relst|prc|25,e|1,0||entry point|8750
        } /* reloc */
        

        void relst() {
        //b ||mov|7,xr|3,pftbl||profile table|8751
        xr= v.pftbl;				// profile table
        //b ||bze|7,xr|6,rls01||branch if no table allocated|8752
        if ( !( xr) ) C_GOTO(rls01);				// branch if no table allocated
        //b ||add|9,(xr)|13,rlcda(xl)||adjust block type word|8753
        *(xr_it.wp) += *((word *)(CFP_B*RLCDA + xl));				// adjust block type word
//      here after dealing with profiler
// rls01:
        //b |rls01|mov|8,wc|3,hshtb||point to start of hash table|8757
        C_GOTO(rls01);
        } /* relst */
        

        void rls01() {
        wc= v.hshtb;				// point to start of hash table
        //b ||mov|8,wb|8,wc||point to first hash bucket|8758
        wb= wc;				// point to first hash bucket
        //b ||mov|8,wa|3,hshte||point beyond hash table|8759
        wa= v.hshte;				// point beyond hash table
        //b ||jsr|6,relaj|||adjust bucket pointers|8760
        C_JSR(relaj);				// adjust bucket pointers
//      loop through slots in hash table
// rls02:
        //b |rls02|beq|8,wc|3,hshte|6,rls05|done if none left|8764
        C_GOTO(rls02);
        } /* rls01 */
        

        void rls02() {
        if ((wc-v.hshte) == 0) C_GOTO(rls05);				// done if none left
        //b ||mov|7,xr|8,wc||else copy slot pointer|8765
        xr= wc;				// else copy slot pointer
        //b ||ica|8,wc|||bump slot pointer|8766
        wc += CFP_B;				// bump slot pointer
        //b ||sub|7,xr|19,*vrnxt||set offset to merge into loop|8767
        xr -= CFP_B*VRNXT;				// set offset to merge into loop
//      loop through vrblks on one hash chain
// rls03:
        //b |rls03|mov|7,xr|13,vrnxt(xr)||point to next vrblk on chain|8771
        C_GOTO(rls03);
        } /* rls02 */
        

        void rls03() {
        xr= *((word *)(CFP_B*VRNXT + xr));				// point to next vrblk on chain
        //b ||bze|7,xr|6,rls02||jump for next bucket if chain end|8772
        if ( !( xr) ) C_GOTO(rls02);				// jump for next bucket if chain end
        //b ||mov|8,wa|19,*vrlen||offset of first loc past ptr fields|8773
        wa= CFP_B*VRLEN;				// offset of first loc past ptr fields
        //b ||mov|8,wb|19,*vrget||offset of first location in vrblk|8774
        wb= CFP_B*VRGET;				// offset of first location in vrblk
        //b ||bnz|13,vrlen(xr)|6,rls04||jump if not system variable|8775
        if (*((word *)(CFP_B*VRLEN + xr))) C_GOTO(rls04);				// jump if not system variable
        //b ||mov|8,wa|19,*vrsi_||offset to include vrsvp field|8776
        wa= CFP_B*VRSI_;				// offset to include vrsvp field
//      merge here to process fields of vrblk
// rls04:
        //b |rls04|add|8,wa|7,xr||create end ptr|8780
        C_GOTO(rls04);
        } /* rls03 */
        

        void rls04() {
        wa += xr;				// create end ptr
        //b ||add|8,wb|7,xr||create start ptr|8781
        wb += xr;				// create start ptr
        //b ||jsr|6,relaj|||adjust pointers in vrblk|8782
        C_JSR(relaj);				// adjust pointers in vrblk
        //b ||brn|6,rls03|||check for another vrblk on chain|8783
         C_GOTO(rls03);				// check for another vrblk on chain
//      here when all vrblks processed
// rls05:
        //b |rls05|exi||||return to caller|8787
        } /* rls04 */
        

        void rls05() {
        C_EXIT(0);				// return to caller
        //b ||ejc|||||8789
        
//      relws -- relocate pointers in the working section
//      (xl)                  list of boundaries and adjustments
//      jsr  relws            call to process working section
//      (wa,wb,wc,xr)         destroyed
//      pointers between a_aaa and r_yyy are examined and
//      adjusted if necessary.  the pointer kvrtn is also
//      adjusted although it lies outside this range.
//      dname is explicitly adjusted because the limits
//      on dynamic region in stack are to the area actively
//      in use (between dnamb and dnamp), and dname is outside
//      this range.
// relws:
        //b |relws|prc|25,e|1,0||entry point|8805
        } /* rls05 */
        

        void relws() {
        //b ||mov|8,wb|20,=a_aaa||point to start of adjustables|8806
        wb= (word)(&v.a_aaa);				// point to start of adjustables
        //b ||mov|8,wa|20,=r_yyy||point to end of adjustables|8807
        wa= (word)(&v.r_yyy);				// point to end of adjustables
        //b ||jsr|6,relaj|||relocate adjustable pointers|8808
        C_JSR(relaj);				// relocate adjustable pointers
        //b ||add|3,dname|13,rldya(xl)||adjust ptr missed by relaj|8809
        v.dname += *((word *)(CFP_B*RLDYA + xl));				// adjust ptr missed by relaj
        //b ||mov|8,wb|20,=kvrtn||case of kvrtn|8810
        wb= (word)(&v.kvrtn);				// case of kvrtn
        //b ||mov|8,wa|8,wb||handled specially|8811
        wa= wb;				// handled specially
        //b ||ica|8,wa|||one value to adjust|8812
        wa += CFP_B;				// one value to adjust
        //b ||jsr|6,relaj|||adjust kvrtn|8813
        C_JSR(relaj);				// adjust kvrtn
        //b ||exi||||return to caller|8814
        C_EXIT(0);				// return to caller
        //b ||ttl|27,s p i t b o l -- initialization||||8817
        /* s p i t b o l -- initialization*/
//      initialisation
//      the following section receives control from the system
//      at the start of a run with the registers set as follows.
//      (wa)                  initial stack pointer
//      (xr)                  points to first word of data area
//      (xl)                  points to last word of data area
// start:
        //b |start|prc|25,e|1,0||entry point|8827
        } /* relws */
        

        void start() {
        //b ||mov|3,mxint|8,wb|||8828
        v.mxint= wb;
        //b ||mov|4,bitsm|8,wb|||8829
        c.bitsm= wb;
        //b ||zer|8,wb||||8830
        wb=0;
        //b ||mov|7,xs|8,wa||discard return|8832
        xs= wa;				// discard return
        //b ||jsr|6,systm|||initialise timer|8833
        C_JSR(systm);				// initialise timer
        //b ||sti|3,timsx|||store time|8836
        v.timsx= ia;				// store time
        //b ||mov|3,statb|7,xr||start address of static|8837
        v.statb= xr;				// start address of static
        //b ||mov|3,rsmem|19,*e_srs||reserve memory|8889
        v.rsmem= CFP_B*E_SRS;				// reserve memory
        //b ||mov|3,stbas|7,xs||store stack base|8890
        v.stbas= xs;				// store stack base
//      now convert free store percentage to a suitable factor
//      for easy testing in alloc routine.
        //b ||ldi|4,intvh|||get 100|8896
        ia = c.intvh;				// get 100
        //b ||dvi|4,alfsp|||form 100 / alfsp|8897
        ia=ia / c.alfsp;				// form 100 / alfsp
        //b ||sti|3,alfsf|||store the factor|8898
        v.alfsf= ia;				// store the factor
//      now convert free sediment percentage to a suitable factor
//      for easy testing in gbcol routine.
        //b ||ldi|4,intvh|||get 100|8904
        ia = c.intvh;				// get 100
        //b ||dvi|4,gbsdp|||form 100 / gbsdp|8905
        ia=ia / c.gbsdp;				// form 100 / gbsdp
        //b ||sti|3,gbsed|||store the factor|8906
        v.gbsed= ia;				// store the factor
//      initialize values for real conversion routine
        //b ||lct|8,wb|18,=cfp_s||load counter for significant digits|8915
        wb= CFP_S;				// load counter for significant digits
        //b ||ldr|4,reav1|||load 1.0|8916
        {ra_it.d = c.reav1;fl=(!isgoodnum(ra_it.d));}				// load 1.0
//      loop to compute 10**(max number significant digits)
// ini03:
        //b |ini03|mlr|4,reavt|||* 10.0|8920
        C_GOTO(ini03);
        } /* start */
        

        void ini03() {
        {w0 = c.reavt;ra_it.d *=  w0_it.d;fl=(!isgoodnum(ra_it.d));}				// * 10.0
        //b ||bct|8,wb|6,ini03||loop till done|8921
        if ((--wb))  C_GOTO(ini03);				// loop till done
        //b ||str|3,gtssc|||store 10**(max sig digits)|8922
        v.gtssc = (ra_it.d);				// store 10**(max sig digits)
        //b ||ldr|4,reap5|||load 0.5|8923
        {ra_it.d = c.reap5;fl=(!isgoodnum(ra_it.d));}				// load 0.5
        //b ||dvr|3,gtssc|||compute 0.5*10**(max sig digits)|8924
        {w0 = v.gtssc; if (w0_it.d != 0.0) {ra_it.d /= w0_it.d;fl= (!isgoodnum(ra_it.d));} else {fl=1;}}				// compute 0.5*10**(max sig digits)
        //b ||str|3,gtsrn|||store as rounding bias|8925
        v.gtsrn = (ra_it.d);				// store as rounding bias
        //b ||zer|8,wc|||set to read parameters|8928
        wc=0;				// set to read parameters
        //b ||jsr|6,prpar|||read them|8929
        C_JSR(prpar);				// read them
        //b ||ejc|||||8930
        
//      now compute starting address for dynamic store and if
//      necessary request more memory.
        //b ||sub|7,xl|19,*e_srs||allow for reserve memory|8935
        xl -= CFP_B*E_SRS;				// allow for reserve memory
        //b ||mov|8,wa|3,prlen||get print buffer length|8936
        wa= v.prlen;				// get print buffer length
        //b ||add|8,wa|18,=cfp_a||add no. of chars in alphabet|8937
        wa += CFP_A;				// add no. of chars in alphabet
        //b ||add|8,wa|18,=nstmx||add chars for gtstg bfr|8938
        wa += NSTMX;				// add chars for gtstg bfr
        //b ||ctb|8,wa|1,8||convert to bytes, allowing a margin|8939
        wa += (CFP_B-1)+CFP_B*8;				// convert to bytes, allowing a margin
        wa &= 0xfffffffffffffff8;
        //b ||mov|7,xr|3,statb||point to static base|8940
        xr= v.statb;				// point to static base
        //b ||add|7,xr|8,wa||increment for above buffers|8941
        xr += wa;				// increment for above buffers
        //b ||add|7,xr|19,*e_hnb||increment for hash table|8942
        xr += CFP_B*E_HNB;				// increment for hash table
        //b ||add|7,xr|19,*e_sts||bump for initial static block|8943
        xr += CFP_B*E_STS;				// bump for initial static block
        //b ||jsr|6,sysmx|||get mxlen|8944
        C_JSR(sysmx);				// get mxlen
        //b ||mov|3,kvmxl|8,wa||provisionally store as maxlngth|8945
        v.kvmxl= wa;				// provisionally store as maxlngth
        //b ||mov|3,mxlen|8,wa||and as mxlen|8946
        v.mxlen= wa;				// and as mxlen
        //b ||bgt|7,xr|8,wa|6,ini06|skip if static hi exceeds mxlen|8947
        if ((xr-wa) > 0) C_GOTO(ini06);				// skip if static hi exceeds mxlen
        //b ||ctb|8,wa|1,1||round up and make bigger than mxlen|8948
        wa += (CFP_B-1)+CFP_B*1;				// round up and make bigger than mxlen
        wa &= 0xfffffffffffffff8;
        //b ||mov|7,xr|8,wa||use it instead|8949
        xr= wa;				// use it instead
//      here to store values which mark initial division
//      of data area into static and dynamic
// ini06:
        //b |ini06|mov|3,dnamb|7,xr||dynamic base adrs|8954
        C_GOTO(ini06);
        } /* ini03 */
        

        void ini06() {
        v.dnamb= xr;				// dynamic base adrs
        //b ||mov|3,dnamp|7,xr||dynamic ptr|8955
        v.dnamp= xr;				// dynamic ptr
        //b ||bnz|8,wa|6,ini07||skip if non-zero mxlen|8956
        if (wa) C_GOTO(ini07);				// skip if non-zero mxlen
        //b ||dca|7,xr|||point a word in front|8957
        xr -= CFP_B;				// point a word in front
        //b ||mov|3,kvmxl|7,xr||use as maxlngth|8958
        v.kvmxl= xr;				// use as maxlngth
        //b ||mov|3,mxlen|7,xr||and as mxlen|8959
        v.mxlen= xr;				// and as mxlen
        //b ||ejc|||||8960
        
//      loop here if necessary till enough memory obtained
//      so that dname is above dnamb
// ini07:
        //b |ini07|mov|3,dname|7,xl||store dynamic end address|8965
        C_GOTO(ini07);
        } /* ini06 */
        

        void ini07() {
        v.dname= xl;				// store dynamic end address
        //b ||blt|3,dnamb|7,xl|6,ini09|skip if high enough|8966
        if ((v.dnamb-xl) < 0) C_GOTO(ini09);				// skip if high enough
        //b ||jsr|6,sysmm|||request more memory|8967
        C_JSR(sysmm);				// request more memory
        //b ||wtb|7,xr|||get as baus (sgd05)|8968
        xr <<= LOG_CFP_B;				// get as baus (sgd05)
        //b ||add|7,xl|7,xr||bump by amount obtained|8969
        xl += xr;				// bump by amount obtained
        //b ||bnz|7,xr|6,ini07||try again|8970
        if (xr) C_GOTO(ini07);				// try again
        //b ||mov|8,wa|18,=mxern||insufficient memory for maxlength|8972
        wa= MXERN;				// insufficient memory for maxlength
        //b ||zer|8,wb|||no column number info|8973
        wb=0;				// no column number info
        //b ||zer|8,wc|||no line number info|8974
        wc=0;				// no line number info
        //b ||mov|7,xr|18,=stgic||initial compile stage|8975
        xr= STGIC;				// initial compile stage
        //b ||mov|7,xl|21,=nulls||no file name|8977
        xl= (word)(&c.nulls);				// no file name
        //b ||ppm|6,ini08|||cant use error logic yet|8980
        C_JSR_1(sysea,C_GOTO(ini08));				// cant use error logic yet
        //b ||brn|6,ini08|||force termination|8981
         C_GOTO(ini08);				// force termination
//      insert text for error 329 in error message table
        //b ||erb|1,329|26,requested maxlngth too large|||8985
        C_ERB(329)
// ini08:
        //b |ini08|mov|7,xr|21,=endmo||point to failure message|8987
        } /* ini07 */
        

        void ini08() {
        xr= (word)(&c.endmo);				// point to failure message
        //b ||mov|8,wa|4,endml||message length|8988
        wa= c.endml;				// message length
        //b ||ppm||||should not fail|8990
        C_JSR_1(syspr,(C_ERR(299)));				// should not fail
        //b ||zer|7,xl|||no fcb chain yet|8991
        xl=0;				// no fcb chain yet
        //b ||mov|8,wb|18,=num10||set special code value|8992
        wb= NUM10;				// set special code value
        //b ||jsr|6,sysej|||pack up (stopr not yet usable)|8993
        C_JSR(sysej);				// pack up (stopr not yet usable)
//      initialise structures at start of static region
// ini09:
        //b |ini09|mov|7,xr|3,statb||point to static again|8997
        C_GOTO(ini09);
        } /* ini08 */
        

        void ini09() {
        xr= v.statb;				// point to static again
        //b ||jsr|6,insta|||initialize static|8998
        C_JSR(insta);				// initialize static
//      initialize number of hash headers
        //b ||mov|8,wa|18,=e_hnb||get number of hash headers|9002
        wa= E_HNB;				// get number of hash headers
        //b ||mti|8,wa|||convert to integer|9003
        ia = (word)(wa);				// convert to integer
        //b ||sti|3,hshnb|||store for use by gtnvr procedure|9004
        v.hshnb= ia;				// store for use by gtnvr procedure
        //b ||lct|8,wa|8,wa||counter for clearing hash table|9005
        wa= wa;				// counter for clearing hash table
        //b ||mov|3,hshtb|7,xr||pointer to hash table|9006
        v.hshtb= xr;				// pointer to hash table
//      loop to clear hash table
// ini11:
        //b |ini11|zer|10,(xr)+|||blank a word|9010
        C_GOTO(ini11);
        } /* ini09 */
        

        void ini11() {
        *(xr_it.wp++)=0;				// blank a word
        //b ||bct|8,wa|6,ini11||loop|9011
        if ((--wa))  C_GOTO(ini11);				// loop
        //b ||mov|3,hshte|7,xr||end of hash table adrs is kept|9012
        v.hshte= xr;				// end of hash table adrs is kept
        //b ||mov|3,state|7,xr||store static end address|9013
        v.state= xr;				// store static end address
//      init table to map statement numbers to source file names
        //b ||mov|8,wc|18,=num01||table will have only one bucket|9018
        wc= NUM01;				// table will have only one bucket
        //b ||mov|7,xl|21,=nulls||default table value|9019
        xl= (word)(&c.nulls);				// default table value
        //b ||mov|3,r_sfc|7,xl||current source file name|9020
        v.r_sfc= xl;				// current source file name
        //b ||jsr|6,tmake|||create table|9021
        C_JSR(tmake);				// create table
        //b ||mov|3,r_sfn|7,xr||save ptr to table|9022
        v.r_sfn= xr;				// save ptr to table
//      initialize table to detect duplicate include file names
        //b ||mov|8,wc|18,=num01||table will have only one bucket|9028
        wc= NUM01;				// table will have only one bucket
        //b ||mov|7,xl|21,=nulls||default table value|9029
        xl= (word)(&c.nulls);				// default table value
        //b ||jsr|6,tmake|||create table|9030
        C_JSR(tmake);				// create table
        //b ||mov|3,r_inc|7,xr||save ptr to table|9031
        v.r_inc= xr;				// save ptr to table
//      initialize array to hold names of nested include files
        //b ||mov|8,wa|18,=ccinm||maximum nesting level|9036
        wa= CCINM;				// maximum nesting level
        //b ||mov|7,xl|21,=nulls||null string default value|9037
        xl= (word)(&c.nulls);				// null string default value
        //b ||ppm|||||9039
        C_JSR_1(vmake,(C_ERR(299)));
        //b ||mov|3,r_ifa|7,xr||save ptr to array|9040
        v.r_ifa= xr;				// save ptr to array
//      init array to hold line numbers of nested include files
        //b ||mov|8,wa|18,=ccinm||maximum nesting level|9044
        wa= CCINM;				// maximum nesting level
        //b ||mov|7,xl|21,=inton||integer one default value|9045
        xl= (word)(&c.inton);				// integer one default value
        //b ||ppm|||||9047
        C_JSR_1(vmake,(C_ERR(299)));
        //b ||mov|3,r_ifl|7,xr||save ptr to array|9048
        v.r_ifl= xr;				// save ptr to array
//      initialize variable blocks for input and output
        //b ||mov|7,xl|21,=v_inp||point to string /input/|9055
        xl= (word)(&c.v_inp);				// point to string /input/
        //b ||mov|8,wb|18,=trtin||trblk type for input|9056
        wb= TRTIN;				// trblk type for input
        //b ||jsr|6,inout|||perform input association|9057
        C_JSR(inout);				// perform input association
        //b ||mov|7,xl|21,=v_oup||point to string /output/|9058
        xl= (word)(&c.v_oup);				// point to string /output/
        //b ||mov|8,wb|18,=trtou||trblk type for output|9059
        wb= TRTOU;				// trblk type for output
        //b ||jsr|6,inout|||perform output association|9060
        C_JSR(inout);				// perform output association
        //b ||mov|8,wc|3,initr||terminal flag|9061
        wc= v.initr;				// terminal flag
        //b ||bze|8,wc|6,ini13||skip if no terminal|9062
        if ( !( wc) ) C_GOTO(ini13);				// skip if no terminal
        //b ||jsr|6,prpar|||associate terminal|9063
        C_JSR(prpar);				// associate terminal
        //b ||ejc|||||9064
        
//      check for expiry date
// ini13:
        //b |ini13|jsr|6,sysdc|||call date check|9068
        C_GOTO(ini13);
        } /* ini11 */
        

        void ini13() {
        C_JSR(sysdc);				// call date check
        //b ||mov|3,flptr|7,xs||in case stack overflows in compiler|9069
        v.flptr= xs;				// in case stack overflows in compiler
//      now compile source input code
        //b ||jsr|6,cmpil|||call compiler|9073
        C_JSR(cmpil);				// call compiler
        //b ||mov|3,r_cod|7,xr||set ptr to first code block|9074
        v.r_cod= xr;				// set ptr to first code block
        //b ||mov|3,r_ttl|21,=nulls||forget title|9075
        v.r_ttl= (word)(&c.nulls);				// forget title
        //b ||mov|3,r_stl|21,=nulls||forget sub-title|9076
        v.r_stl= (word)(&c.nulls);				// forget sub-title
        //b ||zer|3,r_cim|||forget compiler input image|9077
        v.r_cim=0;				// forget compiler input image
        //b ||zer|3,r_ccb|||forget interim code block|9078
        v.r_ccb=0;				// forget interim code block
        //b ||zer|3,cnind|||in case end occurred with include|9080
        v.cnind=0;				// in case end occurred with include
        //b ||zer|3,lstid|||listing include depth|9081
        v.lstid=0;				// listing include depth
        //b ||zer|7,xl|||clear dud value|9083
        xl=0;				// clear dud value
        //b ||zer|8,wb|||dont shift dynamic store up|9084
        wb=0;				// dont shift dynamic store up
        //b ||zer|3,dnams|||collect sediment too|9086
        v.dnams=0;				// collect sediment too
        //b ||jsr|6,gbcol|||clear garbage left from compile|9087
        C_JSR(gbcol);				// clear garbage left from compile
        //b ||mov|3,dnams|7,xr||record new sediment size|9088
        v.dnams= xr;				// record new sediment size
        //b ||bnz|3,cpsts|6,inix0||skip if no listing of comp stats|9092
        if (v.cpsts) C_GOTO(inix0);				// skip if no listing of comp stats
        //b ||jsr|6,prtpg|||eject page|9093
        C_JSR(prtpg);				// eject page
//      print compile statistics
        //b ||jsr|6,prtmm|||print memory usage|9097
        C_JSR(prtmm);				// print memory usage
        //b ||mti|3,cmerc|||get count of errors as integer|9098
        ia = (word)(v.cmerc);				// get count of errors as integer
        //b ||mov|7,xr|21,=encm3||point to /compile errors/|9099
        xr= (word)(&c.encm3);				// point to /compile errors/
        //b ||jsr|6,prtmi|||print it|9100
        C_JSR(prtmi);				// print it
        //b ||mti|3,gbcnt|||garbage collection count|9101
        ia = (word)(v.gbcnt);				// garbage collection count
        //b ||sbi|4,intv1|||adjust for unavoidable collect|9102
        ia-=c.intv1;				// adjust for unavoidable collect
        //b ||mov|7,xr|21,=stpm5||point to /storage regenerations/|9103
        xr= (word)(&c.stpm5);				// point to /storage regenerations/
        //b ||jsr|6,prtmi|||print gbcol count|9104
        C_JSR(prtmi);				// print gbcol count
        //b ||jsr|6,systm|||get time|9105
        C_JSR(systm);				// get time
        //b ||sbi|3,timsx|||get compilation time|9106
        ia-=v.timsx;				// get compilation time
        //b ||mov|7,xr|21,=encm4||point to compilation time (msec)/|9107
        xr= (word)(&c.encm4);				// point to compilation time (msec)/
        //b ||jsr|6,prtmi|||print message|9108
        C_JSR(prtmi);				// print message
        //b ||add|3,lstlc|18,=num05||bump line count|9109
        v.lstlc += NUM05;				// bump line count
        //b ||bze|3,headp|6,inix0||no eject if nothing printed|9111
        if ( !( v.headp) ) C_GOTO(inix0);				// no eject if nothing printed
        //b ||jsr|6,prtpg|||eject printer|9112
        C_JSR(prtpg);				// eject printer
        //b ||ejc|||||9114
        
//      prepare now to start execution
//      set default input record length
// inix0:
        //b |inix0|bgt|3,cswin|18,=iniln|6,inix1|skip if not default -in72 used|9120
        C_GOTO(inix0);
        } /* ini13 */
        

        void inix0() {
        if ((v.cswin-INILN) > 0) C_GOTO(inix1);				// skip if not default -in72 used
        //b ||mov|3,cswin|18,=inils||else use default record length|9121
        v.cswin= INILS;				// else use default record length
//      reset timer
// inix1:
        //b |inix1|jsr|6,systm|||get time again|9125
        C_GOTO(inix1);
        } /* inix0 */
        

        void inix1() {
        C_JSR(systm);				// get time again
        //b ||sti|3,timsx|||store for end run processing|9126
        v.timsx= ia;				// store for end run processing
        //b ||zer|3,gbcnt|||initialise collect count|9127
        v.gbcnt=0;				// initialise collect count
        //b ||jsr|6,sysbx|||call before starting execution|9128
        C_JSR(sysbx);				// call before starting execution
        //b ||add|3,noxeq|3,cswex||add -noexecute flag|9129
        v.noxeq += v.cswex;				// add -noexecute flag
        //b ||bnz|3,noxeq|6,inix2||jump if execution suppressed|9130
        if (v.noxeq) C_GOTO(inix2);				// jump if execution suppressed
//      merge when listing file set for execution.  also
//      merge here when restarting a save file or load module.
// iniy0:
        //b |iniy0|mnz|3,headp|||mark headers out regardless|9140
        C_GOTO(iniy0);
        } /* inix1 */
        

        void iniy0() {
        v.headp = 0xffffffffffffffff;				// mark headers out regardless
        //b ||zer|11,-(xs)|||set failure location on stack|9141
        *(--xs_it.wp)=0;				// set failure location on stack
        //b ||mov|3,flptr|7,xs||save ptr to failure offset word|9142
        v.flptr= xs;				// save ptr to failure offset word
        //b ||mov|7,xr|3,r_cod||load ptr to entry code block|9143
        xr= v.r_cod;				// load ptr to entry code block
        //b ||mov|3,stage|18,=stgxt||set stage for execute time|9144
        v.stage= STGXT;				// set stage for execute time
        //b ||mov|3,polcs|18,=num01||reset interface polling interval|9146
        v.polcs= NUM01;				// reset interface polling interval
        //b ||mov|3,polct|18,=num01||reset interface polling interval|9147
        v.polct= NUM01;				// reset interface polling interval
        //b ||mov|3,pfnte|3,cmpsn||copy stmts compiled count in case|9151
        v.pfnte= v.cmpsn;				// copy stmts compiled count in case
        //b ||mov|3,pfdmp|3,kvpfl||start profiling if &profile set|9152
        v.pfdmp= v.kvpfl;				// start profiling if &profile set
        //b ||jsr|6,systm|||time yet again|9153
        C_JSR(systm);				// time yet again
        //b ||sti|3,pfstm||||9154
        v.pfstm= ia;
        //b ||jsr|6,stgcc|||compute stmgo countdown counters|9156
        C_JSR(stgcc);				// compute stmgo countdown counters
        //b ||bri|9,(xr)|||start xeq with first statement|9157
        w0 = xr_it.wp[0];				// start xeq with first statement
        C_GOTO(w0_it.callp);
//      here if execution is suppressed
// inix2:
        //b |inix2|zer|8,wa|||set abend value to zero|9162
        } /* iniy0 */
        

        void inix2() {
        wa=0;				// set abend value to zero
        //b ||mov|8,wb|18,=nini9||set special code value|9170
        wb= NINI9;				// set special code value
        //b ||zer|7,xl|||no fcb chain|9171
        xl=0;				// no fcb chain
        //b ||jsr|6,sysej|||end of job, exit to system|9172
        C_JSR(sysej);				// end of job, exit to system
//      here from osint to restart a save file or load module.
// rstrt:
        //b |rstrt|prc|25,e|1,0||entry point|9177
        C_GOTO(rstrt);
        } /* inix2 */
        

        void rstrt() {
        //b ||mov|7,xs|3,stbas||discard return|9178
        xs= v.stbas;				// discard return
        //b ||zer|7,xl|||clear xl|9179
        xl=0;				// clear xl
        //b ||brn|6,iniy0|||resume execution|9180
         C_GOTO(iniy0);				// resume execution
        //b ||ttl|27,s p i t b o l -- snobol4 operator routines||||9183
        /* s p i t b o l -- snobol4 operator routines*/
//      this section includes all routines which can be accessed
//      directly from the generated code except system functions.
//      all routines in this section start with a label of the
//      form o_xxx where xxx is three letters. the generated code
//      contains a pointer to the appropriate entry label.
//      since the general form of the generated code consists of
//      pointers to blocks whose first word is the address of the
//      actual entry point label (o_xxx).
//      these routines are in alphabetical order by their
//      entry label names (i.e. by the xxx of the o_xxx name)
//      these routines receive control as follows
//      (cp)                  pointer to next code word
//      (xs)                  current stack pointer
        //b ||ejc|||||9203
        
//      binary plus (addition)
//	align	2
//	nop
        //b |o_add|ent||||entry point|9207
        } /* rstrt */
        

        void o_add() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,oadd1|||jump if real operands|9214
        extern void _l0347();
        C_JMS(arith,P_PRC_ARITH,_l0347);
        } /* o_add */
        

        void _l0347() {
        C_JMS_HANDLE_3(arith,(C_ERR(1)),(C_ERR(2)),C_GOTO(oadd1));				// jump if real operands
//      here to add two integers
        //b ||adi|13,icval(xl)|||add right operand to left|9219
        ia+=*((word *)(CFP_B*ICVAL + xl));				// add right operand to left
        //b ||ino|6,exint|||return integer if no overflow|9220
         C_GOTO(exint);				// return integer if no overflow
        /*g.ino g.iov is a noop, but could be done like g.aov*/
        //b ||erb|1,003|26,addition caused integer overflow|||9221
        C_ERB(3)
//      here to add two reals
// oadd1:
        //b |oadd1|adr|13,rcval(xl)|||add right operand to left|9227
        } /* _l0347 */
        

        void oadd1() {
        {w0 = *((word *)(CFP_B*RCVAL + xl));ra_it.d += w0_it.d;fl=(!isgoodnum(ra_it.d));}				// add right operand to left
        //b ||rno|6,exrea|||return real if no overflow|9228
        if (fl==0) C_GOTO(exrea);				// return real if no overflow
        //b ||erb|1,261|26,addition caused real overflow|||9229
        C_ERB(261)
        //b ||ejc|||||9231
        
//      unary plus (affirmation)
//	align	2
//	nop
        //b |o_aff|ent||||entry point|9235
        } /* oadd1 */
        

        void o_aff() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load operand|9236
        xr= C_POP();				// load operand
        //b ||err|1,004|26,affirmation operand is not numeric|||9238
        C_JSR_1(gtnum,(C_ERR(4)));
        //b ||mov|11,-(xs)|7,xr||result if converted to numeric|9239
        C_PUSH(xr);				// result if converted to numeric
        //b ||lcw|7,xr|||get next code word|9240
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|9241
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9242
        
//      binary bar (alternation)
//	align	2
//	nop
        //b |o_alt|ent||||entry point|9246
        } /* o_aff */
        

        void o_alt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load right operand|9247
        xr= C_POP();				// load right operand
        //b ||err|1,005|26,alternation right operand is not pattern|||9249
        C_JSR_1(gtpat,(C_ERR(5)));
//      merge here from special (left alternation) case
// oalt1:
        //b |oalt1|mov|8,wb|22,=p_alt||set pcode for alternative node|9253
        C_GOTO(oalt1);
        } /* o_alt */
        

        void oalt1() {
        wb= (word)(p_alt);				// set pcode for alternative node
        //b ||jsr|6,pbild|||build alternative node|9254
        C_JSR(pbild);				// build alternative node
        //b ||mov|7,xl|7,xr||save address of alternative node|9255
        xl= xr;				// save address of alternative node
        //b ||mov|7,xr|10,(xs)+||load left operand|9256
        xr= C_POP();				// load left operand
        //b ||err|1,006|26,alternation left operand is not pattern|||9258
        C_JSR_1(gtpat,(C_ERR(6)));
        //b ||beq|7,xr|22,=p_alt|6,oalt2|jump if left arg is alternation|9259
        if ((xr-(word)(p_alt)) == 0) C_GOTO(oalt2);				// jump if left arg is alternation
        //b ||mov|13,pthen(xl)|7,xr||set left operand as successor|9260
        *((word *)(CFP_B*PTHEN + xl))= xr;				// set left operand as successor
        //b ||mov|11,-(xs)|7,xl||stack result|9261
        C_PUSH(xl);				// stack result
        //b ||lcw|7,xr|||get next code word|9262
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|9263
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      come here if left argument is itself an alternation
//      the result is more efficient if we make the replacement
//      (a / b) / c = a / (b / c)
// oalt2:
        //b |oalt2|mov|13,pthen(xl)|13,parm1(xr)||build the (b / c) node|9271
        } /* oalt1 */
        

        void oalt2() {
        *((word *)(CFP_B*PTHEN + xl))= *((word *)(CFP_B*PARM1 + xr));				// build the (b / c) node
        //b ||mov|11,-(xs)|13,pthen(xr)||set a as new left arg|9272
        C_PUSH(*((word *)(CFP_B*PTHEN + xr)));				// set a as new left arg
        //b ||mov|7,xr|7,xl||set (b / c) as new right arg|9273
        xr= xl;				// set (b / c) as new right arg
        //b ||brn|6,oalt1|||merge back to build a / (b / c)|9274
         C_GOTO(oalt1);				// merge back to build a / (b / c)
        //b ||ejc|||||9275
        
//      array reference (multiple subscripts, by name)
//	align	2
//	nop
        //b |o_amn|ent||||entry point|9279
        } /* oalt2 */
        

        void o_amn() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||lcw|7,xr|||load number of subscripts|9280
        xr  = *((word *)reg_cp);				// load number of subscripts
          reg_cp += CFP_B;
        //b ||mov|8,wb|7,xr||set flag for by name|9281
        wb= xr;				// set flag for by name
        //b ||brn|6,arref|||jump to array reference routine|9282
         C_GOTO(arref);				// jump to array reference routine
        //b ||ejc|||||9283
        
//      array reference (multiple subscripts, by value)
//	align	2
//	nop
        //b |o_amv|ent||||entry point|9287
        } /* o_amn */
        

        void o_amv() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||lcw|7,xr|||load number of subscripts|9288
        xr  = *((word *)reg_cp);				// load number of subscripts
          reg_cp += CFP_B;
        //b ||zer|8,wb|||set flag for by value|9289
        wb=0;				// set flag for by value
        //b ||brn|6,arref|||jump to array reference routine|9290
         C_GOTO(arref);				// jump to array reference routine
        //b ||ejc|||||9291
        
//      array reference (one subscript, by name)
//	align	2
//	nop
        //b |o_aon|ent||||entry point|9295
        } /* o_amv */
        

        void o_aon() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|9,(xs)||load subscript value|9296
        xr= *(xs_it.wp);				// load subscript value
        //b ||mov|7,xl|13,num01(xs)||load array value|9297
        xl= *((word *)(CFP_B*NUM01 + xs));				// load array value
        //b ||mov|8,wa|9,(xl)||load first word of array operand|9298
        wa= *(xl_it.wp);				// load first word of array operand
        //b ||beq|8,wa|22,=b_vct|6,oaon2|jump if vector reference|9299
        if ((wa-(word)(b_vct)) == 0) C_GOTO(oaon2);				// jump if vector reference
        //b ||beq|8,wa|22,=b_tbt|6,oaon3|jump if table reference|9300
        if ((wa-(word)(b_tbt)) == 0) C_GOTO(oaon3);				// jump if table reference
//      here to use central array reference routine
// oaon1:
        //b |oaon1|mov|7,xr|18,=num01||set number of subscripts to one|9304
        C_GOTO(oaon1);
        } /* o_aon */
        

        void oaon1() {
        xr= NUM01;				// set number of subscripts to one
        //b ||mov|8,wb|7,xr||set flag for by name|9305
        wb= xr;				// set flag for by name
        //b ||brn|6,arref|||jump to array reference routine|9306
         C_GOTO(arref);				// jump to array reference routine
//      here if we have a vector reference
// oaon2:
        //b |oaon2|bne|9,(xr)|22,=b_icl|6,oaon1|use long routine if not integer|9310
        } /* oaon1 */
        

        void oaon2() {
        if ((*(xr_it.wp)-(word)(b_icl)) != 0) C_GOTO(oaon1);				// use long routine if not integer
        //b ||ldi|13,icval(xr)|||load integer subscript value|9311
        ia = *((word *)(CFP_B*ICVAL + xr));				// load integer subscript value
        //b ||mfi|8,wa|6,exfal||copy as address int, fail if ovflo|9312
        if (ia<0) C_GOTO( exfal);				// copy as address int, fail if ovflo
        wa = ia;
        //b ||bze|8,wa|6,exfal||fail if zero|9313
        if ( !( wa) ) C_GOTO(exfal);				// fail if zero
        //b ||add|8,wa|18,=vcvlb||compute offset in words|9314
        wa += VCVLB;				// compute offset in words
        //b ||wtb|8,wa|||convert to bytes|9315
        wa <<= LOG_CFP_B;				// convert to bytes
        //b ||mov|9,(xs)|8,wa||complete name on stack|9316
        *(xs_it.wp)= wa;				// complete name on stack
        //b ||blt|8,wa|13,vclen(xl)|6,oaon4|exit if subscript not too large|9317
        if ((wa-*((word *)(CFP_B*VCLEN + xl))) < 0) C_GOTO(oaon4);				// exit if subscript not too large
        //b ||brn|6,exfal|||else fail|9318
         C_GOTO(exfal);				// else fail
//      here for table reference
// oaon3:
        //b |oaon3|mnz|8,wb|||set flag for name reference|9322
        } /* oaon2 */
        

        void oaon3() {
        wb = 0xffffffffffffffff;				// set flag for name reference
        //b ||ppm|6,exfal|||fail if access fails|9324
        C_JSR_1(tfind,C_GOTO(exfal));				// fail if access fails
        //b ||mov|13,num01(xs)|7,xl||store name base on stack|9325
        *((word *)(CFP_B*NUM01 + xs))= xl;				// store name base on stack
        //b ||mov|9,(xs)|8,wa||store name offset on stack|9326
        *(xs_it.wp)= wa;				// store name offset on stack
//      here to exit with result on stack
// oaon4:
        //b |oaon4|lcw|7,xr|||result on stack, get code word|9330
        C_GOTO(oaon4);
        } /* oaon3 */
        

        void oaon4() {
        xr  = *((word *)reg_cp);				// result on stack, get code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|9331
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9332
        
//      array reference (one subscript, by value)
//	align	2
//	nop
        //b |o_aov|ent||||entry point|9336
        } /* oaon4 */
        

        void o_aov() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load subscript value|9337
        xr= C_POP();				// load subscript value
        //b ||mov|7,xl|10,(xs)+||load array value|9338
        xl= C_POP();				// load array value
        //b ||mov|8,wa|9,(xl)||load first word of array operand|9339
        wa= *(xl_it.wp);				// load first word of array operand
        //b ||beq|8,wa|22,=b_vct|6,oaov2|jump if vector reference|9340
        if ((wa-(word)(b_vct)) == 0) C_GOTO(oaov2);				// jump if vector reference
        //b ||beq|8,wa|22,=b_tbt|6,oaov3|jump if table reference|9341
        if ((wa-(word)(b_tbt)) == 0) C_GOTO(oaov3);				// jump if table reference
//      here to use central array reference routine
// oaov1:
        //b |oaov1|mov|11,-(xs)|7,xl||restack array value|9345
        C_GOTO(oaov1);
        } /* o_aov */
        

        void oaov1() {
        C_PUSH(xl);				// restack array value
        //b ||mov|11,-(xs)|7,xr||restack subscript|9346
        C_PUSH(xr);				// restack subscript
        //b ||mov|7,xr|18,=num01||set number of subscripts to one|9347
        xr= NUM01;				// set number of subscripts to one
        //b ||zer|8,wb|||set flag for value call|9348
        wb=0;				// set flag for value call
        //b ||brn|6,arref|||jump to array reference routine|9349
         C_GOTO(arref);				// jump to array reference routine
//      here if we have a vector reference
// oaov2:
        //b |oaov2|bne|9,(xr)|22,=b_icl|6,oaov1|use long routine if not integer|9353
        } /* oaov1 */
        

        void oaov2() {
        if ((*(xr_it.wp)-(word)(b_icl)) != 0) C_GOTO(oaov1);				// use long routine if not integer
        //b ||ldi|13,icval(xr)|||load integer subscript value|9354
        ia = *((word *)(CFP_B*ICVAL + xr));				// load integer subscript value
        //b ||mfi|8,wa|6,exfal||move as one word int, fail if ovflo|9355
        if (ia<0) C_GOTO( exfal);				// move as one word int, fail if ovflo
        wa = ia;
        //b ||bze|8,wa|6,exfal||fail if zero|9356
        if ( !( wa) ) C_GOTO(exfal);				// fail if zero
        //b ||add|8,wa|18,=vcvlb||compute offset in words|9357
        wa += VCVLB;				// compute offset in words
        //b ||wtb|8,wa|||convert to bytes|9358
        wa <<= LOG_CFP_B;				// convert to bytes
        //b ||bge|8,wa|13,vclen(xl)|6,exfal|fail if subscript too large|9359
        if ((wa-*((word *)(CFP_B*VCLEN + xl))) >= 0) C_GOTO(exfal);				// fail if subscript too large
        //b ||ppm|6,exfal|||fail if access fails|9361
        C_JSR_1(acess,C_GOTO(exfal));				// fail if access fails
        //b ||mov|11,-(xs)|7,xr||stack result|9362
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|9363
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|9364
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      here for table reference by value
// oaov3:
        //b |oaov3|zer|8,wb|||set flag for value reference|9368
        } /* oaov2 */
        

        void oaov3() {
        wb=0;				// set flag for value reference
        //b ||ppm|6,exfal|||fail if access fails|9370
        C_JSR_1(tfind,C_GOTO(exfal));				// fail if access fails
        //b ||mov|11,-(xs)|7,xr||stack result|9371
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|9372
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|9373
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9374
        
//      assignment
//	align	2
//	nop
        //b |o_ass|ent||||entry point|9378
        } /* oaov3 */
        

        void o_ass() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
//      o_rpl (pattern replacement) merges here
// oass0:
        //b |oass0|mov|8,wb|10,(xs)+||load value to be assigned|9382
        C_GOTO(oass0);
        } /* o_ass */
        

        void oass0() {
        wb= C_POP();				// load value to be assigned
        //b ||mov|8,wa|10,(xs)+||load name offset|9383
        wa= C_POP();				// load name offset
        //b ||mov|7,xl|9,(xs)||load name base|9384
        xl= *(xs_it.wp);				// load name base
        //b ||mov|9,(xs)|8,wb||store assigned value as result|9385
        *(xs_it.wp)= wb;				// store assigned value as result
        //b ||ppm|6,exfal|||fail if assignment fails|9387
        C_JSR_1(asign,C_GOTO(exfal));				// fail if assignment fails
        //b ||lcw|7,xr|||result on stack, get code word|9388
        xr  = *((word *)reg_cp);				// result on stack, get code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|9389
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9390
        
//      compilation error
//	align	2
//	nop
        //b |o_cer|ent||||entry point|9394
        } /* oass0 */
        

        void o_cer() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||erb|1,007|26,compilation error encountered during execution|||9395
        C_ERB(7)
        //b ||ejc|||||9396
        
//      unary at (cursor assignment)
//	align	2
//	nop
        //b |o_cas|ent||||entry point|9400
        } /* o_cer */
        

        void o_cas() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wc|10,(xs)+||load name offset (parm2)|9401
        wc= C_POP();				// load name offset (parm2)
        //b ||mov|7,xr|10,(xs)+||load name base (parm1)|9402
        xr= C_POP();				// load name base (parm1)
        //b ||mov|8,wb|22,=p_cas||set pcode for cursor assignment|9403
        wb= (word)(p_cas);				// set pcode for cursor assignment
        //b ||jsr|6,pbild|||build node|9404
        C_JSR(pbild);				// build node
        //b ||mov|11,-(xs)|7,xr||stack result|9405
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|9406
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|9407
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9408
        
//      concatenation
//	align	2
//	nop
        //b |o_cnc|ent||||entry point|9412
        } /* o_cas */
        

        void o_cnc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|9,(xs)||load right argument|9413
        xr= *(xs_it.wp);				// load right argument
        //b ||beq|7,xr|21,=nulls|6,ocnc3|jump if right arg is null|9414
        if ((xr-(word)(&c.nulls)) == 0) C_GOTO(ocnc3);				// jump if right arg is null
        //b ||mov|7,xl|12,1(xs)||load left argument|9415
        xl= *((word *)(CFP_B*1 + xs));				// load left argument
        //b ||beq|7,xl|21,=nulls|6,ocnc4|jump if left argument is null|9416
        if ((xl-(word)(&c.nulls)) == 0) C_GOTO(ocnc4);				// jump if left argument is null
        //b ||mov|8,wa|22,=b_scl||get constant to test for string|9417
        wa= (word)(b_scl);				// get constant to test for string
        //b ||bne|8,wa|9,(xl)|6,ocnc2|jump if left arg not a string|9418
        if ((wa-*(xl_it.wp)) != 0) C_GOTO(ocnc2);				// jump if left arg not a string
        //b ||bne|8,wa|9,(xr)|6,ocnc2|jump if right arg not a string|9419
        if ((wa-*(xr_it.wp)) != 0) C_GOTO(ocnc2);				// jump if right arg not a string
//      merge here to concatenate two strings
// ocnc1:
        //b |ocnc1|mov|8,wa|13,sclen(xl)||load left argument length|9423
        C_GOTO(ocnc1);
        } /* o_cnc */
        

        void ocnc1() {
        wa= *((word *)(CFP_B*SCLEN + xl));				// load left argument length
        //b ||add|8,wa|13,sclen(xr)||compute result length|9424
        wa += *((word *)(CFP_B*SCLEN + xr));				// compute result length
        //b ||jsr|6,alocs|||allocate scblk for result|9425
        C_JSR(alocs);				// allocate scblk for result
        //b ||mov|12,1(xs)|7,xr||store result ptr over left argument|9426
        *((word *)(CFP_B*1 + xs))= xr;				// store result ptr over left argument
        //b ||psc|7,xr|||prepare to store chars of result|9427
        xr += CFP_F;				// prepare to store chars of result
        //b ||mov|8,wa|13,sclen(xl)||get number of chars in left arg|9428
        wa= *((word *)(CFP_B*SCLEN + xl));				// get number of chars in left arg
        //b ||plc|7,xl|||prepare to load left arg chars|9429
        xl += CFP_F;				// prepare to load left arg chars
        //b ||mvc||||move characters of left argument|9430
        do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);				// move characters of left argument
        //b ||mov|7,xl|10,(xs)+||load right arg pointer, pop stack|9431
        xl= C_POP();				// load right arg pointer, pop stack
        //b ||mov|8,wa|13,sclen(xl)||load number of chars in right arg|9432
        wa= *((word *)(CFP_B*SCLEN + xl));				// load number of chars in right arg
        //b ||plc|7,xl|||prepare to load right arg chars|9433
        xl += CFP_F;				// prepare to load right arg chars
        //b ||mvc||||move characters of right argument|9434
        do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);				// move characters of right argument
        //b ||zer|7,xl|||clear garbage value in xl|9435
        xl=0;				// clear garbage value in xl
        //b ||lcw|7,xr|||result on stack, get code word|9436
        xr  = *((word *)reg_cp);				// result on stack, get code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|9437
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
//      come here if arguments are not both strings
// ocnc2:
        //b |ocnc2|jsr|6,gtstg|||convert right arg to string|9441
        } /* ocnc1 */
        

        void ocnc2() {
        //b ||ppm|6,ocnc5|||jump if right arg is not string|9442
        extern void _l0350();
        C_JMS(gtstg,P_PRC_GTSTG,_l0350);
        } /* ocnc2 */
        

        void _l0350() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(ocnc5));				// jump if right arg is not string
        //b ||mov|7,xl|7,xr||save right arg ptr|9443
        xl= xr;				// save right arg ptr
        //b ||ppm|6,ocnc6|||jump if left arg is not a string|9445
        extern void _l0351();
        C_JMS(gtstg,P_PRC_GTSTG,_l0351);
        } /* _l0350 */
        

        void _l0351() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(ocnc6));				// jump if left arg is not a string
        //b ||mov|11,-(xs)|7,xr||stack left argument|9446
        C_PUSH(xr);				// stack left argument
        //b ||mov|11,-(xs)|7,xl||stack right argument|9447
        C_PUSH(xl);				// stack right argument
        //b ||mov|7,xl|7,xr||move left arg to proper reg|9448
        xl= xr;				// move left arg to proper reg
        //b ||mov|7,xr|9,(xs)||move right arg to proper reg|9449
        xr= *(xs_it.wp);				// move right arg to proper reg
        //b ||brn|6,ocnc1|||merge back to concatenate strings|9450
         C_GOTO(ocnc1);				// merge back to concatenate strings
        //b ||ejc|||||9451
        
//      concatenation (continued)
//      come here for null right argument
// ocnc3:
        //b |ocnc3|ica|7,xs|||remove right arg from stack|9457
        } /* _l0351 */
        

        void ocnc3() {
        xs += CFP_B;				// remove right arg from stack
        //b ||lcw|7,xr|||left argument on stack|9458
        xr  = *((word *)reg_cp);				// left argument on stack
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|9459
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
//      here for null left argument
// ocnc4:
        //b |ocnc4|ica|7,xs|||unstack one argument|9463
        } /* ocnc3 */
        

        void ocnc4() {
        xs += CFP_B;				// unstack one argument
        //b ||mov|9,(xs)|7,xr||store right argument|9464
        *(xs_it.wp)= xr;				// store right argument
        //b ||lcw|7,xr|||result on stack, get code word|9465
        xr  = *((word *)reg_cp);				// result on stack, get code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|9466
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
//      here if right argument is not a string
// ocnc5:
        //b |ocnc5|mov|7,xl|7,xr||move right argument ptr|9470
        } /* ocnc4 */
        

        void ocnc5() {
        xl= xr;				// move right argument ptr
        //b ||mov|7,xr|10,(xs)+||load left arg pointer|9471
        xr= C_POP();				// load left arg pointer
//      merge here when left argument is not a string
// ocnc6:
        //b |ocnc6|jsr|6,gtpat|||convert left arg to pattern|9475
        C_GOTO(ocnc6);
        } /* ocnc5 */
        

        void ocnc6() {
        //b ||err|1,008|26,concatenation left operand is not a string or pattern|||9476
        C_JSR_1(gtpat,(C_ERR(8)));
        //b ||mov|11,-(xs)|7,xr||save result on stack|9477
        C_PUSH(xr);				// save result on stack
        //b ||mov|7,xr|7,xl||point to right operand|9478
        xr= xl;				// point to right operand
        //b ||err|1,009|26,concatenation right operand is not a string or pattern|||9480
        C_JSR_1(gtpat,(C_ERR(9)));
        //b ||mov|7,xl|7,xr||move for pconc|9481
        xl= xr;				// move for pconc
        //b ||mov|7,xr|10,(xs)+||reload left operand ptr|9482
        xr= C_POP();				// reload left operand ptr
        //b ||jsr|6,pconc|||concatenate patterns|9483
        C_JSR(pconc);				// concatenate patterns
        //b ||mov|11,-(xs)|7,xr||stack result|9484
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|9485
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|9486
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9487
        
//      complementation
//	align	2
//	nop
        //b |o_com|ent||||entry point|9491
        } /* ocnc6 */
        

        void o_com() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load operand|9492
        xr= C_POP();				// load operand
        //b ||mov|8,wa|9,(xr)||load type word|9493
        wa= *(xr_it.wp);				// load type word
//      merge back here after conversion
// ocom1:
        //b |ocom1|beq|8,wa|22,=b_icl|6,ocom2|jump if integer|9497
        C_GOTO(ocom1);
        } /* o_com */
        

        void ocom1() {
        if ((wa-(word)(b_icl)) == 0) C_GOTO(ocom2);				// jump if integer
        //b ||beq|8,wa|22,=b_rcl|6,ocom3|jump if real|9500
        if ((wa-(word)(b_rcl)) == 0) C_GOTO(ocom3);				// jump if real
        //b ||err|1,010|26,negation operand is not numeric|||9503
        C_JSR_1(gtnum,(C_ERR(10)));
        //b ||brn|6,ocom1|||back to check cases|9504
         C_GOTO(ocom1);				// back to check cases
//      here to complement integer
// ocom2:
        //b |ocom2|ldi|13,icval(xr)|||load integer value|9508
        } /* ocom1 */
        

        void ocom2() {
        ia = *((word *)(CFP_B*ICVAL + xr));				// load integer value
        //b ||ngi||||negate|9509
        ia= -ia;				// negate
        //b ||ino|6,exint|||return integer if no overflow|9510
         C_GOTO(exint);				// return integer if no overflow
        /*g.ino g.iov is a noop, but could be done like g.aov*/
        //b ||erb|1,011|26,negation caused integer overflow|||9511
        C_ERB(11)
//      here to complement real
// ocom3:
        //b |ocom3|ldr|13,rcval(xr)|||load real value|9517
        } /* ocom2 */
        

        void ocom3() {
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load real value
        //b ||ngr||||negate|9518
        {ra_it.d = - ra_it.d;fl=(!isgoodnum(ra_it.d));}				// negate
        //b ||brn|6,exrea|||return real result|9519
         C_GOTO(exrea);				// return real result
        //b ||ejc|||||9521
        
//      binary slash (division)
//	align	2
//	nop
        //b |o_dvd|ent||||entry point|9525
        } /* ocom3 */
        

        void o_dvd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,odvd2|||jump if real operands|9531
        extern void _l0352();
        C_JMS(arith,P_PRC_ARITH,_l0352);
        } /* o_dvd */
        

        void _l0352() {
        C_JMS_HANDLE_3(arith,(C_ERR(12)),(C_ERR(13)),C_GOTO(odvd2));				// jump if real operands
//      here to divide two integers
        //b ||dvi|13,icval(xl)|||divide left operand by right|9536
        ia=ia / *((word *)(CFP_B*ICVAL + xl));				// divide left operand by right
        //b ||ino|6,exint|||result ok if no overflow|9537
         C_GOTO(exint);				// result ok if no overflow
        /*g.ino g.iov is a noop, but could be done like g.aov*/
        //b ||erb|1,014|26,division caused integer overflow|||9538
        C_ERB(14)
//      here to divide two reals
// odvd2:
        //b |odvd2|dvr|13,rcval(xl)|||divide left operand by right|9544
        } /* _l0352 */
        

        void odvd2() {
        {w0 = *((word *)(CFP_B*RCVAL + xl)); if (w0_it.d != 0.0) {ra_it.d /= w0_it.d;fl= (!isgoodnum(ra_it.d));} else {fl=1;}}				// divide left operand by right
        //b ||rno|6,exrea|||return real if no overflow|9545
        if (fl==0) C_GOTO(exrea);				// return real if no overflow
        //b ||erb|1,262|26,division caused real overflow|||9546
        C_ERB(262)
        //b ||ejc|||||9548
        
//      exponentiation
//	align	2
//	nop
        //b |o_exp|ent||||entry point|9552
        } /* odvd2 */
        

        void o_exp() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load exponent|9553
        xr= C_POP();				// load exponent
        //b ||err|1,015|26,exponentiation right operand is not numeric|||9555
        C_JSR_1(gtnum,(C_ERR(15)));
        //b ||mov|7,xl|7,xr||move exponent to xl|9556
        xl= xr;				// move exponent to xl
        //b ||mov|7,xr|10,(xs)+||load base|9557
        xr= C_POP();				// load base
        //b ||err|1,016|26,exponentiation left operand is not numeric|||9559
        C_JSR_1(gtnum,(C_ERR(16)));
        //b ||beq|9,(xl)|22,=b_rcl|6,oexp7|jump if real exponent|9562
        if ((*(xl_it.wp)-(word)(b_rcl)) == 0) C_GOTO(oexp7);				// jump if real exponent
        //b ||ldi|13,icval(xl)|||load exponent|9564
        ia = *((word *)(CFP_B*ICVAL + xl));				// load exponent
        //b ||ilt|6,oex12|||jump if negative exponent|9565
        if (ia < 0)  C_GOTO(oex12);				// jump if negative exponent
        //b ||beq|8,wa|22,=b_rcl|6,oexp3|jump if base is real|9568
        if ((wa-(word)(b_rcl)) == 0) C_GOTO(oexp3);				// jump if base is real
//      here to exponentiate an integer base and integer exponent
        //b ||mfi|8,wa|6,oexp2||convert exponent to 1 word integer|9573
        if (ia<0) C_GOTO( oexp2);				// convert exponent to 1 word integer
        wa = ia;
        //b ||lct|8,wa|8,wa||set loop counter|9574
        wa= wa;				// set loop counter
        //b ||ldi|13,icval(xr)|||load base as initial value|9575
        ia = *((word *)(CFP_B*ICVAL + xr));				// load base as initial value
        //b ||bnz|8,wa|6,oexp1||jump into loop if non-zero exponent|9576
        if (wa) C_GOTO(oexp1);				// jump into loop if non-zero exponent
        //b ||ieq|6,oexp4|||error if 0**0|9577
        if (ia == 0)  C_GOTO(oexp4);				// error if 0**0
        //b ||ldi|4,intv1|||nonzero**0|9578
        ia = c.intv1;				// nonzero**0
        //b ||brn|6,exint|||give one as result for nonzero**0|9579
         C_GOTO(exint);				// give one as result for nonzero**0
//      loop to perform exponentiation
// oex13:
        //b |oex13|mli|13,icval(xr)|||multiply by base|9583
        } /* o_exp */
        

        void oex13() {
        ia*=*((word *)(CFP_B*ICVAL + xr));				// multiply by base
        //b ||iov|6,oexp2|||jump if overflow|9584
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// jump if overflow
// oexp1:
        //b |oexp1|bct|8,wa|6,oex13||loop if more to go|9585
        C_GOTO(oexp1);
        } /* oex13 */
        

        void oexp1() {
        if ((--wa))  C_GOTO(oex13);				// loop if more to go
        //b ||brn|6,exint|||else return integer result|9586
         C_GOTO(exint);				// else return integer result
//      here if integer overflow
// oexp2:
        //b |oexp2|erb|1,017|26,exponentiation caused integer overflow|||9590
        } /* oexp1 */
        

        void oexp2() {
        C_ERB(17)
        //b ||ejc|||||9591
        
//      exponentiation (continued)
//      here to exponentiate a real to an integer power
// oexp3:
        //b |oexp3|mfi|8,wa|6,oexp6||convert exponent to one word|9599
        } /* oexp2 */
        

        void oexp3() {
        if (ia<0) C_GOTO( oexp6);				// convert exponent to one word
        wa = ia;
        //b ||lct|8,wa|8,wa||set loop counter|9600
        wa= wa;				// set loop counter
        //b ||ldr|13,rcval(xr)|||load base as initial value|9601
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load base as initial value
        //b ||bnz|8,wa|6,oexp5||jump into loop if non-zero exponent|9602
        if (wa) C_GOTO(oexp5);				// jump into loop if non-zero exponent
        //b ||req|6,oexp4|||error if 0.0**0|9603
        if (ra_it.d == 0.0)  C_GOTO(oexp4);				// error if 0.0**0
        //b ||ldr|4,reav1|||nonzero**0|9604
        {ra_it.d = c.reav1;fl=(!isgoodnum(ra_it.d));}				// nonzero**0
        //b ||brn|6,exrea|||return 1.0 if nonzero**zero|9605
         C_GOTO(exrea);				// return 1.0 if nonzero**zero
//      here for error of 0**0 or 0.0**0
// oexp4:
        //b |oexp4|erb|1,018|26,exponentiation result is undefined|||9610
        } /* oexp3 */
        

        void oexp4() {
        C_ERB(18)
//      loop to perform exponentiation
// oex14:
        //b |oex14|mlr|13,rcval(xr)|||multiply by base|9616
        } /* oexp4 */
        

        void oex14() {
        {w0 = *((word *)(CFP_B*RCVAL + xr));ra_it.d *=  w0_it.d;fl=(!isgoodnum(ra_it.d));}				// multiply by base
        //b ||rov|6,oexp6|||jump if overflow|9617
        if (fl) C_GOTO(oexp6);				// jump if overflow
// oexp5:
        //b |oexp5|bct|8,wa|6,oex14||loop till computation complete|9618
        C_GOTO(oexp5);
        } /* oex14 */
        

        void oexp5() {
        if ((--wa))  C_GOTO(oex14);				// loop till computation complete
        //b ||brn|6,exrea|||then return real result|9619
         C_GOTO(exrea);				// then return real result
//      here if real overflow
// oexp6:
        //b |oexp6|erb|1,266|26,exponentiation caused real overflow|||9623
        } /* oexp5 */
        

        void oexp6() {
        C_ERB(266)
//      here with real exponent in (xl), numeric base in (xr)
// oexp7:
        //b |oexp7|beq|9,(xr)|22,=b_rcl|6,oexp8|jump if base real|9628
        } /* oexp6 */
        

        void oexp7() {
        if ((*(xr_it.wp)-(word)(b_rcl)) == 0) C_GOTO(oexp8);				// jump if base real
        //b ||ldi|13,icval(xr)|||load integer base|9629
        ia = *((word *)(CFP_B*ICVAL + xr));				// load integer base
        //b ||itr||||convert to real|9630
        ra =  (double) (ia);				// convert to real
        //b ||jsr|6,rcbld|||create real in (xr)|9631
        C_JSR(rcbld);				// create real in (xr)
//      here with real exponent in (xl)
//      numeric base in (xr) and ra
// oexp8:
        //b |oexp8|zer|8,wb|||set positive result flag|9636
        C_GOTO(oexp8);
        } /* oexp7 */
        

        void oexp8() {
        wb=0;				// set positive result flag
        //b ||ldr|13,rcval(xr)|||load base to ra|9637
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load base to ra
        //b ||rne|6,oexp9|||jump if base non-zero|9638
        if (ra_it.d != 0.0)  C_GOTO(oexp9);				// jump if base non-zero
        //b ||ldr|13,rcval(xl)|||base is zero.  check exponent|9639
        {ra_it.d = *((word *)(CFP_B*RCVAL + xl));fl=(!isgoodnum(ra_it.d));}				// base is zero.  check exponent
        //b ||req|6,oexp4|||jump if 0.0 ** 0.0|9640
        if (ra_it.d == 0.0)  C_GOTO(oexp4);				// jump if 0.0 ** 0.0
        //b ||ldr|4,reav0|||0.0 to non-zero exponent yields 0.0|9641
        {ra_it.d = c.reav0;fl=(!isgoodnum(ra_it.d));}				// 0.0 to non-zero exponent yields 0.0
        //b ||brn|6,exrea|||return zero result|9642
         C_GOTO(exrea);				// return zero result
//      here with non-zero base in (xr) and ra, exponent in (xl)
//      a negative base is allowed if the exponent is integral.
// oexp9:
        //b |oexp9|rgt|6,oex10|||jump if base gt 0.0|9648
        } /* oexp8 */
        

        void oexp9() {
        if (ra_it.d > 0.0)  C_GOTO(oex10);				// jump if base gt 0.0
        //b ||ngr||||make base positive|9649
        {ra_it.d = - ra_it.d;fl=(!isgoodnum(ra_it.d));}				// make base positive
        //b ||jsr|6,rcbld|||create positive base in (xr)|9650
        C_JSR(rcbld);				// create positive base in (xr)
        //b ||ldr|13,rcval(xl)|||examine exponent|9651
        {ra_it.d = *((word *)(CFP_B*RCVAL + xl));fl=(!isgoodnum(ra_it.d));}				// examine exponent
        //b ||chp||||chop to integral value|9652
        {ra_it.d = (long)(ra_it.d);fl=(!isgoodnum(ra_it.d));}				// chop to integral value
        //b ||rti|6,oexp6|||convert to integer, br if too large|9653
        ia =  ( ra_it.d);				// convert to integer, br if too large
        //b ||sbr|13,rcval(xl)|||chop(exponent) - exponent|9654
        {w0 = *((word *)(CFP_B*RCVAL + xl));ra_it.d -= w0_it.d;fl=(!isgoodnum(ra_it.d));}				// chop(exponent) - exponent
        //b ||rne|6,oex11|||non-integral power with neg base|9655
        if (ra_it.d != 0.0)  C_GOTO(oex11);				// non-integral power with neg base
        //b ||mfi|8,wb|||record even/odd exponent|9656
        wb = ia;				// record even/odd exponent
        //b ||anb|8,wb|4,bits1||odd exponent yields negative result|9657
        wb &= c.bits1;				// odd exponent yields negative result
        //b ||ldr|13,rcval(xr)|||restore base to ra|9658
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// restore base to ra
//      here with positive base in ra and (xr), exponent in (xl)
// oex10:
        //b |oex10|lnf||||log of base|9662
        C_GOTO(oex10);
        } /* oexp9 */
        

        void oex10() {
        {ra_it.d = log(ra_it.d);fl=(!isgoodnum(ra_it.d));}				// log of base
        //b ||rov|6,oexp6|||too large|9663
        if (fl) C_GOTO(oexp6);				// too large
        //b ||mlr|13,rcval(xl)|||times exponent|9664
        {w0 = *((word *)(CFP_B*RCVAL + xl));ra_it.d *=  w0_it.d;fl=(!isgoodnum(ra_it.d));}				// times exponent
        //b ||rov|6,oexp6|||too large|9665
        if (fl) C_GOTO(oexp6);				// too large
        //b ||etx||||e ** (exponent * ln(base))|9666
        {ra_it.d = exp(ra_it.d);fl=(!isgoodnum(ra_it.d));}				// e ** (exponent * ln(base))
        //b ||rov|6,oexp6|||too large|9667
        if (fl) C_GOTO(oexp6);				// too large
        //b ||bze|8,wb|6,exrea||if no sign fixup required|9668
        if ( !( wb) ) C_GOTO(exrea);				// if no sign fixup required
        //b ||ngr||||negative result needed|9669
        {ra_it.d = - ra_it.d;fl=(!isgoodnum(ra_it.d));}				// negative result needed
        //b ||brn|6,exrea||||9670
         C_GOTO(exrea);
//      here for non-integral exponent with negative base
// oex11:
        //b |oex11|erb|1,311|26,exponentiation of negative base to non-integral power|||9674
        } /* oex10 */
        

        void oex11() {
        C_ERB(311)
//      here with negative integer exponent in ia
// oex12:
        //b |oex12|mov|11,-(xs)|7,xr||stack base|9683
        } /* oex11 */
        

        void oex12() {
        C_PUSH(xr);				// stack base
        //b ||itr||||convert to real exponent|9684
        ra =  (double) (ia);				// convert to real exponent
        //b ||jsr|6,rcbld|||real negative exponent in (xr)|9685
        C_JSR(rcbld);				// real negative exponent in (xr)
        //b ||mov|7,xl|7,xr||put exponent in xl|9686
        xl= xr;				// put exponent in xl
        //b ||mov|7,xr|10,(xs)+||restore base value|9687
        xr= C_POP();				// restore base value
        //b ||brn|6,oexp7|||process real exponent|9688
         C_GOTO(oexp7);				// process real exponent
        //b ||ejc|||||9692
        
//      failure in expression evaluation
//      this entry point is used if the evaluation of an
//      expression, initiated by the evalx procedure, fails.
//      control is returned to an appropriate point in evalx.
//	align	2
//	nop
        //b |o_fex|ent||||entry point|9700
        } /* oex12 */
        

        void o_fex() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||brn|6,evlx6|||jump to failure loc in evalx|9701
         C_GOTO(evlx6);				// jump to failure loc in evalx
        //b ||ejc|||||9702
        
//      failure during evaluation of a complex or direct goto
//	align	2
//	nop
        //b |o_fif|ent||||entry point|9706
        } /* o_fex */
        

        void o_fif() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||erb|1,020|26,goto evaluation failure|||9707
        C_ERB(20)
        //b ||ejc|||||9708
        
//      function call (more than one argument)
//	align	2
//	nop
        //b |o_fnc|ent||||entry point|9712
        } /* o_fif */
        

        void o_fnc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||lcw|8,wa|||load number of arguments|9713
        wa  = *((word *)reg_cp);				// load number of arguments
          reg_cp += CFP_B;
        //b ||lcw|7,xr|||load function vrblk pointer|9714
        xr  = *((word *)reg_cp);				// load function vrblk pointer
          reg_cp += CFP_B;
        //b ||mov|7,xl|13,vrfnc(xr)||load function pointer|9715
        xl= *((word *)(CFP_B*VRFNC + xr));				// load function pointer
        //b ||bne|8,wa|13,fargs(xl)|6,cfunc|use central routine if wrong num|9716
        if ((wa-*((word *)(CFP_B*FARGS + xl))) != 0) C_GOTO(cfunc);				// use central routine if wrong num
        //b ||bri|9,(xl)|||jump to function if arg count ok|9717
        w0 = xl_it.wp[0];				// jump to function if arg count ok
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9718
        
//      function name error
//	align	2
//	nop
        //b |o_fne|ent||||entry point|9722
        } /* o_fnc */
        

        void o_fne() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||lcw|8,wa|||get next code word|9723
        wa  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bne|8,wa|21,=ornm_|6,ofne1|fail if not evaluating expression|9724
        if ((wa-(word)(&c.ornm_)) != 0) C_GOTO(ofne1);				// fail if not evaluating expression
        //b ||bze|13,num02(xs)|6,evlx3||ok if expr. was wanted by value|9725
        if ( !( *((word *)(CFP_B*NUM02 + xs))) ) C_GOTO(evlx3);				// ok if expr. was wanted by value
//      here for error
// ofne1:
        //b |ofne1|erb|1,021|26,function called by name returned a value|||9729
        C_GOTO(ofne1);
        } /* o_fne */
        

        void ofne1() {
        C_ERB(21)
        //b ||ejc|||||9730
        
//      function call (single argument)
//	align	2
//	nop
        //b |o_fns|ent||||entry point|9734
        } /* ofne1 */
        

        void o_fns() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||lcw|7,xr|||load function vrblk pointer|9735
        xr  = *((word *)reg_cp);				// load function vrblk pointer
          reg_cp += CFP_B;
        //b ||mov|8,wa|18,=num01||set number of arguments to one|9736
        wa= NUM01;				// set number of arguments to one
        //b ||mov|7,xl|13,vrfnc(xr)||load function pointer|9737
        xl= *((word *)(CFP_B*VRFNC + xr));				// load function pointer
        //b ||bne|8,wa|13,fargs(xl)|6,cfunc|use central routine if wrong num|9738
        if ((wa-*((word *)(CFP_B*FARGS + xl))) != 0) C_GOTO(cfunc);				// use central routine if wrong num
        //b ||bri|9,(xl)|||jump to function if arg count ok|9739
        w0 = xl_it.wp[0];				// jump to function if arg count ok
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9740
        
//      call to undefined function
//	align	2
//	nop
        //b |o_fun|ent||||entry point|9743
        } /* o_fns */
        

        void o_fun() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||erb|1,022|26,undefined function called|||9744
        C_ERB(22)
        //b ||ejc|||||9745
        
//      execute complex goto
//	align	2
//	nop
        //b |o_goc|ent||||entry point|9749
        } /* o_fun */
        

        void o_goc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|13,num01(xs)||load name base pointer|9750
        xr= *((word *)(CFP_B*NUM01 + xs));				// load name base pointer
        //b ||bhi|7,xr|3,state|6,ogoc1|jump if not natural variable|9751
        if ((xr-v.state) > 0) C_GOTO(ogoc1);				// jump if not natural variable
        //b ||add|7,xr|19,*vrtra||else point to vrtra field|9752
        xr += CFP_B*VRTRA;				// else point to vrtra field
        //b ||bri|9,(xr)|||and jump through it|9753
        w0 = xr_it.wp[0];				// and jump through it
        C_GOTO(w0_it.callp);
//      here if goto operand is not natural variable
// ogoc1:
        //b |ogoc1|erb|1,023|26,goto operand is not a natural variable|||9757
        } /* o_goc */
        

        void ogoc1() {
        C_ERB(23)
        //b ||ejc|||||9758
        
//      execute direct goto
//	align	2
//	nop
        //b |o_god|ent||||entry point|9762
        } /* ogoc1 */
        

        void o_god() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|9,(xs)||load operand|9763
        xr= *(xs_it.wp);				// load operand
        //b ||mov|8,wa|9,(xr)||load first word|9764
        wa= *(xr_it.wp);				// load first word
        //b ||beq|8,wa|22,=b_cds|6,bcds0|jump if code block to code routine|9765
        if ((wa-(word)(b_cds)) == 0) C_GOTO(bcds0);				// jump if code block to code routine
        //b ||beq|8,wa|22,=b_cdc|6,bcdc0|jump if code block to code routine|9766
        if ((wa-(word)(b_cdc)) == 0) C_GOTO(bcdc0);				// jump if code block to code routine
        //b ||erb|1,024|26,goto operand in direct goto is not code|||9767
        C_ERB(24)
        //b ||ejc|||||9768
        
//      set goto failure trap
//      this routine is executed at the start of a complex or
//      direct failure goto to trap a subsequent fail (see exfal)
//	align	2
//	nop
        //b |o_gof|ent||||entry point|9775
        } /* o_god */
        

        void o_gof() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|3,flptr||point to fail offset on stack|9776
        xr= v.flptr;				// point to fail offset on stack
        //b ||ica|9,(xr)|||point failure to o_fif word|9777
        *(xr_it.wp) += CFP_B;				// point failure to o_fif word
        //b ||icp||||point to next code word|9778
        reg_cp += CFP_B;				// point to next code word
        //b ||lcw|7,xr|||fetch next code word|9779
        xr  = *((word *)reg_cp);				// fetch next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|9780
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9781
        
//      binary dollar (immediate assignment)
//      the pattern built by binary dollar is a compound pattern.
//      see description at start of pattern match section for
//      details of the structure which is constructed.
//	align	2
//	nop
        //b |o_ima|ent||||entry point|9789
        } /* o_gof */
        

        void o_ima() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_imc||set pcode for last node|9790
        wb= (word)(p_imc);				// set pcode for last node
        //b ||mov|8,wc|10,(xs)+||pop name offset (parm2)|9791
        wc= C_POP();				// pop name offset (parm2)
        //b ||mov|7,xr|10,(xs)+||pop name base (parm1)|9792
        xr= C_POP();				// pop name base (parm1)
        //b ||jsr|6,pbild|||build p_imc node|9793
        C_JSR(pbild);				// build p_imc node
        //b ||mov|7,xl|7,xr||save ptr to node|9794
        xl= xr;				// save ptr to node
        //b ||mov|7,xr|9,(xs)||load left argument|9795
        xr= *(xs_it.wp);				// load left argument
        //b ||err|1,025|26,immediate assignment left operand is not pattern|||9797
        C_JSR_1(gtpat,(C_ERR(25)));
        //b ||mov|9,(xs)|7,xr||save ptr to left operand pattern|9798
        *(xs_it.wp)= xr;				// save ptr to left operand pattern
        //b ||mov|8,wb|22,=p_ima||set pcode for first node|9799
        wb= (word)(p_ima);				// set pcode for first node
        //b ||jsr|6,pbild|||build p_ima node|9800
        C_JSR(pbild);				// build p_ima node
        //b ||mov|13,pthen(xr)|10,(xs)+||set left operand as p_ima successor|9801
        *((word *)(CFP_B*PTHEN + xr))= C_POP();				// set left operand as p_ima successor
        //b ||jsr|6,pconc|||concatenate to form final pattern|9802
        C_JSR(pconc);				// concatenate to form final pattern
        //b ||mov|11,-(xs)|7,xr||stack result|9803
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|9804
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|9805
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9806
        
//      indirection (by name)
//	align	2
//	nop
        //b |o_inn|ent||||entry point|9810
        } /* o_ima */
        

        void o_inn() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mnz|8,wb|||set flag for result by name|9811
        wb = 0xffffffffffffffff;				// set flag for result by name
        //b ||brn|6,indir|||jump to common routine|9812
         C_GOTO(indir);				// jump to common routine
        //b ||ejc|||||9813
        
//      interrogation
//	align	2
//	nop
        //b |o_int|ent||||entry point|9817
        } /* o_inn */
        

        void o_int() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|9,(xs)|21,=nulls||replace operand with null|9818
        *(xs_it.wp)= (word)(&c.nulls);				// replace operand with null
        //b ||lcw|7,xr|||get next code word|9819
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|9820
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9821
        
//      indirection (by value)
//	align	2
//	nop
        //b |o_inv|ent||||entry point|9825
        } /* o_int */
        

        void o_inv() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||zer|8,wb|||set flag for by value|9826
        wb=0;				// set flag for by value
        //b ||brn|6,indir|||jump to common routine|9827
         C_GOTO(indir);				// jump to common routine
        //b ||ejc|||||9828
        
//      keyword reference (by name)
//	align	2
//	nop
        //b |o_kwn|ent||||entry point|9832
        } /* o_inv */
        

        void o_kwn() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||jsr|6,kwnam|||get keyword name|9833
        extern void _l0354();
        C_JMS(kwnam,P_PRC_KWNAM,_l0354);
        } /* o_kwn */
        

        void _l0354() {
        //b ||brn|6,exnam|||exit with result name|9834
         C_GOTO(exnam);				// exit with result name
        //b ||ejc|||||9835
        
//      keyword reference (by value)
//	align	2
//	nop
        //b |o_kwv|ent||||entry point|9839
        } /* _l0354 */
        

        void o_kwv() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||jsr|6,kwnam|||get keyword name|9840
        extern void _l0355();
        C_JMS(kwnam,P_PRC_KWNAM,_l0355);
        } /* o_kwv */
        

        void _l0355() {
        //b ||mov|3,dnamp|7,xr||delete kvblk|9841
        v.dnamp= xr;				// delete kvblk
        //b ||ppm|6,exnul|||dummy (unused) failure return|9843
        C_JSR_1(acess,C_GOTO(exnul));				// dummy (unused) failure return
        //b ||mov|11,-(xs)|7,xr||stack result|9844
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|9845
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|9846
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9847
        
//      load expression by name
//	align	2
//	nop
        //b |o_lex|ent||||entry point|9851
        } /* _l0355 */
        

        void o_lex() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wa|19,*evsi_||set size of evblk|9852
        wa= CFP_B*EVSI_;				// set size of evblk
        //b ||jsr|6,alloc|||allocate space for evblk|9853
        C_JSR(alloc);				// allocate space for evblk
        //b ||mov|9,(xr)|22,=b_evt||set type word|9854
        *(xr_it.wp)= (word)(b_evt);				// set type word
        //b ||mov|13,evvar(xr)|21,=trbev||set dummy trblk pointer|9855
        *((word *)(CFP_B*EVVAR + xr))= (word)(&c.trbev);				// set dummy trblk pointer
        //b ||lcw|8,wa|||load exblk pointer|9856
        wa  = *((word *)reg_cp);				// load exblk pointer
          reg_cp += CFP_B;
        //b ||mov|13,evexp(xr)|8,wa||set exblk pointer|9857
        *((word *)(CFP_B*EVEXP + xr))= wa;				// set exblk pointer
        //b ||mov|7,xl|7,xr||move name base to proper reg|9858
        xl= xr;				// move name base to proper reg
        //b ||mov|8,wa|19,*evvar||set name offset = zero|9859
        wa= CFP_B*EVVAR;				// set name offset = zero
        //b ||brn|6,exnam|||exit with name in (xl,wa)|9860
         C_GOTO(exnam);				// exit with name in (xl,wa)
        //b ||ejc|||||9861
        
//      load pattern value
//	align	2
//	nop
        //b |o_lpt|ent||||entry point|9865
        } /* o_lex */
        

        void o_lpt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||lcw|7,xr|||load pattern pointer|9866
        xr  = *((word *)reg_cp);				// load pattern pointer
          reg_cp += CFP_B;
        //b ||mov|11,-(xs)|7,xr||stack result|9867
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|9868
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|9869
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9870
        
//      load variable name
//	align	2
//	nop
        //b |o_lvn|ent||||entry point|9874
        } /* o_lpt */
        

        void o_lvn() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||lcw|8,wa|||load vrblk pointer|9875
        wa  = *((word *)reg_cp);				// load vrblk pointer
          reg_cp += CFP_B;
        //b ||mov|11,-(xs)|8,wa||stack vrblk ptr (name base)|9876
        C_PUSH(wa);				// stack vrblk ptr (name base)
        //b ||mov|11,-(xs)|19,*vrval||stack name offset|9877
        C_PUSH(CFP_B*VRVAL);				// stack name offset
        //b ||lcw|7,xr|||get next code word|9878
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|9879
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9880
        
//      binary asterisk (multiplication)
//	align	2
//	nop
        //b |o_mlt|ent||||entry point|9884
        } /* o_lvn */
        

        void o_mlt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,omlt1|||jump if real operands|9890
        extern void _l0356();
        C_JMS(arith,P_PRC_ARITH,_l0356);
        } /* o_mlt */
        

        void _l0356() {
        C_JMS_HANDLE_3(arith,(C_ERR(26)),(C_ERR(27)),C_GOTO(omlt1));				// jump if real operands
//      here to multiply two integers
        //b ||mli|13,icval(xl)|||multiply left operand by right|9895
        ia*=*((word *)(CFP_B*ICVAL + xl));				// multiply left operand by right
        //b ||ino|6,exint|||return integer if no overflow|9896
         C_GOTO(exint);				// return integer if no overflow
        /*g.ino g.iov is a noop, but could be done like g.aov*/
        //b ||erb|1,028|26,multiplication caused integer overflow|||9897
        C_ERB(28)
//      here to multiply two reals
// omlt1:
        //b |omlt1|mlr|13,rcval(xl)|||multiply left operand by right|9903
        } /* _l0356 */
        

        void omlt1() {
        {w0 = *((word *)(CFP_B*RCVAL + xl));ra_it.d *=  w0_it.d;fl=(!isgoodnum(ra_it.d));}				// multiply left operand by right
        //b ||rno|6,exrea|||return real if no overflow|9904
        if (fl==0) C_GOTO(exrea);				// return real if no overflow
        //b ||erb|1,263|26,multiplication caused real overflow|||9905
        C_ERB(263)
        //b ||ejc|||||9907
        
//      name reference
//	align	2
//	nop
        //b |o_nam|ent||||entry point|9911
        } /* omlt1 */
        

        void o_nam() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wa|19,*nmsi_||set length of nmblk|9912
        wa= CFP_B*NMSI_;				// set length of nmblk
        //b ||jsr|6,alloc|||allocate nmblk|9913
        C_JSR(alloc);				// allocate nmblk
        //b ||mov|9,(xr)|22,=b_nml||set name block code|9914
        *(xr_it.wp)= (word)(b_nml);				// set name block code
        //b ||mov|13,nmofs(xr)|10,(xs)+||set name offset from operand|9915
        *((word *)(CFP_B*NMOFS + xr))= C_POP();				// set name offset from operand
        //b ||mov|13,nmbas(xr)|10,(xs)+||set name base from operand|9916
        *((word *)(CFP_B*NMBAS + xr))= C_POP();				// set name base from operand
        //b ||mov|11,-(xs)|7,xr||stack result|9917
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|9918
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|9919
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9920
        
//      negation
//      initial entry
//	align	2
//	nop
        //b |o_nta|ent||||entry point|9926
        } /* o_nam */
        

        void o_nta() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||lcw|8,wa|||load new failure offset|9927
        wa  = *((word *)reg_cp);				// load new failure offset
          reg_cp += CFP_B;
        //b ||mov|11,-(xs)|3,flptr||stack old failure pointer|9928
        C_PUSH(v.flptr);				// stack old failure pointer
        //b ||mov|11,-(xs)|8,wa||stack new failure offset|9929
        C_PUSH(wa);				// stack new failure offset
        //b ||mov|3,flptr|7,xs||set new failure pointer|9930
        v.flptr= xs;				// set new failure pointer
        //b ||lcw|7,xr|||get next code word|9931
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|9932
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
//      entry after successful evaluation of operand
//	align	2
//	nop
        //b |o_ntb|ent||||entry point|9936
        } /* o_nta */
        

        void o_ntb() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|3,flptr|13,num02(xs)||restore old failure pointer|9937
        v.flptr= *((word *)(CFP_B*NUM02 + xs));				// restore old failure pointer
        //b ||brn|6,exfal|||and fail|9938
         C_GOTO(exfal);				// and fail
//      entry for failure during operand evaluation
//	align	2
//	nop
        //b |o_ntc|ent||||entry point|9942
        } /* o_ntb */
        

        void o_ntc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ica|7,xs|||pop failure offset|9943
        xs += CFP_B;				// pop failure offset
        //b ||mov|3,flptr|10,(xs)+||restore old failure pointer|9944
        v.flptr= C_POP();				// restore old failure pointer
        //b ||brn|6,exnul|||exit giving null result|9945
         C_GOTO(exnul);				// exit giving null result
        //b ||ejc|||||9946
        
//      use of undefined operator
//	align	2
//	nop
        //b |o_oun|ent||||entry point|9950
        } /* o_ntc */
        

        void o_oun() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||erb|1,029|26,undefined operator referenced|||9951
        C_ERB(29)
        //b ||ejc|||||9952
        
//      binary dot (pattern assignment)
//      the pattern built by binary dot is a compound pattern.
//      see description at start of pattern match section for
//      details of the structure which is constructed.
//	align	2
//	nop
        //b |o_pas|ent||||entry point|9960
        } /* o_oun */
        

        void o_pas() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_pac||load pcode for p_pac node|9961
        wb= (word)(p_pac);				// load pcode for p_pac node
        //b ||mov|8,wc|10,(xs)+||load name offset (parm2)|9962
        wc= C_POP();				// load name offset (parm2)
        //b ||mov|7,xr|10,(xs)+||load name base (parm1)|9963
        xr= C_POP();				// load name base (parm1)
        //b ||jsr|6,pbild|||build p_pac node|9964
        C_JSR(pbild);				// build p_pac node
        //b ||mov|7,xl|7,xr||save ptr to node|9965
        xl= xr;				// save ptr to node
        //b ||mov|7,xr|9,(xs)||load left operand|9966
        xr= *(xs_it.wp);				// load left operand
        //b ||err|1,030|26,pattern assignment left operand is not pattern|||9968
        C_JSR_1(gtpat,(C_ERR(30)));
        //b ||mov|9,(xs)|7,xr||save ptr to left operand pattern|9969
        *(xs_it.wp)= xr;				// save ptr to left operand pattern
        //b ||mov|8,wb|22,=p_paa||set pcode for p_paa node|9970
        wb= (word)(p_paa);				// set pcode for p_paa node
        //b ||jsr|6,pbild|||build p_paa node|9971
        C_JSR(pbild);				// build p_paa node
        //b ||mov|13,pthen(xr)|10,(xs)+||set left operand as p_paa successor|9972
        *((word *)(CFP_B*PTHEN + xr))= C_POP();				// set left operand as p_paa successor
        //b ||jsr|6,pconc|||concatenate to form final pattern|9973
        C_JSR(pconc);				// concatenate to form final pattern
        //b ||mov|11,-(xs)|7,xr||stack result|9974
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|9975
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|9976
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||9977
        
//      pattern match (by name, for replacement)
//	align	2
//	nop
        //b |o_pmn|ent||||entry point|9981
        } /* o_pas */
        

        void o_pmn() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||zer|8,wb|||set type code for match by name|9982
        wb=0;				// set type code for match by name
        //b ||brn|6,match|||jump to routine to start match|9983
         C_GOTO(match);				// jump to routine to start match
        //b ||ejc|||||9984
        
//      pattern match (statement)
//      o_pms is used in place of o_pmv when the pattern match
//      occurs at the outer (statement) level since in this
//      case the substring value need not be constructed.
//	align	2
//	nop
        //b |o_pms|ent||||entry point|9992
        } /* o_pmn */
        

        void o_pms() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|18,=num02||set flag for statement to match|9993
        wb= NUM02;				// set flag for statement to match
        //b ||brn|6,match|||jump to routine to start match|9994
         C_GOTO(match);				// jump to routine to start match
        //b ||ejc|||||9995
        
//      pattern match (by value)
//	align	2
//	nop
        //b |o_pmv|ent||||entry point|9999
        } /* o_pms */
        

        void o_pmv() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|18,=num01||set type code for value match|10000
        wb= NUM01;				// set type code for value match
        //b ||brn|6,match|||jump to routine to start match|10001
         C_GOTO(match);				// jump to routine to start match
        //b ||ejc|||||10002
        
//      pop top item on stack
//	align	2
//	nop
        //b |o_pop|ent||||entry point|10006
        } /* o_pmv */
        

        void o_pop() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ica|7,xs|||pop top stack entry|10007
        xs += CFP_B;				// pop top stack entry
        //b ||lcw|7,xr|||get next code word|10008
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|10009
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||10010
        
//      terminate execution (code compiled for end statement)
//	align	2
//	nop
        //b |o_stp|ent||||entry point|10014
        } /* o_pop */
        

        void o_stp() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||brn|6,lend0|||jump to end circuit|10015
         C_GOTO(lend0);				// jump to end circuit
        //b ||ejc|||||10016
        
//      return name from expression
//      this entry points is used if the evaluation of an
//      expression, initiated by the evalx procedure, returns
//      a name. control is returned to the proper point in evalx.
//	align	2
//	nop
        //b |o_rnm|ent||||entry point|10023
        } /* o_stp */
        

        void o_rnm() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||brn|6,evlx4|||return to evalx procedure|10024
         C_GOTO(evlx4);				// return to evalx procedure
        //b ||ejc|||||10025
        
//      pattern replacement
//      when this routine gets control, the following stack
//      entries have been made (see end of match routine p_nth)
//                            subject name base
//                            subject name offset
//                            initial cursor value
//                            final cursor value
//                            subject string pointer
//      (xs) ---------------- replacement value
//	align	2
//	nop
        //b |o_rpl|ent||||entry point|10039
        } /* o_rnm */
        

        void o_rpl() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,031|26,pattern replacement right operand is not a string|||10041
        extern void _l0361();
        C_JMS(gtstg,P_PRC_GTSTG,_l0361);
        } /* o_rpl */
        

        void _l0361() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(31)));
//      get result length and allocate result scblk
        //b ||mov|7,xl|9,(xs)||load subject string pointer|10045
        xl= *(xs_it.wp);				// load subject string pointer
        //b ||add|8,wa|13,sclen(xl)||add subject string length|10050
        wa += *((word *)(CFP_B*SCLEN + xl));				// add subject string length
        //b ||add|8,wa|13,num02(xs)||add starting cursor|10051
        wa += *((word *)(CFP_B*NUM02 + xs));				// add starting cursor
        //b ||sub|8,wa|13,num01(xs)||minus final cursor = total length|10052
        wa -= *((word *)(CFP_B*NUM01 + xs));				// minus final cursor = total length
        //b ||bze|8,wa|6,orpl3||jump if result is null|10053
        if ( !( wa) ) C_GOTO(orpl3);				// jump if result is null
        //b ||mov|11,-(xs)|7,xr||restack replacement string|10054
        C_PUSH(xr);				// restack replacement string
        //b ||jsr|6,alocs|||allocate scblk for result|10055
        C_JSR(alocs);				// allocate scblk for result
        //b ||mov|8,wa|13,num03(xs)||get initial cursor (part 1 len)|10056
        wa= *((word *)(CFP_B*NUM03 + xs));				// get initial cursor (part 1 len)
        //b ||mov|13,num03(xs)|7,xr||stack result pointer|10057
        *((word *)(CFP_B*NUM03 + xs))= xr;				// stack result pointer
        //b ||psc|7,xr|||point to characters of result|10058
        xr += CFP_F;				// point to characters of result
//      move part 1 (start of subject) to result
        //b ||bze|8,wa|6,orpl1||jump if first part is null|10062
        if ( !( wa) ) C_GOTO(orpl1);				// jump if first part is null
        //b ||mov|7,xl|13,num01(xs)||else point to subject string|10063
        xl= *((word *)(CFP_B*NUM01 + xs));				// else point to subject string
        //b ||plc|7,xl|||point to subject string chars|10064
        xl += CFP_F;				// point to subject string chars
        //b ||mvc||||move first part to result|10065
        do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);				// move first part to result
        //b ||ejc|||||10066
        
//      pattern replacement (continued)
//      now move in replacement value
// orpl1:
        //b |orpl1|mov|7,xl|10,(xs)+||load replacement string, pop|10071
        C_GOTO(orpl1);
        } /* _l0361 */
        

        void orpl1() {
        xl= C_POP();				// load replacement string, pop
        //b ||mov|8,wa|13,sclen(xl)||load length|10072
        wa= *((word *)(CFP_B*SCLEN + xl));				// load length
        //b ||bze|8,wa|6,orpl2||jump if null replacement|10073
        if ( !( wa) ) C_GOTO(orpl2);				// jump if null replacement
        //b ||plc|7,xl|||else point to chars of replacement|10074
        xl += CFP_F;				// else point to chars of replacement
        //b ||mvc||||move in chars (part 2)|10075
        do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);				// move in chars (part 2)
//      now move in remainder of string (part 3)
// orpl2:
        //b |orpl2|mov|7,xl|10,(xs)+||load subject string pointer, pop|10079
        C_GOTO(orpl2);
        } /* orpl1 */
        

        void orpl2() {
        xl= C_POP();				// load subject string pointer, pop
        //b ||mov|8,wc|10,(xs)+||load final cursor, pop|10080
        wc= C_POP();				// load final cursor, pop
        //b ||mov|8,wa|13,sclen(xl)||load subject string length|10081
        wa= *((word *)(CFP_B*SCLEN + xl));				// load subject string length
        //b ||sub|8,wa|8,wc||minus final cursor = part 3 length|10082
        wa -= wc;				// minus final cursor = part 3 length
        //b ||bze|8,wa|6,oass0||jump to assign if part 3 is null|10083
        if ( !( wa) ) C_GOTO(oass0);				// jump to assign if part 3 is null
        //b ||plc|7,xl|8,wc||else point to last part of string|10084
        xl_it.chp += CFP_F + wc;				// else point to last part of string
        //b ||mvc||||move part 3 to result|10085
        do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);				// move part 3 to result
        //b ||brn|6,oass0|||jump to perform assignment|10086
         C_GOTO(oass0);				// jump to perform assignment
//      here if result is null
// orpl3:
        //b |orpl3|add|7,xs|19,*num02||pop subject str ptr, final cursor|10090
        } /* orpl2 */
        

        void orpl3() {
        xs += CFP_B*NUM02;				// pop subject str ptr, final cursor
        //b ||mov|9,(xs)|21,=nulls||set null result|10091
        *(xs_it.wp)= (word)(&c.nulls);				// set null result
        //b ||brn|6,oass0|||jump to assign null value|10092
         C_GOTO(oass0);				// jump to assign null value
        //b ||ejc|||||10111
        
//      return value from expression
//      this entry points is used if the evaluation of an
//      expression, initiated by the evalx procedure, returns
//      a value. control is returned to the proper point in evalx
//	align	2
//	nop
        //b |o_rvl|ent||||entry point|10119
        } /* orpl3 */
        

        void o_rvl() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||brn|6,evlx3|||return to evalx procedure|10120
         C_GOTO(evlx3);				// return to evalx procedure
        //b ||ejc|||||10121
        
//      selection
//      initial entry
//	align	2
//	nop
        //b |o_sla|ent||||entry point|10127
        } /* o_rvl */
        

        void o_sla() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||lcw|8,wa|||load new failure offset|10128
        wa  = *((word *)reg_cp);				// load new failure offset
          reg_cp += CFP_B;
        //b ||mov|11,-(xs)|3,flptr||stack old failure pointer|10129
        C_PUSH(v.flptr);				// stack old failure pointer
        //b ||mov|11,-(xs)|8,wa||stack new failure offset|10130
        C_PUSH(wa);				// stack new failure offset
        //b ||mov|3,flptr|7,xs||set new failure pointer|10131
        v.flptr= xs;				// set new failure pointer
        //b ||lcw|7,xr|||get next code word|10132
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|10133
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
//      entry after successful evaluation of alternative
//	align	2
//	nop
        //b |o_slb|ent||||entry point|10137
        } /* o_sla */
        

        void o_slb() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load result|10138
        xr= C_POP();				// load result
        //b ||ica|7,xs|||pop fail offset|10139
        xs += CFP_B;				// pop fail offset
        //b ||mov|3,flptr|9,(xs)||restore old failure pointer|10140
        v.flptr= *(xs_it.wp);				// restore old failure pointer
        //b ||mov|9,(xs)|7,xr||restack result|10141
        *(xs_it.wp)= xr;				// restack result
        //b ||lcw|8,wa|||load new code offset|10142
        wa  = *((word *)reg_cp);				// load new code offset
          reg_cp += CFP_B;
        //b ||add|8,wa|3,r_cod||point to absolute code location|10143
        wa += v.r_cod;				// point to absolute code location
        //b ||lcp|8,wa|||set new code pointer|10144
        reg_cp = wa;				// set new code pointer
        //b ||lcw|7,xr|||get next code word|10145
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|10146
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
//      entry at start of subsequent alternatives
//	align	2
//	nop
        //b |o_slc|ent||||entry point|10150
        } /* o_slb */
        

        void o_slc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||lcw|8,wa|||load new fail offset|10151
        wa  = *((word *)reg_cp);				// load new fail offset
          reg_cp += CFP_B;
        //b ||mov|9,(xs)|8,wa||store new fail offset|10152
        *(xs_it.wp)= wa;				// store new fail offset
        //b ||lcw|7,xr|||get next code word|10153
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|10154
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
//      entry at start of last alternative
//	align	2
//	nop
        //b |o_sld|ent||||entry point|10158
        } /* o_slc */
        

        void o_sld() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ica|7,xs|||pop failure offset|10159
        xs += CFP_B;				// pop failure offset
        //b ||mov|3,flptr|10,(xs)+||restore old failure pointer|10160
        v.flptr= C_POP();				// restore old failure pointer
        //b ||lcw|7,xr|||get next code word|10161
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|10162
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||10163
        
//      binary minus (subtraction)
//	align	2
//	nop
        //b |o_sub|ent||||entry point|10167
        } /* o_sld */
        

        void o_sub() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,osub1|||jump if real operands|10173
        extern void _l0366();
        C_JMS(arith,P_PRC_ARITH,_l0366);
        } /* o_sub */
        

        void _l0366() {
        C_JMS_HANDLE_3(arith,(C_ERR(32)),(C_ERR(33)),C_GOTO(osub1));				// jump if real operands
//      here to subtract two integers
        //b ||sbi|13,icval(xl)|||subtract right operand from left|10178
        ia-=*((word *)(CFP_B*ICVAL + xl));				// subtract right operand from left
        //b ||ino|6,exint|||return integer if no overflow|10179
         C_GOTO(exint);				// return integer if no overflow
        /*g.ino g.iov is a noop, but could be done like g.aov*/
        //b ||erb|1,034|26,subtraction caused integer overflow|||10180
        C_ERB(34)
//      here to subtract two reals
// osub1:
        //b |osub1|sbr|13,rcval(xl)|||subtract right operand from left|10186
        } /* _l0366 */
        

        void osub1() {
        {w0 = *((word *)(CFP_B*RCVAL + xl));ra_it.d -= w0_it.d;fl=(!isgoodnum(ra_it.d));}				// subtract right operand from left
        //b ||rno|6,exrea|||return real if no overflow|10187
        if (fl==0) C_GOTO(exrea);				// return real if no overflow
        //b ||erb|1,264|26,subtraction caused real overflow|||10188
        C_ERB(264)
        //b ||ejc|||||10190
        
//      dummy operator to return control to trxeq procedure
//	align	2
//	nop
        //b |o_txr|ent||||entry point|10194
        } /* osub1 */
        

        void o_txr() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||brn|6,trxq1|||jump into trxeq procedure|10195
         C_GOTO(trxq1);				// jump into trxeq procedure
        //b ||ejc|||||10196
        
//      unexpected failure
//      note that if a setexit trap is operating then
//      transfer to system label continue
//      will result in looping here.  difficult to avoid except
//      with a considerable overhead which is not worthwhile or
//      else by a technique such as setting kverl to zero.
//	align	2
//	nop
        //b |o_unf|ent||||entry point|10206
        } /* o_txr */
        

        void o_unf() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||erb|1,035|26,unexpected failure in -nofail mode|||10207
        C_ERB(35)
        //b ||ttl|27,s p i t b o l -- block action routines||||10208
        /* s p i t b o l -- block action routines*/
//      the first word of every block in dynamic storage and the
//      vrget, vrsto and vrtra fields of a vrblk contain a
//      pointer to an entry point in the program. all such entry
//      points are in the following section except those for
//      pattern blocks which are in the pattern matching segment
//      later on (labels of the form p_xxx), and dope vectors
//      (d_xxx) which are in the dope vector section following
//      the pattern routines (dope vectors are used for cmblks).
//      the entry points in this section have labels of the
//      form b_xxy where xx is the two character block type for
//      the corresponding block and y is any letter.
//      in some cases, the pointers serve no other purpose than
//      to identify the block type. in this case the routine
//      is never executed and thus no code is assembled.
//      for each of these entry points corresponding to a block
//      an entry point identification is assembled (bl_xx).
//      the exact entry conditions depend on the manner in
//      which the routine is accessed and are documented with
//      the individual routines as required.
//      the order of these routines is alphabetical with the
//      following exceptions.
//      the routines for seblk and exblk entries occur first so
//      that expressions can be quickly identified from the fact
//      that their routines lie before the symbol b_e__.
//      these are immediately followed by the routine for a trblk
//      so that the test against the symbol b_t__ checks for
//      trapped values or expression values (see procedure evalp)
//      the pattern routines lie after this section so that
//      patterns are identified with routines starting at or
//      after the initial instruction in these routines (p_aaa).
//      the symbol b_aaa defines the first location for block
//      routines and the symbol p_yyy (at the end of the pattern
//      match routines section) defines the last such entry point
//	align	2
//	db	bl__i
        //b |b_aaa|ent|2,bl__i|||entry point of first block routine|10253
        } /* o_unf */
        

        void b_aaa() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point of first block routine
        //b ||ejc|||||10254
        
//      exblk
//      the routine for an exblk loads the expression onto
//      the stack as a value.
//      (xr)                  pointer to exblk
//	align	2
//	db	bl_ex
        //b |b_exl|ent|2,bl_ex|||entry point (exblk)|10263
        C_GOTO(b_exl);
        } /* b_aaa */
        

        void b_exl() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (exblk)
        //b ||mov|11,-(xs)|7,xr||stack result|10264
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|10265
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|10266
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||10267
        
//      seblk
//      the routine for seblk is accessed from the generated
//      code to load the expression value onto the stack.
//	align	2
//	db	bl_se
        //b |b_sel|ent|2,bl_se|||entry point (seblk)|10274
        } /* b_exl */
        

        void b_sel() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (seblk)
        //b ||mov|11,-(xs)|7,xr||stack result|10275
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|10276
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|10277
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      define symbol which marks end of entries for expressions
//	align	2
//	db	bl__i
        //b |b_e__|ent|2,bl__i|||entry point|10281
        } /* b_sel */
        

        void b_e__() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ejc|||||10282
        
//      trblk
//      the routine for a trblk is never executed
//	align	2
//	db	bl_tr
        //b |b_trt|ent|2,bl_tr|||entry point (trblk)|10288
        C_GOTO(b_trt);
        } /* b_e__ */
        

        void b_trt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (trblk)
//      define symbol marking end of trap and expression blocks
//	align	2
//	db	bl__i
        //b |b_t__|ent|2,bl__i|||end of trblk,seblk,exblk entries|10292
        C_GOTO(b_t__);
        } /* b_trt */
        

        void b_t__() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// end of trblk,seblk,exblk entries
        //b ||ejc|||||10293
        
//      arblk
//      the routine for arblk is never executed
//	align	2
//	db	bl_ar
        //b |b_art|ent|2,bl_ar|||entry point (arblk)|10299
        C_GOTO(b_art);
        } /* b_t__ */
        

        void b_art() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (arblk)
        //b ||ejc|||||10300
        
//      bcblk
//      the routine for a bcblk is never executed
//      (xr)                  pointer to bcblk
//	align	2
//	db	bl_bc
        //b |b_bct|ent|2,bl_bc|||entry point (bcblk)|10308
        C_GOTO(b_bct);
        } /* b_art */
        

        void b_bct() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (bcblk)
        //b ||ejc|||||10309
        
//      bfblk
//      the routine for a bfblk is never executed
//      (xr)                  pointer to bfblk
//	align	2
//	db	bl_bf
        //b |b_bft|ent|2,bl_bf|||entry point (bfblk)|10317
        C_GOTO(b_bft);
        } /* b_bct */
        

        void b_bft() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (bfblk)
        //b ||ejc|||||10318
        
//      ccblk
//      the routine for ccblk is never entered
//	align	2
//	db	bl_cc
        //b |b_cct|ent|2,bl_cc|||entry point (ccblk)|10324
        C_GOTO(b_cct);
        } /* b_bft */
        

        void b_cct() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (ccblk)
        //b ||ejc|||||10325
        
//      cdblk
//      the cdblk routines are executed from the generated code.
//      there are two cases depending on the form of cdfal.
//      entry for complex failure code at cdfal
//      (xr)                  pointer to cdblk
//	align	2
//	db	bl_cd
        //b |b_cdc|ent|2,bl_cd|||entry point (cdblk)|10336
        C_GOTO(b_cdc);
        } /* b_cct */
        

        void b_cdc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (cdblk)
// bcdc0:
        //b |bcdc0|mov|7,xs|3,flptr||pop garbage off stack|10337
        C_GOTO(bcdc0);
        } /* b_cdc */
        

        void bcdc0() {
        xs= v.flptr;				// pop garbage off stack
        //b ||mov|9,(xs)|13,cdfal(xr)||set failure offset|10338
        *(xs_it.wp)= *((word *)(CFP_B*CDFAL + xr));				// set failure offset
        //b ||brn|6,stmgo|||enter stmt|10339
         C_GOTO(stmgo);				// enter stmt
        //b ||ejc|||||10340
        
//      cdblk (continued)
//      entry for simple failure code at cdfal
//      (xr)                  pointer to cdblk
//	align	2
//	db	bl_cd
        //b |b_cds|ent|2,bl_cd|||entry point (cdblk)|10348
        } /* bcdc0 */
        

        void b_cds() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (cdblk)
// bcds0:
        //b |bcds0|mov|7,xs|3,flptr||pop garbage off stack|10349
        C_GOTO(bcds0);
        } /* b_cds */
        

        void bcds0() {
        xs= v.flptr;				// pop garbage off stack
        //b ||mov|9,(xs)|19,*cdfal||set failure offset|10350
        *(xs_it.wp)= CFP_B*CDFAL;				// set failure offset
        //b ||brn|6,stmgo|||enter stmt|10351
         C_GOTO(stmgo);				// enter stmt
        //b ||ejc|||||10352
        
//      cmblk
//      the routine for a cmblk is never executed
//	align	2
//	db	bl_cm
        //b |b_cmt|ent|2,bl_cm|||entry point (cmblk)|10358
        } /* bcds0 */
        

        void b_cmt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (cmblk)
        //b ||ejc|||||10359
        
//      ctblk
//      the routine for a ctblk is never executed
//	align	2
//	db	bl_ct
        //b |b_ctt|ent|2,bl_ct|||entry point (ctblk)|10365
        C_GOTO(b_ctt);
        } /* b_cmt */
        

        void b_ctt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (ctblk)
        //b ||ejc|||||10366
        
//      dfblk
//      the routine for a dfblk is accessed from the o_fnc entry
//      to call a datatype function and build a pdblk.
//      (xl)                  pointer to dfblk
//	align	2
//	db	bl_df
        //b |b_dfc|ent|2,bl_df|||entry point|10375
        C_GOTO(b_dfc);
        } /* b_ctt */
        

        void b_dfc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wa|13,dfpdl(xl)||load length of pdblk|10376
        wa= *((word *)(CFP_B*DFPDL + xl));				// load length of pdblk
        //b ||jsr|6,alloc|||allocate pdblk|10377
        C_JSR(alloc);				// allocate pdblk
        //b ||mov|9,(xr)|22,=b_pdt||store type word|10378
        *(xr_it.wp)= (word)(b_pdt);				// store type word
        //b ||mov|13,pddfp(xr)|7,xl||store dfblk pointer|10379
        *((word *)(CFP_B*PDDFP + xr))= xl;				// store dfblk pointer
        //b ||mov|8,wc|7,xr||save pointer to pdblk|10380
        wc= xr;				// save pointer to pdblk
        //b ||add|7,xr|8,wa||point past pdblk|10381
        xr += wa;				// point past pdblk
        //b ||lct|8,wa|13,fargs(xl)||set to count fields|10382
        wa= *((word *)(CFP_B*FARGS + xl));				// set to count fields
//      loop to acquire field values from stack
// bdfc1:
        //b |bdfc1|mov|11,-(xr)|10,(xs)+||move a field value|10386
        C_GOTO(bdfc1);
        } /* b_dfc */
        

        void bdfc1() {
        *(--xr_it.wp)= C_POP();				// move a field value
        //b ||bct|8,wa|6,bdfc1||loop till all moved|10387
        if ((--wa))  C_GOTO(bdfc1);				// loop till all moved
        //b ||mov|7,xr|8,wc||recall pointer to pdblk|10388
        xr= wc;				// recall pointer to pdblk
        //b ||brn|6,exsid|||exit setting id field|10389
         C_GOTO(exsid);				// exit setting id field
        //b ||ejc|||||10390
        
//      efblk
//      the routine for an efblk is passed control form the o_fnc
//      entry to call an external function.
//      (xl)                  pointer to efblk
//	align	2
//	db	bl_ef
        //b |b_efc|ent|2,bl_ef|||entry point (efblk)|10399
        } /* bdfc1 */
        

        void b_efc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (efblk)
        //b ||mov|8,wc|13,fargs(xl)||load number of arguments|10402
        wc= *((word *)(CFP_B*FARGS + xl));				// load number of arguments
        //b ||wtb|8,wc|||convert to offset|10403
        wc <<= LOG_CFP_B;				// convert to offset
        //b ||mov|11,-(xs)|7,xl||save pointer to efblk|10404
        C_PUSH(xl);				// save pointer to efblk
        //b ||mov|7,xt|7,xs||copy pointer to arguments|10405
        xt= xs;				// copy pointer to arguments
//      loop to convert arguments
// befc1:
        //b |befc1|ica|7,xt|||point to next entry|10409
        C_GOTO(befc1);
        } /* b_efc */
        

        void befc1() {
        xt += CFP_B;				// point to next entry
        //b ||mov|7,xr|9,(xs)||load pointer to efblk|10410
        xr= *(xs_it.wp);				// load pointer to efblk
        //b ||dca|8,wc|||decrement eftar offset|10411
        wc -= CFP_B;				// decrement eftar offset
        //b ||add|7,xr|8,wc||point to next eftar entry|10412
        xr += wc;				// point to next eftar entry
        //b ||mov|7,xr|13,eftar(xr)||load eftar entry|10413
        xr= *((word *)(CFP_B*EFTAR + xr));				// load eftar entry
        //b ||bsw|7,xr|1,5||switch on type|10422
        extern word _l0370 [];				// switch on type
        { w0 = ((word *)_l0370)[xr];  C_GOTO(w0_it.callp);}
        }  /* befc1 */
        

        word  _l0370 [] = {
        //b ||iff|1,0|6,befc7||no conversion needed|10440
        	(word)((word)(befc7)),				// no conversion needed
        //b ||iff|1,1|6,befc2||string|10440
        	(word)((word)(befc2)),				// string
        //b ||iff|1,2|6,befc3||integer|10440
        	(word)((word)(befc3)),				// integer
        //b ||iff|1,3|6,befc4||real|10440
        	(word)((word)(befc4)),				// real
        //b ||iff|1,4|6,beff1||file|10440
        	(word)((word)(beff1)),				// file
        //b ||esw||||end of switch on type|10440
             }; /* bsw list for _l0370 */				// end of switch on type
//      here to convert to file
// beff1:
        //b |beff1|mov|11,-(xs)|7,xt||save entry pointer|10445
        void beff1() {
        C_PUSH(xt);				// save entry pointer
        //b ||mov|3,befof|8,wc||save offset|10446
        v.befof= wc;				// save offset
        //b ||mov|11,-(xs)|9,(xt)||stack arg pointer|10447
        C_PUSH(*(xt_it.wp));				// stack arg pointer
        //b ||err|1,298|26,external function argument is not file|||10451
        extern void _l0371();
        C_JMS(iofcb,P_PRC_IOFCB,_l0371);
        } /* beff1 */
        

        void _l0371() {
        C_JMS_HANDLE_3(iofcb,(C_ERR(298)),(C_ERR(298)),(C_ERR(298)));
        //b ||mov|7,xr|8,wa||point to fcb|10452
        xr= wa;				// point to fcb
        //b ||mov|7,xt|10,(xs)+||reload entry pointer|10453
        xt= C_POP();				// reload entry pointer
        //b ||brn|6,befc5|||jump to merge|10454
         C_GOTO(befc5);				// jump to merge
//      here to convert to string
// befc2:
        //b |befc2|mov|11,-(xs)|9,(xt)||stack arg ptr|10459
        } /* _l0371 */
        

        void befc2() {
        C_PUSH(*(xt_it.wp));				// stack arg ptr
        //b ||err|1,039|26,external function argument is not a string|||10461
        extern void _l0372();
        C_JMS(gtstg,P_PRC_GTSTG,_l0372);
        } /* befc2 */
        

        void _l0372() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(39)));
        //b ||brn|6,befc6|||jump to merge|10462
         C_GOTO(befc6);				// jump to merge
        //b ||ejc|||||10463
        
//      efblk (continued)
//      here to convert an integer
// befc3:
        //b |befc3|mov|7,xr|9,(xt)||load next argument|10469
        } /* _l0372 */
        

        void befc3() {
        xr= *(xt_it.wp);				// load next argument
        //b ||mov|3,befof|8,wc||save offset|10470
        v.befof= wc;				// save offset
        //b ||err|1,040|26,external function argument is not integer|||10472
        C_JSR_1(gtint,(C_ERR(40)));
        //b ||brn|6,befc5|||merge with real case|10475
         C_GOTO(befc5);				// merge with real case
//      here to convert a real
// befc4:
        //b |befc4|mov|7,xr|9,(xt)||load next argument|10479
        } /* befc3 */
        

        void befc4() {
        xr= *(xt_it.wp);				// load next argument
        //b ||mov|3,befof|8,wc||save offset|10480
        v.befof= wc;				// save offset
        //b ||err|1,265|26,external function argument is not real|||10482
        C_JSR_1(gtrea,(C_ERR(265)));
//      integer case merges here
// befc5:
        //b |befc5|mov|8,wc|3,befof||restore offset|10487
        C_GOTO(befc5);
        } /* befc4 */
        

        void befc5() {
        wc= v.befof;				// restore offset
//      string merges here
// befc6:
        //b |befc6|mov|9,(xt)|7,xr||store converted result|10491
        C_GOTO(befc6);
        } /* befc5 */
        

        void befc6() {
        *(xt_it.wp)= xr;				// store converted result
//      no conversion merges here
// befc7:
        //b |befc7|bnz|8,wc|6,befc1||loop back if more to go|10495
        C_GOTO(befc7);
        } /* befc6 */
        

        void befc7() {
        if (wc) C_GOTO(befc1);				// loop back if more to go
//      here after converting all the arguments
        //b ||mov|7,xl|10,(xs)+||restore efblk pointer|10499
        xl= C_POP();				// restore efblk pointer
        //b ||mov|8,wa|13,fargs(xl)||get number of args|10500
        wa= *((word *)(CFP_B*FARGS + xl));				// get number of args
        //b ||err|1,326|26,calling external function - bad argument type|||10504
        C_JSR_3(sysex,C_GOTO(exfal),(C_ERR(327)),(C_ERR(326)));
        //b ||wtb|8,wa|||convert number of args to bytes|10506
        wa <<= LOG_CFP_B;				// convert number of args to bytes
        //b ||add|7,xs|8,wa||remove arguments from stack|10507
        xs += wa;				// remove arguments from stack
        //b ||ejc|||||10509
        
//      efblk (continued)
//      return here with result in xr
//      first defend against non-standard null string returned
        //b ||mov|8,wb|13,efrsl(xl)||get result type id|10517
        wb= *((word *)(CFP_B*EFRSL + xl));				// get result type id
        //b ||bnz|8,wb|6,befa8||branch if not unconverted|10518
        if (wb) C_GOTO(befa8);				// branch if not unconverted
        //b ||bne|9,(xr)|22,=b_scl|6,befc8|jump if not a string|10519
        if ((*(xr_it.wp)-(word)(b_scl)) != 0) C_GOTO(befc8);				// jump if not a string
        //b ||bze|13,sclen(xr)|6,exnul||return null if null|10520
        if ( !( *((word *)(CFP_B*SCLEN + xr))) ) C_GOTO(exnul);				// return null if null
//      here if converted result to check for null string
// befa8:
        //b |befa8|bne|8,wb|18,=num01|6,befc8|jump if not a string|10524
        C_GOTO(befa8);
        } /* befc7 */
        

        void befa8() {
        if ((wb-NUM01) != 0) C_GOTO(befc8);				// jump if not a string
        //b ||bze|13,sclen(xr)|6,exnul||return null if null|10525
        if ( !( *((word *)(CFP_B*SCLEN + xr))) ) C_GOTO(exnul);				// return null if null
//      return if result is in dynamic storage
// befc8:
        //b |befc8|blt|7,xr|3,dnamb|6,befc9|jump if not in dynamic storage|10529
        C_GOTO(befc8);
        } /* befa8 */
        

        void befc8() {
        if ((xr-v.dnamb) < 0) C_GOTO(befc9);				// jump if not in dynamic storage
        //b ||ble|7,xr|3,dnamp|6,exixr|return result if already dynamic|10530
        if ((xr-v.dnamp) <= 0) C_GOTO(exixr);				// return result if already dynamic
//      here we copy a result into the dynamic region
// befc9:
        //b |befc9|mov|8,wa|9,(xr)||get possible type word|10534
        C_GOTO(befc9);
        } /* befc8 */
        

        void befc9() {
        wa= *(xr_it.wp);				// get possible type word
        //b ||bze|8,wb|6,bef11||jump if unconverted result|10535
        if ( !( wb) ) C_GOTO(bef11);				// jump if unconverted result
        //b ||mov|8,wa|22,=b_scl||string|10536
        wa= (word)(b_scl);				// string
        //b ||beq|8,wb|18,=num01|6,bef10|yes jump|10537
        if ((wb-NUM01) == 0) C_GOTO(bef10);				// yes jump
        //b ||mov|8,wa|22,=b_icl||integer|10538
        wa= (word)(b_icl);				// integer
        //b ||beq|8,wb|18,=num02|6,bef10|yes jump|10539
        if ((wb-NUM02) == 0) C_GOTO(bef10);				// yes jump
        //b ||mov|8,wa|22,=b_rcl||real|10542
        wa= (word)(b_rcl);				// real
//      store type word in result
// bef10:
        //b |bef10|mov|9,(xr)|8,wa||stored before copying to dynamic|10547
        C_GOTO(bef10);
        } /* befc9 */
        

        void bef10() {
        *(xr_it.wp)= wa;				// stored before copying to dynamic
//      merge for unconverted result
// bef11:
        //b |bef11|beq|9,(xr)|22,=b_scl|6,bef12|branch if string result|10551
        C_GOTO(bef11);
        } /* bef10 */
        

        void bef11() {
        if ((*(xr_it.wp)-(word)(b_scl)) == 0) C_GOTO(bef12);				// branch if string result
        //b ||jsr|6,blkln|||get length of block|10552
        C_JSR(blkln);				// get length of block
        //b ||mov|7,xl|7,xr||copy address of old block|10553
        xl= xr;				// copy address of old block
        //b ||jsr|6,alloc|||allocate dynamic block same size|10554
        C_JSR(alloc);				// allocate dynamic block same size
        //b ||mov|11,-(xs)|7,xr||set pointer to new block as result|10555
        C_PUSH(xr);				// set pointer to new block as result
        //b ||mvw||||copy old block to dynamic block|10556
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// copy old block to dynamic block
        //b ||zer|7,xl|||clear garbage value|10557
        xl=0;				// clear garbage value
        //b ||lcw|7,xr|||get next code word|10558
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|10559
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
//      here to return a string result that was not in dynamic.
//      cannot use the simple word copy above because it will not
//      guarantee zero padding in the last word.
// bef12:
        //b |bef12|mov|7,xl|7,xr||save source string pointer|10565
        } /* bef11 */
        

        void bef12() {
        xl= xr;				// save source string pointer
        //b ||mov|8,wa|13,sclen(xr)||fetch string length|10566
        wa= *((word *)(CFP_B*SCLEN + xr));				// fetch string length
        //b ||bze|8,wa|6,exnul||return null string if length zero|10567
        if ( !( wa) ) C_GOTO(exnul);				// return null string if length zero
        //b ||jsr|6,alocs|||allocate space for string|10568
        C_JSR(alocs);				// allocate space for string
        //b ||mov|11,-(xs)|7,xr||save as result pointer|10569
        C_PUSH(xr);				// save as result pointer
        //b ||psc|7,xr|||prepare to store chars of result|10570
        xr += CFP_F;				// prepare to store chars of result
        //b ||plc|7,xl|||point to chars in source string|10571
        xl += CFP_F;				// point to chars in source string
        //b ||mov|8,wa|8,wc||number of characters to copy|10572
        wa= wc;				// number of characters to copy
        //b ||mvc||||move characters to result string|10573
        do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);				// move characters to result string
        //b ||zer|7,xl|||clear garbage value|10574
        xl=0;				// clear garbage value
        //b ||lcw|7,xr|||get next code word|10575
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|10576
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||10578
        
//      evblk
//      the routine for an evblk is never executed
//	align	2
//	db	bl_ev
        //b |b_evt|ent|2,bl_ev|||entry point (evblk)|10584
        } /* bef12 */
        

        void b_evt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (evblk)
        //b ||ejc|||||10585
        
//      ffblk
//      the routine for an ffblk is executed from the o_fnc entry
//      to call a field function and extract a field value/name.
//      (xl)                  pointer to ffblk
//	align	2
//	db	bl_ff
        //b |b_ffc|ent|2,bl_ff|||entry point (ffblk)|10594
        C_GOTO(b_ffc);
        } /* b_evt */
        

        void b_ffc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (ffblk)
        //b ||mov|7,xr|7,xl||copy ffblk pointer|10595
        xr= xl;				// copy ffblk pointer
        //b ||lcw|8,wc|||load next code word|10596
        wc  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||mov|7,xl|9,(xs)||load pdblk pointer|10597
        xl= *(xs_it.wp);				// load pdblk pointer
        //b ||bne|9,(xl)|22,=b_pdt|6,bffc2|jump if not pdblk at all|10598
        if ((*(xl_it.wp)-(word)(b_pdt)) != 0) C_GOTO(bffc2);				// jump if not pdblk at all
        //b ||mov|8,wa|13,pddfp(xl)||load dfblk pointer from pdblk|10599
        wa= *((word *)(CFP_B*PDDFP + xl));				// load dfblk pointer from pdblk
//      loop to find correct ffblk for this pdblk
// bffc1:
        //b |bffc1|beq|8,wa|13,ffdfp(xr)|6,bffc3|jump if this is the correct ffblk|10603
        C_GOTO(bffc1);
        } /* b_ffc */
        

        void bffc1() {
        if ((wa-*((word *)(CFP_B*FFDFP + xr))) == 0) C_GOTO(bffc3);				// jump if this is the correct ffblk
        //b ||mov|7,xr|13,ffnxt(xr)||else link to next ffblk on chain|10604
        xr= *((word *)(CFP_B*FFNXT + xr));				// else link to next ffblk on chain
        //b ||bnz|7,xr|6,bffc1||loop back if another entry to check|10605
        if (xr) C_GOTO(bffc1);				// loop back if another entry to check
//      here for bad argument
// bffc2:
        //b |bffc2|erb|1,041|26,field function argument is wrong datatype|||10609
        C_GOTO(bffc2);
        } /* bffc1 */
        

        void bffc2() {
        C_ERB(41)
        //b ||ejc|||||10610
        
//      ffblk (continued)
//      here after locating correct ffblk
// bffc3:
        //b |bffc3|mov|8,wa|13,ffofs(xr)||load field offset|10616
        } /* bffc2 */
        

        void bffc3() {
        wa= *((word *)(CFP_B*FFOFS + xr));				// load field offset
        //b ||beq|8,wc|21,=ofne_|6,bffc5|jump if called by name|10617
        if ((wc-(word)(&c.ofne_)) == 0) C_GOTO(bffc5);				// jump if called by name
        //b ||add|7,xl|8,wa||else point to value field|10618
        xl += wa;				// else point to value field
        //b ||mov|7,xr|9,(xl)||load value|10619
        xr= *(xl_it.wp);				// load value
        //b ||bne|9,(xr)|22,=b_trt|6,bffc4|jump if not trapped|10620
        if ((*(xr_it.wp)-(word)(b_trt)) != 0) C_GOTO(bffc4);				// jump if not trapped
        //b ||sub|7,xl|8,wa||else restore name base,offset|10621
        xl -= wa;				// else restore name base,offset
        //b ||mov|9,(xs)|8,wc||save next code word over pdblk ptr|10622
        *(xs_it.wp)= wc;				// save next code word over pdblk ptr
        //b ||ppm|6,exfal|||fail if access fails|10624
        C_JSR_1(acess,C_GOTO(exfal));				// fail if access fails
        //b ||mov|8,wc|9,(xs)||restore next code word|10625
        wc= *(xs_it.wp);				// restore next code word
//      here after getting value in (xr), xl is garbage
// bffc4:
        //b |bffc4|mov|9,(xs)|7,xr||store value on stack (over pdblk)|10629
        C_GOTO(bffc4);
        } /* bffc3 */
        

        void bffc4() {
        *(xs_it.wp)= xr;				// store value on stack (over pdblk)
        //b ||mov|7,xr|8,wc||copy next code word|10630
        xr= wc;				// copy next code word
        //b ||mov|7,xl|9,(xr)||load entry address|10631
        xl= *(xr_it.wp);				// load entry address
        //b ||bri|7,xl|||jump to routine for next code word|10632
        C_GOTO(xl_it.callp);				// jump to routine for next code word
//      here if called by name
// bffc5:
        //b |bffc5|mov|11,-(xs)|8,wa||store name offset (base is set)|10636
        } /* bffc4 */
        

        void bffc5() {
        C_PUSH(wa);				// store name offset (base is set)
        //b ||lcw|7,xr|||get next code word|10637
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|10638
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||10639
        
//      icblk
//      the routine for icblk is executed from the generated
//      code to load an integer value onto the stack.
//      (xr)                  pointer to icblk
//	align	2
//	db	bl_ic
        //b |b_icl|ent|2,bl_ic|||entry point (icblk)|10648
        } /* bffc5 */
        

        void b_icl() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (icblk)
        //b ||mov|11,-(xs)|7,xr||stack result|10649
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|10650
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|10651
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||10652
        
//      kvblk
//      the routine for a kvblk is never executed.
//	align	2
//	db	bl_kv
        //b |b_kvt|ent|2,bl_kv|||entry point (kvblk)|10658
        } /* b_icl */
        

        void b_kvt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (kvblk)
        //b ||ejc|||||10659
        
//      nmblk
//      the routine for a nmblk is executed from the generated
//      code for the case of loading a name onto the stack
//      where the name is that of a natural variable which can
//      be preevaluated at compile time.
//      (xr)                  pointer to nmblk
//	align	2
//	db	bl_nm
        //b |b_nml|ent|2,bl_nm|||entry point (nmblk)|10670
        C_GOTO(b_nml);
        } /* b_kvt */
        

        void b_nml() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (nmblk)
        //b ||mov|11,-(xs)|7,xr||stack result|10671
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|10672
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|10673
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||10674
        
//      pdblk
//      the routine for a pdblk is never executed
//	align	2
//	db	bl_pd
        //b |b_pdt|ent|2,bl_pd|||entry point (pdblk)|10680
        } /* b_nml */
        

        void b_pdt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (pdblk)
        //b ||ejc|||||10681
        
//      pfblk
//      the routine for a pfblk is executed from the entry o_fnc
//      to call a program defined function.
//      (xl)                  pointer to pfblk
//      the following stack entries are made before passing
//      control to the program defined function.
//                            saved value of first argument
//                            .
//                            saved value of last argument
//                            saved value of first local
//                            .
//                            saved value of last local
//                            saved value of function name
//                            saved code block ptr (r_cod)
//                            saved code pointer (-r_cod)
//                            saved value of flprt
//                            saved value of flptr
//                            pointer to pfblk
//      flptr --------------- zero (to be overwritten with offs)
//	align	2
//	db	bl_pf
        //b |b_pfc|ent|2,bl_pf|||entry point (pfblk)|10707
        C_GOTO(b_pfc);
        } /* b_pdt */
        

        void b_pfc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (pfblk)
        //b ||mov|3,bpfpf|7,xl||save pfblk ptr (need not be reloc)|10708
        v.bpfpf= xl;				// save pfblk ptr (need not be reloc)
        //b ||mov|7,xr|7,xl||copy for the moment|10709
        xr= xl;				// copy for the moment
        //b ||mov|7,xl|13,pfvbl(xr)||point to vrblk for function|10710
        xl= *((word *)(CFP_B*PFVBL + xr));				// point to vrblk for function
//      loop to find old value of function
// bpf01:
        //b |bpf01|mov|8,wb|7,xl||save pointer|10714
        C_GOTO(bpf01);
        } /* b_pfc */
        

        void bpf01() {
        wb= xl;				// save pointer
        //b ||mov|7,xl|13,vrval(xl)||load value|10715
        xl= *((word *)(CFP_B*VRVAL + xl));				// load value
        //b ||beq|9,(xl)|22,=b_trt|6,bpf01|loop if trblk|10716
        if ((*(xl_it.wp)-(word)(b_trt)) == 0) C_GOTO(bpf01);				// loop if trblk
//      set value to null and save old function value
        //b ||mov|3,bpfsv|7,xl||save old value|10720
        v.bpfsv= xl;				// save old value
        //b ||mov|7,xl|8,wb||point back to block with value|10721
        xl= wb;				// point back to block with value
        //b ||mov|13,vrval(xl)|21,=nulls||set value to null|10722
        *((word *)(CFP_B*VRVAL + xl))= (word)(&c.nulls);				// set value to null
        //b ||mov|8,wa|13,fargs(xr)||load number of arguments|10723
        wa= *((word *)(CFP_B*FARGS + xr));				// load number of arguments
        //b ||add|7,xr|19,*pfarg||point to pfarg entries|10724
        xr += CFP_B*PFARG;				// point to pfarg entries
        //b ||bze|8,wa|6,bpf04||jump if no arguments|10725
        if ( !( wa) ) C_GOTO(bpf04);				// jump if no arguments
        //b ||mov|7,xt|7,xs||ptr to last arg|10726
        xt= xs;				// ptr to last arg
        //b ||wtb|8,wa|||convert no. of args to bytes offset|10727
        wa <<= LOG_CFP_B;				// convert no. of args to bytes offset
        //b ||add|7,xt|8,wa||point before first arg|10728
        xt += wa;				// point before first arg
        //b ||mov|3,bpfxt|7,xt||remember arg pointer|10729
        v.bpfxt= xt;				// remember arg pointer
        //b ||ejc|||||10730
        
//      pfblk (continued)
//      loop to save old argument values and set new ones
// bpf02:
        //b |bpf02|mov|7,xl|10,(xr)+||load vrblk ptr for next argument|10736
        C_GOTO(bpf02);
        } /* bpf01 */
        

        void bpf02() {
        xl= *(xr_it.wp++);				// load vrblk ptr for next argument
//      loop through possible trblk chain to find value
// bpf03:
        //b |bpf03|mov|8,wc|7,xl||save pointer|10740
        C_GOTO(bpf03);
        } /* bpf02 */
        

        void bpf03() {
        wc= xl;				// save pointer
        //b ||mov|7,xl|13,vrval(xl)||load next value|10741
        xl= *((word *)(CFP_B*VRVAL + xl));				// load next value
        //b ||beq|9,(xl)|22,=b_trt|6,bpf03|loop back if trblk|10742
        if ((*(xl_it.wp)-(word)(b_trt)) == 0) C_GOTO(bpf03);				// loop back if trblk
//      save old value and get new value
        //b ||mov|8,wa|7,xl||keep old value|10746
        wa= xl;				// keep old value
        //b ||mov|7,xt|3,bpfxt||point before next stacked arg|10747
        xt= v.bpfxt;				// point before next stacked arg
        //b ||mov|8,wb|11,-(xt)||load argument (new value)|10748
        wb= *(--xt_it.wp);				// load argument (new value)
        //b ||mov|9,(xt)|8,wa||save old value|10749
        *(xt_it.wp)= wa;				// save old value
        //b ||mov|3,bpfxt|7,xt||keep arg ptr for next time|10750
        v.bpfxt= xt;				// keep arg ptr for next time
        //b ||mov|7,xl|8,wc||point back to block with value|10751
        xl= wc;				// point back to block with value
        //b ||mov|13,vrval(xl)|8,wb||set new value|10752
        *((word *)(CFP_B*VRVAL + xl))= wb;				// set new value
        //b ||bne|7,xs|3,bpfxt|6,bpf02|loop if not all done|10753
        if ((xs-v.bpfxt) != 0) C_GOTO(bpf02);				// loop if not all done
//      now process locals
// bpf04:
        //b |bpf04|mov|7,xl|3,bpfpf||restore pfblk pointer|10757
        C_GOTO(bpf04);
        } /* bpf03 */
        

        void bpf04() {
        xl= v.bpfpf;				// restore pfblk pointer
        //b ||mov|8,wa|13,pfnlo(xl)||load number of locals|10758
        wa= *((word *)(CFP_B*PFNLO + xl));				// load number of locals
        //b ||bze|8,wa|6,bpf07||jump if no locals|10759
        if ( !( wa) ) C_GOTO(bpf07);				// jump if no locals
        //b ||mov|8,wb|21,=nulls||get null constant|10760
        wb= (word)(&c.nulls);				// get null constant
        //b ||lct|8,wa|8,wa||set local counter|10761
        wa= wa;				// set local counter
//      loop to process locals
// bpf05:
        //b |bpf05|mov|7,xl|10,(xr)+||load vrblk ptr for next local|10765
        C_GOTO(bpf05);
        } /* bpf04 */
        

        void bpf05() {
        xl= *(xr_it.wp++);				// load vrblk ptr for next local
//      loop through possible trblk chain to find value
// bpf06:
        //b |bpf06|mov|8,wc|7,xl||save pointer|10769
        C_GOTO(bpf06);
        } /* bpf05 */
        

        void bpf06() {
        wc= xl;				// save pointer
        //b ||mov|7,xl|13,vrval(xl)||load next value|10770
        xl= *((word *)(CFP_B*VRVAL + xl));				// load next value
        //b ||beq|9,(xl)|22,=b_trt|6,bpf06|loop back if trblk|10771
        if ((*(xl_it.wp)-(word)(b_trt)) == 0) C_GOTO(bpf06);				// loop back if trblk
//      save old value and set null as new value
        //b ||mov|11,-(xs)|7,xl||stack old value|10775
        C_PUSH(xl);				// stack old value
        //b ||mov|7,xl|8,wc||point back to block with value|10776
        xl= wc;				// point back to block with value
        //b ||mov|13,vrval(xl)|8,wb||set null as new value|10777
        *((word *)(CFP_B*VRVAL + xl))= wb;				// set null as new value
        //b ||bct|8,wa|6,bpf05||loop till all locals processed|10778
        if ((--wa))  C_GOTO(bpf05);				// loop till all locals processed
        //b ||ejc|||||10779
        
//      pfblk (continued)
//      here after processing arguments and locals
// bpf07:
        //b |bpf07|zer|7,xr|||zero reg xr in case|10788
        C_GOTO(bpf07);
        } /* bpf06 */
        

        void bpf07() {
        xr=0;				// zero reg xr in case
        //b ||bze|3,kvpfl|6,bpf7c||skip if profiling is off|10789
        if ( !( v.kvpfl) ) C_GOTO(bpf7c);				// skip if profiling is off
        //b ||beq|3,kvpfl|18,=num02|6,bpf7a|branch on type of profile|10790
        if ((v.kvpfl-NUM02) == 0) C_GOTO(bpf7a);				// branch on type of profile
//      here if &profile = 1
        //b ||jsr|6,systm|||get current time|10794
        C_JSR(systm);				// get current time
        //b ||sti|3,pfetm|||save for a sec|10795
        v.pfetm= ia;				// save for a sec
        //b ||sbi|3,pfstm|||find time used by caller|10796
        ia-=v.pfstm;				// find time used by caller
        //b ||jsr|6,icbld|||build into an icblk|10797
        C_JSR(icbld);				// build into an icblk
        //b ||ldi|3,pfetm|||reload current time|10798
        ia = v.pfetm;				// reload current time
        //b ||brn|6,bpf7b|||merge|10799
         C_GOTO(bpf7b);				// merge
//       here if &profile = 2
// bpf7a:
        //b |bpf7a|ldi|3,pfstm|||get start time of calling stmt|10803
        } /* bpf07 */
        

        void bpf7a() {
        ia = v.pfstm;				// get start time of calling stmt
        //b ||jsr|6,icbld|||assemble an icblk round it|10804
        C_JSR(icbld);				// assemble an icblk round it
        //b ||jsr|6,systm|||get now time|10805
        C_JSR(systm);				// get now time
//      both types of profile merge here
// bpf7b:
        //b |bpf7b|sti|3,pfstm|||set start time of 1st func stmt|10809
        C_GOTO(bpf7b);
        } /* bpf7a */
        

        void bpf7b() {
        v.pfstm= ia;				// set start time of 1st func stmt
        //b ||mnz|3,pffnc|||flag function entry|10810
        v.pffnc = 0xffffffffffffffff;				// flag function entry
//      no profiling merges here
// bpf7c:
        //b |bpf7c|mov|11,-(xs)|7,xr||stack icblk ptr (or zero)|10814
        C_GOTO(bpf7c);
        } /* bpf7b */
        

        void bpf7c() {
        C_PUSH(xr);				// stack icblk ptr (or zero)
        //b ||mov|8,wa|3,r_cod||load old code block pointer|10815
        wa= v.r_cod;				// load old code block pointer
        //b ||scp|8,wb|||get code pointer|10817
        wb= reg_cp;				// get code pointer
        //b ||sub|8,wb|8,wa||make code pointer into offset|10818
        wb -= wa;				// make code pointer into offset
        //b ||mov|7,xl|3,bpfpf||recall pfblk pointer|10819
        xl= v.bpfpf;				// recall pfblk pointer
        //b ||mov|11,-(xs)|3,bpfsv||stack old value of function name|10820
        C_PUSH(v.bpfsv);				// stack old value of function name
        //b ||mov|11,-(xs)|8,wa||stack code block pointer|10821
        C_PUSH(wa);				// stack code block pointer
        //b ||mov|11,-(xs)|8,wb||stack code offset|10822
        C_PUSH(wb);				// stack code offset
        //b ||mov|11,-(xs)|3,flprt||stack old flprt|10823
        C_PUSH(v.flprt);				// stack old flprt
        //b ||mov|11,-(xs)|3,flptr||stack old failure pointer|10824
        C_PUSH(v.flptr);				// stack old failure pointer
        //b ||mov|11,-(xs)|7,xl||stack pointer to pfblk|10825
        C_PUSH(xl);				// stack pointer to pfblk
        //b ||zer|11,-(xs)|||dummy zero entry for fail return|10826
        *(--xs_it.wp)=0;				// dummy zero entry for fail return
        //b ||chk||||check for stack overflow|10827
        if(xs<v.lowspmin) { C_GOTO(sec06); } /* stack overflow check */				// check for stack overflow
        //b ||mov|3,flptr|7,xs||set new fail return value|10828
        v.flptr= xs;				// set new fail return value
        //b ||mov|3,flprt|7,xs||set new flprt|10829
        v.flprt= xs;				// set new flprt
        //b ||mov|8,wa|3,kvtra||load trace value|10830
        wa= v.kvtra;				// load trace value
        //b ||add|8,wa|3,kvftr||add ftrace value|10831
        wa += v.kvftr;				// add ftrace value
        //b ||bnz|8,wa|6,bpf09||jump if tracing possible|10832
        if (wa) C_GOTO(bpf09);				// jump if tracing possible
        //b ||icv|3,kvfnc|||else bump fnclevel|10833
        (v.kvfnc)++;				// else bump fnclevel
//      here to actually jump to function
// bpf08:
        //b |bpf08|mov|7,xr|13,pfcod(xl)||point to vrblk of entry label|10837
        C_GOTO(bpf08);
        } /* bpf7c */
        

        void bpf08() {
        xr= *((word *)(CFP_B*PFCOD + xl));				// point to vrblk of entry label
        //b ||mov|7,xr|13,vrlbl(xr)||point to target code|10838
        xr= *((word *)(CFP_B*VRLBL + xr));				// point to target code
        //b ||beq|7,xr|21,=stndl|6,bpf17|test for undefined label|10839
        if ((xr-(word)(&c.stndl)) == 0) C_GOTO(bpf17);				// test for undefined label
        //b ||bne|9,(xr)|22,=b_trt|6,bpf8a|jump if not trapped|10840
        if ((*(xr_it.wp)-(word)(b_trt)) != 0) C_GOTO(bpf8a);				// jump if not trapped
        //b ||mov|7,xr|13,trlbl(xr)||else load ptr to real label code|10841
        xr= *((word *)(CFP_B*TRLBL + xr));				// else load ptr to real label code
// bpf8a:
        //b |bpf8a|bri|9,(xr)|||off to execute function|10842
        C_GOTO(bpf8a);
        } /* bpf08 */
        

        void bpf8a() {
        w0 = xr_it.wp[0];				// off to execute function
        C_GOTO(w0_it.callp);
//      here if tracing is possible
// bpf09:
        //b |bpf09|mov|7,xr|13,pfctr(xl)||load possible call trace trblk|10846
        } /* bpf8a */
        

        void bpf09() {
        xr= *((word *)(CFP_B*PFCTR + xl));				// load possible call trace trblk
        //b ||mov|7,xl|13,pfvbl(xl)||load vrblk pointer for function|10847
        xl= *((word *)(CFP_B*PFVBL + xl));				// load vrblk pointer for function
        //b ||mov|8,wa|19,*vrval||set name offset for variable|10848
        wa= CFP_B*VRVAL;				// set name offset for variable
        //b ||bze|3,kvtra|6,bpf10||jump if trace mode is off|10849
        if ( !( v.kvtra) ) C_GOTO(bpf10);				// jump if trace mode is off
        //b ||bze|7,xr|6,bpf10||or if there is no call trace|10850
        if ( !( xr) ) C_GOTO(bpf10);				// or if there is no call trace
//      here if call traced
        //b ||dcv|3,kvtra|||decrement trace count|10854
        (v.kvtra)--;				// decrement trace count
        //b ||bze|13,trfnc(xr)|6,bpf11||jump if print trace|10855
        if ( !( *((word *)(CFP_B*TRFNC + xr))) ) C_GOTO(bpf11);				// jump if print trace
        //b ||jsr|6,trxeq|||execute function type trace|10856
        C_JSR(trxeq);				// execute function type trace
        //b ||ejc|||||10857
        
//      pfblk (continued)
//      here to test for ftrace trace
// bpf10:
        //b |bpf10|bze|3,kvftr|6,bpf16||jump if ftrace is off|10863
        C_GOTO(bpf10);
        } /* bpf09 */
        

        void bpf10() {
        if ( !( v.kvftr) ) C_GOTO(bpf16);				// jump if ftrace is off
        //b ||dcv|3,kvftr|||else decrement ftrace|10864
        (v.kvftr)--;				// else decrement ftrace
//      here for print trace
// bpf11:
        //b |bpf11|jsr|6,prtsn|||print statement number|10868
        C_GOTO(bpf11);
        } /* bpf10 */
        

        void bpf11() {
        C_JSR(prtsn);				// print statement number
        //b ||jsr|6,prtnm|||print function name|10869
        C_JSR(prtnm);				// print function name
        //b ||mov|8,wa|18,=ch_pp||load left paren|10870
        wa= CH_PP;				// load left paren
        //b ||jsr|6,prtch|||print left paren|10871
        C_JSR(prtch);				// print left paren
        //b ||mov|7,xl|13,num01(xs)||recover pfblk pointer|10872
        xl= *((word *)(CFP_B*NUM01 + xs));				// recover pfblk pointer
        //b ||bze|13,fargs(xl)|6,bpf15||skip if no arguments|10873
        if ( !( *((word *)(CFP_B*FARGS + xl))) ) C_GOTO(bpf15);				// skip if no arguments
        //b ||zer|8,wb|||else set argument counter|10874
        wb=0;				// else set argument counter
        //b ||brn|6,bpf13|||jump into loop|10875
         C_GOTO(bpf13);				// jump into loop
//      loop to print argument values
// bpf12:
        //b |bpf12|mov|8,wa|18,=ch_cm||load comma|10879
        } /* bpf11 */
        

        void bpf12() {
        wa= CH_CM;				// load comma
        //b ||jsr|6,prtch|||print to separate from last arg|10880
        C_JSR(prtch);				// print to separate from last arg
//      merge here first time (no comma required)
// bpf13:
        //b |bpf13|mov|9,(xs)|8,wb||save arg ctr (over failoffs is ok)|10884
        C_GOTO(bpf13);
        } /* bpf12 */
        

        void bpf13() {
        *(xs_it.wp)= wb;				// save arg ctr (over failoffs is ok)
        //b ||wtb|8,wb|||convert to byte offset|10885
        wb <<= LOG_CFP_B;				// convert to byte offset
        //b ||add|7,xl|8,wb||point to next argument pointer|10886
        xl += wb;				// point to next argument pointer
        //b ||mov|7,xr|13,pfarg(xl)||load next argument vrblk ptr|10887
        xr= *((word *)(CFP_B*PFARG + xl));				// load next argument vrblk ptr
        //b ||sub|7,xl|8,wb||restore pfblk pointer|10888
        xl -= wb;				// restore pfblk pointer
        //b ||mov|7,xr|13,vrval(xr)||load next value|10889
        xr= *((word *)(CFP_B*VRVAL + xr));				// load next value
        //b ||jsr|6,prtvl|||print argument value|10890
        C_JSR(prtvl);				// print argument value
        //b ||ejc|||||10891
        
//      here after dealing with one argument
        //b ||mov|8,wb|9,(xs)||restore argument counter|10895
        wb= *(xs_it.wp);				// restore argument counter
        //b ||icv|8,wb|||increment argument counter|10896
        (wb)++;				// increment argument counter
        //b ||blt|8,wb|13,fargs(xl)|6,bpf12|loop if more to print|10897
        if ((wb-*((word *)(CFP_B*FARGS + xl))) < 0) C_GOTO(bpf12);				// loop if more to print
//      merge here in no args case to print paren
// bpf15:
        //b |bpf15|mov|8,wa|18,=ch_rp||load right paren|10901
        C_GOTO(bpf15);
        } /* bpf13 */
        

        void bpf15() {
        wa= CH_RP;				// load right paren
        //b ||jsr|6,prtch|||print to terminate output|10902
        C_JSR(prtch);				// print to terminate output
        //b ||jsr|6,prtnl|||terminate print line|10903
        C_JSR(prtnl);				// terminate print line
//      merge here to exit with test for fnclevel trace
// bpf16:
        //b |bpf16|icv|3,kvfnc|||increment fnclevel|10907
        C_GOTO(bpf16);
        } /* bpf15 */
        

        void bpf16() {
        (v.kvfnc)++;				// increment fnclevel
        //b ||mov|7,xl|3,r_fnc||load ptr to possible trblk|10908
        xl= v.r_fnc;				// load ptr to possible trblk
        //b ||jsr|6,ktrex|||call keyword trace routine|10909
        C_JSR(ktrex);				// call keyword trace routine
//      call function after trace tests complete
        //b ||mov|7,xl|13,num01(xs)||restore pfblk pointer|10913
        xl= *((word *)(CFP_B*NUM01 + xs));				// restore pfblk pointer
        //b ||brn|6,bpf08|||jump back to execute function|10914
         C_GOTO(bpf08);				// jump back to execute function
//      here if calling a function whose entry label is undefined
// bpf17:
        //b |bpf17|mov|3,flptr|13,num02(xs)||reset so exfal can return to evalx|10918
        } /* bpf16 */
        

        void bpf17() {
        v.flptr= *((word *)(CFP_B*NUM02 + xs));				// reset so exfal can return to evalx
        //b ||erb|1,286|26,function call to undefined entry label|||10919
        C_ERB(286)
        //b ||ejc|||||10922
        
//      rcblk
//      the routine for an rcblk is executed from the generated
//      code to load a real value onto the stack.
//      (xr)                  pointer to rcblk
//	align	2
//	db	bl_rc
        //b |b_rcl|ent|2,bl_rc|||entry point (rcblk)|10931
        } /* bpf17 */
        

        void b_rcl() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (rcblk)
        //b ||mov|11,-(xs)|7,xr||stack result|10932
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|10933
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|10934
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||10936
        
//      scblk
//      the routine for an scblk is executed from the generated
//      code to load a string value onto the stack.
//      (xr)                  pointer to scblk
//	align	2
//	db	bl_sc
        //b |b_scl|ent|2,bl_sc|||entry point (scblk)|10945
        } /* b_rcl */
        

        void b_scl() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (scblk)
        //b ||mov|11,-(xs)|7,xr||stack result|10946
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|10947
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|10948
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||10949
        
//      tbblk
//      the routine for a tbblk is never executed
//	align	2
//	db	bl_tb
        //b |b_tbt|ent|2,bl_tb|||entry point (tbblk)|10955
        } /* b_scl */
        

        void b_tbt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (tbblk)
        //b ||ejc|||||10956
        
//      teblk
//      the routine for a teblk is never executed
//	align	2
//	db	bl_te
        //b |b_tet|ent|2,bl_te|||entry point (teblk)|10962
        C_GOTO(b_tet);
        } /* b_tbt */
        

        void b_tet() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (teblk)
        //b ||ejc|||||10963
        
//      vcblk
//      the routine for a vcblk is never executed
//	align	2
//	db	bl_vc
        //b |b_vct|ent|2,bl_vc|||entry point (vcblk)|10969
        C_GOTO(b_vct);
        } /* b_tet */
        

        void b_vct() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (vcblk)
        //b ||ejc|||||10970
        
//      vrblk
//      the vrblk routines are executed from the generated code.
//      there are six entries for vrblk covering various cases
//	align	2
//	db	bl__i
        //b |b_vr_|ent|2,bl__i|||mark start of vrblk entry points|10977
        C_GOTO(b_vr_);
        } /* b_vct */
        

        void b_vr_() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// mark start of vrblk entry points
//      entry for vrget (trapped case). this routine is called
//      from the generated code to load the value of a variable.
//      this entry point is used if an access trace or input
//      association is currently active.
//      (xr)                  pointer to vrget field of vrblk
//	align	2
//	db	bl__i
        //b |b_vra|ent|2,bl__i|||entry point|10986
        C_GOTO(b_vra);
        } /* b_vr_ */
        

        void b_vra() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xl|7,xr||copy name base (vrget = 0)|10987
        xl= xr;				// copy name base (vrget = 0)
        //b ||mov|8,wa|19,*vrval||set name offset|10988
        wa= CFP_B*VRVAL;				// set name offset
        //b ||ppm|6,exfal|||fail if access fails|10990
        C_JSR_1(acess,C_GOTO(exfal));				// fail if access fails
        //b ||mov|11,-(xs)|7,xr||stack result|10991
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|10992
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|10993
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||10994
        
//      vrblk (continued)
//      entry for vrsto (error case. this routine is called from
//      the executed code for an attempt to modify the value
//      of a protected (pattern valued) natural variable.
//	align	2
//	nop
        //b |b_vre|ent||||entry point|11002
        } /* b_vra */
        

        void b_vre() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||erb|1,042|26,attempt to change value of protected variable|||11003
        C_ERB(42)
        //b ||ejc|||||11004
        
//      vrblk (continued)
//      entry for vrtra (untrapped case). this routine is called
//      from the executed code to transfer to a label.
//      (xr)                  pointer to vrtra field of vrblk
//	align	2
//	nop
        //b |b_vrg|ent||||entry point|11013
        } /* b_vre */
        

        void b_vrg() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|13,vrlbo(xr)||load code pointer|11014
        xr= *((word *)(CFP_B*VRLBO + xr));				// load code pointer
        //b ||mov|7,xl|9,(xr)||load entry address|11015
        xl= *(xr_it.wp);				// load entry address
        //b ||bri|7,xl|||jump to routine for next code word|11016
        C_GOTO(xl_it.callp);				// jump to routine for next code word
        //b ||ejc|||||11017
        
//      vrblk (continued)
//      entry for vrget (untrapped case). this routine is called
//      from the generated code to load the value of a variable.
//      (xr)                  points to vrget field of vrblk
//	align	2
//	nop
        //b |b_vrl|ent||||entry point|11026
        } /* b_vrg */
        

        void b_vrl() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|11,-(xs)|13,vrval(xr)||load value onto stack (vrget = 0)|11027
        C_PUSH(*((word *)(CFP_B*VRVAL + xr)));				// load value onto stack (vrget = 0)
        //b ||lcw|7,xr|||get next code word|11028
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|11029
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||11030
        
//      vrblk (continued)
//      entry for vrsto (untrapped case). this routine is called
//      from the generated code to store the value of a variable.
//      (xr)                  pointer to vrsto field of vrblk
//	align	2
//	nop
        //b |b_vrs|ent||||entry point|11039
        } /* b_vrl */
        

        void b_vrs() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|13,vrvlo(xr)|9,(xs)||store value, leave on stack|11040
        *((word *)(CFP_B*VRVLO + xr))= *(xs_it.wp);				// store value, leave on stack
        //b ||lcw|7,xr|||get next code word|11041
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|11042
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||11043
        
//      vrblk (continued)
//      vrtra (trapped case). this routine is called from the
//      generated code to transfer to a label when a label
//      trace is currently active.
//	align	2
//	nop
        //b |b_vrt|ent||||entry point|11051
        } /* b_vrs */
        

        void b_vrt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||sub|7,xr|19,*vrtra||point back to start of vrblk|11052
        xr -= CFP_B*VRTRA;				// point back to start of vrblk
        //b ||mov|7,xl|7,xr||copy vrblk pointer|11053
        xl= xr;				// copy vrblk pointer
        //b ||mov|8,wa|19,*vrval||set name offset|11054
        wa= CFP_B*VRVAL;				// set name offset
        //b ||mov|7,xr|13,vrlbl(xl)||load pointer to trblk|11055
        xr= *((word *)(CFP_B*VRLBL + xl));				// load pointer to trblk
        //b ||bze|3,kvtra|6,bvrt2||jump if trace is off|11056
        if ( !( v.kvtra) ) C_GOTO(bvrt2);				// jump if trace is off
        //b ||dcv|3,kvtra|||else decrement trace count|11057
        (v.kvtra)--;				// else decrement trace count
        //b ||bze|13,trfnc(xr)|6,bvrt1||jump if print trace case|11058
        if ( !( *((word *)(CFP_B*TRFNC + xr))) ) C_GOTO(bvrt1);				// jump if print trace case
        //b ||jsr|6,trxeq|||else execute full trace|11059
        C_JSR(trxeq);				// else execute full trace
        //b ||brn|6,bvrt2|||merge to jump to label|11060
         C_GOTO(bvrt2);				// merge to jump to label
//      here for print trace -- print colon ( label name )
// bvrt1:
        //b |bvrt1|jsr|6,prtsn|||print statement number|11064
        } /* b_vrt */
        

        void bvrt1() {
        C_JSR(prtsn);				// print statement number
        //b ||mov|7,xr|7,xl||copy vrblk pointer|11065
        xr= xl;				// copy vrblk pointer
        //b ||mov|8,wa|18,=ch_cl||colon|11066
        wa= CH_CL;				// colon
        //b ||jsr|6,prtch|||print it|11067
        C_JSR(prtch);				// print it
        //b ||mov|8,wa|18,=ch_pp||left paren|11068
        wa= CH_PP;				// left paren
        //b ||jsr|6,prtch|||print it|11069
        C_JSR(prtch);				// print it
        //b ||jsr|6,prtvn|||print label name|11070
        C_JSR(prtvn);				// print label name
        //b ||mov|8,wa|18,=ch_rp||right paren|11071
        wa= CH_RP;				// right paren
        //b ||jsr|6,prtch|||print it|11072
        C_JSR(prtch);				// print it
        //b ||jsr|6,prtnl|||terminate line|11073
        C_JSR(prtnl);				// terminate line
        //b ||mov|7,xr|13,vrlbl(xl)||point back to trblk|11074
        xr= *((word *)(CFP_B*VRLBL + xl));				// point back to trblk
//      merge here to jump to label
// bvrt2:
        //b |bvrt2|mov|7,xr|13,trlbl(xr)||load pointer to actual code|11078
        C_GOTO(bvrt2);
        } /* bvrt1 */
        

        void bvrt2() {
        xr= *((word *)(CFP_B*TRLBL + xr));				// load pointer to actual code
        //b ||bri|9,(xr)|||execute statement at label|11079
        w0 = xr_it.wp[0];				// execute statement at label
        C_GOTO(w0_it.callp);
        //b ||ejc|||||11080
        
//      vrblk (continued)
//      entry for vrsto (trapped case). this routine is called
//      from the generated code to store the value of a variable.
//      this entry is used when a value trace or output
//      association is currently active.
//      (xr)                  pointer to vrsto field of vrblk
//	align	2
//	nop
        //b |b_vrv|ent||||entry point|11091
        } /* bvrt2 */
        

        void b_vrv() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|9,(xs)||load value (leave copy on stack)|11092
        wb= *(xs_it.wp);				// load value (leave copy on stack)
        //b ||sub|7,xr|19,*vrsto||point to vrblk|11093
        xr -= CFP_B*VRSTO;				// point to vrblk
        //b ||mov|7,xl|7,xr||copy vrblk pointer|11094
        xl= xr;				// copy vrblk pointer
        //b ||mov|8,wa|19,*vrval||set offset|11095
        wa= CFP_B*VRVAL;				// set offset
        //b ||ppm|6,exfal|||fail if assignment fails|11097
        C_JSR_1(asign,C_GOTO(exfal));				// fail if assignment fails
        //b ||lcw|7,xr|||else get next code word|11098
        xr  = *((word *)reg_cp);				// else get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|11099
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||11100
        
//      xnblk
//      the routine for an xnblk is never executed
//	align	2
//	db	bl_xn
        //b |b_xnt|ent|2,bl_xn|||entry point (xnblk)|11106
        } /* b_vrv */
        

        void b_xnt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (xnblk)
        //b ||ejc|||||11107
        
//      xrblk
//      the routine for an xrblk is never executed
//	align	2
//	db	bl_xr
        //b |b_xrt|ent|2,bl_xr|||entry point (xrblk)|11113
        C_GOTO(b_xrt);
        } /* b_xnt */
        

        void b_xrt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point (xrblk)
//      mark entry address past last block action routine
//	align	2
//	db	bl__i
        //b |b_yyy|ent|2,bl__i|||last block routine entry point|11117
        C_GOTO(b_yyy);
        } /* b_xrt */
        

        void b_yyy() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// last block routine entry point
        //b ||ttl|27,s p i t b o l -- pattern matching routines||||11118
        /* s p i t b o l -- pattern matching routines*/
//      the following section consists of the pattern matching
//      routines. all pattern nodes contain a pointer (pcode)
//      to one of the routines in this section (p_xxx).
//      note that this section follows the b_xxx routines to
//      enable a fast test for the pattern datatype.
//	align	2
//	db	bl__i
        //b |p_aaa|ent|2,bl__i|||entry to mark first pattern|11127
        C_GOTO(p_aaa);
        } /* b_yyy */
        

        void p_aaa() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry to mark first pattern
//      the entry conditions to the match routine are as follows
//      (see o_pmn, o_pmv, o_pms and procedure match).
//      stack contents.
//                            name base (o_pmn only)
//                            name offset (o_pmn only)
//                            type (0-o_pmn, 1-o_pmv, 2-o_pms)
//      pmhbs --------------- initial cursor (zero)
//                            initial node pointer
//      xs ------------------ =ndabo (anchored), =nduna (unanch)
//      register values.
//           (xs)             set as shown in stack diagram
//           (xr)             pointer to initial pattern node
//           (wb)             initial cursor (zero)
//      global pattern values
//           r_pms            pointer to subject string scblk
//           pmssl            length of subject string in chars
//           pmdfl            dot flag, initially zero
//           pmhbs            set as shown in stack diagram
//      control is passed by branching through the pcode
//      field of the initial pattern node (bri (xr)).
        //b ||ejc|||||11157
        
//      description of algorithm
//      a pattern structure is represented as a linked graph
//      of nodes with the following structure.
//           +------------------------------------+
//           i                pcode               i
//           +------------------------------------+
//           i                pthen               i
//           +------------------------------------+
//           i                parm1               i
//           +------------------------------------+
//           i                parm2               i
//           +------------------------------------+
//      pcode is a pointer to the routine which will perform
//      the match of this particular node type.
//      pthen is a pointer to the successor node. i.e. the node
//      to be matched if the attempt to match this node succeeds.
//      if this is the last node of the pattern pthen points
//      to the dummy node ndnth which initiates pattern exit.
//      parm1, parm2 are parameters whose use varies with the
//      particular node. they are only present if required.
//      alternatives are handled with the special alternative
//      node whose parameter points to the node to be matched
//      if there is a failure on the successor path.
//      the following example illustrates the manner in which
//      the structure is built up. the pattern is
//      (a / b / c) (d / e)   where / is alternation
//      in the diagram, the node marked + represents an
//      alternative node and the dotted line from a + node
//      represents the parameter pointer to the alternative.
//      +---+     +---+     +---+     +---+
//      i + i-----i a i-----i + i-----i d i-----
//      +---+     +---+  i  +---+     +---+
//        .              i    .
//        .              i    .
//      +---+     +---+  i  +---+
//      i + i-----i b i--i  i e i-----
//      +---+     +---+  i  +---+
//        .              i
//        .              i
//      +---+            i
//      i c i------------i
//      +---+
        //b ||ejc|||||11211
        
//      during the match, the registers are used as follows.
//      (xr)                  points to the current node
//      (xl)                  scratch
//      (xs)                  main stack pointer
//      (wb)                  cursor (number of chars matched)
//      (wa,wc)               scratch
//      to keep track of alternatives, the main stack is used as
//      a history stack and contains two word entries.
//      word 1                saved cursor value
//      word 2                node to match on failure
//      when a failure occurs, the most recent entry on this
//      stack is popped off to restore the cursor and point
//      to the node to be matched as an alternative. the entry
//      at the bottom of the stack points to the following
//      special nodes depending on the scan mode.
//      anchored mode         the bottom entry points to the
//                            special node ndabo which causes an
//                            abort. the cursor value stored
//                            with this entry is always zero.
//      unanchored mode       the bottom entry points to the
//                            special node nduna which moves the
//                            anchor point and restarts the match
//                            the cursor saved with this entry
//                            is the number of characters which
//                            lie before the initial anchor point
//                            (i.e. the number of anchor moves).
//                            this entry is three words long and
//                            also contains the initial pattern.
//      entries are made on this history stack by alternative
//      nodes and by some special compound patterns as described
//      later on. the following global locations are used during
//      pattern matching.
//      r_pms                 pointer to subject string
//      pmssl                 length of subject string
//      pmdfl                 flag set non-zero for dot patterns
//      pmhbs                 base ptr for current history stack
//      the following exit points are available to match routines
//      succp                 success in matching current node
//      failp                 failure in matching current node
        //b ||ejc|||||11262
        
//      compound patterns
//      some patterns have implicit alternatives and their
//      representation in the pattern structure consists of a
//      linked set of nodes as indicated by these diagrams.
//      as before, the + represents an alternative node and
//      the dotted line from a + node is the parameter pointer
//      to the alternative pattern.
//      arb
//      ---
//           +---+            this node (p_arb) matches null
//           i b i-----       and stacks cursor, successor ptr,
//           +---+            cursor (copy) and a ptr to ndarc.
//      bal
//      ---
//           +---+            the p_bal node scans a balanced
//           i b i-----       string and then stacks a pointer
//           +---+            to itself on the history stack.
        //b ||ejc|||||11290
        
//      compound pattern structures (continued)
//      arbno
//      -----
//           +---+            this alternative node matches null
//      +----i + i-----       the first time and stacks a pointer
//      i    +---+            to the argument pattern x.
//      i      .
//      i      .
//      i    +---+            node (p_aba) to stack cursor
//      i    i a i            and history stack base ptr.
//      i    +---+
//      i      i
//      i      i
//      i    +---+            this is the argument pattern. as
//      i    i x i            indicated, the successor of the
//      i    +---+            pattern is the p_abc node
//      i      i
//      i      i
//      i    +---+            this node (p_abc) pops pmhbs,
//      +----i c i            stacks old pmhbs and ptr to ndabd
//           +---+            (unless optimization has occurred)
//      structure and execution of this pattern resemble those of
//      recursive pattern matching and immediate assignment.
//      the alternative node at the head of the structure matches
//      null initially but on subsequent failure ensures attempt
//      to match the argument.  before the argument is matched
//      p_aba stacks the cursor, pmhbs and a ptr to p_abb.  if
//      the argument cant be matched , p_abb removes this special
//      stack entry and fails.
//      if argument is matched , p_abc restores the outer pmhbs
//      value (saved by p_aba) .  then if the argument has left
//      alternatives on stack it stacks the inner value of pmhbs
//      and a ptr to ndabd. if argument left nothing on the stack
//      it optimises by removing items stacked by p_aba.  finally
//      a check is made that argument matched more than the null
//      string (check is intended to prevent useless looping).
//      if so the successor is again the alternative node at the
//      head of the structure , ensuring a possible extra attempt
//      to match the arg if necessary.  if not , the successor to
//      alternative is taken so as to terminate the loop.  p_abd
//      restores inner pmhbs ptr and fails , thus trying to match
//      alternatives left by the arbno argument.
        //b ||ejc|||||11338
        
//      compound pattern structures (continued)
//      breakx
//      ------
//           +---+            this node is a break node for
//      +----i b i            the argument to breakx, identical
//      i    +---+            to an ordinary break node.
//      i      i
//      i      i
//      i    +---+            this alternative node stacks a
//      i    i + i-----       pointer to the breakx node to
//      i    +---+            allow for subsequent failure
//      i      .
//      i      .
//      i    +---+            this is the breakx node itself. it
//      +----i x i            matches one character and then
//           +---+            proceeds back to the break node.
//      fence
//      -----
//           +---+            the fence node matches null and
//           i f i-----       stacks a pointer to node ndabo to
//           +---+            abort on a subsequent rematch
//      succeed
//      -------
//           +---+            the node for succeed matches null
//           i s i-----       and stacks a pointer to itself
//           +---+            to repeat the match on a failure.
        //b ||ejc|||||11378
        
//      compound patterns (continued)
//      binary dot (pattern assignment)
//      -------------------------------
//           +---+            this node (p_paa) saves the current
//           i a i            cursor and a pointer to the
//           +---+            special node ndpab on the stack.
//             i
//             i
//           +---+            this is the structure for the
//           i x i            pattern left argument of the
//           +---+            pattern assignment call.
//             i
//             i
//           +---+            this node (p_pac) saves the cursor,
//           i c i-----       a ptr to itself, the cursor (copy)
//           +---+            and a ptr to ndpad on the stack.
//      the function of the match routine for ndpab (p_pab)
//      is simply to unstack itself and fail back onto the stack.
//      the match routine for p_pac also sets the global pattern
//      flag pmdfl non-zero to indicate that pattern assignments
//      may have occured in the pattern match
//      if pmdfl is set at the end of the match (see p_nth), the
//      history stack is scanned for matching ndpab-ndpad pairs
//      and the corresponding pattern assignments are executed.
//      the function of the match routine for ndpad (p_pad)
//      is simply to remove its entry from the stack and fail.
//      this includes removing the special node pointer stored
//      in addition to the standard two entries on the stack.
        //b ||ejc|||||11415
        
//      compount pattern structures (continued)
//      fence (function)
//      ----------------
//           +---+            this node (p_fna) saves the
//           i a i            current history stack and a
//           +---+            pointer to ndfnb on the stack.
//             i
//             i
//           +---+            this is the pattern structure
//           i x i            given as the argument to the
//           +---+            fence function.
//             i
//             i
//           +---+            this node p_fnc restores the outer
//           i c i            history stack ptr saved in p_fna,
//           +---+            and stacks the inner stack base
//                            ptr and a pointer to ndfnd on the
//                            stack.
//      ndfnb (f_fnb) simply is the failure exit for pattern
//      argument failure, and it pops itself and fails onto the
//      stack.
//      the match routine p_fnc allows for an optimization when
//      the fence pattern leaves no alternatives.  in this case,
//      the ndfnb entry is popped, and the match continues.
//      ndfnd (p_fnd) is entered when the pattern fails after
//      going through a non-optimized p_fnc, and it pops the
//      stack back past the innter stack base created by p_fna
        //b ||ejc|||||11449
        
//      compound patterns (continued)
//      expression patterns (recursive pattern matches)
//      -----------------------------------------------
//      initial entry for a pattern node is to the routine p_exa.
//      if the evaluated result of the expression is itself a
//      pattern, then the following steps are taken to arrange
//      for proper recursive processing.
//      1)   a pointer to the current node (the p_exa node) is
//           stored on the history stack with a dummy cursor.
//      2)   a special history stack entry is made in which the
//           node pointer points to ndexb, and the cursor value
//           is the saved value of pmhbs on entry to this node.
//           the match routine for ndexb (p_exb) restores pmhbs
//           from this cursor entry, pops off the p_exa node
//           pointer and fails.
//      3)   the resulting history stack pointer is saved in
//           pmhbs to establish a new level of history stack.
//      after matching a pattern, the end of match routine gets
//      control (p_nth). this routine proceeds as follows.
//      1)   load the current value of pmhbs and recognize the
//           outer level case by the fact that the associated
//           cursor in this case is the pattern match type code
//           which is less than 3. terminate the match in this
//           case and continue execution of the program.
//      2)   otherwise make a special history stack entry in
//           which the node pointer points to the special node
//           ndexc and the cursor is the current value of pmhbs.
//           the match routine for ndexc (p_exc) resets pmhbs to
//           this (inner) value and and then fails.
//      3)   using the history stack entry made on starting the
//           expression (accessible with the current value of
//           pmhbs), restore the p_exa node pointer and the old
//           pmhbs setting. take the successor and continue.
//      an optimization is possible if the expression pattern
//      makes no entries on the history stack. in this case,
//      instead of building the p_exc node in step 2, it is more
//      efficient to simply pop off the p_exb entry and its
//      associated node pointer. the effect is the same.
        //b ||ejc|||||11499
        
//      compound patterns (continued)
//      binary dollar (immediate assignment)
//      ------------------------------------
//           +---+            this node (p_ima) stacks the cursor
//           i a i            pmhbs and a ptr to ndimb and resets
//           +---+            the stack ptr pmhbs.
//             i
//             i
//           +---+            this is the left structure for the
//           i x i            pattern left argument of the
//           +---+            immediate assignment call.
//             i
//             i
//           +---+            this node (p_imc) performs the
//           i c i-----       assignment, pops pmhbs and stacks
//           +---+            the old pmhbs and a ptr to ndimd.
//      the structure and execution of this pattern are similar
//      to those of the recursive expression pattern matching.
//      the match routine for ndimb (p_imb) restores the outer
//      level value of pmhbs, unstacks the saved cursor and fails
//      the match routine p_imc uses the current value of pmhbs
//      to locate the p_imb entry. this entry is used to make
//      the assignment and restore the outer level value of
//      pmhbs. finally, the inner level value of pmhbs and a
//      pointer to the special node ndimd are stacked.
//      the match routine for ndimd (p_imd) restores the inner
//      level value of pmhbs and fails back into the stack.
//      an optimization occurs if the inner pattern makes no
//      entries on the history stack. in this case, p_imc pops
//      the p_imb entry instead of making a p_imd entry.
        //b ||ejc|||||11539
        
//      arbno
//      see compound patterns section for stucture and
//      algorithm for matching this node type.
//      no parameters
//	align	2
//	db	bl_p0
        //b |p_aba|ent|2,bl_p0|||p0blk|11548
        C_GOTO(p_aba);
        } /* p_aaa */
        

        void p_aba() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||mov|11,-(xs)|8,wb||stack cursor|11549
        C_PUSH(wb);				// stack cursor
        //b ||mov|11,-(xs)|7,xr||stack dummy node ptr|11550
        C_PUSH(xr);				// stack dummy node ptr
        //b ||mov|11,-(xs)|3,pmhbs||stack old stack base ptr|11551
        C_PUSH(v.pmhbs);				// stack old stack base ptr
        //b ||mov|11,-(xs)|21,=ndabb||stack ptr to node ndabb|11552
        C_PUSH((word)(&c.ndabb));				// stack ptr to node ndabb
        //b ||mov|3,pmhbs|7,xs||store new stack base ptr|11553
        v.pmhbs= xs;				// store new stack base ptr
        //b ||brn|6,succp|||succeed|11554
         C_GOTO(succp);				// succeed
        //b ||ejc|||||11555
        
//      arbno (remove p_aba special stack entry)
//      no parameters (dummy pattern)
//	align	2
//	nop
        //b |p_abb|ent||||entry point|11561
        } /* p_aba */
        

        void p_abb() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|3,pmhbs|8,wb||restore history stack base ptr|11562
        v.pmhbs= wb;				// restore history stack base ptr
        //b ||brn|6,flpop|||fail and pop dummy node ptr|11563
         C_GOTO(flpop);				// fail and pop dummy node ptr
        //b ||ejc|||||11564
        
//      arbno (check if arg matched null string)
//      no parameters (dummy pattern)
//	align	2
//	db	bl_p0
        //b |p_abc|ent|2,bl_p0|||p0blk|11570
        } /* p_abb */
        

        void p_abc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||mov|7,xt|3,pmhbs||keep p_abb stack base|11571
        xt= v.pmhbs;				// keep p_abb stack base
        //b ||mov|8,wa|13,num03(xt)||load initial cursor|11572
        wa= *((word *)(CFP_B*NUM03 + xt));				// load initial cursor
        //b ||mov|3,pmhbs|13,num01(xt)||restore outer stack base ptr|11573
        v.pmhbs= *((word *)(CFP_B*NUM01 + xt));				// restore outer stack base ptr
        //b ||beq|7,xt|7,xs|6,pabc1|jump if no history stack entries|11574
        if ((xt-xs) == 0) C_GOTO(pabc1);				// jump if no history stack entries
        //b ||mov|11,-(xs)|7,xt||else save inner pmhbs entry|11575
        C_PUSH(xt);				// else save inner pmhbs entry
        //b ||mov|11,-(xs)|21,=ndabd||stack ptr to special node ndabd|11576
        C_PUSH((word)(&c.ndabd));				// stack ptr to special node ndabd
        //b ||brn|6,pabc2|||merge|11577
         C_GOTO(pabc2);				// merge
//      optimise case of no extra entries on stack from arbno arg
// pabc1:
        //b |pabc1|add|7,xs|19,*num04||remove ndabb entry and cursor|11581
        } /* p_abc */
        

        void pabc1() {
        xs += CFP_B*NUM04;				// remove ndabb entry and cursor
//      merge to check for matching of null string
// pabc2:
        //b |pabc2|bne|8,wa|8,wb|6,succp|allow further attempt if non-null|11585
        C_GOTO(pabc2);
        } /* pabc1 */
        

        void pabc2() {
        if ((wa-wb) != 0) C_GOTO(succp);				// allow further attempt if non-null
        //b ||mov|7,xr|13,pthen(xr)||bypass alternative node so as to ...|11586
        xr= *((word *)(CFP_B*PTHEN + xr));				// bypass alternative node so as to ...
        //b ||brn|6,succp|||... refuse further match attempts|11587
         C_GOTO(succp);				// ... refuse further match attempts
        //b ||ejc|||||11588
        
//      arbno (try for alternatives in arbno argument)
//      no parameters (dummy pattern)
//	align	2
//	nop
        //b |p_abd|ent||||entry point|11594
        } /* pabc2 */
        

        void p_abd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|3,pmhbs|8,wb||restore inner stack base ptr|11595
        v.pmhbs= wb;				// restore inner stack base ptr
        //b ||brn|6,failp|||and fail|11596
         C_GOTO(failp);				// and fail
        //b ||ejc|||||11597
        
//      abort
//      no parameters
//	align	2
//	db	bl_p0
        //b |p_abo|ent|2,bl_p0|||p0blk|11603
        } /* p_abd */
        

        void p_abo() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||brn|6,exfal|||signal statement failure|11604
         C_GOTO(exfal);				// signal statement failure
        //b ||ejc|||||11605
        
//      alternation
//      parm1                 alternative node
//	align	2
//	db	bl_p1
        //b |p_alt|ent|2,bl_p1|||p1blk|11611
        } /* p_abo */
        

        void p_alt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||mov|11,-(xs)|8,wb||stack cursor|11612
        C_PUSH(wb);				// stack cursor
        //b ||mov|11,-(xs)|13,parm1(xr)||stack pointer to alternative|11613
        C_PUSH(*((word *)(CFP_B*PARM1 + xr)));				// stack pointer to alternative
        //b ||chk||||check for stack overflow|11614
        if(xs<v.lowspmin) { C_GOTO(sec06); } /* stack overflow check */				// check for stack overflow
        //b ||brn|6,succp|||if all ok, then succeed|11615
         C_GOTO(succp);				// if all ok, then succeed
        //b ||ejc|||||11616
        
//      any (one character argument) (1-char string also)
//      parm1                 character argument
//	align	2
//	db	bl_p1
        //b |p_ans|ent|2,bl_p1|||p1blk|11622
        } /* p_alt */
        

        void p_ans() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||beq|8,wb|3,pmssl|6,failp|fail if no chars left|11623
        if ((wb-v.pmssl) == 0) C_GOTO(failp);				// fail if no chars left
        //b ||mov|7,xl|3,r_pms||else point to subject string|11624
        xl= v.r_pms;				// else point to subject string
        //b ||plc|7,xl|8,wb||point to current character|11625
        xl_it.chp += CFP_F + wb;				// point to current character
        //b ||lch|8,wa|9,(xl)||load current character|11626
        wa = *(xl_it.chp);				// load current character
        //b ||bne|8,wa|13,parm1(xr)|6,failp|fail if no match|11627
        if ((wa-*((word *)(CFP_B*PARM1 + xr))) != 0) C_GOTO(failp);				// fail if no match
        //b ||icv|8,wb|||else bump cursor|11628
        (wb)++;				// else bump cursor
        //b ||brn|6,succp|||and succeed|11629
         C_GOTO(succp);				// and succeed
        //b ||ejc|||||11630
        
//      any (multi-character argument case)
//      parm1                 pointer to ctblk
//      parm2                 bit mask to select bit in ctblk
//	align	2
//	db	bl_p2
        //b |p_any|ent|2,bl_p2|||p2blk|11637
        } /* p_ans */
        

        void p_any() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p2blk
//      expression argument case merges here
// pany1:
        //b |pany1|beq|8,wb|3,pmssl|6,failp|fail if no characters left|11641
        C_GOTO(pany1);
        } /* p_any */
        

        void pany1() {
        if ((wb-v.pmssl) == 0) C_GOTO(failp);				// fail if no characters left
        //b ||mov|7,xl|3,r_pms||else point to subject string|11642
        xl= v.r_pms;				// else point to subject string
        //b ||plc|7,xl|8,wb||get char ptr to current character|11643
        xl_it.chp += CFP_F + wb;				// get char ptr to current character
        //b ||lch|8,wa|9,(xl)||load current character|11644
        wa = *(xl_it.chp);				// load current character
        //b ||mov|7,xl|13,parm1(xr)||point to ctblk|11645
        xl= *((word *)(CFP_B*PARM1 + xr));				// point to ctblk
        //b ||wtb|8,wa|||change to byte offset|11646
        wa <<= LOG_CFP_B;				// change to byte offset
        //b ||add|7,xl|8,wa||point to entry in ctblk|11647
        xl += wa;				// point to entry in ctblk
        //b ||mov|8,wa|13,ctchs(xl)||load word from ctblk|11648
        wa= *((word *)(CFP_B*CTCHS + xl));				// load word from ctblk
        //b ||anb|8,wa|13,parm2(xr)||and with selected bit|11649
        wa &= *((word *)(CFP_B*PARM2 + xr));				// and with selected bit
        //b ||zrb|8,wa|6,failp||fail if no match|11650
        if (!(wa)) C_GOTO(failp);				// fail if no match
        //b ||icv|8,wb|||else bump cursor|11651
        (wb)++;				// else bump cursor
        //b ||brn|6,succp|||and succeed|11652
         C_GOTO(succp);				// and succeed
        //b ||ejc|||||11653
        
//      any (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        //b |p_ayd|ent|2,bl_p1|||p1blk|11659
        } /* pany1 */
        

        void p_ayd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||ppm|6,pany1|||merge multi-char case if ok|11663
        C_JSR_3(evals,(C_ERR(43)),C_GOTO(failp),C_GOTO(pany1));				// merge multi-char case if ok
        //b ||ejc|||||11664
        
//      p_arb                 initial arb match
//      no parameters
//      the p_arb node is part of a compound pattern structure
//      for an arb pattern (see description of compound patterns)
//	align	2
//	db	bl_p0
        //b |p_arb|ent|2,bl_p0|||p0blk|11673
        C_GOTO(p_arb);
        } /* p_ayd */
        

        void p_arb() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||mov|7,xr|13,pthen(xr)||load successor pointer|11674
        xr= *((word *)(CFP_B*PTHEN + xr));				// load successor pointer
        //b ||mov|11,-(xs)|8,wb||stack dummy cursor|11675
        C_PUSH(wb);				// stack dummy cursor
        //b ||mov|11,-(xs)|7,xr||stack successor pointer|11676
        C_PUSH(xr);				// stack successor pointer
        //b ||mov|11,-(xs)|8,wb||stack cursor|11677
        C_PUSH(wb);				// stack cursor
        //b ||mov|11,-(xs)|21,=ndarc||stack ptr to special node ndarc|11678
        C_PUSH((word)(&c.ndarc));				// stack ptr to special node ndarc
        //b ||bri|9,(xr)|||execute next node matching null|11679
        w0 = xr_it.wp[0];				// execute next node matching null
        C_GOTO(w0_it.callp);
        //b ||ejc|||||11680
        
//      p_arc                 extend arb match
//      no parameters (dummy pattern)
//	align	2
//	nop
        //b |p_arc|ent||||entry point|11686
        } /* p_arb */
        

        void p_arc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||beq|8,wb|3,pmssl|6,flpop|fail and pop stack to successor|11687
        if ((wb-v.pmssl) == 0) C_GOTO(flpop);				// fail and pop stack to successor
        //b ||icv|8,wb|||else bump cursor|11688
        (wb)++;				// else bump cursor
        //b ||mov|11,-(xs)|8,wb||stack updated cursor|11689
        C_PUSH(wb);				// stack updated cursor
        //b ||mov|11,-(xs)|7,xr||restack pointer to ndarc node|11690
        C_PUSH(xr);				// restack pointer to ndarc node
        //b ||mov|7,xr|13,num02(xs)||load successor pointer|11691
        xr= *((word *)(CFP_B*NUM02 + xs));				// load successor pointer
        //b ||bri|9,(xr)|||off to reexecute successor node|11692
        w0 = xr_it.wp[0];				// off to reexecute successor node
        C_GOTO(w0_it.callp);
        //b ||ejc|||||11693
        
//      bal
//      no parameters
//      the p_bal node is part of the compound structure built
//      for bal (see section on compound patterns).
//	align	2
//	db	bl_p0
        //b |p_bal|ent|2,bl_p0|||p0blk|11702
        } /* p_arc */
        

        void p_bal() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||zer|8,wc|||zero parentheses level counter|11703
        wc=0;				// zero parentheses level counter
        //b ||mov|7,xl|3,r_pms||point to subject string|11704
        xl= v.r_pms;				// point to subject string
        //b ||plc|7,xl|8,wb||point to current character|11705
        xl_it.chp += CFP_F + wb;				// point to current character
        //b ||brn|6,pbal2|||jump into scan loop|11706
         C_GOTO(pbal2);				// jump into scan loop
//      loop to scan out characters
// pbal1:
        //b |pbal1|lch|8,wa|10,(xl)+||load next character, bump pointer|11710
        } /* p_bal */
        

        void pbal1() {
        wa = *(xl_it.chp++);				// load next character, bump pointer
        //b ||icv|8,wb|||push cursor for character|11711
        (wb)++;				// push cursor for character
        //b ||beq|8,wa|18,=ch_pp|6,pbal3|jump if left paren|11712
        if ((wa-CH_PP) == 0) C_GOTO(pbal3);				// jump if left paren
        //b ||beq|8,wa|18,=ch_rp|6,pbal4|jump if right paren|11713
        if ((wa-CH_RP) == 0) C_GOTO(pbal4);				// jump if right paren
        //b ||bze|8,wc|6,pbal5||else succeed if at outer level|11714
        if ( !( wc) ) C_GOTO(pbal5);				// else succeed if at outer level
//      here after processing one character
// pbal2:
        //b |pbal2|bne|8,wb|3,pmssl|6,pbal1|loop back unless end of string|11718
        C_GOTO(pbal2);
        } /* pbal1 */
        

        void pbal2() {
        if ((wb-v.pmssl) != 0) C_GOTO(pbal1);				// loop back unless end of string
        //b ||brn|6,failp|||in which case, fail|11719
         C_GOTO(failp);				// in which case, fail
//      here on left paren
// pbal3:
        //b |pbal3|icv|8,wc|||bump paren level|11723
        } /* pbal2 */
        

        void pbal3() {
        (wc)++;				// bump paren level
        //b ||brn|6,pbal2|||loop back to check end of string|11724
         C_GOTO(pbal2);				// loop back to check end of string
//      here for right paren
// pbal4:
        //b |pbal4|bze|8,wc|6,failp||fail if no matching left paren|11728
        } /* pbal3 */
        

        void pbal4() {
        if ( !( wc) ) C_GOTO(failp);				// fail if no matching left paren
        //b ||dcv|8,wc|||else decrement level counter|11729
        (wc)--;				// else decrement level counter
        //b ||bnz|8,wc|6,pbal2||loop back if not at outer level|11730
        if (wc) C_GOTO(pbal2);				// loop back if not at outer level
//      here after successfully scanning a balanced string
// pbal5:
        //b |pbal5|mov|11,-(xs)|8,wb||stack cursor|11734
        C_GOTO(pbal5);
        } /* pbal4 */
        

        void pbal5() {
        C_PUSH(wb);				// stack cursor
        //b ||mov|11,-(xs)|7,xr||stack ptr to bal node for extend|11735
        C_PUSH(xr);				// stack ptr to bal node for extend
        //b ||brn|6,succp|||and succeed|11736
         C_GOTO(succp);				// and succeed
        //b ||ejc|||||11737
        
//      break (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        //b |p_bkd|ent|2,bl_p1|||p1blk|11743
        } /* pbal5 */
        

        void p_bkd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||ppm|6,pbrk1|||merge with multi-char case if ok|11747
        C_JSR_3(evals,(C_ERR(44)),C_GOTO(failp),C_GOTO(pbrk1));				// merge with multi-char case if ok
        //b ||ejc|||||11748
        
//      break (one character argument)
//      parm1                 character argument
//	align	2
//	db	bl_p1
        //b |p_bks|ent|2,bl_p1|||p1blk|11754
        C_GOTO(p_bks);
        } /* p_bkd */
        

        void p_bks() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||mov|8,wc|3,pmssl||get subject string length|11755
        wc= v.pmssl;				// get subject string length
        //b ||sub|8,wc|8,wb||get number of characters left|11756
        wc -= wb;				// get number of characters left
        //b ||bze|8,wc|6,failp||fail if no characters left|11757
        if ( !( wc) ) C_GOTO(failp);				// fail if no characters left
        //b ||lct|8,wc|8,wc||set counter for chars left|11758
        wc= wc;				// set counter for chars left
        //b ||mov|7,xl|3,r_pms||point to subject string|11759
        xl= v.r_pms;				// point to subject string
        //b ||plc|7,xl|8,wb||point to current character|11760
        xl_it.chp += CFP_F + wb;				// point to current character
//      loop to scan till break character found
// pbks1:
        //b |pbks1|lch|8,wa|10,(xl)+||load next char, bump pointer|11764
        C_GOTO(pbks1);
        } /* p_bks */
        

        void pbks1() {
        wa = *(xl_it.chp++);				// load next char, bump pointer
        //b ||beq|8,wa|13,parm1(xr)|6,succp|succeed if break character found|11765
        if ((wa-*((word *)(CFP_B*PARM1 + xr))) == 0) C_GOTO(succp);				// succeed if break character found
        //b ||icv|8,wb|||else push cursor|11766
        (wb)++;				// else push cursor
        //b ||bct|8,wc|6,pbks1||loop back if more to go|11767
        if ((--wc))  C_GOTO(pbks1);				// loop back if more to go
        //b ||brn|6,failp|||fail if end of string, no break chr|11768
         C_GOTO(failp);				// fail if end of string, no break chr
        //b ||ejc|||||11769
        
//      break (multi-character argument)
//      parm1                 pointer to ctblk
//      parm2                 bit mask to select bit column
//	align	2
//	db	bl_p2
        //b |p_brk|ent|2,bl_p2|||p2blk|11776
        } /* pbks1 */
        

        void p_brk() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p2blk
//      expression argument merges here
// pbrk1:
        //b |pbrk1|mov|8,wc|3,pmssl||load subject string length|11780
        C_GOTO(pbrk1);
        } /* p_brk */
        

        void pbrk1() {
        wc= v.pmssl;				// load subject string length
        //b ||sub|8,wc|8,wb||get number of characters left|11781
        wc -= wb;				// get number of characters left
        //b ||bze|8,wc|6,failp||fail if no characters left|11782
        if ( !( wc) ) C_GOTO(failp);				// fail if no characters left
        //b ||lct|8,wc|8,wc||set counter for characters left|11783
        wc= wc;				// set counter for characters left
        //b ||mov|7,xl|3,r_pms||else point to subject string|11784
        xl= v.r_pms;				// else point to subject string
        //b ||plc|7,xl|8,wb||point to current character|11785
        xl_it.chp += CFP_F + wb;				// point to current character
        //b ||mov|3,psave|7,xr||save node pointer|11786
        v.psave= xr;				// save node pointer
//      loop to search for break character
// pbrk2:
        //b |pbrk2|lch|8,wa|10,(xl)+||load next char, bump pointer|11790
        C_GOTO(pbrk2);
        } /* pbrk1 */
        

        void pbrk2() {
        wa = *(xl_it.chp++);				// load next char, bump pointer
        //b ||mov|7,xr|13,parm1(xr)||load pointer to ctblk|11791
        xr= *((word *)(CFP_B*PARM1 + xr));				// load pointer to ctblk
        //b ||wtb|8,wa|||convert to byte offset|11792
        wa <<= LOG_CFP_B;				// convert to byte offset
        //b ||add|7,xr|8,wa||point to ctblk entry|11793
        xr += wa;				// point to ctblk entry
        //b ||mov|8,wa|13,ctchs(xr)||load ctblk word|11794
        wa= *((word *)(CFP_B*CTCHS + xr));				// load ctblk word
        //b ||mov|7,xr|3,psave||restore node pointer|11795
        xr= v.psave;				// restore node pointer
        //b ||anb|8,wa|13,parm2(xr)||and with selected bit|11796
        wa &= *((word *)(CFP_B*PARM2 + xr));				// and with selected bit
        //b ||nzb|8,wa|6,succp||succeed if break character found|11797
        if (wa) C_GOTO(succp);				// succeed if break character found
        //b ||icv|8,wb|||else push cursor|11798
        (wb)++;				// else push cursor
        //b ||bct|8,wc|6,pbrk2||loop back unless end of string|11799
        if ((--wc))  C_GOTO(pbrk2);				// loop back unless end of string
        //b ||brn|6,failp|||fail if end of string, no break chr|11800
         C_GOTO(failp);				// fail if end of string, no break chr
        //b ||ejc|||||11801
        
//      breakx (extension)
//      this is the entry which causes an extension of a breakx
//      match when failure occurs. see section on compound
//      patterns for full details of breakx matching.
//      no parameters
//	align	2
//	db	bl_p0
        //b |p_bkx|ent|2,bl_p0|||p0blk|11811
        } /* pbrk2 */
        

        void p_bkx() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||icv|8,wb|||step cursor past previous break chr|11812
        (wb)++;				// step cursor past previous break chr
        //b ||brn|6,succp|||succeed to rematch break|11813
         C_GOTO(succp);				// succeed to rematch break
        //b ||ejc|||||11814
        
//      breakx (expression argument)
//      see section on compound patterns for full structure of
//      breakx pattern. the actual character matching uses a
//      break node. however, the entry for the expression
//      argument case is separated to get proper error messages.
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        //b |p_bxd|ent|2,bl_p1|||p1blk|11825
        } /* p_bkx */
        

        void p_bxd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||ppm|6,pbrk1|||merge with break if all ok|11829
        C_JSR_3(evals,(C_ERR(45)),C_GOTO(failp),C_GOTO(pbrk1));				// merge with break if all ok
        //b ||ejc|||||11830
        
//      cursor assignment
//      parm1                 name base
//      parm2                 name offset
//	align	2
//	db	bl_p2
        //b |p_cas|ent|2,bl_p2|||p2blk|11837
        C_GOTO(p_cas);
        } /* p_bxd */
        

        void p_cas() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p2blk
        //b ||mov|11,-(xs)|7,xr||save node pointer|11838
        C_PUSH(xr);				// save node pointer
        //b ||mov|11,-(xs)|8,wb||save cursor|11839
        C_PUSH(wb);				// save cursor
        //b ||mov|7,xl|13,parm1(xr)||load name base|11840
        xl= *((word *)(CFP_B*PARM1 + xr));				// load name base
        //b ||mti|8,wb|||load cursor as integer|11841
        ia = (word)(wb);				// load cursor as integer
        //b ||mov|8,wb|13,parm2(xr)||load name offset|11842
        wb= *((word *)(CFP_B*PARM2 + xr));				// load name offset
        //b ||jsr|6,icbld|||get icblk for cursor value|11843
        C_JSR(icbld);				// get icblk for cursor value
        //b ||mov|8,wa|8,wb||move name offset|11844
        wa= wb;				// move name offset
        //b ||mov|8,wb|7,xr||move value to assign|11845
        wb= xr;				// move value to assign
        //b ||ppm|6,flpop|||fail on assignment failure|11847
        C_JSR_1(asinp,C_GOTO(flpop));				// fail on assignment failure
        //b ||mov|8,wb|10,(xs)+||else restore cursor|11848
        wb= C_POP();				// else restore cursor
        //b ||mov|7,xr|10,(xs)+||restore node pointer|11849
        xr= C_POP();				// restore node pointer
        //b ||brn|6,succp|||and succeed matching null|11850
         C_GOTO(succp);				// and succeed matching null
        //b ||ejc|||||11851
        
//      expression node (p_exa, initial entry)
//      see compound patterns description for the structure and
//      algorithms for handling expression nodes.
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        //b |p_exa|ent|2,bl_p1|||p1blk|11860
        } /* p_cas */
        

        void p_exa() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||ppm|6,failp|||fail if evaluation fails|11862
        C_JSR_1(evalp,C_GOTO(failp));				// fail if evaluation fails
        //b ||blo|8,wa|22,=p_aaa|6,pexa1|jump if result is not a pattern|11863
        if ((wa-(word)(p_aaa)) < 0) C_GOTO(pexa1);				// jump if result is not a pattern
//      here if result of expression is a pattern
        //b ||mov|11,-(xs)|8,wb||stack dummy cursor|11867
        C_PUSH(wb);				// stack dummy cursor
        //b ||mov|11,-(xs)|7,xr||stack ptr to p_exa node|11868
        C_PUSH(xr);				// stack ptr to p_exa node
        //b ||mov|11,-(xs)|3,pmhbs||stack history stack base ptr|11869
        C_PUSH(v.pmhbs);				// stack history stack base ptr
        //b ||mov|11,-(xs)|21,=ndexb||stack ptr to special node ndexb|11870
        C_PUSH((word)(&c.ndexb));				// stack ptr to special node ndexb
        //b ||mov|3,pmhbs|7,xs||store new stack base pointer|11871
        v.pmhbs= xs;				// store new stack base pointer
        //b ||mov|7,xr|7,xl||copy node pointer|11872
        xr= xl;				// copy node pointer
        //b ||bri|9,(xr)|||match first node in expression pat|11873
        w0 = xr_it.wp[0];				// match first node in expression pat
        C_GOTO(w0_it.callp);
//      here if result of expression is not a pattern
// pexa1:
        //b |pexa1|beq|8,wa|22,=b_scl|6,pexa2|jump if it is already a string|11877
        } /* p_exa */
        

        void pexa1() {
        if ((wa-(word)(b_scl)) == 0) C_GOTO(pexa2);				// jump if it is already a string
        //b ||mov|11,-(xs)|7,xl||else stack result|11878
        C_PUSH(xl);				// else stack result
        //b ||mov|7,xl|7,xr||save node pointer|11879
        xl= xr;				// save node pointer
        //b ||err|1,046|26,expression does not evaluate to pattern|||11881
        extern void _l0384();
        C_JMS(gtstg,P_PRC_GTSTG,_l0384);
        } /* pexa1 */
        

        void _l0384() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(46)));
        //b ||mov|8,wc|7,xr||copy string pointer|11882
        wc= xr;				// copy string pointer
        //b ||mov|7,xr|7,xl||restore node pointer|11883
        xr= xl;				// restore node pointer
        //b ||mov|7,xl|8,wc||copy string pointer again|11884
        xl= wc;				// copy string pointer again
//      merge here with string pointer in xl
// pexa2:
        //b |pexa2|bze|13,sclen(xl)|6,succp||just succeed if null string|11888
        C_GOTO(pexa2);
        } /* _l0384 */
        

        void pexa2() {
        if ( !( *((word *)(CFP_B*SCLEN + xl))) ) C_GOTO(succp);				// just succeed if null string
        //b ||brn|6,pstr1|||else merge with string circuit|11889
         C_GOTO(pstr1);				// else merge with string circuit
        //b ||ejc|||||11890
        
//      expression node (p_exb, remove ndexb entry)
//      see compound patterns description for the structure and
//      algorithms for handling expression nodes.
//      no parameters (dummy pattern)
//	align	2
//	nop
        //b |p_exb|ent||||entry point|11899
        } /* pexa2 */
        

        void p_exb() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|3,pmhbs|8,wb||restore outer level stack pointer|11900
        v.pmhbs= wb;				// restore outer level stack pointer
        //b ||brn|6,flpop|||fail and pop p_exa node ptr|11901
         C_GOTO(flpop);				// fail and pop p_exa node ptr
        //b ||ejc|||||11902
        
//      expression node (p_exc, remove ndexc entry)
//      see compound patterns description for the structure and
//      algorithms for handling expression nodes.
//      no parameters (dummy pattern)
//	align	2
//	nop
        //b |p_exc|ent||||entry point|11911
        } /* p_exb */
        

        void p_exc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|3,pmhbs|8,wb||restore inner stack base pointer|11912
        v.pmhbs= wb;				// restore inner stack base pointer
        //b ||brn|6,failp|||and fail into expr pattern alternvs|11913
         C_GOTO(failp);				// and fail into expr pattern alternvs
        //b ||ejc|||||11914
        
//      fail
//      no parameters
//	align	2
//	db	bl_p0
        //b |p_fal|ent|2,bl_p0|||p0blk|11920
        } /* p_exc */
        

        void p_fal() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||brn|6,failp|||just signal failure|11921
         C_GOTO(failp);				// just signal failure
        //b ||ejc|||||11922
        
//      fence
//      see compound patterns section for the structure and
//      algorithm for matching this node type.
//      no parameters
//	align	2
//	db	bl_p0
        //b |p_fen|ent|2,bl_p0|||p0blk|11931
        } /* p_fal */
        

        void p_fen() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||mov|11,-(xs)|8,wb||stack dummy cursor|11932
        C_PUSH(wb);				// stack dummy cursor
        //b ||mov|11,-(xs)|21,=ndabo||stack ptr to abort node|11933
        C_PUSH((word)(&c.ndabo));				// stack ptr to abort node
        //b ||brn|6,succp|||and succeed matching null|11934
         C_GOTO(succp);				// and succeed matching null
        //b ||ejc|||||11935
        
//      fence (function)
//      see compound patterns comments at start of this section
//      for details of scheme
//      no parameters
//	align	2
//	db	bl_p0
        //b |p_fna|ent|2,bl_p0|||p0blk|11944
        } /* p_fen */
        

        void p_fna() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||mov|11,-(xs)|3,pmhbs||stack current history stack base|11945
        C_PUSH(v.pmhbs);				// stack current history stack base
        //b ||mov|11,-(xs)|21,=ndfnb||stack indir ptr to p_fnb (failure)|11946
        C_PUSH((word)(&c.ndfnb));				// stack indir ptr to p_fnb (failure)
        //b ||mov|3,pmhbs|7,xs||begin new history stack|11947
        v.pmhbs= xs;				// begin new history stack
        //b ||brn|6,succp|||succeed|11948
         C_GOTO(succp);				// succeed
        //b ||ejc|||||11949
        
//      fence (function) (reset history stack and fail)
//      no parameters (dummy pattern)
//	align	2
//	db	bl_p0
        //b |p_fnb|ent|2,bl_p0|||p0blk|11955
        } /* p_fna */
        

        void p_fnb() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||mov|3,pmhbs|8,wb||restore outer pmhbs stack base|11956
        v.pmhbs= wb;				// restore outer pmhbs stack base
        //b ||brn|6,failp|||...and fail|11957
         C_GOTO(failp);				// ...and fail
        //b ||ejc|||||11958
        
//      fence (function) (make fence trap entry on stack)
//      no parameters (dummy pattern)
//	align	2
//	db	bl_p0
        //b |p_fnc|ent|2,bl_p0|||p0blk|11964
        } /* p_fnb */
        

        void p_fnc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||mov|7,xt|3,pmhbs||get inner stack base ptr|11965
        xt= v.pmhbs;				// get inner stack base ptr
        //b ||mov|3,pmhbs|13,num01(xt)||restore outer stack base|11966
        v.pmhbs= *((word *)(CFP_B*NUM01 + xt));				// restore outer stack base
        //b ||beq|7,xt|7,xs|6,pfnc1|optimize if no alternatives|11967
        if ((xt-xs) == 0) C_GOTO(pfnc1);				// optimize if no alternatives
        //b ||mov|11,-(xs)|7,xt||else stack inner stack base|11968
        C_PUSH(xt);				// else stack inner stack base
        //b ||mov|11,-(xs)|21,=ndfnd||stack ptr to ndfnd|11969
        C_PUSH((word)(&c.ndfnd));				// stack ptr to ndfnd
        //b ||brn|6,succp|||succeed|11970
         C_GOTO(succp);				// succeed
//      here when fence function left nothing on the stack
// pfnc1:
        //b |pfnc1|add|7,xs|19,*num02||pop off p_fnb entry|11974
        } /* p_fnc */
        

        void pfnc1() {
        xs += CFP_B*NUM02;				// pop off p_fnb entry
        //b ||brn|6,succp|||succeed|11975
         C_GOTO(succp);				// succeed
        //b ||ejc|||||11976
        
//      fence (function) (skip past alternatives on failure)
//      no parameters (dummy pattern)
//	align	2
//	db	bl_p0
        //b |p_fnd|ent|2,bl_p0|||p0blk|11982
        } /* pfnc1 */
        

        void p_fnd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||mov|7,xs|8,wb||pop stack to fence() history base|11983
        xs= wb;				// pop stack to fence() history base
        //b ||brn|6,flpop|||pop base entry and fail|11984
         C_GOTO(flpop);				// pop base entry and fail
        //b ||ejc|||||11985
        
//      immediate assignment (initial entry, save current cursor)
//      see compound patterns description for details of the
//      structure and algorithm for matching this node type.
//      no parameters
//	align	2
//	db	bl_p0
        //b |p_ima|ent|2,bl_p0|||p0blk|11994
        } /* p_fnd */
        

        void p_ima() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||mov|11,-(xs)|8,wb||stack cursor|11995
        C_PUSH(wb);				// stack cursor
        //b ||mov|11,-(xs)|7,xr||stack dummy node pointer|11996
        C_PUSH(xr);				// stack dummy node pointer
        //b ||mov|11,-(xs)|3,pmhbs||stack old stack base pointer|11997
        C_PUSH(v.pmhbs);				// stack old stack base pointer
        //b ||mov|11,-(xs)|21,=ndimb||stack ptr to special node ndimb|11998
        C_PUSH((word)(&c.ndimb));				// stack ptr to special node ndimb
        //b ||mov|3,pmhbs|7,xs||store new stack base pointer|11999
        v.pmhbs= xs;				// store new stack base pointer
        //b ||brn|6,succp|||and succeed|12000
         C_GOTO(succp);				// and succeed
        //b ||ejc|||||12001
        
//      immediate assignment (remove cursor mark entry)
//      see compound patterns description for details of the
//      structure and algorithms for matching this node type.
//      no parameters (dummy pattern)
//	align	2
//	nop
        //b |p_imb|ent||||entry point|12010
        } /* p_ima */
        

        void p_imb() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|3,pmhbs|8,wb||restore history stack base ptr|12011
        v.pmhbs= wb;				// restore history stack base ptr
        //b ||brn|6,flpop|||fail and pop dummy node ptr|12012
         C_GOTO(flpop);				// fail and pop dummy node ptr
        //b ||ejc|||||12013
        
//      immediate assignment (perform actual assignment)
//      see compound patterns description for details of the
//      structure and algorithms for matching this node type.
//      parm1                 name base of variable
//      parm2                 name offset of variable
//	align	2
//	db	bl_p2
        //b |p_imc|ent|2,bl_p2|||p2blk|12023
        } /* p_imb */
        

        void p_imc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p2blk
        //b ||mov|7,xt|3,pmhbs||load pointer to p_imb entry|12024
        xt= v.pmhbs;				// load pointer to p_imb entry
        //b ||mov|8,wa|8,wb||copy final cursor|12025
        wa= wb;				// copy final cursor
        //b ||mov|8,wb|13,num03(xt)||load initial cursor|12026
        wb= *((word *)(CFP_B*NUM03 + xt));				// load initial cursor
        //b ||mov|3,pmhbs|13,num01(xt)||restore outer stack base pointer|12027
        v.pmhbs= *((word *)(CFP_B*NUM01 + xt));				// restore outer stack base pointer
        //b ||beq|7,xt|7,xs|6,pimc1|jump if no history stack entries|12028
        if ((xt-xs) == 0) C_GOTO(pimc1);				// jump if no history stack entries
        //b ||mov|11,-(xs)|7,xt||else save inner pmhbs pointer|12029
        C_PUSH(xt);				// else save inner pmhbs pointer
        //b ||mov|11,-(xs)|21,=ndimd||and a ptr to special node ndimd|12030
        C_PUSH((word)(&c.ndimd));				// and a ptr to special node ndimd
        //b ||brn|6,pimc2|||merge|12031
         C_GOTO(pimc2);				// merge
//      here if no entries made on history stack
// pimc1:
        //b |pimc1|add|7,xs|19,*num04||remove ndimb entry and cursor|12035
        } /* p_imc */
        

        void pimc1() {
        xs += CFP_B*NUM04;				// remove ndimb entry and cursor
//      merge here to perform assignment
// pimc2:
        //b |pimc2|mov|11,-(xs)|8,wa||save current (final) cursor|12039
        C_GOTO(pimc2);
        } /* pimc1 */
        

        void pimc2() {
        C_PUSH(wa);				// save current (final) cursor
        //b ||mov|11,-(xs)|7,xr||save current node pointer|12040
        C_PUSH(xr);				// save current node pointer
        //b ||mov|7,xl|3,r_pms||point to subject string|12041
        xl= v.r_pms;				// point to subject string
        //b ||sub|8,wa|8,wb||compute substring length|12042
        wa -= wb;				// compute substring length
        //b ||jsr|6,sbstr|||build substring|12043
        C_JSR(sbstr);				// build substring
        //b ||mov|8,wb|7,xr||move result|12044
        wb= xr;				// move result
        //b ||mov|7,xr|9,(xs)||reload node pointer|12045
        xr= *(xs_it.wp);				// reload node pointer
        //b ||mov|7,xl|13,parm1(xr)||load name base|12046
        xl= *((word *)(CFP_B*PARM1 + xr));				// load name base
        //b ||mov|8,wa|13,parm2(xr)||load name offset|12047
        wa= *((word *)(CFP_B*PARM2 + xr));				// load name offset
        //b ||ppm|6,flpop|||fail if assignment fails|12049
        C_JSR_1(asinp,C_GOTO(flpop));				// fail if assignment fails
        //b ||mov|7,xr|10,(xs)+||else restore node pointer|12050
        xr= C_POP();				// else restore node pointer
        //b ||mov|8,wb|10,(xs)+||restore cursor|12051
        wb= C_POP();				// restore cursor
        //b ||brn|6,succp|||and succeed|12052
         C_GOTO(succp);				// and succeed
        //b ||ejc|||||12053
        
//      immediate assignment (remove ndimd entry on failure)
//      see compound patterns description for details of the
//      structure and algorithms for matching this node type.
//      no parameters (dummy pattern)
//	align	2
//	nop
        //b |p_imd|ent||||entry point|12062
        } /* pimc2 */
        

        void p_imd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|3,pmhbs|8,wb||restore inner stack base pointer|12063
        v.pmhbs= wb;				// restore inner stack base pointer
        //b ||brn|6,failp|||and fail|12064
         C_GOTO(failp);				// and fail
        //b ||ejc|||||12065
        
//      len (integer argument)
//      parm1                 integer argument
//	align	2
//	db	bl_p1
        //b |p_len|ent|2,bl_p1|||p1blk|12071
        } /* p_imd */
        

        void p_len() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
//      expression argument case merges here
// plen1:
        //b |plen1|add|8,wb|13,parm1(xr)||push cursor indicated amount|12075
        C_GOTO(plen1);
        } /* p_len */
        

        void plen1() {
        wb += *((word *)(CFP_B*PARM1 + xr));				// push cursor indicated amount
        //b ||ble|8,wb|3,pmssl|6,succp|succeed if not off end|12076
        if ((wb-v.pmssl) <= 0) C_GOTO(succp);				// succeed if not off end
        //b ||brn|6,failp|||else fail|12077
         C_GOTO(failp);				// else fail
        //b ||ejc|||||12078
        
//      len (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        //b |p_lnd|ent|2,bl_p1|||p1blk|12084
        } /* plen1 */
        

        void p_lnd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||ppm|6,plen1|||merge with normal circuit if ok|12089
        C_JSR_4(evali,(C_ERR(47)),(C_ERR(48)),C_GOTO(failp),C_GOTO(plen1));				// merge with normal circuit if ok
        //b ||ejc|||||12090
        
//      notany (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        //b |p_nad|ent|2,bl_p1|||p1blk|12096
        C_GOTO(p_nad);
        } /* p_lnd */
        

        void p_nad() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||ppm|6,pnay1|||merge with multi-char case if ok|12100
        C_JSR_3(evals,(C_ERR(49)),C_GOTO(failp),C_GOTO(pnay1));				// merge with multi-char case if ok
        //b ||ejc|||||12101
        
//      notany (one character argument)
//      parm1                 character argument
//	align	2
//	db	bl_p1
        //b |p_nas|ent|2,bl_p1|||entry point|12107
        C_GOTO(p_nas);
        } /* p_nad */
        

        void p_nas() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||beq|8,wb|3,pmssl|6,failp|fail if no chars left|12108
        if ((wb-v.pmssl) == 0) C_GOTO(failp);				// fail if no chars left
        //b ||mov|7,xl|3,r_pms||else point to subject string|12109
        xl= v.r_pms;				// else point to subject string
        //b ||plc|7,xl|8,wb||point to current character in strin|12110
        xl_it.chp += CFP_F + wb;				// point to current character in strin
        //b ||lch|8,wa|9,(xl)||load current character|12111
        wa = *(xl_it.chp);				// load current character
        //b ||beq|8,wa|13,parm1(xr)|6,failp|fail if match|12112
        if ((wa-*((word *)(CFP_B*PARM1 + xr))) == 0) C_GOTO(failp);				// fail if match
        //b ||icv|8,wb|||else bump cursor|12113
        (wb)++;				// else bump cursor
        //b ||brn|6,succp|||and succeed|12114
         C_GOTO(succp);				// and succeed
        //b ||ejc|||||12115
        
//      notany (multi-character string argument)
//      parm1                 pointer to ctblk
//      parm2                 bit mask to select bit column
//	align	2
//	db	bl_p2
        //b |p_nay|ent|2,bl_p2|||p2blk|12122
        } /* p_nas */
        

        void p_nay() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p2blk
//      expression argument case merges here
// pnay1:
        //b |pnay1|beq|8,wb|3,pmssl|6,failp|fail if no characters left|12126
        C_GOTO(pnay1);
        } /* p_nay */
        

        void pnay1() {
        if ((wb-v.pmssl) == 0) C_GOTO(failp);				// fail if no characters left
        //b ||mov|7,xl|3,r_pms||else point to subject string|12127
        xl= v.r_pms;				// else point to subject string
        //b ||plc|7,xl|8,wb||point to current character|12128
        xl_it.chp += CFP_F + wb;				// point to current character
        //b ||lch|8,wa|9,(xl)||load current character|12129
        wa = *(xl_it.chp);				// load current character
        //b ||wtb|8,wa|||convert to byte offset|12130
        wa <<= LOG_CFP_B;				// convert to byte offset
        //b ||mov|7,xl|13,parm1(xr)||load pointer to ctblk|12131
        xl= *((word *)(CFP_B*PARM1 + xr));				// load pointer to ctblk
        //b ||add|7,xl|8,wa||point to entry in ctblk|12132
        xl += wa;				// point to entry in ctblk
        //b ||mov|8,wa|13,ctchs(xl)||load entry from ctblk|12133
        wa= *((word *)(CFP_B*CTCHS + xl));				// load entry from ctblk
        //b ||anb|8,wa|13,parm2(xr)||and with selected bit|12134
        wa &= *((word *)(CFP_B*PARM2 + xr));				// and with selected bit
        //b ||nzb|8,wa|6,failp||fail if character is matched|12135
        if (wa) C_GOTO(failp);				// fail if character is matched
        //b ||icv|8,wb|||else bump cursor|12136
        (wb)++;				// else bump cursor
        //b ||brn|6,succp|||and succeed|12137
         C_GOTO(succp);				// and succeed
        //b ||ejc|||||12138
        
//      end of pattern match
//      this routine is entered on successful completion.
//      see description of expression patterns in compound
//      pattern section for handling of recursion in matching.
//      this pattern also results from an attempt to convert the
//      null string to a pattern via convert()
//      no parameters (dummy pattern)
//	align	2
//	db	bl_p0
        //b |p_nth|ent|2,bl_p0|||p0blk (dummy)|12151
        } /* pnay1 */
        

        void p_nth() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk (dummy)
        //b ||mov|7,xt|3,pmhbs||load pointer to base of stack|12152
        xt= v.pmhbs;				// load pointer to base of stack
        //b ||mov|8,wa|13,num01(xt)||load saved pmhbs (or pattern type)|12153
        wa= *((word *)(CFP_B*NUM01 + xt));				// load saved pmhbs (or pattern type)
        //b ||ble|8,wa|18,=num02|6,pnth2|jump if outer level (pattern type)|12154
        if ((wa-NUM02) <= 0) C_GOTO(pnth2);				// jump if outer level (pattern type)
//      here we are at the end of matching an expression pattern
        //b ||mov|3,pmhbs|8,wa||restore outer stack base pointer|12158
        v.pmhbs= wa;				// restore outer stack base pointer
        //b ||mov|7,xr|13,num02(xt)||restore pointer to p_exa node|12159
        xr= *((word *)(CFP_B*NUM02 + xt));				// restore pointer to p_exa node
        //b ||beq|7,xt|7,xs|6,pnth1|jump if no history stack entries|12160
        if ((xt-xs) == 0) C_GOTO(pnth1);				// jump if no history stack entries
        //b ||mov|11,-(xs)|7,xt||else stack inner stack base ptr|12161
        C_PUSH(xt);				// else stack inner stack base ptr
        //b ||mov|11,-(xs)|21,=ndexc||stack ptr to special node ndexc|12162
        C_PUSH((word)(&c.ndexc));				// stack ptr to special node ndexc
        //b ||brn|6,succp|||and succeed|12163
         C_GOTO(succp);				// and succeed
//      here if no history stack entries during pattern
// pnth1:
        //b |pnth1|add|7,xs|19,*num04||remove p_exb entry and node ptr|12167
        } /* p_nth */
        

        void pnth1() {
        xs += CFP_B*NUM04;				// remove p_exb entry and node ptr
        //b ||brn|6,succp|||and succeed|12168
         C_GOTO(succp);				// and succeed
//      here if end of match at outer level
// pnth2:
        //b |pnth2|mov|3,pmssl|8,wb||save final cursor in safe place|12172
        } /* pnth1 */
        

        void pnth2() {
        v.pmssl= wb;				// save final cursor in safe place
        //b ||bze|3,pmdfl|6,pnth6||jump if no pattern assignments|12173
        if ( !( v.pmdfl) ) C_GOTO(pnth6);				// jump if no pattern assignments
        //b ||ejc|||||12174
        
//      end of pattern match (continued)
//      now we must perform pattern assignments. this is done by
//      scanning the history stack for matching ndpab-ndpad pairs
// pnth3:
        //b |pnth3|dca|7,xt|||point past cursor entry|12181
        C_GOTO(pnth3);
        } /* pnth2 */
        

        void pnth3() {
        xt -= CFP_B;				// point past cursor entry
        //b ||mov|8,wa|11,-(xt)||load node pointer|12182
        wa= *(--xt_it.wp);				// load node pointer
        //b ||beq|8,wa|21,=ndpad|6,pnth4|jump if ndpad entry|12183
        if ((wa-(word)(&c.ndpad)) == 0) C_GOTO(pnth4);				// jump if ndpad entry
        //b ||bne|8,wa|21,=ndpab|6,pnth5|jump if not ndpab entry|12184
        if ((wa-(word)(&c.ndpab)) != 0) C_GOTO(pnth5);				// jump if not ndpab entry
//      here for ndpab entry, stack initial cursor
//      note that there must be more entries on the stack.
        //b ||mov|11,-(xs)|13,num01(xt)||stack initial cursor|12189
        C_PUSH(*((word *)(CFP_B*NUM01 + xt)));				// stack initial cursor
        //b ||chk||||check for stack overflow|12190
        if(xs<v.lowspmin) { C_GOTO(sec06); } /* stack overflow check */				// check for stack overflow
        //b ||brn|6,pnth3|||loop back if ok|12191
         C_GOTO(pnth3);				// loop back if ok
//      here for ndpad entry. the starting cursor from the
//      matching ndpad entry is now the top stack entry.
// pnth4:
        //b |pnth4|mov|8,wa|13,num01(xt)||load final cursor|12196
        } /* pnth3 */
        

        void pnth4() {
        wa= *((word *)(CFP_B*NUM01 + xt));				// load final cursor
        //b ||mov|8,wb|9,(xs)||load initial cursor from stack|12197
        wb= *(xs_it.wp);				// load initial cursor from stack
        //b ||mov|9,(xs)|7,xt||save history stack scan ptr|12198
        *(xs_it.wp)= xt;				// save history stack scan ptr
        //b ||sub|8,wa|8,wb||compute length of string|12199
        wa -= wb;				// compute length of string
//      build substring and perform assignment
        //b ||mov|7,xl|3,r_pms||point to subject string|12203
        xl= v.r_pms;				// point to subject string
        //b ||jsr|6,sbstr|||construct substring|12204
        C_JSR(sbstr);				// construct substring
        //b ||mov|8,wb|7,xr||copy substring pointer|12205
        wb= xr;				// copy substring pointer
        //b ||mov|7,xt|9,(xs)||reload history stack scan ptr|12206
        xt= *(xs_it.wp);				// reload history stack scan ptr
        //b ||mov|7,xl|13,num02(xt)||load pointer to p_pac node with nam|12207
        xl= *((word *)(CFP_B*NUM02 + xt));				// load pointer to p_pac node with nam
        //b ||mov|8,wa|13,parm2(xl)||load name offset|12208
        wa= *((word *)(CFP_B*PARM2 + xl));				// load name offset
        //b ||mov|7,xl|13,parm1(xl)||load name base|12209
        xl= *((word *)(CFP_B*PARM1 + xl));				// load name base
        //b ||ppm|6,exfal|||match fails if name eval fails|12211
        C_JSR_1(asinp,C_GOTO(exfal));				// match fails if name eval fails
        //b ||mov|7,xt|10,(xs)+||else restore history stack ptr|12212
        xt= C_POP();				// else restore history stack ptr
        //b ||ejc|||||12213
        
//      end of pattern match (continued)
//      here check for end of entries
// pnth5:
        //b |pnth5|bne|7,xt|7,xs|6,pnth3|loop if more entries to scan|12219
        C_GOTO(pnth5);
        } /* pnth4 */
        

        void pnth5() {
        if ((xt-xs) != 0) C_GOTO(pnth3);				// loop if more entries to scan
//      here after dealing with pattern assignments
// pnth6:
        //b |pnth6|mov|7,xs|3,pmhbs||wipe out history stack|12223
        C_GOTO(pnth6);
        } /* pnth5 */
        

        void pnth6() {
        xs= v.pmhbs;				// wipe out history stack
        //b ||mov|8,wb|10,(xs)+||load initial cursor|12224
        wb= C_POP();				// load initial cursor
        //b ||mov|8,wc|10,(xs)+||load match type code|12225
        wc= C_POP();				// load match type code
        //b ||mov|8,wa|3,pmssl||load final cursor value|12226
        wa= v.pmssl;				// load final cursor value
        //b ||mov|7,xl|3,r_pms||point to subject string|12227
        xl= v.r_pms;				// point to subject string
        //b ||zer|3,r_pms|||clear subject string ptr for gbcol|12228
        v.r_pms=0;				// clear subject string ptr for gbcol
        //b ||bze|8,wc|6,pnth7||jump if call by name|12229
        if ( !( wc) ) C_GOTO(pnth7);				// jump if call by name
        //b ||beq|8,wc|18,=num02|6,pnth9|exit if statement level call|12230
        if ((wc-NUM02) == 0) C_GOTO(pnth9);				// exit if statement level call
//      here we have a call by value, build substring
        //b ||sub|8,wa|8,wb||compute length of string|12234
        wa -= wb;				// compute length of string
        //b ||jsr|6,sbstr|||build substring|12235
        C_JSR(sbstr);				// build substring
        //b ||mov|11,-(xs)|7,xr||stack result|12236
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|12237
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|12238
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      here for call by name, make stack entries for o_rpl
// pnth7:
        //b |pnth7|mov|11,-(xs)|8,wb||stack initial cursor|12242
        } /* pnth6 */
        

        void pnth7() {
        C_PUSH(wb);				// stack initial cursor
        //b ||mov|11,-(xs)|8,wa||stack final cursor|12243
        C_PUSH(wa);				// stack final cursor
//      here with xl pointing to scblk or bcblk
// pnth8:
        //b |pnth8|mov|11,-(xs)|7,xl||stack subject pointer|12252
        C_GOTO(pnth8);
        } /* pnth7 */
        

        void pnth8() {
        C_PUSH(xl);				// stack subject pointer
//      here to obey next code word
// pnth9:
        //b |pnth9|lcw|7,xr|||get next code word|12256
        C_GOTO(pnth9);
        } /* pnth8 */
        

        void pnth9() {
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|12257
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||12258
        
//      pos (integer argument)
//      parm1                 integer argument
//	align	2
//	db	bl_p1
        //b |p_pos|ent|2,bl_p1|||p1blk|12264
        } /* pnth9 */
        

        void p_pos() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
//      optimize pos if it is the first pattern element,
//      unanchored mode, cursor is zero and pos argument
//      is not beyond end of string.  force cursor position
//      and number of unanchored moves.
//      this optimization is performed invisible provided
//      the argument is either a simple integer or an
//      expression that is an untraced variable (that is,
//      it has no side effects that would be lost by short-
//      circuiting the normal logic of failing and moving the
//      unanchored starting point.)
//      pos (integer argument)
//      parm1                 integer argument
        //b ||beq|8,wb|13,parm1(xr)|6,succp|succeed if at right location|12282
        if ((wb-*((word *)(CFP_B*PARM1 + xr))) == 0) C_GOTO(succp);				// succeed if at right location
        //b ||bnz|8,wb|6,failp||don't look further if cursor not 0|12283
        if (wb) C_GOTO(failp);				// don't look further if cursor not 0
        //b ||mov|7,xt|3,pmhbs||get history stack base ptr|12284
        xt= v.pmhbs;				// get history stack base ptr
        //b ||bne|7,xr|11,-(xt)|6,failp|fail if pos is not first node|12285
        if ((xr-*(--xt_it.wp)) != 0) C_GOTO(failp);				// fail if pos is not first node
//      expression argument circuit merges here
// ppos2:
        //b |ppos2|bne|11,-(xt)|21,=nduna|6,failp|fail if not unanchored mode|12289
        C_GOTO(ppos2);
        } /* p_pos */
        

        void ppos2() {
        if ((*(--xt_it.wp)-(word)(&c.nduna)) != 0) C_GOTO(failp);				// fail if not unanchored mode
        //b ||mov|8,wb|13,parm1(xr)||get desired cursor position|12290
        wb= *((word *)(CFP_B*PARM1 + xr));				// get desired cursor position
        //b ||bgt|8,wb|3,pmssl|6,exfal|abort if off end|12291
        if ((wb-v.pmssl) > 0) C_GOTO(exfal);				// abort if off end
        //b ||mov|13,num02(xt)|8,wb||fake number of unanchored moves|12292
        *((word *)(CFP_B*NUM02 + xt))= wb;				// fake number of unanchored moves
        //b ||brn|6,succp|||continue match with adjusted cursor|12293
         C_GOTO(succp);				// continue match with adjusted cursor
        //b ||ejc|||||12294
        
//      pos (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        //b |p_psd|ent|2,bl_p1|||p1blk|12300
        } /* ppos2 */
        

        void p_psd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||ppm|6,ppos1|||process expression case|12305
        C_JSR_4(evali,(C_ERR(50)),(C_ERR(51)),C_GOTO(failp),C_GOTO(ppos1));				// process expression case
// ppos1:
        //b |ppos1|beq|8,wb|13,parm1(xr)|6,succp|succeed if at right location|12307
        C_GOTO(ppos1);
        } /* p_psd */
        

        void ppos1() {
        if ((wb-*((word *)(CFP_B*PARM1 + xr))) == 0) C_GOTO(succp);				// succeed if at right location
        //b ||bnz|8,wb|6,failp||don't look further if cursor not 0|12308
        if (wb) C_GOTO(failp);				// don't look further if cursor not 0
        //b ||bnz|3,evlif|6,failp||fail if complex argument|12309
        if (v.evlif) C_GOTO(failp);				// fail if complex argument
        //b ||mov|7,xt|3,pmhbs||get history stack base ptr|12310
        xt= v.pmhbs;				// get history stack base ptr
        //b ||mov|8,wa|3,evlio||get original node ptr|12311
        wa= v.evlio;				// get original node ptr
        //b ||bne|8,wa|11,-(xt)|6,failp|fail if pos is not first node|12312
        if ((wa-*(--xt_it.wp)) != 0) C_GOTO(failp);				// fail if pos is not first node
        //b ||brn|6,ppos2|||merge with integer argument code|12313
         C_GOTO(ppos2);				// merge with integer argument code
        //b ||ejc|||||12314
        
//      pattern assignment (initial entry, save cursor)
//      see compound patterns description for the structure and
//      algorithms for matching this node type.
//      no parameters
//	align	2
//	db	bl_p0
        //b |p_paa|ent|2,bl_p0|||p0blk|12323
        } /* ppos1 */
        

        void p_paa() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||mov|11,-(xs)|8,wb||stack initial cursor|12324
        C_PUSH(wb);				// stack initial cursor
        //b ||mov|11,-(xs)|21,=ndpab||stack ptr to ndpab special node|12325
        C_PUSH((word)(&c.ndpab));				// stack ptr to ndpab special node
        //b ||brn|6,succp|||and succeed matching null|12326
         C_GOTO(succp);				// and succeed matching null
        //b ||ejc|||||12327
        
//      pattern assignment (remove saved cursor)
//      see compound patterns description for the structure and
//      algorithms for matching this node type.
//      no parameters (dummy pattern)
//	align	2
//	nop
        //b |p_pab|ent||||entry point|12336
        } /* p_paa */
        

        void p_pab() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||brn|6,failp|||just fail (entry is already popped)|12337
         C_GOTO(failp);				// just fail (entry is already popped)
        //b ||ejc|||||12338
        
//      pattern assignment (end of match, make assign entry)
//      see compound patterns description for the structure and
//      algorithms for matching this node type.
//      parm1                 name base of variable
//      parm2                 name offset of variable
//	align	2
//	db	bl_p2
        //b |p_pac|ent|2,bl_p2|||p2blk|12348
        } /* p_pab */
        

        void p_pac() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p2blk
        //b ||mov|11,-(xs)|8,wb||stack dummy cursor value|12349
        C_PUSH(wb);				// stack dummy cursor value
        //b ||mov|11,-(xs)|7,xr||stack pointer to p_pac node|12350
        C_PUSH(xr);				// stack pointer to p_pac node
        //b ||mov|11,-(xs)|8,wb||stack final cursor|12351
        C_PUSH(wb);				// stack final cursor
        //b ||mov|11,-(xs)|21,=ndpad||stack ptr to special ndpad node|12352
        C_PUSH((word)(&c.ndpad));				// stack ptr to special ndpad node
        //b ||mnz|3,pmdfl|||set dot flag non-zero|12353
        v.pmdfl = 0xffffffffffffffff;				// set dot flag non-zero
        //b ||brn|6,succp|||and succeed|12354
         C_GOTO(succp);				// and succeed
        //b ||ejc|||||12355
        
//      pattern assignment (remove assign entry)
//      see compound patterns description for the structure and
//      algorithms for matching this node type.
//      no parameters (dummy node)
//	align	2
//	nop
        //b |p_pad|ent||||entry point|12364
        } /* p_pac */
        

        void p_pad() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||brn|6,flpop|||fail and remove p_pac node|12365
         C_GOTO(flpop);				// fail and remove p_pac node
        //b ||ejc|||||12366
        
//      rem
//      no parameters
//	align	2
//	db	bl_p0
        //b |p_rem|ent|2,bl_p0|||p0blk|12372
        } /* p_pad */
        

        void p_rem() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||mov|8,wb|3,pmssl||point cursor to end of string|12373
        wb= v.pmssl;				// point cursor to end of string
        //b ||brn|6,succp|||and succeed|12374
         C_GOTO(succp);				// and succeed
        //b ||ejc|||||12375
        
//      rpos (expression argument)
//      optimize rpos if it is the first pattern element,
//      unanchored mode, cursor is zero and rpos argument
//      is not beyond end of string.  force cursor position
//      and number of unanchored moves.
//      this optimization is performed invisibly provided
//      the argument is either a simple integer or an
//      expression that is an untraced variable (that is,
//      it has no side effects that would be lost by short-
//      circuiting the normal logic of failing and moving the
//      unanchored starting point).
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        //b |p_rpd|ent|2,bl_p1|||p1blk|12393
        } /* p_rem */
        

        void p_rpd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||ppm|6,prps1|||merge with normal case if ok|12398
        C_JSR_4(evali,(C_ERR(52)),(C_ERR(53)),C_GOTO(failp),C_GOTO(prps1));				// merge with normal case if ok
// prps1:
        //b |prps1|mov|8,wc|3,pmssl||get length of string|12400
        C_GOTO(prps1);
        } /* p_rpd */
        

        void prps1() {
        wc= v.pmssl;				// get length of string
        //b ||sub|8,wc|8,wb||get number of characters remaining|12401
        wc -= wb;				// get number of characters remaining
        //b ||beq|8,wc|13,parm1(xr)|6,succp|succeed if at right location|12402
        if ((wc-*((word *)(CFP_B*PARM1 + xr))) == 0) C_GOTO(succp);				// succeed if at right location
        //b ||bnz|8,wb|6,failp||don't look further if cursor not 0|12403
        if (wb) C_GOTO(failp);				// don't look further if cursor not 0
        //b ||bnz|3,evlif|6,failp||fail if complex argument|12404
        if (v.evlif) C_GOTO(failp);				// fail if complex argument
        //b ||mov|7,xt|3,pmhbs||get history stack base ptr|12405
        xt= v.pmhbs;				// get history stack base ptr
        //b ||mov|8,wa|3,evlio||get original node ptr|12406
        wa= v.evlio;				// get original node ptr
        //b ||bne|8,wa|11,-(xt)|6,failp|fail if pos is not first node|12407
        if ((wa-*(--xt_it.wp)) != 0) C_GOTO(failp);				// fail if pos is not first node
        //b ||brn|6,prps2|||merge with integer arg code|12408
         C_GOTO(prps2);				// merge with integer arg code
        //b ||ejc|||||12409
        
//      rpos (integer argument)
//      parm1                 integer argument
//	align	2
//	db	bl_p1
        //b |p_rps|ent|2,bl_p1|||p1blk|12415
        } /* prps1 */
        

        void p_rps() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
//      rpos (integer argument)
//      parm1                 integer argument
        //b ||mov|8,wc|3,pmssl||get length of string|12421
        wc= v.pmssl;				// get length of string
        //b ||sub|8,wc|8,wb||get number of characters remaining|12422
        wc -= wb;				// get number of characters remaining
        //b ||beq|8,wc|13,parm1(xr)|6,succp|succeed if at right location|12423
        if ((wc-*((word *)(CFP_B*PARM1 + xr))) == 0) C_GOTO(succp);				// succeed if at right location
        //b ||bnz|8,wb|6,failp||don't look further if cursor not 0|12424
        if (wb) C_GOTO(failp);				// don't look further if cursor not 0
        //b ||mov|7,xt|3,pmhbs||get history stack base ptr|12425
        xt= v.pmhbs;				// get history stack base ptr
        //b ||bne|7,xr|11,-(xt)|6,failp|fail if rpos is not first node|12426
        if ((xr-*(--xt_it.wp)) != 0) C_GOTO(failp);				// fail if rpos is not first node
//      expression argument merges here
// prps2:
        //b |prps2|bne|11,-(xt)|21,=nduna|6,failp|fail if not unanchored mode|12430
        C_GOTO(prps2);
        } /* p_rps */
        

        void prps2() {
        if ((*(--xt_it.wp)-(word)(&c.nduna)) != 0) C_GOTO(failp);				// fail if not unanchored mode
        //b ||mov|8,wb|3,pmssl||point to end of string|12431
        wb= v.pmssl;				// point to end of string
        //b ||blt|8,wb|13,parm1(xr)|6,failp|fail if string not long enough|12432
        if ((wb-*((word *)(CFP_B*PARM1 + xr))) < 0) C_GOTO(failp);				// fail if string not long enough
        //b ||sub|8,wb|13,parm1(xr)||else set new cursor|12433
        wb -= *((word *)(CFP_B*PARM1 + xr));				// else set new cursor
        //b ||mov|13,num02(xt)|8,wb||fake number of unanchored moves|12434
        *((word *)(CFP_B*NUM02 + xt))= wb;				// fake number of unanchored moves
        //b ||brn|6,succp|||continue match with adjusted cursor|12435
         C_GOTO(succp);				// continue match with adjusted cursor
        //b ||ejc|||||12436
        
//      rtab (integer argument)
//      parm1                 integer argument
//	align	2
//	db	bl_p1
        //b |p_rtb|ent|2,bl_p1|||p1blk|12442
        } /* prps2 */
        

        void p_rtb() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
//      expression argument case merges here
// prtb1:
        //b |prtb1|mov|8,wc|8,wb||save initial cursor|12446
        C_GOTO(prtb1);
        } /* p_rtb */
        

        void prtb1() {
        wc= wb;				// save initial cursor
        //b ||mov|8,wb|3,pmssl||point to end of string|12447
        wb= v.pmssl;				// point to end of string
        //b ||blt|8,wb|13,parm1(xr)|6,failp|fail if string not long enough|12448
        if ((wb-*((word *)(CFP_B*PARM1 + xr))) < 0) C_GOTO(failp);				// fail if string not long enough
        //b ||sub|8,wb|13,parm1(xr)||else set new cursor|12449
        wb -= *((word *)(CFP_B*PARM1 + xr));				// else set new cursor
        //b ||bge|8,wb|8,wc|6,succp|and succeed if not too far already|12450
        if ((wb-wc) >= 0) C_GOTO(succp);				// and succeed if not too far already
        //b ||brn|6,failp|||in which case, fail|12451
         C_GOTO(failp);				// in which case, fail
        //b ||ejc|||||12452
        
//      rtab (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        //b |p_rtd|ent|2,bl_p1|||p1blk|12458
        } /* prtb1 */
        

        void p_rtd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||ppm|6,prtb1|||merge with normal case if success|12463
        C_JSR_4(evali,(C_ERR(54)),(C_ERR(55)),C_GOTO(failp),C_GOTO(prtb1));				// merge with normal case if success
        //b ||ejc|||||12464
        
//      span (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        //b |p_spd|ent|2,bl_p1|||p1blk|12470
        C_GOTO(p_spd);
        } /* p_rtd */
        

        void p_spd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||ppm|6,pspn1|||merge with multi-char case if ok|12474
        C_JSR_3(evals,(C_ERR(56)),C_GOTO(failp),C_GOTO(pspn1));				// merge with multi-char case if ok
        //b ||ejc|||||12475
        
//      span (multi-character argument case)
//      parm1                 pointer to ctblk
//      parm2                 bit mask to select bit column
//	align	2
//	db	bl_p2
        //b |p_spn|ent|2,bl_p2|||p2blk|12482
        C_GOTO(p_spn);
        } /* p_spd */
        

        void p_spn() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p2blk
//      expression argument case merges here
// pspn1:
        //b |pspn1|mov|8,wc|3,pmssl||copy subject string length|12486
        C_GOTO(pspn1);
        } /* p_spn */
        

        void pspn1() {
        wc= v.pmssl;				// copy subject string length
        //b ||sub|8,wc|8,wb||calculate number of characters left|12487
        wc -= wb;				// calculate number of characters left
        //b ||bze|8,wc|6,failp||fail if no characters left|12488
        if ( !( wc) ) C_GOTO(failp);				// fail if no characters left
        //b ||mov|7,xl|3,r_pms||point to subject string|12489
        xl= v.r_pms;				// point to subject string
        //b ||plc|7,xl|8,wb||point to current character|12490
        xl_it.chp += CFP_F + wb;				// point to current character
        //b ||mov|3,psavc|8,wb||save initial cursor|12491
        v.psavc= wb;				// save initial cursor
        //b ||mov|3,psave|7,xr||save node pointer|12492
        v.psave= xr;				// save node pointer
        //b ||lct|8,wc|8,wc||set counter for chars left|12493
        wc= wc;				// set counter for chars left
//      loop to scan matching characters
// pspn2:
        //b |pspn2|lch|8,wa|10,(xl)+||load next character, bump pointer|12497
        C_GOTO(pspn2);
        } /* pspn1 */
        

        void pspn2() {
        wa = *(xl_it.chp++);				// load next character, bump pointer
        //b ||wtb|8,wa|||convert to byte offset|12498
        wa <<= LOG_CFP_B;				// convert to byte offset
        //b ||mov|7,xr|13,parm1(xr)||point to ctblk|12499
        xr= *((word *)(CFP_B*PARM1 + xr));				// point to ctblk
        //b ||add|7,xr|8,wa||point to ctblk entry|12500
        xr += wa;				// point to ctblk entry
        //b ||mov|8,wa|13,ctchs(xr)||load ctblk entry|12501
        wa= *((word *)(CFP_B*CTCHS + xr));				// load ctblk entry
        //b ||mov|7,xr|3,psave||restore node pointer|12502
        xr= v.psave;				// restore node pointer
        //b ||anb|8,wa|13,parm2(xr)||and with selected bit|12503
        wa &= *((word *)(CFP_B*PARM2 + xr));				// and with selected bit
        //b ||zrb|8,wa|6,pspn3||jump if no match|12504
        if (!(wa)) C_GOTO(pspn3);				// jump if no match
        //b ||icv|8,wb|||else push cursor|12505
        (wb)++;				// else push cursor
        //b ||bct|8,wc|6,pspn2||loop back unless end of string|12506
        if ((--wc))  C_GOTO(pspn2);				// loop back unless end of string
//      here after scanning matching characters
// pspn3:
        //b |pspn3|bne|8,wb|3,psavc|6,succp|succeed if chars matched|12510
        C_GOTO(pspn3);
        } /* pspn2 */
        

        void pspn3() {
        if ((wb-v.psavc) != 0) C_GOTO(succp);				// succeed if chars matched
        //b ||brn|6,failp|||else fail if null string matched|12511
         C_GOTO(failp);				// else fail if null string matched
        //b ||ejc|||||12512
        
//      span (one character argument)
//      parm1                 character argument
//	align	2
//	db	bl_p1
        //b |p_sps|ent|2,bl_p1|||p1blk|12518
        } /* pspn3 */
        

        void p_sps() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||mov|8,wc|3,pmssl||get subject string length|12519
        wc= v.pmssl;				// get subject string length
        //b ||sub|8,wc|8,wb||calculate number of characters left|12520
        wc -= wb;				// calculate number of characters left
        //b ||bze|8,wc|6,failp||fail if no characters left|12521
        if ( !( wc) ) C_GOTO(failp);				// fail if no characters left
        //b ||mov|7,xl|3,r_pms||else point to subject string|12522
        xl= v.r_pms;				// else point to subject string
        //b ||plc|7,xl|8,wb||point to current character|12523
        xl_it.chp += CFP_F + wb;				// point to current character
        //b ||mov|3,psavc|8,wb||save initial cursor|12524
        v.psavc= wb;				// save initial cursor
        //b ||lct|8,wc|8,wc||set counter for characters left|12525
        wc= wc;				// set counter for characters left
//      loop to scan matching characters
// psps1:
        //b |psps1|lch|8,wa|10,(xl)+||load next character, bump pointer|12529
        C_GOTO(psps1);
        } /* p_sps */
        

        void psps1() {
        wa = *(xl_it.chp++);				// load next character, bump pointer
        //b ||bne|8,wa|13,parm1(xr)|6,psps2|jump if no match|12530
        if ((wa-*((word *)(CFP_B*PARM1 + xr))) != 0) C_GOTO(psps2);				// jump if no match
        //b ||icv|8,wb|||else push cursor|12531
        (wb)++;				// else push cursor
        //b ||bct|8,wc|6,psps1||and loop unless end of string|12532
        if ((--wc))  C_GOTO(psps1);				// and loop unless end of string
//      here after scanning matching characters
// psps2:
        //b |psps2|bne|8,wb|3,psavc|6,succp|succeed if chars matched|12536
        C_GOTO(psps2);
        } /* psps1 */
        

        void psps2() {
        if ((wb-v.psavc) != 0) C_GOTO(succp);				// succeed if chars matched
        //b ||brn|6,failp|||fail if null string matched|12537
         C_GOTO(failp);				// fail if null string matched
        //b ||ejc|||||12538
        
//      multi-character string
//      note that one character strings use the circuit for
//      one character any arguments (p_an1).
//      parm1                 pointer to scblk for string arg
//	align	2
//	db	bl_p1
        //b |p_str|ent|2,bl_p1|||p1blk|12547
        } /* psps2 */
        

        void p_str() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||mov|7,xl|13,parm1(xr)||get pointer to string|12548
        xl= *((word *)(CFP_B*PARM1 + xr));				// get pointer to string
//      merge here after evaluating expression with string value
// pstr1:
        //b |pstr1|mov|3,psave|7,xr||save node pointer|12552
        C_GOTO(pstr1);
        } /* p_str */
        

        void pstr1() {
        v.psave= xr;				// save node pointer
        //b ||mov|7,xr|3,r_pms||load subject string pointer|12553
        xr= v.r_pms;				// load subject string pointer
        //b ||plc|7,xr|8,wb||point to current character|12554
        xr_it.chp += CFP_F + wb;				// point to current character
        //b ||add|8,wb|13,sclen(xl)||compute new cursor position|12555
        wb += *((word *)(CFP_B*SCLEN + xl));				// compute new cursor position
        //b ||bgt|8,wb|3,pmssl|6,failp|fail if past end of string|12556
        if ((wb-v.pmssl) > 0) C_GOTO(failp);				// fail if past end of string
        //b ||mov|3,psavc|8,wb||save updated cursor|12557
        v.psavc= wb;				// save updated cursor
        //b ||mov|8,wa|13,sclen(xl)||get number of chars to compare|12558
        wa= *((word *)(CFP_B*SCLEN + xl));				// get number of chars to compare
        //b ||plc|7,xl|||point to chars of test string|12559
        xl += CFP_F;				// point to chars of test string
        //b ||cmc|6,failp|6,failp||compare, fail if not equal|12560
        C_CMC_DIFFER(xl_it,xr_it,wa_it,failp);				// compare, fail if not equal
        //b ||mov|7,xr|3,psave||if all matched, restore node ptr|12561
        xr= v.psave;				// if all matched, restore node ptr
        //b ||mov|8,wb|3,psavc||restore updated cursor|12562
        wb= v.psavc;				// restore updated cursor
        //b ||brn|6,succp|||and succeed|12563
         C_GOTO(succp);				// and succeed
        //b ||ejc|||||12564
        
//      succeed
//      see section on compound patterns for details of the
//      structure and algorithms for matching this node type
//      no parameters
//	align	2
//	db	bl_p0
        //b |p_suc|ent|2,bl_p0|||p0blk|12573
        } /* pstr1 */
        

        void p_suc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p0blk
        //b ||mov|11,-(xs)|8,wb||stack cursor|12574
        C_PUSH(wb);				// stack cursor
        //b ||mov|11,-(xs)|7,xr||stack pointer to this node|12575
        C_PUSH(xr);				// stack pointer to this node
        //b ||brn|6,succp|||succeed matching null|12576
         C_GOTO(succp);				// succeed matching null
        //b ||ejc|||||12577
        
//      tab (integer argument)
//      parm1                 integer argument
//	align	2
//	db	bl_p1
        //b |p_tab|ent|2,bl_p1|||p1blk|12583
        } /* p_suc */
        

        void p_tab() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
//      expression argument case merges here
// ptab1:
        //b |ptab1|bgt|8,wb|13,parm1(xr)|6,failp|fail if too far already|12587
        C_GOTO(ptab1);
        } /* p_tab */
        

        void ptab1() {
        if ((wb-*((word *)(CFP_B*PARM1 + xr))) > 0) C_GOTO(failp);				// fail if too far already
        //b ||mov|8,wb|13,parm1(xr)||else set new cursor position|12588
        wb= *((word *)(CFP_B*PARM1 + xr));				// else set new cursor position
        //b ||ble|8,wb|3,pmssl|6,succp|succeed if not off end|12589
        if ((wb-v.pmssl) <= 0) C_GOTO(succp);				// succeed if not off end
        //b ||brn|6,failp|||else fail|12590
         C_GOTO(failp);				// else fail
        //b ||ejc|||||12591
        
//      tab (expression argument)
//      parm1                 expression pointer
//	align	2
//	db	bl_p1
        //b |p_tbd|ent|2,bl_p1|||p1blk|12597
        } /* ptab1 */
        

        void p_tbd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// p1blk
        //b ||ppm|6,ptab1|||merge with normal case if ok|12602
        C_JSR_4(evali,(C_ERR(57)),(C_ERR(58)),C_GOTO(failp),C_GOTO(ptab1));				// merge with normal case if ok
        //b ||ejc|||||12603
        
//      anchor movement
//      no parameters (dummy node)
//	align	2
//	nop
        //b |p_una|ent||||entry point|12609
        C_GOTO(p_una);
        } /* p_tbd */
        

        void p_una() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|8,wb||copy initial pattern node pointer|12610
        xr= wb;				// copy initial pattern node pointer
        //b ||mov|8,wb|9,(xs)||get initial cursor|12611
        wb= *(xs_it.wp);				// get initial cursor
        //b ||beq|8,wb|3,pmssl|6,exfal|match fails if at end of string|12612
        if ((wb-v.pmssl) == 0) C_GOTO(exfal);				// match fails if at end of string
        //b ||icv|8,wb|||else increment cursor|12613
        (wb)++;				// else increment cursor
        //b ||mov|9,(xs)|8,wb||store incremented cursor|12614
        *(xs_it.wp)= wb;				// store incremented cursor
        //b ||mov|11,-(xs)|7,xr||restack initial node ptr|12615
        C_PUSH(xr);				// restack initial node ptr
        //b ||mov|11,-(xs)|21,=nduna||restack unanchored node|12616
        C_PUSH((word)(&c.nduna));				// restack unanchored node
        //b ||bri|9,(xr)|||rematch first node|12617
        w0 = xr_it.wp[0];				// rematch first node
        C_GOTO(w0_it.callp);
        //b ||ejc|||||12618
        
//      end of pattern match routines
//      the following entry point marks the end of the pattern
//      matching routines and also the end of the entry points
//      referenced from the first word of blocks in dynamic store
//	align	2
//	db	bl__i
        //b |p_yyy|ent|2,bl__i|||mark last entry in pattern section|12626
        } /* p_una */
        

        void p_yyy() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// mark last entry in pattern section
        //b ||ttl|27,s p i t b o l -- snobol4 built-in label routines||||12627
        /* s p i t b o l -- snobol4 built-in label routines*/
//      the following section contains the routines for labels
//      which have a predefined meaning in snobol4.
//      control is passed directly to the label name entry point.
//      entry names are of the form l_xxx where xxx is the three
//      letter variable name identifier.
//      entries are in alphabetical order
        //b ||ejc|||||12638
        
//      abort
//	align	2
//	nop
        //b |l_abo|ent||||entry point|12642
        C_GOTO(l_abo);
        } /* p_yyy */
        

        void l_abo() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
//      merge here if execution terminates in error
// labo1:
        //b |labo1|mov|8,wa|3,kvert||load error code|12646
        C_GOTO(labo1);
        } /* l_abo */
        

        void labo1() {
        wa= v.kvert;				// load error code
        //b ||bze|8,wa|6,labo3||jump if no error has occured|12647
        if ( !( wa) ) C_GOTO(labo3);				// jump if no error has occured
        //b ||jsr|6,sysax|||call after execution proc|12649
        C_JSR(sysax);				// call after execution proc
        //b ||mov|8,wc|3,kvstn||current statement|12653
        wc= v.kvstn;				// current statement
        //b ||jsr|6,filnm|||obtain file name for this statement|12654
        C_JSR(filnm);				// obtain file name for this statement
        //b ||mov|7,xr|3,r_cod||current code block|12657
        xr= v.r_cod;				// current code block
        //b ||mov|8,wc|13,cdsln(xr)||line number|12658
        wc= *((word *)(CFP_B*CDSLN + xr));				// line number
        //b ||zer|8,wb|||column number|12662
        wb=0;				// column number
        //b ||mov|7,xr|3,stage|||12663
        xr= v.stage;
        //b ||ppm|6,stpr4|||if system does not want print|12665
        C_JSR_1(sysea,C_GOTO(stpr4));				// if system does not want print
        //b ||jsr|6,prtpg|||else eject printer|12667
        C_JSR(prtpg);				// else eject printer
        //b ||bze|7,xr|6,labo2||did sysea request print|12669
        if ( !( xr) ) C_GOTO(labo2);				// did sysea request print
        //b ||jsr|6,prtst|||print text from sysea|12670
        C_JSR(prtst);				// print text from sysea
// labo2:
        //b |labo2|jsr|6,ermsg|||print error message|12672
        C_GOTO(labo2);
        } /* labo1 */
        

        void labo2() {
        C_JSR(ermsg);				// print error message
        //b ||zer|7,xr|||indicate no message to print|12673
        xr=0;				// indicate no message to print
        //b ||brn|6,stopr|||jump to routine to stop run|12674
         C_GOTO(stopr);				// jump to routine to stop run
//      here if no error had occured
// labo3:
        //b |labo3|erb|1,036|26,goto abort with no preceding error|||12678
        } /* labo2 */
        

        void labo3() {
        C_ERB(36)
        //b ||ejc|||||12679
        
//      continue
//	align	2
//	nop
        //b |l_cnt|ent||||entry point|12683
        } /* labo3 */
        

        void l_cnt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
//      merge here after execution error
// lcnt1:
        //b |lcnt1|mov|7,xr|3,r_cnt||load continuation code block ptr|12687
        C_GOTO(lcnt1);
        } /* l_cnt */
        

        void lcnt1() {
        xr= v.r_cnt;				// load continuation code block ptr
        //b ||bze|7,xr|6,lcnt3||jump if no previous error|12688
        if ( !( xr) ) C_GOTO(lcnt3);				// jump if no previous error
        //b ||zer|3,r_cnt|||clear flag|12689
        v.r_cnt=0;				// clear flag
        //b ||mov|3,r_cod|7,xr||else store as new code block ptr|12690
        v.r_cod= xr;				// else store as new code block ptr
        //b ||bne|9,(xr)|22,=b_cdc|6,lcnt2|jump if not complex go|12691
        if ((*(xr_it.wp)-(word)(b_cdc)) != 0) C_GOTO(lcnt2);				// jump if not complex go
        //b ||mov|8,wa|3,stxoc||get offset of error|12692
        wa= v.stxoc;				// get offset of error
        //b ||bge|8,wa|3,stxof|6,lcnt4|jump if error in goto evaluation|12693
        if ((wa-v.stxof) >= 0) C_GOTO(lcnt4);				// jump if error in goto evaluation
//      here if error did not occur in complex failure goto
// lcnt2:
        //b |lcnt2|add|7,xr|3,stxof||add failure offset|12697
        C_GOTO(lcnt2);
        } /* lcnt1 */
        

        void lcnt2() {
        xr += v.stxof;				// add failure offset
        //b ||lcp|7,xr|||load code pointer|12698
        reg_cp = xr;				// load code pointer
        //b ||mov|7,xs|3,flptr||reset stack pointer|12699
        xs= v.flptr;				// reset stack pointer
        //b ||lcw|7,xr|||get next code word|12700
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|12701
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
//      here if no previous error
// lcnt3:
        //b |lcnt3|icv|3,errft|||fatal error|12705
        } /* lcnt2 */
        

        void lcnt3() {
        (v.errft)++;				// fatal error
        //b ||erb|1,037|26,goto continue with no preceding error|||12706
        C_ERB(37)
//      here if error in evaluation of failure goto.
//      cannot continue back to failure goto!
// lcnt4:
        //b |lcnt4|icv|3,errft|||fatal error|12711
        } /* lcnt3 */
        

        void lcnt4() {
        (v.errft)++;				// fatal error
        //b ||erb|1,332|26,goto continue with error in failure goto|||12712
        C_ERB(332)
        //b ||ejc|||||12713
        
//      end
//	align	2
//	nop
        //b |l_end|ent||||entry point|12717
        } /* lcnt4 */
        

        void l_end() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
//      merge here from end code circuit
// lend0:
        //b |lend0|mov|7,xr|21,=endms||point to message /normal term.../|12721
        C_GOTO(lend0);
        } /* l_end */
        

        void lend0() {
        xr= (word)(&c.endms);				// point to message /normal term.../
        //b ||brn|6,stopr|||jump to routine to stop run|12722
         C_GOTO(stopr);				// jump to routine to stop run
        //b ||ejc|||||12723
        
//      freturn
//	align	2
//	nop
        //b |l_frt|ent||||entry point|12727
        } /* lend0 */
        

        void l_frt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wa|21,=scfrt||point to string /freturn/|12728
        wa= (word)(&c.scfrt);				// point to string /freturn/
        //b ||brn|6,retrn|||jump to common return routine|12729
         C_GOTO(retrn);				// jump to common return routine
        //b ||ejc|||||12730
        
//      nreturn
//	align	2
//	nop
        //b |l_nrt|ent||||entry point|12734
        } /* l_frt */
        

        void l_nrt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wa|21,=scnrt||point to string /nreturn/|12735
        wa= (word)(&c.scnrt);				// point to string /nreturn/
        //b ||brn|6,retrn|||jump to common return routine|12736
         C_GOTO(retrn);				// jump to common return routine
        //b ||ejc|||||12737
        
//      return
//	align	2
//	nop
        //b |l_rtn|ent||||entry point|12741
        } /* l_nrt */
        

        void l_rtn() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wa|21,=scrtn||point to string /return/|12742
        wa= (word)(&c.scrtn);				// point to string /return/
        //b ||brn|6,retrn|||jump to common return routine|12743
         C_GOTO(retrn);				// jump to common return routine
        //b ||ejc|||||12744
        
//      scontinue
//	align	2
//	nop
        //b |l_scn|ent||||entry point|12748
        } /* l_rtn */
        

        void l_scn() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|3,r_cnt||load continuation code block ptr|12749
        xr= v.r_cnt;				// load continuation code block ptr
        //b ||bze|7,xr|6,lscn2||jump if no previous error|12750
        if ( !( xr) ) C_GOTO(lscn2);				// jump if no previous error
        //b ||zer|3,r_cnt|||clear flag|12751
        v.r_cnt=0;				// clear flag
        //b ||bne|3,kvert|18,=nm320|6,lscn1|error must be user interrupt|12752
        if ((v.kvert-NM320) != 0) C_GOTO(lscn1);				// error must be user interrupt
        //b ||beq|3,kvert|18,=nm321|6,lscn2|detect scontinue loop|12753
        if ((v.kvert-NM321) == 0) C_GOTO(lscn2);				// detect scontinue loop
        //b ||mov|3,r_cod|7,xr||else store as new code block ptr|12754
        v.r_cod= xr;				// else store as new code block ptr
        //b ||add|7,xr|3,stxoc||add resume offset|12755
        xr += v.stxoc;				// add resume offset
        //b ||lcp|7,xr|||load code pointer|12756
        reg_cp = xr;				// load code pointer
        //b ||lcw|7,xr|||get next code word|12757
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|12758
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
//      here if no user interrupt
// lscn1:
        //b |lscn1|icv|3,errft|||fatal error|12762
        } /* l_scn */
        

        void lscn1() {
        (v.errft)++;				// fatal error
        //b ||erb|1,331|26,goto scontinue with no user interrupt|||12763
        C_ERB(331)
//      here if in scontinue loop or if no previous error
// lscn2:
        //b |lscn2|icv|3,errft|||fatal error|12767
        } /* lscn1 */
        

        void lscn2() {
        (v.errft)++;				// fatal error
        //b ||erb|1,321|26,goto scontinue with no preceding error|||12768
        C_ERB(321)
        //b ||ejc|||||12769
        
//      undefined label
//	align	2
//	nop
        //b |l_und|ent||||entry point|12773
        } /* lscn2 */
        

        void l_und() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||erb|1,038|26,goto undefined label|||12774
        C_ERB(38)
        //b ||ttl|27,s p i t b o l -- predefined snobol4 functions||||12775
        /* s p i t b o l -- predefined snobol4 functions*/
//      the following section contains coding for functions
//      which are predefined and available at the snobol level.
//      these routines receive control directly from the code or
//      indirectly through the o_fnc, o_fns or cfunc routines.
//      in both cases the conditions on entry are as follows
//      the arguments are on the stack. the number of arguments
//      has been adjusted to correspond to the svblk svnar field.
//      in certain functions the direct call is not permitted
//      and in these instances we also have.
//      (wa)                  actual number of arguments in call
//      control returns by placing the function result value on
//      on the stack and continuing execution with the next
//      word from the generated code.
//      the names of the entry points of these functions are of
//      the form s_xxx where xxx is the three letter code for
//      the system variable name. the functions are in order
//      alphabetically by their entry names.
        //b ||ejc|||||12800
        
//      any
//	align	2
//	nop
        //b |s_any|ent||||entry point|12854
        } /* l_und */
        

        void s_any() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_ans||set pcode for single char case|12855
        wb= (word)(p_ans);				// set pcode for single char case
        //b ||mov|7,xl|22,=p_any||pcode for multi-char case|12856
        xl= (word)(p_any);				// pcode for multi-char case
        //b ||mov|8,wc|22,=p_ayd||pcode for expression case|12857
        wc= (word)(p_ayd);				// pcode for expression case
        //b ||err|1,059|26,any argument is not a string or expression|||12859
        extern void _l0401();
        C_JMS(patst,P_PRC_PATST,_l0401);
        } /* s_any */
        

        void _l0401() {
        C_JMS_HANDLE_1(patst,(C_ERR(59)));
        //b ||mov|11,-(xs)|7,xr||stack result|12860
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|12861
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|12862
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||12863
        
//      apply
//      apply does not permit the direct (fast) call so that
//      wa contains the actual number of arguments passed.
//	align	2
//	nop
        //b |s_app|ent||||entry point|12889
        } /* _l0401 */
        

        void s_app() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||bze|8,wa|6,sapp3||jump if no arguments|12890
        if ( !( wa) ) C_GOTO(sapp3);				// jump if no arguments
        //b ||dcv|8,wa|||else get applied func arg count|12891
        (wa)--;				// else get applied func arg count
        //b ||mov|8,wb|8,wa||copy|12892
        wb= wa;				// copy
        //b ||wtb|8,wb|||convert to bytes|12893
        wb <<= LOG_CFP_B;				// convert to bytes
        //b ||mov|7,xt|7,xs||copy stack pointer|12894
        xt= xs;				// copy stack pointer
        //b ||add|7,xt|8,wb||point to function argument on stack|12895
        xt += wb;				// point to function argument on stack
        //b ||mov|7,xr|9,(xt)||load function ptr (apply 1st arg)|12896
        xr= *(xt_it.wp);				// load function ptr (apply 1st arg)
        //b ||bze|8,wa|6,sapp2||jump if no args for applied func|12897
        if ( !( wa) ) C_GOTO(sapp2);				// jump if no args for applied func
        //b ||lct|8,wb|8,wa||else set counter for loop|12898
        wb= wa;				// else set counter for loop
//      loop to move arguments up on stack
// sapp1:
        //b |sapp1|dca|7,xt|||point to next argument|12902
        C_GOTO(sapp1);
        } /* s_app */
        

        void sapp1() {
        xt -= CFP_B;				// point to next argument
        //b ||mov|13,num01(xt)|9,(xt)||move argument up|12903
        *((word *)(CFP_B*NUM01 + xt))= *(xt_it.wp);				// move argument up
        //b ||bct|8,wb|6,sapp1||loop till all moved|12904
        if ((--wb))  C_GOTO(sapp1);				// loop till all moved
//      merge here to call function (wa = number of arguments)
// sapp2:
        //b |sapp2|ica|7,xs|||adjust stack ptr for apply 1st arg|12908
        C_GOTO(sapp2);
        } /* sapp1 */
        

        void sapp2() {
        xs += CFP_B;				// adjust stack ptr for apply 1st arg
        //b ||ppm|6,sapp3|||jump if not natural variable|12910
        C_JSR_1(gtnvr,C_GOTO(sapp3));				// jump if not natural variable
        //b ||mov|7,xl|13,vrfnc(xr)||else point to function block|12911
        xl= *((word *)(CFP_B*VRFNC + xr));				// else point to function block
        //b ||brn|6,cfunc|||go call applied function|12912
         C_GOTO(cfunc);				// go call applied function
//      here for invalid first argument
// sapp3:
        //b |sapp3|erb|1,060|26,apply first arg is not natural variable name|||12916
        } /* sapp2 */
        

        void sapp3() {
        C_ERB(60)
        //b ||ejc|||||12917
        
//      arbno
//      arbno builds a compound pattern. see description at
//      start of pattern matching section for structure formed.
//	align	2
//	nop
        //b |s_abn|ent||||entry point|12924
        } /* sapp3 */
        

        void s_abn() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||zer|7,xr|||set parm1 = 0 for the moment|12925
        xr=0;				// set parm1 = 0 for the moment
        //b ||mov|8,wb|22,=p_alt||set pcode for alternative node|12926
        wb= (word)(p_alt);				// set pcode for alternative node
        //b ||jsr|6,pbild|||build alternative node|12927
        C_JSR(pbild);				// build alternative node
        //b ||mov|7,xl|7,xr||save ptr to alternative pattern|12928
        xl= xr;				// save ptr to alternative pattern
        //b ||mov|8,wb|22,=p_abc||pcode for p_abc|12929
        wb= (word)(p_abc);				// pcode for p_abc
        //b ||zer|7,xr|||p0blk|12930
        xr=0;				// p0blk
        //b ||jsr|6,pbild|||build p_abc node|12931
        C_JSR(pbild);				// build p_abc node
        //b ||mov|13,pthen(xr)|7,xl||put alternative node as successor|12932
        *((word *)(CFP_B*PTHEN + xr))= xl;				// put alternative node as successor
        //b ||mov|8,wa|7,xl||remember alternative node pointer|12933
        wa= xl;				// remember alternative node pointer
        //b ||mov|7,xl|7,xr||copy p_abc node ptr|12934
        xl= xr;				// copy p_abc node ptr
        //b ||mov|7,xr|9,(xs)||load arbno argument|12935
        xr= *(xs_it.wp);				// load arbno argument
        //b ||mov|9,(xs)|8,wa||stack alternative node pointer|12936
        *(xs_it.wp)= wa;				// stack alternative node pointer
        //b ||err|1,061|26,arbno argument is not pattern|||12938
        C_JSR_1(gtpat,(C_ERR(61)));
        //b ||jsr|6,pconc|||concat arg with p_abc node|12939
        C_JSR(pconc);				// concat arg with p_abc node
        //b ||mov|7,xl|7,xr||remember ptr to concd patterns|12940
        xl= xr;				// remember ptr to concd patterns
        //b ||mov|8,wb|22,=p_aba||pcode for p_aba|12941
        wb= (word)(p_aba);				// pcode for p_aba
        //b ||zer|7,xr|||p0blk|12942
        xr=0;				// p0blk
        //b ||jsr|6,pbild|||build p_aba node|12943
        C_JSR(pbild);				// build p_aba node
        //b ||mov|13,pthen(xr)|7,xl||concatenate nodes|12944
        *((word *)(CFP_B*PTHEN + xr))= xl;				// concatenate nodes
        //b ||mov|7,xl|9,(xs)||recall ptr to alternative node|12945
        xl= *(xs_it.wp);				// recall ptr to alternative node
        //b ||mov|13,parm1(xl)|7,xr||point alternative back to argument|12946
        *((word *)(CFP_B*PARM1 + xl))= xr;				// point alternative back to argument
        //b ||lcw|7,xr|||get next code word|12947
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|12948
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||12949
        
//      arg
//	align	2
//	nop
        //b |s_arg|ent||||entry point|12953
        } /* s_abn */
        

        void s_arg() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exfal|||fail if out of range or negative|12956
        extern void _l0402();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0402);
        } /* s_arg */
        

        void _l0402() {
        C_JMS_HANDLE_2(gtsmi,(C_ERR(62)),C_GOTO(exfal));				// fail if out of range or negative
        //b ||mov|8,wa|7,xr||save argument number|12957
        wa= xr;				// save argument number
        //b ||mov|7,xr|10,(xs)+||load first argument|12958
        xr= C_POP();				// load first argument
        //b ||ppm|6,sarg1|||jump if not natural variable|12960
        C_JSR_1(gtnvr,C_GOTO(sarg1));				// jump if not natural variable
        //b ||mov|7,xr|13,vrfnc(xr)||else load function block pointer|12961
        xr= *((word *)(CFP_B*VRFNC + xr));				// else load function block pointer
        //b ||bne|9,(xr)|22,=b_pfc|6,sarg1|jump if not program defined|12962
        if ((*(xr_it.wp)-(word)(b_pfc)) != 0) C_GOTO(sarg1);				// jump if not program defined
        //b ||bze|8,wa|6,exfal||fail if arg number is zero|12963
        if ( !( wa) ) C_GOTO(exfal);				// fail if arg number is zero
        //b ||bgt|8,wa|13,fargs(xr)|6,exfal|fail if arg number is too large|12964
        if ((wa-*((word *)(CFP_B*FARGS + xr))) > 0) C_GOTO(exfal);				// fail if arg number is too large
        //b ||wtb|8,wa|||else convert to byte offset|12965
        wa <<= LOG_CFP_B;				// else convert to byte offset
        //b ||add|7,xr|8,wa||point to argument selected|12966
        xr += wa;				// point to argument selected
        //b ||mov|7,xr|13,pfagb(xr)||load argument vrblk pointer|12967
        xr= *((word *)(CFP_B*PFAGB + xr));				// load argument vrblk pointer
        //b ||brn|6,exvnm|||exit to build nmblk|12968
         C_GOTO(exvnm);				// exit to build nmblk
//      here if 1st argument is bad
// sarg1:
        //b |sarg1|erb|1,063|26,arg first argument is not program function name|||12972
        } /* _l0402 */
        

        void sarg1() {
        C_ERB(63)
        //b ||ejc|||||12973
        
//      array
//	align	2
//	nop
        //b |s_arr|ent||||entry point|12977
        } /* sarg1 */
        

        void s_arr() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xl|10,(xs)+||load initial element value|12978
        xl= C_POP();				// load initial element value
        //b ||mov|7,xr|10,(xs)+||load first argument|12979
        xr= C_POP();				// load first argument
        //b ||ppm|6,sar02|||jump if not integer|12981
        C_JSR_1(gtint,C_GOTO(sar02));				// jump if not integer
//      here for integer first argument, build vcblk
        //b ||ldi|13,icval(xr)|||load integer value|12985
        ia = *((word *)(CFP_B*ICVAL + xr));				// load integer value
        //b ||ile|6,sar10|||jump if zero or neg (bad dimension)|12986
        if (ia <= 0)  C_GOTO(sar10);				// jump if zero or neg (bad dimension)
        //b ||mfi|8,wa|6,sar11||else convert to one word, test ovfl|12987
        if (ia<0) C_GOTO( sar11);				// else convert to one word, test ovfl
        wa = ia;
        //b ||ppm|6,sar11|||fail if too large|12989
        C_JSR_1(vmake,C_GOTO(sar11));				// fail if too large
        //b ||brn|6,exsid|||exit setting idval|12990
         C_GOTO(exsid);				// exit setting idval
        //b ||ejc|||||12991
        
//      array (continued)
//      here if first argument is not an integer
// sar02:
        //b |sar02|mov|11,-(xs)|7,xr||replace argument on stack|12997
        } /* s_arr */
        

        void sar02() {
        C_PUSH(xr);				// replace argument on stack
        //b ||ppm|6,exnul|||dummy (unused) null string exit|13000
        extern void _l0403();
        C_JMS(xscni,P_PRC_XSCNI,_l0403);
        } /* sar02 */
        

        void _l0403() {
        C_JMS_HANDLE_2(xscni,(C_ERR(64)),C_GOTO(exnul));				// dummy (unused) null string exit
        //b ||mov|11,-(xs)|3,r_xsc||save prototype pointer|13001
        C_PUSH(v.r_xsc);				// save prototype pointer
        //b ||mov|11,-(xs)|7,xl||save default value|13002
        C_PUSH(xl);				// save default value
        //b ||zer|3,arcdm|||zero count of dimensions|13003
        v.arcdm=0;				// zero count of dimensions
        //b ||zer|3,arptr|||zero offset to indicate pass one|13004
        v.arptr=0;				// zero offset to indicate pass one
        //b ||ldi|4,intv1|||load integer one|13005
        ia = c.intv1;				// load integer one
        //b ||sti|3,arnel|||initialize element count|13006
        v.arnel= ia;				// initialize element count
//      the following code is executed twice. the first time
//      (arptr eq 0), it is used to count the number of elements
//      and number of dimensions. the second time (arptr gt 0) is
//      used to actually fill in the dim,lbd fields of the arblk.
// sar03:
        //b |sar03|ldi|4,intv1|||load one as default low bound|13013
        C_GOTO(sar03);
        } /* _l0403 */
        

        void sar03() {
        ia = c.intv1;				// load one as default low bound
        //b ||sti|3,arsvl|||save as low bound|13014
        v.arsvl= ia;				// save as low bound
        //b ||mov|8,wc|18,=ch_cl||set delimiter one = colon|13015
        wc= CH_CL;				// set delimiter one = colon
        //b ||mov|7,xl|18,=ch_cm||set delimiter two = comma|13016
        xl= CH_CM;				// set delimiter two = comma
        //b ||zer|8,wa|||retain blanks in prototype|13017
        wa=0;				// retain blanks in prototype
        //b ||jsr|6,xscan|||scan next bound|13018
        C_JSR(xscan);				// scan next bound
        //b ||bne|8,wa|18,=num01|6,sar04|jump if not colon|13019
        if ((wa-NUM01) != 0) C_GOTO(sar04);				// jump if not colon
//      here we have a colon ending a low bound
        //b ||err|1,065|26,array first argument lower bound is not integer|||13024
        C_JSR_1(gtint,(C_ERR(65)));
        //b ||ldi|13,icval(xr)|||load value of low bound|13025
        ia = *((word *)(CFP_B*ICVAL + xr));				// load value of low bound
        //b ||sti|3,arsvl|||store low bound value|13026
        v.arsvl= ia;				// store low bound value
        //b ||mov|8,wc|18,=ch_cm||set delimiter one = comma|13027
        wc= CH_CM;				// set delimiter one = comma
        //b ||mov|7,xl|8,wc||and delimiter two = comma|13028
        xl= wc;				// and delimiter two = comma
        //b ||zer|8,wa|||retain blanks in prototype|13029
        wa=0;				// retain blanks in prototype
        //b ||jsr|6,xscan|||scan high bound|13030
        C_JSR(xscan);				// scan high bound
        //b ||ejc|||||13031
        
//      array (continued)
//      merge here to process upper bound
// sar04:
        //b |sar04|jsr|6,gtint|||convert high bound to integer|13037
        C_GOTO(sar04);
        } /* sar03 */
        

        void sar04() {
        //b ||err|1,066|26,array first argument upper bound is not integer|||13038
        C_JSR_1(gtint,(C_ERR(66)));
        //b ||ldi|13,icval(xr)|||get high bound|13039
        ia = *((word *)(CFP_B*ICVAL + xr));				// get high bound
        //b ||sbi|3,arsvl|||subtract lower bound|13040
        ia-=v.arsvl;				// subtract lower bound
        //b ||iov|6,sar10|||bad dimension if overflow|13041
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// bad dimension if overflow
        //b ||ilt|6,sar10|||bad dimension if negative|13042
        if (ia < 0)  C_GOTO(sar10);				// bad dimension if negative
        //b ||adi|4,intv1|||add 1 to get dimension|13043
        ia+=c.intv1;				// add 1 to get dimension
        //b ||iov|6,sar10|||bad dimension if overflow|13044
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// bad dimension if overflow
        //b ||mov|7,xl|3,arptr||load offset (also pass indicator)|13045
        xl= v.arptr;				// load offset (also pass indicator)
        //b ||bze|7,xl|6,sar05||jump if first pass|13046
        if ( !( xl) ) C_GOTO(sar05);				// jump if first pass
//      here in second pass to store lbd and dim in arblk
        //b ||add|7,xl|9,(xs)||point to current location in arblk|13050
        xl += *(xs_it.wp);				// point to current location in arblk
        //b ||sti|13,cfp_i(xl)|||store dimension|13051
        *((word *)(CFP_B*CFP_I + xl))= ia;				// store dimension
        //b ||ldi|3,arsvl|||load low bound|13052
        ia = v.arsvl;				// load low bound
        //b ||sti|9,(xl)|||store low bound|13053
        *(xl_it.wp)= ia;				// store low bound
        //b ||add|3,arptr|19,*ardms||bump offset to next bounds|13054
        v.arptr += CFP_B*ARDMS;				// bump offset to next bounds
        //b ||brn|6,sar06|||jump to check for end of bounds|13055
         C_GOTO(sar06);				// jump to check for end of bounds
//      here in pass 1
// sar05:
        //b |sar05|icv|3,arcdm|||bump dimension count|13059
        } /* sar04 */
        

        void sar05() {
        (v.arcdm)++;				// bump dimension count
        //b ||mli|3,arnel|||multiply dimension by count so far|13060
        ia*=v.arnel;				// multiply dimension by count so far
        //b ||iov|6,sar11|||too large if overflow|13061
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// too large if overflow
        //b ||sti|3,arnel|||else store updated element count|13062
        v.arnel= ia;				// else store updated element count
//      merge here after processing one set of bounds
// sar06:
        //b |sar06|bnz|8,wa|6,sar03||loop back unless end of bounds|13066
        C_GOTO(sar06);
        } /* sar05 */
        

        void sar06() {
        if (wa) C_GOTO(sar03);				// loop back unless end of bounds
        //b ||bnz|3,arptr|6,sar09||jump if end of pass 2|13067
        if (v.arptr) C_GOTO(sar09);				// jump if end of pass 2
        //b ||ejc|||||13068
        
//      array (continued)
//      here at end of pass one, build arblk
        //b ||ldi|3,arnel|||get number of elements|13074
        ia = v.arnel;				// get number of elements
        //b ||mfi|8,wb|6,sar11||get as addr integer, test ovflo|13075
        if (ia<0) C_GOTO( sar11);				// get as addr integer, test ovflo
        wb = ia;
        //b ||wtb|8,wb|||else convert to length in bytes|13076
        wb <<= LOG_CFP_B;				// else convert to length in bytes
        //b ||mov|8,wa|19,*arsi_||set size of standard fields|13077
        wa= CFP_B*ARSI_;				// set size of standard fields
        //b ||lct|8,wc|3,arcdm||set dimension count to control loop|13078
        wc= v.arcdm;				// set dimension count to control loop
//      loop to allow space for dimensions
// sar07:
        //b |sar07|add|8,wa|19,*ardms||allow space for one set of bounds|13082
        C_GOTO(sar07);
        } /* sar06 */
        

        void sar07() {
        wa += CFP_B*ARDMS;				// allow space for one set of bounds
        //b ||bct|8,wc|6,sar07||loop back till all accounted for|13083
        if ((--wc))  C_GOTO(sar07);				// loop back till all accounted for
        //b ||mov|7,xl|8,wa||save size (=arofs)|13084
        xl= wa;				// save size (=arofs)
//      now allocate space for arblk
        //b ||add|8,wa|8,wb||add space for elements|13088
        wa += wb;				// add space for elements
        //b ||ica|8,wa|||allow for arpro prototype field|13089
        wa += CFP_B;				// allow for arpro prototype field
        //b ||bgt|8,wa|3,mxlen|6,sar11|fail if too large|13090
        if ((wa-v.mxlen) > 0) C_GOTO(sar11);				// fail if too large
        //b ||jsr|6,alloc|||else allocate arblk|13091
        C_JSR(alloc);				// else allocate arblk
        //b ||mov|8,wb|9,(xs)||load default value|13092
        wb= *(xs_it.wp);				// load default value
        //b ||mov|9,(xs)|7,xr||save arblk pointer|13093
        *(xs_it.wp)= xr;				// save arblk pointer
        //b ||mov|8,wc|8,wa||save length in bytes|13094
        wc= wa;				// save length in bytes
        //b ||btw|8,wa|||convert length back to words|13095
        wa >>= LOG_CFP_B;				// convert length back to words
        //b ||lct|8,wa|8,wa||set counter to control loop|13096
        wa= wa;				// set counter to control loop
//      loop to clear entire arblk to default value
// sar08:
        //b |sar08|mov|10,(xr)+|8,wb||set one word|13100
        C_GOTO(sar08);
        } /* sar07 */
        

        void sar08() {
        *(xr_it.wp++)= wb;				// set one word
        //b ||bct|8,wa|6,sar08||loop till all set|13101
        if ((--wa))  C_GOTO(sar08);				// loop till all set
        //b ||ejc|||||13102
        
//      array (continued)
//      now set initial fields of arblk
        //b ||mov|7,xr|10,(xs)+||reload arblk pointer|13108
        xr= C_POP();				// reload arblk pointer
        //b ||mov|8,wb|9,(xs)||load prototype|13109
        wb= *(xs_it.wp);				// load prototype
        //b ||mov|9,(xr)|22,=b_art||set type word|13110
        *(xr_it.wp)= (word)(b_art);				// set type word
        //b ||mov|13,arlen(xr)|8,wc||store length in bytes|13111
        *((word *)(CFP_B*ARLEN + xr))= wc;				// store length in bytes
        //b ||zer|13,idval(xr)|||zero id till we get it built|13112
        *((word *)(CFP_B*IDVAL + xr))=0;				// zero id till we get it built
        //b ||mov|13,arofs(xr)|7,xl||set prototype field ptr|13113
        *((word *)(CFP_B*AROFS + xr))= xl;				// set prototype field ptr
        //b ||mov|13,arndm(xr)|3,arcdm||set number of dimensions|13114
        *((word *)(CFP_B*ARNDM + xr))= v.arcdm;				// set number of dimensions
        //b ||mov|8,wc|7,xr||save arblk pointer|13115
        wc= xr;				// save arblk pointer
        //b ||add|7,xr|7,xl||point to prototype field|13116
        xr += xl;				// point to prototype field
        //b ||mov|9,(xr)|8,wb||store prototype ptr in arblk|13117
        *(xr_it.wp)= wb;				// store prototype ptr in arblk
        //b ||mov|3,arptr|19,*arlbd||set offset for pass 2 bounds scan|13118
        v.arptr= CFP_B*ARLBD;				// set offset for pass 2 bounds scan
        //b ||mov|3,r_xsc|8,wb||reset string pointer for xscan|13119
        v.r_xsc= wb;				// reset string pointer for xscan
        //b ||mov|9,(xs)|8,wc||store arblk pointer on stack|13120
        *(xs_it.wp)= wc;				// store arblk pointer on stack
        //b ||zer|3,xsofs|||reset offset ptr to start of string|13121
        v.xsofs=0;				// reset offset ptr to start of string
        //b ||brn|6,sar03|||jump back to rescan bounds|13122
         C_GOTO(sar03);				// jump back to rescan bounds
//      here after filling in bounds information (end pass two)
// sar09:
        //b |sar09|mov|7,xr|10,(xs)+||reload pointer to arblk|13126
        } /* sar08 */
        

        void sar09() {
        xr= C_POP();				// reload pointer to arblk
        //b ||brn|6,exsid|||exit setting idval|13127
         C_GOTO(exsid);				// exit setting idval
//      here for bad dimension
// sar10:
        //b |sar10|erb|1,067|26,array dimension is zero, negative or out of range|||13131
        } /* sar09 */
        

        void sar10() {
        C_ERB(67)
//      here if array is too large
// sar11:
        //b |sar11|erb|1,068|26,array size exceeds maximum permitted|||13135
        } /* sar10 */
        

        void sar11() {
        C_ERB(68)
        //b ||ejc|||||13136
        
//      atan
//	align	2
//	nop
        //b |s_atn|ent||||entry point|13141
        } /* sar11 */
        

        void s_atn() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||get argument|13142
        xr= C_POP();				// get argument
        //b ||err|1,301|26,atan argument not numeric|||13144
        C_JSR_1(gtrea,(C_ERR(301)));
        //b ||ldr|13,rcval(xr)|||load accumulator with argument|13145
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load accumulator with argument
        //b ||atn||||take arctangent|13146
        {ra_it.d = atan(ra_it.d);fl=(!isgoodnum(ra_it.d));}				// take arctangent
        //b ||brn|6,exrea|||overflow, out of range not possible|13147
         C_GOTO(exrea);				// overflow, out of range not possible
        //b ||ejc|||||13148
        
        //b ||ejc|||||13151
        
//      backspace
//	align	2
//	nop
        //b |s_bsp|ent||||entry point|13155
        } /* s_atn */
        

        void s_bsp() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,317|26,backspace file does not exist|||13159
        extern void _l0405();
        C_JMS(iofcb,P_PRC_IOFCB,_l0405);
        } /* s_bsp */
        

        void _l0405() {
        C_JMS_HANDLE_3(iofcb,(C_ERR(316)),(C_ERR(316)),(C_ERR(317)));
        //b ||err|1,319|26,backspace caused non-recoverable error|||13163
        C_JSR_3(sysbs,(C_ERR(317)),(C_ERR(318)),(C_ERR(319)));
        //b ||brn|6,exnul|||return null as result|13164
         C_GOTO(exnul);				// return null as result
        //b ||ejc|||||13165
        
//      break
//	align	2
//	nop
        //b |s_brk|ent||||entry point|13198
        } /* _l0405 */
        

        void s_brk() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_bks||set pcode for single char case|13199
        wb= (word)(p_bks);				// set pcode for single char case
        //b ||mov|7,xl|22,=p_brk||pcode for multi-char case|13200
        xl= (word)(p_brk);				// pcode for multi-char case
        //b ||mov|8,wc|22,=p_bkd||pcode for expression case|13201
        wc= (word)(p_bkd);				// pcode for expression case
        //b ||err|1,069|26,break argument is not a string or expression|||13203
        extern void _l0406();
        C_JMS(patst,P_PRC_PATST,_l0406);
        } /* s_brk */
        

        void _l0406() {
        C_JMS_HANDLE_1(patst,(C_ERR(69)));
        //b ||mov|11,-(xs)|7,xr||stack result|13204
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|13205
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|13206
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||13207
        
//      breakx
//      breakx is a compound pattern. see description at start
//      of pattern matching section for structure formed.
//	align	2
//	nop
        //b |s_bkx|ent||||entry point|13214
        } /* _l0406 */
        

        void s_bkx() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_bks||pcode for single char argument|13215
        wb= (word)(p_bks);				// pcode for single char argument
        //b ||mov|7,xl|22,=p_brk||pcode for multi-char argument|13216
        xl= (word)(p_brk);				// pcode for multi-char argument
        //b ||mov|8,wc|22,=p_bxd||pcode for expression case|13217
        wc= (word)(p_bxd);				// pcode for expression case
        //b ||err|1,070|26,breakx argument is not a string or expression|||13219
        extern void _l0407();
        C_JMS(patst,P_PRC_PATST,_l0407);
        } /* s_bkx */
        

        void _l0407() {
        C_JMS_HANDLE_1(patst,(C_ERR(70)));
//      now hook breakx node on at front end
        //b ||mov|11,-(xs)|7,xr||save ptr to break node|13223
        C_PUSH(xr);				// save ptr to break node
        //b ||mov|8,wb|22,=p_bkx||set pcode for breakx node|13224
        wb= (word)(p_bkx);				// set pcode for breakx node
        //b ||jsr|6,pbild|||build it|13225
        C_JSR(pbild);				// build it
        //b ||mov|13,pthen(xr)|9,(xs)||set break node as successor|13226
        *((word *)(CFP_B*PTHEN + xr))= *(xs_it.wp);				// set break node as successor
        //b ||mov|8,wb|22,=p_alt||set pcode for alternation node|13227
        wb= (word)(p_alt);				// set pcode for alternation node
        //b ||jsr|6,pbild|||build (parm1=alt=breakx node)|13228
        C_JSR(pbild);				// build (parm1=alt=breakx node)
        //b ||mov|8,wa|7,xr||save ptr to alternation node|13229
        wa= xr;				// save ptr to alternation node
        //b ||mov|7,xr|9,(xs)||point to break node|13230
        xr= *(xs_it.wp);				// point to break node
        //b ||mov|13,pthen(xr)|8,wa||set alternate node as successor|13231
        *((word *)(CFP_B*PTHEN + xr))= wa;				// set alternate node as successor
        //b ||lcw|7,xr|||result on stack|13232
        xr  = *((word *)reg_cp);				// result on stack
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|13233
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||13234
        
//      char
//	align	2
//	nop
        //b |s_chr|ent||||entry point|13238
        } /* _l0407 */
        

        void s_chr() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,schr1|||too big error exit|13241
        extern void _l0408();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0408);
        } /* s_chr */
        

        void _l0408() {
        C_JMS_HANDLE_2(gtsmi,(C_ERR(281)),C_GOTO(schr1));				// too big error exit
        //b ||bge|8,wc|18,=cfp_a|6,schr1|see if out of range of host set|13242
        if ((wc-CFP_A) >= 0) C_GOTO(schr1);				// see if out of range of host set
        //b ||mov|8,wa|18,=num01||if not set scblk allocation|13243
        wa= NUM01;				// if not set scblk allocation
        //b ||mov|8,wb|8,wc||save char code|13244
        wb= wc;				// save char code
        //b ||jsr|6,alocs|||allocate 1 bau scblk|13245
        C_JSR(alocs);				// allocate 1 bau scblk
        //b ||mov|7,xl|7,xr||copy scblk pointer|13246
        xl= xr;				// copy scblk pointer
        //b ||psc|7,xl|||get set to stuff char|13247
        xl += CFP_F;				// get set to stuff char
        //b ||sch|8,wb|9,(xl)||stuff it|13248
        *(xl_it.chp) = wb;				// stuff it
        //b ||csc|7,xl|||complete store character|13249
        //b ||zer|7,xl|||clear slop in xl|13250
        xl=0;				// clear slop in xl
        //b ||mov|11,-(xs)|7,xr||stack result|13251
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|13252
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|13253
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      here if char argument is out of range
// schr1:
        //b |schr1|erb|1,282|26,char argument not in range|||13257
        } /* _l0408 */
        

        void schr1() {
        C_ERB(282)
        //b ||ejc|||||13258
        
//      chop
//	align	2
//	nop
        //b |s_chp|ent||||entry point|13263
        } /* schr1 */
        

        void s_chp() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||get argument|13264
        xr= C_POP();				// get argument
        //b ||err|1,302|26,chop argument not numeric|||13266
        C_JSR_1(gtrea,(C_ERR(302)));
        //b ||ldr|13,rcval(xr)|||load accumulator with argument|13267
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load accumulator with argument
        //b ||chp||||truncate to integer valued real|13268
        {ra_it.d = (long)(ra_it.d);fl=(!isgoodnum(ra_it.d));}				// truncate to integer valued real
        //b ||brn|6,exrea|||no overflow possible|13269
         C_GOTO(exrea);				// no overflow possible
        //b ||ejc|||||13270
        
//      clear
//	align	2
//	nop
        //b |s_clr|ent||||entry point|13275
        } /* s_chp */
        

        void s_clr() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,sclr2|||jump if null|13278
        extern void _l0409();
        C_JMS(xscni,P_PRC_XSCNI,_l0409);
        } /* s_clr */
        

        void _l0409() {
        C_JMS_HANDLE_2(xscni,(C_ERR(71)),C_GOTO(sclr2));				// jump if null
//      loop to scan out names in first argument. variables in
//      the list are flagged by setting vrget of vrblk to zero.
// sclr1:
        //b |sclr1|mov|8,wc|18,=ch_cm||set delimiter one = comma|13283
        C_GOTO(sclr1);
        } /* _l0409 */
        

        void sclr1() {
        wc= CH_CM;				// set delimiter one = comma
        //b ||mov|7,xl|8,wc||delimiter two = comma|13284
        xl= wc;				// delimiter two = comma
        //b ||mnz|8,wa|||skip/trim blanks in prototype|13285
        wa = 0xffffffffffffffff;				// skip/trim blanks in prototype
        //b ||jsr|6,xscan|||scan next variable name|13286
        C_JSR(xscan);				// scan next variable name
        //b ||err|1,072|26,clear argument has null variable name|||13288
        C_JSR_1(gtnvr,(C_ERR(72)));
        //b ||zer|13,vrget(xr)|||else flag by zeroing vrget field|13289
        *((word *)(CFP_B*VRGET + xr))=0;				// else flag by zeroing vrget field
        //b ||bnz|8,wa|6,sclr1||loop back if stopped by comma|13290
        if (wa) C_GOTO(sclr1);				// loop back if stopped by comma
//      here after flagging variables in argument list
// sclr2:
        //b |sclr2|mov|8,wb|3,hshtb||point to start of hash table|13294
        C_GOTO(sclr2);
        } /* sclr1 */
        

        void sclr2() {
        wb= v.hshtb;				// point to start of hash table
//      loop through slots in hash table
// sclr3:
        //b |sclr3|beq|8,wb|3,hshte|6,exnul|exit returning null if none left|13298
        C_GOTO(sclr3);
        } /* sclr2 */
        

        void sclr3() {
        if ((wb-v.hshte) == 0) C_GOTO(exnul);				// exit returning null if none left
        //b ||mov|7,xr|8,wb||else copy slot pointer|13299
        xr= wb;				// else copy slot pointer
        //b ||ica|8,wb|||bump slot pointer|13300
        wb += CFP_B;				// bump slot pointer
        //b ||sub|7,xr|19,*vrnxt||set offset to merge into loop|13301
        xr -= CFP_B*VRNXT;				// set offset to merge into loop
//      loop through vrblks on one hash chain
// sclr4:
        //b |sclr4|mov|7,xr|13,vrnxt(xr)||point to next vrblk on chain|13305
        C_GOTO(sclr4);
        } /* sclr3 */
        

        void sclr4() {
        xr= *((word *)(CFP_B*VRNXT + xr));				// point to next vrblk on chain
        //b ||bze|7,xr|6,sclr3||jump for next bucket if chain end|13306
        if ( !( xr) ) C_GOTO(sclr3);				// jump for next bucket if chain end
        //b ||bnz|13,vrget(xr)|6,sclr5||jump if not flagged|13307
        if (*((word *)(CFP_B*VRGET + xr))) C_GOTO(sclr5);				// jump if not flagged
        //b ||ejc|||||13308
        
//      clear (continued)
//      here for flagged variable, do not set value to null
        //b ||jsr|6,setvr|||for flagged var, restore vrget|13314
        C_JSR(setvr);				// for flagged var, restore vrget
        //b ||brn|6,sclr4|||and loop back for next vrblk|13315
         C_GOTO(sclr4);				// and loop back for next vrblk
//      here to set value of a variable to null
//      protected variables (arb, etc) are exempt
// sclr5:
        //b |sclr5|beq|13,vrsto(xr)|22,=b_vre|6,sclr4|check for protected variable|13320
        } /* sclr4 */
        

        void sclr5() {
        if ((*((word *)(CFP_B*VRSTO + xr))-(word)(b_vre)) == 0) C_GOTO(sclr4);				// check for protected variable
        //b ||mov|7,xl|7,xr||copy vrblk pointer|13321
        xl= xr;				// copy vrblk pointer
//      loop to locate value at end of possible trblk chain
// sclr6:
        //b |sclr6|mov|8,wa|7,xl||save block pointer|13325
        C_GOTO(sclr6);
        } /* sclr5 */
        

        void sclr6() {
        wa= xl;				// save block pointer
        //b ||mov|7,xl|13,vrval(xl)||load next value field|13326
        xl= *((word *)(CFP_B*VRVAL + xl));				// load next value field
        //b ||beq|9,(xl)|22,=b_trt|6,sclr6|loop back if trapped|13327
        if ((*(xl_it.wp)-(word)(b_trt)) == 0) C_GOTO(sclr6);				// loop back if trapped
//      now store the null value
        //b ||mov|7,xl|8,wa||restore block pointer|13331
        xl= wa;				// restore block pointer
        //b ||mov|13,vrval(xl)|21,=nulls||store null constant value|13332
        *((word *)(CFP_B*VRVAL + xl))= (word)(&c.nulls);				// store null constant value
        //b ||brn|6,sclr4|||loop back for next vrblk|13333
         C_GOTO(sclr4);				// loop back for next vrblk
        //b ||ejc|||||13334
        
//      code
//	align	2
//	nop
        //b |s_cod|ent||||entry point|13338
        } /* sclr6 */
        

        void s_cod() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load argument|13339
        xr= C_POP();				// load argument
        //b ||ppm|6,exfal|||fail if conversion is impossible|13341
        C_JSR_1(gtcod,C_GOTO(exfal));				// fail if conversion is impossible
        //b ||mov|11,-(xs)|7,xr||stack result|13342
        C_PUSH(xr);				// stack result
        //b ||zer|3,r_ccb|||forget interim code block|13343
        v.r_ccb=0;				// forget interim code block
        //b ||lcw|7,xr|||get next code word|13344
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|13345
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||13346
        
//      collect
//	align	2
//	nop
        //b |s_col|ent||||entry point|13350
        } /* s_cod */
        

        void s_col() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load argument|13351
        xr= C_POP();				// load argument
        //b ||err|1,073|26,collect argument is not integer|||13353
        C_JSR_1(gtint,(C_ERR(73)));
        //b ||ldi|13,icval(xr)|||load collect argument|13354
        ia = *((word *)(CFP_B*ICVAL + xr));				// load collect argument
        //b ||sti|3,clsvi|||save collect argument|13355
        v.clsvi= ia;				// save collect argument
        //b ||zer|8,wb|||set no move up|13356
        wb=0;				// set no move up
        //b ||zer|3,r_ccb|||forget interim code block|13357
        v.r_ccb=0;				// forget interim code block
        //b ||zer|3,dnams|||collect sediment too|13359
        v.dnams=0;				// collect sediment too
        //b ||jsr|6,gbcol|||perform garbage collection|13360
        C_JSR(gbcol);				// perform garbage collection
        //b ||mov|3,dnams|7,xr||record new sediment size|13361
        v.dnams= xr;				// record new sediment size
        //b ||mov|8,wa|3,dname||point to end of memory|13365
        wa= v.dname;				// point to end of memory
        //b ||sub|8,wa|3,dnamp||subtract next location|13366
        wa -= v.dnamp;				// subtract next location
        //b ||btw|8,wa|||convert bytes to words|13367
        wa >>= LOG_CFP_B;				// convert bytes to words
        //b ||mti|8,wa|||convert words available as integer|13368
        ia = (word)(wa);				// convert words available as integer
        //b ||sbi|3,clsvi|||subtract argument|13369
        ia-=v.clsvi;				// subtract argument
        //b ||iov|6,exfal|||fail if overflow|13370
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// fail if overflow
        //b ||ilt|6,exfal|||fail if not enough|13371
        if (ia < 0)  C_GOTO(exfal);				// fail if not enough
        //b ||adi|3,clsvi|||else recompute available|13372
        ia+=v.clsvi;				// else recompute available
        //b ||brn|6,exint|||and exit with integer result|13373
         C_GOTO(exint);				// and exit with integer result
        //b ||ejc|||||13374
        
//      convert
//	align	2
//	nop
        //b |s_cnv|ent||||entry point|13403
        } /* s_col */
        

        void s_cnv() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,scv29|||error if second argument not string|13405
        extern void _l0410();
        C_JMS(gtstg,P_PRC_GTSTG,_l0410);
        } /* s_cnv */
        

        void _l0410() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(scv29));				// error if second argument not string
        //b ||bze|8,wa|6,scv29||or if null string|13406
        if ( !( wa) ) C_GOTO(scv29);				// or if null string
        //b ||mov|7,xl|9,(xs)||load first argument|13410
        xl= *(xs_it.wp);				// load first argument
        //b ||bne|9,(xl)|22,=b_pdt|6,scv01|jump if not program defined|13411
        if ((*(xl_it.wp)-(word)(b_pdt)) != 0) C_GOTO(scv01);				// jump if not program defined
//      here for program defined datatype
        //b ||mov|7,xl|13,pddfp(xl)||point to dfblk|13415
        xl= *((word *)(CFP_B*PDDFP + xl));				// point to dfblk
        //b ||mov|7,xl|13,dfnam(xl)||load datatype name|13416
        xl= *((word *)(CFP_B*DFNAM + xl));				// load datatype name
        //b ||ppm|6,exits|||exit if ident with arg as result|13418
        C_JSR_1(ident,C_GOTO(exits));				// exit if ident with arg as result
        //b ||brn|6,exfal|||else fail|13419
         C_GOTO(exfal);				// else fail
//      here if not program defined datatype
// scv01:
        //b |scv01|mov|11,-(xs)|7,xr||save string argument|13423
        } /* _l0410 */
        

        void scv01() {
        C_PUSH(xr);				// save string argument
        //b ||mov|7,xl|21,=svctb||point to table of names to compare|13424
        xl= (word)(&c.svctb);				// point to table of names to compare
        //b ||zer|8,wb|||initialize counter|13425
        wb=0;				// initialize counter
        //b ||mov|8,wc|8,wa||save length of argument string|13426
        wc= wa;				// save length of argument string
//      loop through table entries
// scv02:
        //b |scv02|mov|7,xr|10,(xl)+||load next table entry, bump pointer|13430
        C_GOTO(scv02);
        } /* scv01 */
        

        void scv02() {
        xr= *(xl_it.wp++);				// load next table entry, bump pointer
        //b ||bze|7,xr|6,exfal||fail if zero marking end of list|13431
        if ( !( xr) ) C_GOTO(exfal);				// fail if zero marking end of list
        //b ||bne|8,wc|13,sclen(xr)|6,scv05|jump if wrong length|13432
        if ((wc-*((word *)(CFP_B*SCLEN + xr))) != 0) C_GOTO(scv05);				// jump if wrong length
        //b ||mov|3,cnvtp|7,xl||else store table pointer|13433
        v.cnvtp= xl;				// else store table pointer
        //b ||plc|7,xr|||point to chars of table entry|13434
        xr += CFP_F;				// point to chars of table entry
        //b ||mov|7,xl|9,(xs)||load pointer to string argument|13435
        xl= *(xs_it.wp);				// load pointer to string argument
        //b ||plc|7,xl|||point to chars of string arg|13436
        xl += CFP_F;				// point to chars of string arg
        //b ||mov|8,wa|8,wc||set number of chars to compare|13437
        wa= wc;				// set number of chars to compare
        //b ||cmc|6,scv04|6,scv04||compare, jump if no match|13438
        C_CMC_DIFFER(xl_it,xr_it,wa_it,scv04);				// compare, jump if no match
        //b ||ejc|||||13439
        
//      convert (continued)
//      here we have a match
// scv03:
        //b |scv03|mov|7,xl|8,wb||copy entry number|13445
        C_GOTO(scv03);
        } /* scv02 */
        

        void scv03() {
        xl= wb;				// copy entry number
        //b ||ica|7,xs|||pop string arg off stack|13446
        xs += CFP_B;				// pop string arg off stack
        //b ||mov|7,xr|10,(xs)+||load first argument|13447
        xr= C_POP();				// load first argument
        //b ||bsw|7,xl|2,cnvtt||jump to appropriate routine|13448
        extern word _l0412 [];				// jump to appropriate routine
        { w0 = ((word *)_l0412)[xl];  C_GOTO(w0_it.callp);}
        }  /* scv03 */
        

        word  _l0412 [] = {
        //b ||iff|1,0|6,scv06||string|13466
        	(word)((word)(scv06)),				// string
        //b ||iff|1,1|6,scv07||integer|13466
        	(word)((word)(scv07)),				// integer
        //b ||iff|1,2|6,scv09||name|13466
        	(word)((word)(scv09)),				// name
        //b ||iff|1,3|6,scv10||pattern|13466
        	(word)((word)(scv10)),				// pattern
        //b ||iff|1,4|6,scv11||array|13466
        	(word)((word)(scv11)),				// array
        //b ||iff|1,5|6,scv19||table|13466
        	(word)((word)(scv19)),				// table
        //b ||iff|1,6|6,scv25||expression|13466
        	(word)((word)(scv25)),				// expression
        //b ||iff|1,7|6,scv26||code|13466
        	(word)((word)(scv26)),				// code
        //b ||iff|1,8|6,scv27||numeric|13466
        	(word)((word)(scv27)),				// numeric
        //b ||iff|2,cnvrt|6,scv08||real|13466
        	(word)((word)(scv08)),				// real
        //b ||esw||||end of switch table|13466
             }; /* bsw list for _l0412 */				// end of switch table
//      here if no match with table entry
// scv04:
        //b |scv04|mov|7,xl|3,cnvtp||restore table pointer, merge|13470
        void scv04() {
        xl= v.cnvtp;				// restore table pointer, merge
//      merge here if lengths did not match
// scv05:
        //b |scv05|icv|8,wb|||bump entry number|13474
        C_GOTO(scv05);
        } /* scv04 */
        

        void scv05() {
        (wb)++;				// bump entry number
        //b ||brn|6,scv02|||loop back to check next entry|13475
         C_GOTO(scv02);				// loop back to check next entry
//      here to convert to string
// scv06:
        //b |scv06|mov|11,-(xs)|7,xr||replace string argument on stack|13479
        } /* scv05 */
        

        void scv06() {
        C_PUSH(xr);				// replace string argument on stack
        //b ||ppm|6,exfal|||fail if conversion not possible|13481
        extern void _l0413();
        C_JMS(gtstg,P_PRC_GTSTG,_l0413);
        } /* scv06 */
        

        void _l0413() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(exfal));				// fail if conversion not possible
        //b ||mov|11,-(xs)|7,xr||stack result|13482
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|13483
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|13484
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||13485
        
//      convert (continued)
//      here to convert to integer
// scv07:
        //b |scv07|jsr|6,gtint|||convert to integer|13491
        } /* _l0413 */
        

        void scv07() {
        //b ||ppm|6,exfal|||fail if conversion not possible|13492
        C_JSR_1(gtint,C_GOTO(exfal));				// fail if conversion not possible
        //b ||mov|11,-(xs)|7,xr||stack result|13493
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|13494
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|13495
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      here to convert to real
// scv08:
        //b |scv08|jsr|6,gtrea|||convert to real|13501
        } /* scv07 */
        

        void scv08() {
        //b ||ppm|6,exfal|||fail if conversion not possible|13502
        C_JSR_1(gtrea,C_GOTO(exfal));				// fail if conversion not possible
        //b ||mov|11,-(xs)|7,xr||stack result|13503
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|13504
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|13505
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      here to convert to name
// scv09:
        //b |scv09|beq|9,(xr)|22,=b_nml|6,exixr|return if already a name|13510
        } /* scv08 */
        

        void scv09() {
        if ((*(xr_it.wp)-(word)(b_nml)) == 0) C_GOTO(exixr);				// return if already a name
        //b ||ppm|6,exfal|||fail if conversion not possible|13512
        C_JSR_1(gtnvr,C_GOTO(exfal));				// fail if conversion not possible
        //b ||brn|6,exvnm|||else exit building nmblk for vrblk|13513
         C_GOTO(exvnm);				// else exit building nmblk for vrblk
//      here to convert to pattern
// scv10:
        //b |scv10|jsr|6,gtpat|||convert to pattern|13517
        } /* scv09 */
        

        void scv10() {
        //b ||ppm|6,exfal|||fail if conversion not possible|13518
        C_JSR_1(gtpat,C_GOTO(exfal));				// fail if conversion not possible
        //b ||mov|11,-(xs)|7,xr||stack result|13519
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|13520
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|13521
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      convert to array
//      if the first argument is a table, then we go through
//      an intermediate array of addresses that is sorted to
//      provide a result ordered by time of entry in the
//      original table.  see c3.762.
// scv11:
        //b |scv11|mov|11,-(xs)|7,xr||save argument on stack|13530
        } /* scv10 */
        

        void scv11() {
        C_PUSH(xr);				// save argument on stack
        //b ||zer|8,wa|||use table chain block addresses|13531
        wa=0;				// use table chain block addresses
        //b ||ppm|6,exfal|||fail if not convertible|13534
        C_JSR_2(gtarr,C_GOTO(exfal),C_GOTO(exfal));				// fail if not convertible
        //b ||mov|7,xl|10,(xs)+||reload original arg|13535
        xl= C_POP();				// reload original arg
        //b ||bne|9,(xl)|22,=b_tbt|6,exsid|exit if original not a table|13536
        if ((*(xl_it.wp)-(word)(b_tbt)) != 0) C_GOTO(exsid);				// exit if original not a table
        //b ||mov|11,-(xs)|7,xr||sort the intermediate array|13537
        C_PUSH(xr);				// sort the intermediate array
        //b ||mov|11,-(xs)|21,=nulls||on first column|13538
        C_PUSH((word)(&c.nulls));				// on first column
        //b ||zer|8,wa|||sort ascending|13539
        wa=0;				// sort ascending
        //b ||ppm|6,exfal|||if sort fails, so shall we|13541
        extern void _l0414();
        C_JMS(sorta,P_PRC_SORTA,_l0414);
        } /* scv11 */
        

        void _l0414() {
        C_JMS_HANDLE_1(sorta,C_GOTO(exfal));				// if sort fails, so shall we
        //b ||mov|8,wb|7,xr||save array result|13542
        wb= xr;				// save array result
        //b ||ldi|13,ardim(xr)|||load dim 1 (number of elements)|13543
        ia = *((word *)(CFP_B*ARDIM + xr));				// load dim 1 (number of elements)
        //b ||mfi|8,wa|||get as one word integer|13544
        wa = ia;				// get as one word integer
        //b ||lct|8,wa|8,wa||copy to control loop|13545
        wa= wa;				// copy to control loop
        //b ||add|7,xr|19,*arvl2||point to first element in array|13546
        xr += CFP_B*ARVL2;				// point to first element in array
//      here for each row of this 2-column array
// scv12:
        //b |scv12|mov|7,xl|9,(xr)||get teblk address|13550
        C_GOTO(scv12);
        } /* _l0414 */
        

        void scv12() {
        xl= *(xr_it.wp);				// get teblk address
        //b ||mov|10,(xr)+|13,tesub(xl)||replace with subscript|13551
        *(xr_it.wp++)= *((word *)(CFP_B*TESUB + xl));				// replace with subscript
        //b ||mov|10,(xr)+|13,teval(xl)||replace with value|13552
        *(xr_it.wp++)= *((word *)(CFP_B*TEVAL + xl));				// replace with value
        //b ||bct|8,wa|6,scv12||loop till all copied over|13553
        if ((--wa))  C_GOTO(scv12);				// loop till all copied over
        //b ||mov|7,xr|8,wb||retrieve array address|13554
        xr= wb;				// retrieve array address
        //b ||brn|6,exsid|||exit setting id field|13555
         C_GOTO(exsid);				// exit setting id field
//      convert to table
// scv19:
        //b |scv19|mov|8,wa|9,(xr)||load first word of block|13559
        } /* scv12 */
        

        void scv19() {
        wa= *(xr_it.wp);				// load first word of block
        //b ||mov|11,-(xs)|7,xr||replace arblk pointer on stack|13560
        C_PUSH(xr);				// replace arblk pointer on stack
        //b ||beq|8,wa|22,=b_tbt|6,exits|return arg if already a table|13561
        if ((wa-(word)(b_tbt)) == 0) C_GOTO(exits);				// return arg if already a table
        //b ||bne|8,wa|22,=b_art|6,exfal|else fail if not an array|13562
        if ((wa-(word)(b_art)) != 0) C_GOTO(exfal);				// else fail if not an array
        //b ||ejc|||||13563
        
//      convert (continued)
//      here to convert an array to table
        //b ||bne|13,arndm(xr)|18,=num02|6,exfal|fail if not 2-dim array|13569
        if ((*((word *)(CFP_B*ARNDM + xr))-NUM02) != 0) C_GOTO(exfal);				// fail if not 2-dim array
        //b ||ldi|13,ardm2(xr)|||load dim 2|13570
        ia = *((word *)(CFP_B*ARDM2 + xr));				// load dim 2
        //b ||sbi|4,intv2|||subtract 2 to compare|13571
        ia-=c.intv2;				// subtract 2 to compare
        //b ||ine|6,exfal|||fail if dim2 not 2|13572
        if (ia != 0)  C_GOTO(exfal);				// fail if dim2 not 2
//      here we have an arblk of the right shape
        //b ||ldi|13,ardim(xr)|||load dim 1 (number of elements)|13576
        ia = *((word *)(CFP_B*ARDIM + xr));				// load dim 1 (number of elements)
        //b ||mfi|8,wa|||get as one word integer|13577
        wa = ia;				// get as one word integer
        //b ||lct|8,wb|8,wa||copy to control loop|13578
        wb= wa;				// copy to control loop
        //b ||add|8,wa|18,=tbsi_||add space for standard fields|13579
        wa += TBSI_;				// add space for standard fields
        //b ||wtb|8,wa|||convert length to bytes|13580
        wa <<= LOG_CFP_B;				// convert length to bytes
        //b ||jsr|6,alloc|||allocate space for tbblk|13581
        C_JSR(alloc);				// allocate space for tbblk
        //b ||mov|8,wc|7,xr||copy tbblk pointer|13582
        wc= xr;				// copy tbblk pointer
        //b ||mov|11,-(xs)|7,xr||save tbblk pointer|13583
        C_PUSH(xr);				// save tbblk pointer
        //b ||mov|10,(xr)+|22,=b_tbt||store type word|13584
        *(xr_it.wp++)= (word)(b_tbt);				// store type word
        //b ||zer|10,(xr)+|||store zero for idval for now|13585
        *(xr_it.wp++)=0;				// store zero for idval for now
        //b ||mov|10,(xr)+|8,wa||store length|13586
        *(xr_it.wp++)= wa;				// store length
        //b ||mov|10,(xr)+|21,=nulls||null initial lookup value|13587
        *(xr_it.wp++)= (word)(&c.nulls);				// null initial lookup value
//      loop to initialize bucket ptrs to point to table
// scv20:
        //b |scv20|mov|10,(xr)+|8,wc||set bucket ptr to point to tbblk|13591
        C_GOTO(scv20);
        } /* scv19 */
        

        void scv20() {
        *(xr_it.wp++)= wc;				// set bucket ptr to point to tbblk
        //b ||bct|8,wb|6,scv20||loop till all initialized|13592
        if ((--wb))  C_GOTO(scv20);				// loop till all initialized
        //b ||mov|8,wb|19,*arvl2||set offset to first arblk element|13593
        wb= CFP_B*ARVL2;				// set offset to first arblk element
//      loop to copy elements from array to table
// scv21:
        //b |scv21|mov|7,xl|13,num01(xs)||point to arblk|13597
        C_GOTO(scv21);
        } /* scv20 */
        

        void scv21() {
        xl= *((word *)(CFP_B*NUM01 + xs));				// point to arblk
        //b ||beq|8,wb|13,arlen(xl)|6,scv24|jump if all moved|13598
        if ((wb-*((word *)(CFP_B*ARLEN + xl))) == 0) C_GOTO(scv24);				// jump if all moved
        //b ||add|7,xl|8,wb||else point to current location|13599
        xl += wb;				// else point to current location
        //b ||add|8,wb|19,*num02||bump offset|13600
        wb += CFP_B*NUM02;				// bump offset
        //b ||mov|7,xr|9,(xl)||load subscript name|13601
        xr= *(xl_it.wp);				// load subscript name
        //b ||dca|7,xl|||adjust ptr to merge (trval=1+1)|13602
        xl -= CFP_B;				// adjust ptr to merge (trval=1+1)
        //b ||ejc|||||13603
        
//      convert (continued)
//      loop to chase down trblk chain for value
// scv22:
        //b |scv22|mov|7,xl|13,trval(xl)||point to next value|13609
        C_GOTO(scv22);
        } /* scv21 */
        

        void scv22() {
        xl= *((word *)(CFP_B*TRVAL + xl));				// point to next value
        //b ||beq|9,(xl)|22,=b_trt|6,scv22|loop back if trapped|13610
        if ((*(xl_it.wp)-(word)(b_trt)) == 0) C_GOTO(scv22);				// loop back if trapped
//      here with name in xr, value in xl
// scv23:
        //b |scv23|mov|11,-(xs)|7,xl||stack value|13614
        C_GOTO(scv23);
        } /* scv22 */
        

        void scv23() {
        C_PUSH(xl);				// stack value
        //b ||mov|7,xl|13,num01(xs)||load tbblk pointer|13615
        xl= *((word *)(CFP_B*NUM01 + xs));				// load tbblk pointer
        //b ||ppm|6,exfal|||fail if acess fails|13617
        C_JSR_1(tfind,C_GOTO(exfal));				// fail if acess fails
        //b ||mov|13,teval(xl)|10,(xs)+||store value in teblk|13618
        *((word *)(CFP_B*TEVAL + xl))= C_POP();				// store value in teblk
        //b ||brn|6,scv21|||loop back for next element|13619
         C_GOTO(scv21);				// loop back for next element
//      here after moving all elements to tbblk
// scv24:
        //b |scv24|mov|7,xr|10,(xs)+||load tbblk pointer|13623
        } /* scv23 */
        

        void scv24() {
        xr= C_POP();				// load tbblk pointer
        //b ||ica|7,xs|||pop arblk pointer|13624
        xs += CFP_B;				// pop arblk pointer
        //b ||brn|6,exsid|||exit setting idval|13625
         C_GOTO(exsid);				// exit setting idval
//      convert to expression
// scv25:
        //b |scv25|zer|8,wb|||by value|13630
        } /* scv24 */
        

        void scv25() {
        wb=0;				// by value
        //b ||ppm|6,exfal|||fail if conversion not possible|13635
        C_JSR_1(gtexp,C_GOTO(exfal));				// fail if conversion not possible
        //b ||zer|3,r_ccb|||forget interim code block|13636
        v.r_ccb=0;				// forget interim code block
        //b ||mov|11,-(xs)|7,xr||stack result|13637
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|13638
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|13639
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      convert to code
// scv26:
        //b |scv26|jsr|6,gtcod|||convert to code|13643
        } /* scv25 */
        

        void scv26() {
        //b ||ppm|6,exfal|||fail if conversion is not possible|13644
        C_JSR_1(gtcod,C_GOTO(exfal));				// fail if conversion is not possible
        //b ||zer|3,r_ccb|||forget interim code block|13645
        v.r_ccb=0;				// forget interim code block
        //b ||mov|11,-(xs)|7,xr||stack result|13646
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|13647
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|13648
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      convert to numeric
// scv27:
        //b |scv27|jsr|6,gtnum|||convert to numeric|13652
        } /* scv26 */
        

        void scv27() {
        //b ||ppm|6,exfal|||fail if unconvertible|13653
        C_JSR_1(gtnum,C_GOTO(exfal));				// fail if unconvertible
// scv31:
        //b |scv31|mov|11,-(xs)|7,xr||stack result|13654
        C_GOTO(scv31);
        } /* scv27 */
        

        void scv31() {
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|13655
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|13656
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||13657
        
//      second argument not string or null
// scv29:
        //b |scv29|erb|1,074|26,convert second argument is not a string|||13683
        } /* scv31 */
        

        void scv29() {
        C_ERB(74)
//      copy
//	align	2
//	nop
        //b |s_cop|ent||||entry point|13687
        } /* scv29 */
        

        void s_cop() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exits|||return if no idval field|13689
        extern void _l0423();
        C_JMS(copyb,P_PRC_COPYB,_l0423);
        } /* s_cop */
        

        void _l0423() {
        C_JMS_HANDLE_1(copyb,C_GOTO(exits));				// return if no idval field
        //b ||brn|6,exsid|||exit setting id value|13690
         C_GOTO(exsid);				// exit setting id value
        //b ||ejc|||||13691
        
//      cos
//	align	2
//	nop
        //b |s_cos|ent||||entry point|13696
        } /* _l0423 */
        

        void s_cos() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||get argument|13697
        xr= C_POP();				// get argument
        //b ||err|1,303|26,cos argument not numeric|||13699
        C_JSR_1(gtrea,(C_ERR(303)));
        //b ||ldr|13,rcval(xr)|||load accumulator with argument|13700
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load accumulator with argument
        //b ||cos||||take cosine|13701
        {ra_it.d = cos(ra_it.d);fl=(!isgoodnum(ra_it.d));}				// take cosine
        //b ||rno|6,exrea|||if no overflow, return result in ra|13702
        if (fl==0) C_GOTO(exrea);				// if no overflow, return result in ra
        //b ||erb|1,322|26,cos argument is out of range|||13703
        C_ERB(322)
        //b ||ejc|||||13704
        
//      data
//	align	2
//	nop
        //b |s_dat|ent||||entry point|13709
        } /* s_cos */
        

        void s_dat() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,076|26,data argument is null|||13712
        extern void _l0424();
        C_JMS(xscni,P_PRC_XSCNI,_l0424);
        } /* s_dat */
        

        void _l0424() {
        C_JMS_HANDLE_2(xscni,(C_ERR(75)),(C_ERR(76)));
//      scan out datatype name
        //b ||mov|8,wc|18,=ch_pp||delimiter one = left paren|13716
        wc= CH_PP;				// delimiter one = left paren
        //b ||mov|7,xl|8,wc||delimiter two = left paren|13717
        xl= wc;				// delimiter two = left paren
        //b ||mnz|8,wa|||skip/trim blanks in prototype|13718
        wa = 0xffffffffffffffff;				// skip/trim blanks in prototype
        //b ||jsr|6,xscan|||scan datatype name|13719
        C_JSR(xscan);				// scan datatype name
        //b ||bnz|8,wa|6,sdat1||skip if left paren found|13720
        if (wa) C_GOTO(sdat1);				// skip if left paren found
        //b ||erb|1,077|26,data argument is missing a left paren|||13721
        C_ERB(77)
//      here after scanning datatype name
// sdat1:
        //b |sdat1|mov|7,xl|7,xr||save name ptr|13731
        } /* _l0424 */
        

        void sdat1() {
        xl= xr;				// save name ptr
        //b ||mov|8,wa|13,sclen(xr)||get length|13733
        wa= *((word *)(CFP_B*SCLEN + xr));				// get length
        //b ||ctb|8,wa|2,scsi_||compute space needed|13734
        wa += (CFP_B-1)+CFP_B*SCSI_;				// compute space needed
        wa &= 0xfffffffffffffff8;
        //b ||jsr|6,alost|||request static store for name|13735
        C_JSR(alost);				// request static store for name
        //b ||mov|11,-(xs)|7,xr||save datatype name|13736
        C_PUSH(xr);				// save datatype name
        //b ||mvw||||copy name to static|13737
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// copy name to static
        //b ||mov|7,xr|9,(xs)||get name ptr|13738
        xr= *(xs_it.wp);				// get name ptr
        //b ||zer|7,xl|||scrub dud register|13739
        xl=0;				// scrub dud register
        //b ||err|1,078|26,data argument has null datatype name|||13741
        C_JSR_1(gtnvr,(C_ERR(78)));
        //b ||mov|3,datdv|7,xr||save vrblk pointer for datatype|13742
        v.datdv= xr;				// save vrblk pointer for datatype
        //b ||mov|3,datxs|7,xs||store starting stack value|13743
        v.datxs= xs;				// store starting stack value
        //b ||zer|8,wb|||zero count of field names|13744
        wb=0;				// zero count of field names
//      loop to scan field names and stack vrblk pointers
// sdat2:
        //b |sdat2|mov|8,wc|18,=ch_rp||delimiter one = right paren|13748
        C_GOTO(sdat2);
        } /* sdat1 */
        

        void sdat2() {
        wc= CH_RP;				// delimiter one = right paren
        //b ||mov|7,xl|18,=ch_cm||delimiter two = comma|13749
        xl= CH_CM;				// delimiter two = comma
        //b ||mnz|8,wa|||skip/trim blanks in prototype|13750
        wa = 0xffffffffffffffff;				// skip/trim blanks in prototype
        //b ||jsr|6,xscan|||scan next field name|13751
        C_JSR(xscan);				// scan next field name
        //b ||bnz|8,wa|6,sdat3||jump if delimiter found|13752
        if (wa) C_GOTO(sdat3);				// jump if delimiter found
        //b ||erb|1,079|26,data argument is missing a right paren|||13753
        C_ERB(79)
//      here after scanning out one field name
// sdat3:
        //b |sdat3|jsr|6,gtnvr|||locate vrblk for field name|13757
        } /* sdat2 */
        

        void sdat3() {
        //b ||err|1,080|26,data argument has null field name|||13758
        C_JSR_1(gtnvr,(C_ERR(80)));
        //b ||mov|11,-(xs)|7,xr||stack vrblk pointer|13759
        C_PUSH(xr);				// stack vrblk pointer
        //b ||icv|8,wb|||increment counter|13760
        (wb)++;				// increment counter
        //b ||beq|8,wa|18,=num02|6,sdat2|loop back if stopped by comma|13761
        if ((wa-NUM02) == 0) C_GOTO(sdat2);				// loop back if stopped by comma
        //b ||ejc|||||13762
        
//      data (continued)
//      now build the dfblk
        //b ||mov|8,wa|18,=dfsi_||set size of dfblk standard fields|13768
        wa= DFSI_;				// set size of dfblk standard fields
        //b ||add|8,wa|8,wb||add number of fields|13769
        wa += wb;				// add number of fields
        //b ||wtb|8,wa|||convert length to bytes|13770
        wa <<= LOG_CFP_B;				// convert length to bytes
        //b ||mov|8,wc|8,wb||preserve no. of fields|13771
        wc= wb;				// preserve no. of fields
        //b ||jsr|6,alost|||allocate space for dfblk|13772
        C_JSR(alost);				// allocate space for dfblk
        //b ||mov|8,wb|8,wc||get no of fields|13773
        wb= wc;				// get no of fields
        //b ||mov|7,xt|3,datxs||point to start of stack|13774
        xt= v.datxs;				// point to start of stack
        //b ||mov|8,wc|9,(xt)||load datatype name|13775
        wc= *(xt_it.wp);				// load datatype name
        //b ||mov|9,(xt)|7,xr||save dfblk pointer on stack|13776
        *(xt_it.wp)= xr;				// save dfblk pointer on stack
        //b ||mov|10,(xr)+|22,=b_dfc||store type word|13777
        *(xr_it.wp++)= (word)(b_dfc);				// store type word
        //b ||mov|10,(xr)+|8,wb||store number of fields (fargs)|13778
        *(xr_it.wp++)= wb;				// store number of fields (fargs)
        //b ||mov|10,(xr)+|8,wa||store length (dflen)|13779
        *(xr_it.wp++)= wa;				// store length (dflen)
        //b ||sub|8,wa|19,*pddfs||compute pdblk length (for dfpdl)|13780
        wa -= CFP_B*PDDFS;				// compute pdblk length (for dfpdl)
        //b ||mov|10,(xr)+|8,wa||store pdblk length (dfpdl)|13781
        *(xr_it.wp++)= wa;				// store pdblk length (dfpdl)
        //b ||mov|10,(xr)+|8,wc||store datatype name (dfnam)|13782
        *(xr_it.wp++)= wc;				// store datatype name (dfnam)
        //b ||lct|8,wc|8,wb||copy number of fields|13783
        wc= wb;				// copy number of fields
//      loop to move field name vrblk pointers to dfblk
// sdat4:
        //b |sdat4|mov|10,(xr)+|11,-(xt)||move one field name vrblk pointer|13787
        C_GOTO(sdat4);
        } /* sdat3 */
        

        void sdat4() {
        *(xr_it.wp++)= *(--xt_it.wp);				// move one field name vrblk pointer
        //b ||bct|8,wc|6,sdat4||loop till all moved|13788
        if ((--wc))  C_GOTO(sdat4);				// loop till all moved
//      now define the datatype function
        //b ||mov|8,wc|8,wa||copy length of pdblk for later loop|13792
        wc= wa;				// copy length of pdblk for later loop
        //b ||mov|7,xr|3,datdv||point to vrblk|13793
        xr= v.datdv;				// point to vrblk
        //b ||mov|7,xt|3,datxs||point back on stack|13794
        xt= v.datxs;				// point back on stack
        //b ||mov|7,xl|9,(xt)||load dfblk pointer|13795
        xl= *(xt_it.wp);				// load dfblk pointer
        //b ||jsr|6,dffnc|||define function|13796
        C_JSR(dffnc);				// define function
        //b ||ejc|||||13797
        
//      data (continued)
//      loop to build ffblks
//      notice that the ffblks are constructed in reverse order
//      so that the required offsets can be obtained from
//      successive decrementation of the pdblk length (in wc).
// sdat5:
        //b |sdat5|mov|8,wa|19,*ffsi_||set length of ffblk|13808
        C_GOTO(sdat5);
        } /* sdat4 */
        

        void sdat5() {
        wa= CFP_B*FFSI_;				// set length of ffblk
        //b ||jsr|6,alloc|||allocate space for ffblk|13809
        C_JSR(alloc);				// allocate space for ffblk
        //b ||mov|9,(xr)|22,=b_ffc||set type word|13810
        *(xr_it.wp)= (word)(b_ffc);				// set type word
        //b ||mov|13,fargs(xr)|18,=num01||store fargs (always one)|13811
        *((word *)(CFP_B*FARGS + xr))= NUM01;				// store fargs (always one)
        //b ||mov|7,xt|3,datxs||point back on stack|13812
        xt= v.datxs;				// point back on stack
        //b ||mov|13,ffdfp(xr)|9,(xt)||copy dfblk ptr to ffblk|13813
        *((word *)(CFP_B*FFDFP + xr))= *(xt_it.wp);				// copy dfblk ptr to ffblk
        //b ||dca|8,wc|||decrement old dfpdl to get next ofs|13814
        wc -= CFP_B;				// decrement old dfpdl to get next ofs
        //b ||mov|13,ffofs(xr)|8,wc||set offset to this field|13815
        *((word *)(CFP_B*FFOFS + xr))= wc;				// set offset to this field
        //b ||zer|13,ffnxt(xr)|||tentatively set zero forward ptr|13816
        *((word *)(CFP_B*FFNXT + xr))=0;				// tentatively set zero forward ptr
        //b ||mov|7,xl|7,xr||copy ffblk pointer for dffnc|13817
        xl= xr;				// copy ffblk pointer for dffnc
        //b ||mov|7,xr|9,(xs)||load vrblk pointer for field|13818
        xr= *(xs_it.wp);				// load vrblk pointer for field
        //b ||mov|7,xr|13,vrfnc(xr)||load current function pointer|13819
        xr= *((word *)(CFP_B*VRFNC + xr));				// load current function pointer
        //b ||bne|9,(xr)|22,=b_ffc|6,sdat6|skip if not currently a field func|13820
        if ((*(xr_it.wp)-(word)(b_ffc)) != 0) C_GOTO(sdat6);				// skip if not currently a field func
//      here we must chain an old ffblk ptr to preserve it in the
//      case of multiple field functions with the same name
        //b ||mov|13,ffnxt(xl)|7,xr||link new ffblk to previous chain|13825
        *((word *)(CFP_B*FFNXT + xl))= xr;				// link new ffblk to previous chain
//      merge here to define field function
// sdat6:
        //b |sdat6|mov|7,xr|10,(xs)+||load vrblk pointer|13829
        C_GOTO(sdat6);
        } /* sdat5 */
        

        void sdat6() {
        xr= C_POP();				// load vrblk pointer
        //b ||jsr|6,dffnc|||define field function|13830
        C_JSR(dffnc);				// define field function
        //b ||bne|7,xs|3,datxs|6,sdat5|loop back till all done|13831
        if ((xs-v.datxs) != 0) C_GOTO(sdat5);				// loop back till all done
        //b ||ica|7,xs|||pop dfblk pointer|13832
        xs += CFP_B;				// pop dfblk pointer
        //b ||brn|6,exnul|||return with null result|13833
         C_GOTO(exnul);				// return with null result
        //b ||ejc|||||13834
        
//      datatype
//	align	2
//	nop
        //b |s_dtp|ent||||entry point|13838
        } /* sdat6 */
        

        void s_dtp() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load argument|13839
        xr= C_POP();				// load argument
        //b ||jsr|6,dtype|||get datatype|13840
        C_JSR(dtype);				// get datatype
        //b ||mov|11,-(xs)|7,xr||stack result|13841
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|13842
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|13843
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||13844
        
//      date
//	align	2
//	nop
        //b |s_dte|ent||||entry point|13848
        } /* s_dtp */
        

        void s_dte() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load argument|13849
        xr= C_POP();				// load argument
        //b ||err|1,330|26,date argument is not integer|||13851
        C_JSR_1(gtint,(C_ERR(330)));
        //b ||jsr|6,sysdt|||call system date routine|13852
        C_JSR(sysdt);				// call system date routine
        //b ||mov|8,wa|13,num01(xl)||load length for sbstr|13853
        wa= *((word *)(CFP_B*NUM01 + xl));				// load length for sbstr
        //b ||bze|8,wa|6,exnul||return null if length is zero|13854
        if ( !( wa) ) C_GOTO(exnul);				// return null if length is zero
        //b ||zer|8,wb|||set zero offset|13855
        wb=0;				// set zero offset
        //b ||jsr|6,sbstr|||use sbstr to build scblk|13856
        C_JSR(sbstr);				// use sbstr to build scblk
        //b ||mov|11,-(xs)|7,xr||stack result|13857
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|13858
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|13859
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||13860
        
//      define
//	align	2
//	nop
        //b |s_def|ent||||entry point|13864
        } /* s_dte */
        

        void s_def() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load second argument|13865
        xr= C_POP();				// load second argument
        //b ||zer|3,deflb|||zero label pointer in case null|13866
        v.deflb=0;				// zero label pointer in case null
        //b ||beq|7,xr|21,=nulls|6,sdf01|jump if null second argument|13867
        if ((xr-(word)(&c.nulls)) == 0) C_GOTO(sdf01);				// jump if null second argument
        //b ||ppm|6,sdf12|||jump if not a variable name|13869
        C_JSR_1(gtnvr,C_GOTO(sdf12));				// jump if not a variable name
        //b ||mov|3,deflb|7,xr||else set specified entry|13870
        v.deflb= xr;				// else set specified entry
//      scan function name
// sdf01:
        //b |sdf01|jsr|6,xscni|||prepare to scan first argument|13874
        C_GOTO(sdf01);
        } /* s_def */
        

        void sdf01() {
        //b ||err|1,082|26,define first argument is null|||13876
        extern void _l0434();
        C_JMS(xscni,P_PRC_XSCNI,_l0434);
        } /* sdf01 */
        

        void _l0434() {
        C_JMS_HANDLE_2(xscni,(C_ERR(81)),(C_ERR(82)));
        //b ||mov|8,wc|18,=ch_pp||delimiter one = left paren|13877
        wc= CH_PP;				// delimiter one = left paren
        //b ||mov|7,xl|8,wc||delimiter two = left paren|13878
        xl= wc;				// delimiter two = left paren
        //b ||mnz|8,wa|||skip/trim blanks in prototype|13879
        wa = 0xffffffffffffffff;				// skip/trim blanks in prototype
        //b ||jsr|6,xscan|||scan out function name|13880
        C_JSR(xscan);				// scan out function name
        //b ||bnz|8,wa|6,sdf02||jump if left paren found|13881
        if (wa) C_GOTO(sdf02);				// jump if left paren found
        //b ||erb|1,083|26,define first argument is missing a left paren|||13882
        C_ERB(83)
//      here after scanning out function name
// sdf02:
        //b |sdf02|jsr|6,gtnvr|||get variable name|13886
        } /* _l0434 */
        

        void sdf02() {
        //b ||err|1,084|26,define first argument has null function name|||13887
        C_JSR_1(gtnvr,(C_ERR(84)));
        //b ||mov|3,defvr|7,xr||save vrblk pointer for function nam|13888
        v.defvr= xr;				// save vrblk pointer for function nam
        //b ||zer|8,wb|||zero count of arguments|13889
        wb=0;				// zero count of arguments
        //b ||mov|3,defxs|7,xs||save initial stack pointer|13890
        v.defxs= xs;				// save initial stack pointer
        //b ||bnz|3,deflb|6,sdf03||jump if second argument given|13891
        if (v.deflb) C_GOTO(sdf03);				// jump if second argument given
        //b ||mov|3,deflb|7,xr||else default is function name|13892
        v.deflb= xr;				// else default is function name
//      loop to scan argument names and stack vrblk pointers
// sdf03:
        //b |sdf03|mov|8,wc|18,=ch_rp||delimiter one = right paren|13896
        C_GOTO(sdf03);
        } /* sdf02 */
        

        void sdf03() {
        wc= CH_RP;				// delimiter one = right paren
        //b ||mov|7,xl|18,=ch_cm||delimiter two = comma|13897
        xl= CH_CM;				// delimiter two = comma
        //b ||mnz|8,wa|||skip/trim blanks in prototype|13898
        wa = 0xffffffffffffffff;				// skip/trim blanks in prototype
        //b ||jsr|6,xscan|||scan out next argument name|13899
        C_JSR(xscan);				// scan out next argument name
        //b ||bnz|8,wa|6,sdf04||skip if delimiter found|13900
        if (wa) C_GOTO(sdf04);				// skip if delimiter found
        //b ||erb|1,085|26,null arg name or missing ) in define first arg.|||13901
        C_ERB(85)
        //b ||ejc|||||13902
        
//      define (continued)
//      here after scanning an argument name
// sdf04:
        //b |sdf04|bne|7,xr|21,=nulls|6,sdf05|skip if non-null|13908
        } /* sdf03 */
        

        void sdf04() {
        if ((xr-(word)(&c.nulls)) != 0) C_GOTO(sdf05);				// skip if non-null
        //b ||bze|8,wb|6,sdf06||ignore null if case of no arguments|13909
        if ( !( wb) ) C_GOTO(sdf06);				// ignore null if case of no arguments
//      here after dealing with the case of no arguments
// sdf05:
        //b |sdf05|jsr|6,gtnvr|||get vrblk pointer|13913
        C_GOTO(sdf05);
        } /* sdf04 */
        

        void sdf05() {
        //b ||ppm|6,sdf03|||loop back to ignore null name|13914
        C_JSR_1(gtnvr,C_GOTO(sdf03));				// loop back to ignore null name
        //b ||mov|11,-(xs)|7,xr||stack argument vrblk pointer|13915
        C_PUSH(xr);				// stack argument vrblk pointer
        //b ||icv|8,wb|||increment counter|13916
        (wb)++;				// increment counter
        //b ||beq|8,wa|18,=num02|6,sdf03|loop back if stopped by a comma|13917
        if ((wa-NUM02) == 0) C_GOTO(sdf03);				// loop back if stopped by a comma
//      here after scanning out function argument names
// sdf06:
        //b |sdf06|mov|3,defna|8,wb||save number of arguments|13921
        C_GOTO(sdf06);
        } /* sdf05 */
        

        void sdf06() {
        v.defna= wb;				// save number of arguments
        //b ||zer|8,wb|||zero count of locals|13922
        wb=0;				// zero count of locals
//      loop to scan local names and stack vrblk pointers
// sdf07:
        //b |sdf07|mov|8,wc|18,=ch_cm||set delimiter one = comma|13926
        C_GOTO(sdf07);
        } /* sdf06 */
        

        void sdf07() {
        wc= CH_CM;				// set delimiter one = comma
        //b ||mov|7,xl|8,wc||set delimiter two = comma|13927
        xl= wc;				// set delimiter two = comma
        //b ||mnz|8,wa|||skip/trim blanks in prototype|13928
        wa = 0xffffffffffffffff;				// skip/trim blanks in prototype
        //b ||jsr|6,xscan|||scan out next local name|13929
        C_JSR(xscan);				// scan out next local name
        //b ||bne|7,xr|21,=nulls|6,sdf08|skip if non-null|13930
        if ((xr-(word)(&c.nulls)) != 0) C_GOTO(sdf08);				// skip if non-null
        //b ||bze|8,wa|6,sdf09||exit scan if end of string|13931
        if ( !( wa) ) C_GOTO(sdf09);				// exit scan if end of string
//      here after scanning out a local name
// sdf08:
        //b |sdf08|jsr|6,gtnvr|||get vrblk pointer|13935
        C_GOTO(sdf08);
        } /* sdf07 */
        

        void sdf08() {
        //b ||ppm|6,sdf07|||loop back to ignore null name|13936
        C_JSR_1(gtnvr,C_GOTO(sdf07));				// loop back to ignore null name
        //b ||icv|8,wb|||if ok, increment count|13937
        (wb)++;				// if ok, increment count
        //b ||mov|11,-(xs)|7,xr||stack vrblk pointer|13938
        C_PUSH(xr);				// stack vrblk pointer
        //b ||bnz|8,wa|6,sdf07||loop back if stopped by a comma|13939
        if (wa) C_GOTO(sdf07);				// loop back if stopped by a comma
        //b ||ejc|||||13940
        
//      define (continued)
//      here after scanning locals, build pfblk
// sdf09:
        //b |sdf09|mov|8,wa|8,wb||copy count of locals|13946
        C_GOTO(sdf09);
        } /* sdf08 */
        

        void sdf09() {
        wa= wb;				// copy count of locals
        //b ||add|8,wa|3,defna||add number of arguments|13947
        wa += v.defna;				// add number of arguments
        //b ||mov|8,wc|8,wa||set sum args+locals as loop count|13948
        wc= wa;				// set sum args+locals as loop count
        //b ||add|8,wa|18,=pfsi_||add space for standard fields|13949
        wa += PFSI_;				// add space for standard fields
        //b ||wtb|8,wa|||convert length to bytes|13950
        wa <<= LOG_CFP_B;				// convert length to bytes
        //b ||jsr|6,alloc|||allocate space for pfblk|13951
        C_JSR(alloc);				// allocate space for pfblk
        //b ||mov|7,xl|7,xr||save pointer to pfblk|13952
        xl= xr;				// save pointer to pfblk
        //b ||mov|10,(xr)+|22,=b_pfc||store first word|13953
        *(xr_it.wp++)= (word)(b_pfc);				// store first word
        //b ||mov|10,(xr)+|3,defna||store number of arguments|13954
        *(xr_it.wp++)= v.defna;				// store number of arguments
        //b ||mov|10,(xr)+|8,wa||store length (pflen)|13955
        *(xr_it.wp++)= wa;				// store length (pflen)
        //b ||mov|10,(xr)+|3,defvr||store vrblk ptr for function name|13956
        *(xr_it.wp++)= v.defvr;				// store vrblk ptr for function name
        //b ||mov|10,(xr)+|8,wb||store number of locals|13957
        *(xr_it.wp++)= wb;				// store number of locals
        //b ||zer|10,(xr)+|||deal with label later|13958
        *(xr_it.wp++)=0;				// deal with label later
        //b ||zer|10,(xr)+|||zero pfctr|13959
        *(xr_it.wp++)=0;				// zero pfctr
        //b ||zer|10,(xr)+|||zero pfrtr|13960
        *(xr_it.wp++)=0;				// zero pfrtr
        //b ||bze|8,wc|6,sdf11||skip if no args or locals|13961
        if ( !( wc) ) C_GOTO(sdf11);				// skip if no args or locals
        //b ||mov|8,wa|7,xl||keep pfblk pointer|13962
        wa= xl;				// keep pfblk pointer
        //b ||mov|7,xt|3,defxs||point before arguments|13963
        xt= v.defxs;				// point before arguments
        //b ||lct|8,wc|8,wc||get count of args+locals for loop|13964
        wc= wc;				// get count of args+locals for loop
//      loop to move locals and args to pfblk
// sdf10:
        //b |sdf10|mov|10,(xr)+|11,-(xt)||store one entry and bump pointers|13968
        C_GOTO(sdf10);
        } /* sdf09 */
        

        void sdf10() {
        *(xr_it.wp++)= *(--xt_it.wp);				// store one entry and bump pointers
        //b ||bct|8,wc|6,sdf10||loop till all stored|13969
        if ((--wc))  C_GOTO(sdf10);				// loop till all stored
        //b ||mov|7,xl|8,wa||recover pfblk pointer|13970
        xl= wa;				// recover pfblk pointer
        //b ||ejc|||||13971
        
//      define (continued)
//      now deal with label
// sdf11:
        //b |sdf11|mov|7,xs|3,defxs||pop stack|13977
        C_GOTO(sdf11);
        } /* sdf10 */
        

        void sdf11() {
        xs= v.defxs;				// pop stack
        //b ||mov|13,pfcod(xl)|3,deflb||store label vrblk in pfblk|13978
        *((word *)(CFP_B*PFCOD + xl))= v.deflb;				// store label vrblk in pfblk
        //b ||mov|7,xr|3,defvr||point back to vrblk for function|13979
        xr= v.defvr;				// point back to vrblk for function
        //b ||jsr|6,dffnc|||define function|13980
        C_JSR(dffnc);				// define function
        //b ||brn|6,exnul|||and exit returning null|13981
         C_GOTO(exnul);				// and exit returning null
//      here for erroneous label
// sdf12:
        //b |sdf12|erb|1,086|26,define function entry point is not defined label|||13985
        } /* sdf11 */
        

        void sdf12() {
        C_ERB(86)
        //b ||ejc|||||13986
        
//      detach
//	align	2
//	nop
        //b |s_det|ent||||entry point|13990
        } /* sdf12 */
        

        void s_det() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load argument|13991
        xr= C_POP();				// load argument
        //b ||err|1,087|26,detach argument is not appropriate name|||13993
        C_JSR_1(gtvar,(C_ERR(87)));
        //b ||jsr|6,dtach|||detach i/o association from name|13994
        C_JSR(dtach);				// detach i/o association from name
        //b ||brn|6,exnul|||return null result|13995
         C_GOTO(exnul);				// return null result
        //b ||ejc|||||13996
        
//      differ
//	align	2
//	nop
        //b |s_dif|ent||||entry point|14000
        } /* s_det */
        

        void s_dif() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load second argument|14001
        xr= C_POP();				// load second argument
        //b ||mov|7,xl|10,(xs)+||load first argument|14002
        xl= C_POP();				// load first argument
        //b ||ppm|6,exfal|||fail if ident|14004
        C_JSR_1(ident,C_GOTO(exfal));				// fail if ident
        //b ||brn|6,exnul|||return null if differ|14005
         C_GOTO(exnul);				// return null if differ
        //b ||ejc|||||14006
        
//      dump
//	align	2
//	nop
        //b |s_dmp|ent||||entry point|14010
        } /* s_dif */
        

        void s_dmp() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,089|26,dump argument is negative or too large|||14013
        extern void _l0447();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0447);
        } /* s_dmp */
        

        void _l0447() {
        C_JMS_HANDLE_2(gtsmi,(C_ERR(88)),(C_ERR(89)));
        //b ||jsr|6,dumpr|||else call dump routine|14014
        C_JSR(dumpr);				// else call dump routine
        //b ||brn|6,exnul|||and return null as result|14015
         C_GOTO(exnul);				// and return null as result
        //b ||ejc|||||14016
        
//      dupl
//	align	2
//	nop
        //b |s_dup|ent||||entry point|14020
        } /* _l0447 */
        

        void s_dup() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,sdup7|||jump if negative or too big|14023
        extern void _l0448();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0448);
        } /* s_dup */
        

        void _l0448() {
        C_JMS_HANDLE_2(gtsmi,(C_ERR(90)),C_GOTO(sdup7));				// jump if negative or too big
        //b ||mov|8,wb|7,xr||save duplication factor|14024
        wb= xr;				// save duplication factor
        //b ||ppm|6,sdup4|||jump if not a string|14026
        extern void _l0449();
        C_JMS(gtstg,P_PRC_GTSTG,_l0449);
        } /* _l0448 */
        

        void _l0449() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(sdup4));				// jump if not a string
//      here for case of duplication of a string
        //b ||mti|8,wa|||acquire length as integer|14030
        ia = (word)(wa);				// acquire length as integer
        //b ||sti|3,dupsi|||save for the moment|14031
        v.dupsi= ia;				// save for the moment
        //b ||mti|8,wb|||get duplication factor as integer|14032
        ia = (word)(wb);				// get duplication factor as integer
        //b ||mli|3,dupsi|||form product|14033
        ia*=v.dupsi;				// form product
        //b ||iov|6,sdup3|||jump if overflow|14034
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// jump if overflow
        //b ||ieq|6,exnul|||return null if result length = 0|14035
        if (ia == 0)  C_GOTO(exnul);				// return null if result length = 0
        //b ||mfi|8,wa|6,sdup3||get as addr integer, check ovflo|14036
        if (ia<0) C_GOTO( sdup3);				// get as addr integer, check ovflo
        wa = ia;
//      merge here with result length in wa
// sdup1:
        //b |sdup1|mov|7,xl|7,xr||save string pointer|14040
        C_GOTO(sdup1);
        } /* _l0449 */
        

        void sdup1() {
        xl= xr;				// save string pointer
        //b ||jsr|6,alocs|||allocate space for string|14041
        C_JSR(alocs);				// allocate space for string
        //b ||mov|11,-(xs)|7,xr||save as result pointer|14042
        C_PUSH(xr);				// save as result pointer
        //b ||mov|8,wc|7,xl||save pointer to argument string|14043
        wc= xl;				// save pointer to argument string
        //b ||psc|7,xr|||prepare to store chars of result|14044
        xr += CFP_F;				// prepare to store chars of result
        //b ||lct|8,wb|8,wb||set counter to control loop|14045
        wb= wb;				// set counter to control loop
//      loop through duplications
// sdup2:
        //b |sdup2|mov|7,xl|8,wc||point back to argument string|14049
        C_GOTO(sdup2);
        } /* sdup1 */
        

        void sdup2() {
        xl= wc;				// point back to argument string
        //b ||mov|8,wa|13,sclen(xl)||get number of characters|14050
        wa= *((word *)(CFP_B*SCLEN + xl));				// get number of characters
        //b ||plc|7,xl|||point to chars in argument string|14051
        xl += CFP_F;				// point to chars in argument string
        //b ||mvc||||move characters to result string|14052
        do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);				// move characters to result string
        //b ||bct|8,wb|6,sdup2||loop till all duplications done|14053
        if ((--wb))  C_GOTO(sdup2);				// loop till all duplications done
        //b ||zer|7,xl|||clear garbage value|14054
        xl=0;				// clear garbage value
        //b ||lcw|7,xr|||get next code word|14055
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|14056
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||14057
        
//      dupl (continued)
//      here if too large, set max length and let alocs catch it
// sdup3:
        //b |sdup3|mov|8,wa|3,dname||set impossible length for alocs|14063
        } /* sdup2 */
        

        void sdup3() {
        wa= v.dname;				// set impossible length for alocs
        //b ||brn|6,sdup1|||merge back|14064
         C_GOTO(sdup1);				// merge back
//      here if not a string
// sdup4:
        //b |sdup4|jsr|6,gtpat|||convert argument to pattern|14068
        } /* sdup3 */
        

        void sdup4() {
        //b ||err|1,091|26,dupl first argument is not a string or pattern|||14069
        C_JSR_1(gtpat,(C_ERR(91)));
//      here to duplicate a pattern argument
        //b ||mov|11,-(xs)|7,xr||store pattern on stack|14073
        C_PUSH(xr);				// store pattern on stack
        //b ||mov|7,xr|21,=ndnth||start off with null pattern|14074
        xr= (word)(&c.ndnth);				// start off with null pattern
        //b ||bze|8,wb|6,sdup6||null pattern is result if dupfac=0|14075
        if ( !( wb) ) C_GOTO(sdup6);				// null pattern is result if dupfac=0
        //b ||mov|11,-(xs)|8,wb||preserve loop count|14076
        C_PUSH(wb);				// preserve loop count
//      loop to duplicate by successive concatenation
// sdup5:
        //b |sdup5|mov|7,xl|7,xr||copy current value as right argumnt|14080
        C_GOTO(sdup5);
        } /* sdup4 */
        

        void sdup5() {
        xl= xr;				// copy current value as right argumnt
        //b ||mov|7,xr|13,num01(xs)||get a new copy of left|14081
        xr= *((word *)(CFP_B*NUM01 + xs));				// get a new copy of left
        //b ||jsr|6,pconc|||concatenate|14082
        C_JSR(pconc);				// concatenate
        //b ||dcv|9,(xs)|||count down|14083
        (*(xs_it.wp))--;				// count down
        //b ||bnz|9,(xs)|6,sdup5||loop|14084
        if (*(xs_it.wp)) C_GOTO(sdup5);				// loop
        //b ||ica|7,xs|||pop loop count|14085
        xs += CFP_B;				// pop loop count
//      here to exit after constructing pattern
// sdup6:
        //b |sdup6|mov|9,(xs)|7,xr||store result on stack|14089
        C_GOTO(sdup6);
        } /* sdup5 */
        

        void sdup6() {
        *(xs_it.wp)= xr;				// store result on stack
        //b ||lcw|7,xr|||get next code word|14090
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|14091
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
//      fail if second arg is out of range
// sdup7:
        //b |sdup7|ica|7,xs|||pop first argument|14095
        } /* sdup6 */
        

        void sdup7() {
        xs += CFP_B;				// pop first argument
        //b ||brn|6,exfal|||fail|14096
         C_GOTO(exfal);				// fail
        //b ||ejc|||||14097
        
//      eject
//	align	2
//	nop
        //b |s_ejc|ent||||entry point|14101
        } /* sdup7 */
        

        void s_ejc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,093|26,eject file does not exist|||14105
        extern void _l0451();
        C_JMS(iofcb,P_PRC_IOFCB,_l0451);
        } /* s_ejc */
        

        void _l0451() {
        C_JMS_HANDLE_3(iofcb,(C_ERR(92)),C_GOTO(sejc1),(C_ERR(93)));
        //b ||err|1,095|26,eject caused non-recoverable output error|||14109
        C_JSR_3(sysef,(C_ERR(93)),(C_ERR(94)),(C_ERR(95)));
        //b ||brn|6,exnul|||return null as result|14110
         C_GOTO(exnul);				// return null as result
//      here to eject standard output file
// sejc1:
        //b |sejc1|jsr|6,sysep|||call routine to eject printer|14114
        } /* _l0451 */
        

        void sejc1() {
        C_JSR(sysep);				// call routine to eject printer
        //b ||brn|6,exnul|||exit with null result|14115
         C_GOTO(exnul);				// exit with null result
        //b ||ejc|||||14116
        
//      endfile
//	align	2
//	nop
        //b |s_enf|ent||||entry point|14120
        } /* sejc1 */
        

        void s_enf() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,098|26,endfile file does not exist|||14124
        extern void _l0452();
        C_JMS(iofcb,P_PRC_IOFCB,_l0452);
        } /* s_enf */
        

        void _l0452() {
        C_JMS_HANDLE_3(iofcb,(C_ERR(96)),(C_ERR(97)),(C_ERR(98)));
        //b ||err|1,100|26,endfile caused non-recoverable output error|||14128
        C_JSR_3(sysen,(C_ERR(98)),(C_ERR(99)),(C_ERR(100)));
        //b ||mov|8,wb|7,xl||remember vrblk ptr from iofcb call|14129
        wb= xl;				// remember vrblk ptr from iofcb call
        //b ||mov|7,xr|7,xl||copy pointer|14130
        xr= xl;				// copy pointer
//      loop to find trtrf block
// senf1:
        //b |senf1|mov|7,xl|7,xr||remember previous entry|14134
        C_GOTO(senf1);
        } /* _l0452 */
        

        void senf1() {
        xl= xr;				// remember previous entry
        //b ||mov|7,xr|13,trval(xr)||chain along|14135
        xr= *((word *)(CFP_B*TRVAL + xr));				// chain along
        //b ||bne|9,(xr)|22,=b_trt|6,exnul|skip out if chain end|14136
        if ((*(xr_it.wp)-(word)(b_trt)) != 0) C_GOTO(exnul);				// skip out if chain end
        //b ||bne|13,trtyp(xr)|18,=trtfc|6,senf1|loop if not found|14137
        if ((*((word *)(CFP_B*TRTYP + xr))-TRTFC) != 0) C_GOTO(senf1);				// loop if not found
        //b ||mov|13,trval(xl)|13,trval(xr)||remove trtrf|14138
        *((word *)(CFP_B*TRVAL + xl))= *((word *)(CFP_B*TRVAL + xr));				// remove trtrf
        //b ||mov|3,enfch|13,trtrf(xr)||point to head of iochn|14139
        v.enfch= *((word *)(CFP_B*TRTRF + xr));				// point to head of iochn
        //b ||mov|8,wc|13,trfpt(xr)||point to fcblk|14140
        wc= *((word *)(CFP_B*TRFPT + xr));				// point to fcblk
        //b ||mov|7,xr|8,wb||filearg1 vrblk from iofcb|14141
        xr= wb;				// filearg1 vrblk from iofcb
        //b ||jsr|6,setvr|||reset it|14142
        C_JSR(setvr);				// reset it
        //b ||mov|7,xl|20,=r_fcb||ptr to head of fcblk chain|14143
        xl= (word)(&v.r_fcb);				// ptr to head of fcblk chain
        //b ||sub|7,xl|19,*num02||adjust ready to enter loop|14144
        xl -= CFP_B*NUM02;				// adjust ready to enter loop
//      find fcblk
// senf2:
        //b |senf2|mov|7,xr|7,xl||copy ptr|14148
        C_GOTO(senf2);
        } /* senf1 */
        

        void senf2() {
        xr= xl;				// copy ptr
        //b ||mov|7,xl|13,num02(xl)||get next link|14149
        xl= *((word *)(CFP_B*NUM02 + xl));				// get next link
        //b ||bze|7,xl|6,senf4||stop if chain end|14150
        if ( !( xl) ) C_GOTO(senf4);				// stop if chain end
        //b ||beq|13,num03(xl)|8,wc|6,senf3|jump if fcblk found|14151
        if ((*((word *)(CFP_B*NUM03 + xl))-wc) == 0) C_GOTO(senf3);				// jump if fcblk found
        //b ||brn|6,senf2|||loop|14152
         C_GOTO(senf2);				// loop
//      remove fcblk
// senf3:
        //b |senf3|mov|13,num02(xr)|13,num02(xl)||delete fcblk from chain|14156
        } /* senf2 */
        

        void senf3() {
        *((word *)(CFP_B*NUM02 + xr))= *((word *)(CFP_B*NUM02 + xl));				// delete fcblk from chain
//      loop which detaches all vbls on iochn chain
// senf4:
        //b |senf4|mov|7,xl|3,enfch||get chain head|14160
        C_GOTO(senf4);
        } /* senf3 */
        

        void senf4() {
        xl= v.enfch;				// get chain head
        //b ||bze|7,xl|6,exnul||finished if chain end|14161
        if ( !( xl) ) C_GOTO(exnul);				// finished if chain end
        //b ||mov|3,enfch|13,trtrf(xl)||chain along|14162
        v.enfch= *((word *)(CFP_B*TRTRF + xl));				// chain along
        //b ||mov|8,wa|13,ionmo(xl)||name offset|14163
        wa= *((word *)(CFP_B*IONMO + xl));				// name offset
        //b ||mov|7,xl|13,ionmb(xl)||name base|14164
        xl= *((word *)(CFP_B*IONMB + xl));				// name base
        //b ||jsr|6,dtach|||detach name|14165
        C_JSR(dtach);				// detach name
        //b ||brn|6,senf4|||loop till done|14166
         C_GOTO(senf4);				// loop till done
        //b ||ejc|||||14167
        
//      eq
//	align	2
//	nop
        //b |s_eqf|ent||||entry point|14171
        } /* senf4 */
        

        void s_eqf() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exfal|||fail if gt|14177
        extern void _l0453();
        C_JMS(acomp,P_PRC_ACOMP,_l0453);
        } /* s_eqf */
        

        void _l0453() {
        C_JMS_HANDLE_5(acomp,(C_ERR(101)),(C_ERR(102)),C_GOTO(exfal),C_GOTO(exnul),C_GOTO(exfal));				// fail if gt
        //b ||ejc|||||14178
        
//      eval
//	align	2
//	nop
        //b |s_evl|ent||||entry point|14182
        C_GOTO(s_evl);
        } /* _l0453 */
        

        void s_evl() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load argument|14183
        xr= C_POP();				// load argument
        //b ||lcw|8,wc|||load next code word|14189
        wc  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||bne|8,wc|21,=ofne_|6,sevl1|jump if called by value|14190
        if ((wc-(word)(&c.ofne_)) != 0) C_GOTO(sevl1);				// jump if called by value
        //b ||scp|7,xl|||copy code pointer|14191
        xl= reg_cp;				// copy code pointer
        //b ||mov|8,wa|9,(xl)||get next code word|14192
        wa= *(xl_it.wp);				// get next code word
        //b ||bne|8,wa|21,=ornm_|6,sevl2|by name unless expression|14193
        if ((wa-(word)(&c.ornm_)) != 0) C_GOTO(sevl2);				// by name unless expression
        //b ||bnz|13,num01(xs)|6,sevl2||jump if by name|14194
        if (*((word *)(CFP_B*NUM01 + xs))) C_GOTO(sevl2);				// jump if by name
//      here if called by value
// sevl1:
        //b |sevl1|zer|8,wb|||set flag for by value|14198
        C_GOTO(sevl1);
        } /* s_evl */
        

        void sevl1() {
        wb=0;				// set flag for by value
        //b ||mov|11,-(xs)|8,wc||save code word|14200
        C_PUSH(wc);				// save code word
        //b ||err|1,103|26,eval argument is not expression|||14202
        C_JSR_1(gtexp,(C_ERR(103)));
        //b ||zer|3,r_ccb|||forget interim code block|14203
        v.r_ccb=0;				// forget interim code block
        //b ||zer|8,wb|||set flag for by value|14204
        wb=0;				// set flag for by value
        //b ||ppm|6,exfal|||fail if evaluation fails|14209
        C_JSR_1(evalx,C_GOTO(exfal));				// fail if evaluation fails
        //b ||mov|7,xl|7,xr||copy result|14210
        xl= xr;				// copy result
        //b ||mov|7,xr|9,(xs)||reload next code word|14211
        xr= *(xs_it.wp);				// reload next code word
        //b ||mov|9,(xs)|7,xl||stack result|14212
        *(xs_it.wp)= xl;				// stack result
        //b ||bri|9,(xr)|||jump to execute next code word|14213
        w0 = xr_it.wp[0];				// jump to execute next code word
        C_GOTO(w0_it.callp);
//      here if called by name
// sevl2:
        //b |sevl2|mov|8,wb|18,=num01||set flag for by name|14217
        } /* sevl1 */
        

        void sevl2() {
        wb= NUM01;				// set flag for by name
        //b ||err|1,103|26,eval argument is not expression|||14220
        C_JSR_1(gtexp,(C_ERR(103)));
        //b ||zer|3,r_ccb|||forget interim code block|14221
        v.r_ccb=0;				// forget interim code block
        //b ||mov|8,wb|18,=num01||set flag for by name|14222
        wb= NUM01;				// set flag for by name
        //b ||ppm|6,exfal|||fail if evaluation fails|14225
        C_JSR_1(evalx,C_GOTO(exfal));				// fail if evaluation fails
        //b ||brn|6,exnam|||exit with name|14226
         C_GOTO(exnam);				// exit with name
        //b ||ejc|||||14229
        
//      exit
//	align	2
//	nop
        //b |s_ext|ent||||entry point|14233
        } /* sevl2 */
        

        void s_ext() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||zer|8,wb|||clear amount of static shift|14234
        wb=0;				// clear amount of static shift
        //b ||zer|3,r_ccb|||forget interim code block|14235
        v.r_ccb=0;				// forget interim code block
        //b ||zer|3,dnams|||collect sediment too|14237
        v.dnams=0;				// collect sediment too
        //b ||jsr|6,gbcol|||compact memory by collecting|14238
        C_JSR(gbcol);				// compact memory by collecting
        //b ||mov|3,dnams|7,xr||record new sediment size|14239
        v.dnams= xr;				// record new sediment size
        //b ||err|1,288|26,exit second argument is not a string|||14244
        extern void _l0454();
        C_JMS(gtstg,P_PRC_GTSTG,_l0454);
        } /* s_ext */
        

        void _l0454() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(288)));
        //b ||mov|7,xl|7,xr||copy second arg string pointer|14245
        xl= xr;				// copy second arg string pointer
        //b ||err|1,104|26,exit first argument is not suitable integer or string|||14247
        extern void _l0455();
        C_JMS(gtstg,P_PRC_GTSTG,_l0455);
        } /* _l0454 */
        

        void _l0455() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(104)));
        //b ||mov|11,-(xs)|7,xl||save second argument|14248
        C_PUSH(xl);				// save second argument
        //b ||mov|7,xl|7,xr||copy first arg string ptr|14249
        xl= xr;				// copy first arg string ptr
        //b ||ppm|6,sext1|||skip if unconvertible|14251
        C_JSR_1(gtint,C_GOTO(sext1));				// skip if unconvertible
        //b ||zer|7,xl|||note it is integer|14252
        xl=0;				// note it is integer
        //b ||ldi|13,icval(xr)|||get integer arg|14253
        ia = *((word *)(CFP_B*ICVAL + xr));				// get integer arg
//      merge to call osint exit routine
// sext1:
        //b |sext1|mov|8,wb|3,r_fcb||get fcblk chain header|14257
        C_GOTO(sext1);
        } /* _l0455 */
        

        void sext1() {
        wb= v.r_fcb;				// get fcblk chain header
        //b ||mov|7,xr|21,=headv||point to v.v string|14258
        xr= (word)(&c.headv);				// point to v.v string
        //b ||mov|8,wa|10,(xs)+||provide second argument scblk|14259
        wa= C_POP();				// provide second argument scblk
        //b ||err|1,106|26,exit action caused irrecoverable error|||14262
        C_JSR_2(sysxi,(C_ERR(105)),(C_ERR(106)));
        //b ||ieq|6,exnul|||return if argument 0|14263
        if (ia == 0)  C_GOTO(exnul);				// return if argument 0
        //b ||igt|6,sext2|||skip if positive|14264
        if (ia > 0)  C_GOTO(sext2);				// skip if positive
        //b ||ngi||||make positive|14265
        ia= -ia;				// make positive
//      check for option respecification
//      sysxi returns 0 in wa when a file has been resumed,
//      1 when this is a continuation of an exit(4) or exit(-4)
//      action.
// sext2:
        //b |sext2|mfi|8,wc|||get value in work reg|14273
        C_GOTO(sext2);
        } /* sext1 */
        

        void sext2() {
        wc = ia;				// get value in work reg
        //b ||add|8,wa|8,wc||prepare to test for continue|14274
        wa += wc;				// prepare to test for continue
        //b ||beq|8,wa|18,=num05|6,sext5|continued execution if 4 plus 1|14275
        if ((wa-NUM05) == 0) C_GOTO(sext5);				// continued execution if 4 plus 1
        //b ||zer|3,gbcnt|||resuming execution so reset|14276
        v.gbcnt=0;				// resuming execution so reset
        //b ||bge|8,wc|18,=num03|6,sext3|skip if was 3 or 4|14277
        if ((wc-NUM03) >= 0) C_GOTO(sext3);				// skip if was 3 or 4
        //b ||mov|11,-(xs)|8,wc||save value|14278
        C_PUSH(wc);				// save value
        //b ||zer|8,wc|||set to read options|14279
        wc=0;				// set to read options
        //b ||jsr|6,prpar|||read syspp options|14280
        C_JSR(prpar);				// read syspp options
        //b ||mov|8,wc|10,(xs)+||restore value|14281
        wc= C_POP();				// restore value
//      deal with header option (fiddled by prpar)
// sext3:
        //b |sext3|mnz|3,headp|||assume no headers|14285
        C_GOTO(sext3);
        } /* sext2 */
        

        void sext3() {
        v.headp = 0xffffffffffffffff;				// assume no headers
        //b ||bne|8,wc|18,=num01|6,sext4|skip if not 1|14286
        if ((wc-NUM01) != 0) C_GOTO(sext4);				// skip if not 1
        //b ||zer|3,headp|||request header printing|14287
        v.headp=0;				// request header printing
//      almost ready to resume running
// sext4:
        //b |sext4|jsr|6,systm|||get execution time start (sgd11)|14291
        C_GOTO(sext4);
        } /* sext3 */
        

        void sext4() {
        C_JSR(systm);				// get execution time start (sgd11)
        //b ||sti|3,timsx|||save as initial time|14292
        v.timsx= ia;				// save as initial time
        //b ||ldi|3,kvstc|||reset to ensure ...|14293
        ia = v.kvstc;				// reset to ensure ...
        //b ||sti|3,kvstl|||... correct execution stats|14294
        v.kvstl= ia;				// ... correct execution stats
        //b ||jsr|6,stgcc|||recompute countdown counters|14295
        C_JSR(stgcc);				// recompute countdown counters
        //b ||brn|6,exnul|||resume execution|14296
         C_GOTO(exnul);				// resume execution
//      here after exit(4) or exit(-4) -- create save file
//      or load module and continue execution.
//      return integer 1 to signal the continuation of the
//      original execution.
// sext5:
        //b |sext5|mov|7,xr|21,=inton||integer one|14304
        } /* sext4 */
        

        void sext5() {
        xr= (word)(&c.inton);				// integer one
        //b ||brn|6,exixr|||return as result|14305
         C_GOTO(exixr);				// return as result
        //b ||ejc|||||14307
        
//      exp
//	align	2
//	nop
        //b |s_exp|ent||||entry point|14312
        } /* sext5 */
        

        void s_exp() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||get argument|14313
        xr= C_POP();				// get argument
        //b ||err|1,304|26,exp argument not numeric|||14315
        C_JSR_1(gtrea,(C_ERR(304)));
        //b ||ldr|13,rcval(xr)|||load accumulator with argument|14316
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load accumulator with argument
        //b ||etx||||take exponential|14317
        {ra_it.d = exp(ra_it.d);fl=(!isgoodnum(ra_it.d));}				// take exponential
        //b ||rno|6,exrea|||if no overflow, return result in ra|14318
        if (fl==0) C_GOTO(exrea);				// if no overflow, return result in ra
        //b ||erb|1,305|26,exp produced real overflow|||14319
        C_ERB(305)
        //b ||ejc|||||14320
        
//      field
//	align	2
//	nop
        //b |s_fld|ent||||entry point|14325
        } /* s_exp */
        

        void s_fld() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exfal|||fail if out of range|14328
        extern void _l0456();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0456);
        } /* s_fld */
        

        void _l0456() {
        C_JMS_HANDLE_2(gtsmi,(C_ERR(107)),C_GOTO(exfal));				// fail if out of range
        //b ||mov|8,wb|7,xr||else save integer value|14329
        wb= xr;				// else save integer value
        //b ||mov|7,xr|10,(xs)+||load first argument|14330
        xr= C_POP();				// load first argument
        //b ||ppm|6,sfld1|||jump (error) if not variable name|14332
        C_JSR_1(gtnvr,C_GOTO(sfld1));				// jump (error) if not variable name
        //b ||mov|7,xr|13,vrfnc(xr)||else point to function block|14333
        xr= *((word *)(CFP_B*VRFNC + xr));				// else point to function block
        //b ||bne|9,(xr)|22,=b_dfc|6,sfld1|error if not datatype function|14334
        if ((*(xr_it.wp)-(word)(b_dfc)) != 0) C_GOTO(sfld1);				// error if not datatype function
//      here if first argument is a datatype function name
        //b ||bze|8,wb|6,exfal||fail if argument number is zero|14338
        if ( !( wb) ) C_GOTO(exfal);				// fail if argument number is zero
        //b ||bgt|8,wb|13,fargs(xr)|6,exfal|fail if too large|14339
        if ((wb-*((word *)(CFP_B*FARGS + xr))) > 0) C_GOTO(exfal);				// fail if too large
        //b ||wtb|8,wb|||else convert to byte offset|14340
        wb <<= LOG_CFP_B;				// else convert to byte offset
        //b ||add|7,xr|8,wb||point to field name|14341
        xr += wb;				// point to field name
        //b ||mov|7,xr|13,dfflb(xr)||load vrblk pointer|14342
        xr= *((word *)(CFP_B*DFFLB + xr));				// load vrblk pointer
        //b ||brn|6,exvnm|||exit to build nmblk|14343
         C_GOTO(exvnm);				// exit to build nmblk
//      here for bad first argument
// sfld1:
        //b |sfld1|erb|1,108|26,field first argument is not datatype name|||14347
        } /* _l0456 */
        

        void sfld1() {
        C_ERB(108)
        //b ||ejc|||||14348
        
//      fence
//	align	2
//	nop
        //b |s_fnc|ent||||entry point|14352
        } /* sfld1 */
        

        void s_fnc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_fnc||set pcode for p_fnc|14353
        wb= (word)(p_fnc);				// set pcode for p_fnc
        //b ||zer|7,xr|||p0blk|14354
        xr=0;				// p0blk
        //b ||jsr|6,pbild|||build p_fnc node|14355
        C_JSR(pbild);				// build p_fnc node
        //b ||mov|7,xl|7,xr||save pointer to it|14356
        xl= xr;				// save pointer to it
        //b ||mov|7,xr|10,(xs)+||get argument|14357
        xr= C_POP();				// get argument
        //b ||err|1,259|26,fence argument is not pattern|||14359
        C_JSR_1(gtpat,(C_ERR(259)));
        //b ||jsr|6,pconc|||concatenate to p_fnc node|14360
        C_JSR(pconc);				// concatenate to p_fnc node
        //b ||mov|7,xl|7,xr||save ptr to concatenated pattern|14361
        xl= xr;				// save ptr to concatenated pattern
        //b ||mov|8,wb|22,=p_fna||set for p_fna pcode|14362
        wb= (word)(p_fna);				// set for p_fna pcode
        //b ||zer|7,xr|||p0blk|14363
        xr=0;				// p0blk
        //b ||jsr|6,pbild|||construct p_fna node|14364
        C_JSR(pbild);				// construct p_fna node
        //b ||mov|13,pthen(xr)|7,xl||set pattern as pthen|14365
        *((word *)(CFP_B*PTHEN + xr))= xl;				// set pattern as pthen
        //b ||mov|11,-(xs)|7,xr||set as result|14366
        C_PUSH(xr);				// set as result
        //b ||lcw|7,xr|||get next code word|14367
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute next code word|14368
        w0 = xr_it.wp[0];				// execute next code word
        C_GOTO(w0_it.callp);
        //b ||ejc|||||14369
        
//      ge
//	align	2
//	nop
        //b |s_gef|ent||||entry point|14373
        } /* s_fnc */
        

        void s_gef() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exnul|||return null if gt|14379
        extern void _l0457();
        C_JMS(acomp,P_PRC_ACOMP,_l0457);
        } /* s_gef */
        

        void _l0457() {
        C_JMS_HANDLE_5(acomp,(C_ERR(109)),(C_ERR(110)),C_GOTO(exfal),C_GOTO(exnul),C_GOTO(exnul));				// return null if gt
        //b ||ejc|||||14380
        
//      gt
//	align	2
//	nop
        //b |s_gtf|ent||||entry point|14384
        C_GOTO(s_gtf);
        } /* _l0457 */
        

        void s_gtf() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exnul|||return null if gt|14390
        extern void _l0458();
        C_JMS(acomp,P_PRC_ACOMP,_l0458);
        } /* s_gtf */
        

        void _l0458() {
        C_JMS_HANDLE_5(acomp,(C_ERR(111)),(C_ERR(112)),C_GOTO(exfal),C_GOTO(exfal),C_GOTO(exnul));				// return null if gt
        //b ||ejc|||||14391
        
//      host
//	align	2
//	nop
        //b |s_hst|ent||||entry point|14395
        C_GOTO(s_hst);
        } /* _l0458 */
        

        void s_hst() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wc|10,(xs)+||get fifth arg|14396
        wc= C_POP();				// get fifth arg
        //b ||mov|8,wb|10,(xs)+||get fourth arg|14397
        wb= C_POP();				// get fourth arg
        //b ||mov|7,xr|10,(xs)+||get third arg|14398
        xr= C_POP();				// get third arg
        //b ||mov|7,xl|10,(xs)+||get second arg|14399
        xl= C_POP();				// get second arg
        //b ||mov|8,wa|10,(xs)+||get first arg|14400
        wa= C_POP();				// get first arg
        //b ||ppm|6,shst4|||return copy of xr|14409
        C_JSR_8(syshs,(C_ERR(254)),(C_ERR(255)),C_GOTO(shst1),C_GOTO(exnul),C_GOTO(exixr),C_GOTO(exfal),C_GOTO(shst3),C_GOTO(shst4));				// return copy of xr
//      return host string
// shst1:
        //b |shst1|bze|7,xl|6,exnul||null string if syshs uncooperative|14413
        C_GOTO(shst1);
        } /* s_hst */
        

        void shst1() {
        if ( !( xl) ) C_GOTO(exnul);				// null string if syshs uncooperative
        //b ||mov|8,wa|13,sclen(xl)||length|14414
        wa= *((word *)(CFP_B*SCLEN + xl));				// length
        //b ||zer|8,wb|||zero offset|14415
        wb=0;				// zero offset
//      copy string and return
// shst2:
        //b |shst2|jsr|6,sbstr|||build copy of string|14419
        C_GOTO(shst2);
        } /* shst1 */
        

        void shst2() {
        C_JSR(sbstr);				// build copy of string
        //b ||mov|11,-(xs)|7,xr||stack the result|14420
        C_PUSH(xr);				// stack the result
        //b ||lcw|7,xr|||load next code word|14421
        xr  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|14422
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      return actual string pointed to by xl
// shst3:
        //b |shst3|zer|8,wb|||treat xl like an scblk ptr|14426
        } /* shst2 */
        

        void shst3() {
        wb=0;				// treat xl like an scblk ptr
        //b ||sub|8,wb|18,=cfp_f||by creating a negative offset|14427
        wb -= CFP_F;				// by creating a negative offset
        //b ||brn|6,shst2|||join to copy string|14428
         C_GOTO(shst2);				// join to copy string
//      return copy of block pointed to by xr
// shst4:
        //b |shst4|mov|11,-(xs)|7,xr||stack results|14432
        } /* shst3 */
        

        void shst4() {
        C_PUSH(xr);				// stack results
        //b ||ppm|6,exits|||if not an aggregate structure|14434
        extern void _l0459();
        C_JMS(copyb,P_PRC_COPYB,_l0459);
        } /* shst4 */
        

        void _l0459() {
        C_JMS_HANDLE_1(copyb,C_GOTO(exits));				// if not an aggregate structure
        //b ||brn|6,exsid|||set current id value otherwise|14435
         C_GOTO(exsid);				// set current id value otherwise
        //b ||ejc|||||14436
        
//      ident
//	align	2
//	nop
        //b |s_idn|ent||||entry point|14440
        } /* _l0459 */
        

        void s_idn() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load second argument|14441
        xr= C_POP();				// load second argument
        //b ||mov|7,xl|10,(xs)+||load first argument|14442
        xl= C_POP();				// load first argument
        //b ||ppm|6,exnul|||return null if ident|14444
        C_JSR_1(ident,C_GOTO(exnul));				// return null if ident
        //b ||brn|6,exfal|||fail if differ|14445
         C_GOTO(exfal);				// fail if differ
        //b ||ejc|||||14446
        
//      input
//	align	2
//	nop
        //b |s_inp|ent||||entry point|14450
        } /* s_idn */
        

        void s_inp() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||zer|8,wb|||input flag|14451
        wb=0;				// input flag
        //b ||err|1,289|26,input channel currently in use|||14459
        extern void _l0460();
        C_JMS(ioput,P_PRC_IOPUT,_l0460);
        } /* s_inp */
        

        void _l0460() {
        C_JMS_HANDLE_7(ioput,(C_ERR(113)),(C_ERR(114)),(C_ERR(115)),(C_ERR(116)),C_GOTO(exfal),(C_ERR(117)),(C_ERR(289)));
        //b ||brn|6,exnul|||return null string|14460
         C_GOTO(exnul);				// return null string
        //b ||ejc|||||14461
        
//      integer
//	align	2
//	nop
        //b |s_int|ent||||entry point|14494
        } /* _l0460 */
        

        void s_int() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load argument|14495
        xr= C_POP();				// load argument
        //b ||ppm|6,exfal|||fail if non-numeric|14497
        C_JSR_1(gtnum,C_GOTO(exfal));				// fail if non-numeric
        //b ||beq|8,wa|22,=b_icl|6,exnul|return null if integer|14498
        if ((wa-(word)(b_icl)) == 0) C_GOTO(exnul);				// return null if integer
        //b ||brn|6,exfal|||fail if real|14499
         C_GOTO(exfal);				// fail if real
        //b ||ejc|||||14500
        
//      item
//      item does not permit the direct (fast) call so that
//      wa contains the actual number of arguments passed.
//	align	2
//	nop
        //b |s_itm|ent||||entry point|14507
        } /* s_int */
        

        void s_itm() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
//      deal with case of no args
        //b ||bnz|8,wa|6,sitm1||jump if at least one arg|14511
        if (wa) C_GOTO(sitm1);				// jump if at least one arg
        //b ||mov|11,-(xs)|21,=nulls||else supply garbage null arg|14512
        C_PUSH((word)(&c.nulls));				// else supply garbage null arg
        //b ||mov|8,wa|18,=num01||and fix argument count|14513
        wa= NUM01;				// and fix argument count
//      check for name/value cases
// sitm1:
        //b |sitm1|scp|7,xr|||get current code pointer|14517
        C_GOTO(sitm1);
        } /* s_itm */
        

        void sitm1() {
        xr= reg_cp;				// get current code pointer
        //b ||mov|7,xl|9,(xr)||load next code word|14518
        xl= *(xr_it.wp);				// load next code word
        //b ||dcv|8,wa|||get number of subscripts|14519
        (wa)--;				// get number of subscripts
        //b ||mov|7,xr|8,wa||copy for arref|14520
        xr= wa;				// copy for arref
        //b ||beq|7,xl|21,=ofne_|6,sitm2|jump if called by name|14521
        if ((xl-(word)(&c.ofne_)) == 0) C_GOTO(sitm2);				// jump if called by name
//      here if called by value
        //b ||zer|8,wb|||set code for call by value|14525
        wb=0;				// set code for call by value
        //b ||brn|6,arref|||off to array reference routine|14526
         C_GOTO(arref);				// off to array reference routine
//      here for call by name
// sitm2:
        //b |sitm2|mnz|8,wb|||set code for call by name|14530
        } /* sitm1 */
        

        void sitm2() {
        wb = 0xffffffffffffffff;				// set code for call by name
        //b ||lcw|8,wa|||load and ignore ofne_ call|14531
        wa  = *((word *)reg_cp);				// load and ignore ofne_ call
          reg_cp += CFP_B;
        //b ||brn|6,arref|||off to array reference routine|14532
         C_GOTO(arref);				// off to array reference routine
        //b ||ejc|||||14533
        
//      le
//	align	2
//	nop
        //b |s_lef|ent||||entry point|14537
        } /* sitm2 */
        

        void s_lef() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exfal|||fail if gt|14543
        extern void _l0461();
        C_JMS(acomp,P_PRC_ACOMP,_l0461);
        } /* s_lef */
        

        void _l0461() {
        C_JMS_HANDLE_5(acomp,(C_ERR(118)),(C_ERR(119)),C_GOTO(exnul),C_GOTO(exnul),C_GOTO(exfal));				// fail if gt
        //b ||ejc|||||14544
        
//      len
//	align	2
//	nop
        //b |s_len|ent||||entry point|14548
        C_GOTO(s_len);
        } /* _l0461 */
        

        void s_len() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_len||set pcode for integer arg case|14549
        wb= (word)(p_len);				// set pcode for integer arg case
        //b ||mov|8,wa|22,=p_lnd||set pcode for expr arg case|14550
        wa= (word)(p_lnd);				// set pcode for expr arg case
        //b ||err|1,121|26,len argument is negative or too large|||14553
        extern void _l0462();
        C_JMS(patin,P_PRC_PATIN,_l0462);
        } /* s_len */
        

        void _l0462() {
        C_JMS_HANDLE_2(patin,(C_ERR(120)),(C_ERR(121)));
        //b ||mov|11,-(xs)|7,xr||stack result|14554
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|14555
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|14556
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||14557
        
//      leq
//	align	2
//	nop
        //b |s_leq|ent||||entry point|14561
        } /* _l0462 */
        

        void s_leq() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exfal|||fail if lgt|14567
        extern void _l0463();
        C_JMS(lcomp,P_PRC_LCOMP,_l0463);
        } /* s_leq */
        

        void _l0463() {
        C_JMS_HANDLE_5(lcomp,(C_ERR(122)),(C_ERR(123)),C_GOTO(exfal),C_GOTO(exnul),C_GOTO(exfal));				// fail if lgt
        //b ||ejc|||||14568
        
//      lge
//	align	2
//	nop
        //b |s_lge|ent||||entry point|14572
        C_GOTO(s_lge);
        } /* _l0463 */
        

        void s_lge() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exnul|||return null if lgt|14578
        extern void _l0464();
        C_JMS(lcomp,P_PRC_LCOMP,_l0464);
        } /* s_lge */
        

        void _l0464() {
        C_JMS_HANDLE_5(lcomp,(C_ERR(124)),(C_ERR(125)),C_GOTO(exfal),C_GOTO(exnul),C_GOTO(exnul));				// return null if lgt
        //b ||ejc|||||14579
        
//      lgt
//	align	2
//	nop
        //b |s_lgt|ent||||entry point|14583
        C_GOTO(s_lgt);
        } /* _l0464 */
        

        void s_lgt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exnul|||return null if lgt|14589
        extern void _l0465();
        C_JMS(lcomp,P_PRC_LCOMP,_l0465);
        } /* s_lgt */
        

        void _l0465() {
        C_JMS_HANDLE_5(lcomp,(C_ERR(126)),(C_ERR(127)),C_GOTO(exfal),C_GOTO(exfal),C_GOTO(exnul));				// return null if lgt
        //b ||ejc|||||14590
        
//      lle
//	align	2
//	nop
        //b |s_lle|ent||||entry point|14594
        C_GOTO(s_lle);
        } /* _l0465 */
        

        void s_lle() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exfal|||fail if lgt|14600
        extern void _l0466();
        C_JMS(lcomp,P_PRC_LCOMP,_l0466);
        } /* s_lle */
        

        void _l0466() {
        C_JMS_HANDLE_5(lcomp,(C_ERR(128)),(C_ERR(129)),C_GOTO(exnul),C_GOTO(exnul),C_GOTO(exfal));				// fail if lgt
        //b ||ejc|||||14601
        
//      llt
//	align	2
//	nop
        //b |s_llt|ent||||entry point|14605
        C_GOTO(s_llt);
        } /* _l0466 */
        

        void s_llt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exfal|||fail if lgt|14611
        extern void _l0467();
        C_JMS(lcomp,P_PRC_LCOMP,_l0467);
        } /* s_llt */
        

        void _l0467() {
        C_JMS_HANDLE_5(lcomp,(C_ERR(130)),(C_ERR(131)),C_GOTO(exnul),C_GOTO(exfal),C_GOTO(exfal));				// fail if lgt
        //b ||ejc|||||14612
        
//      lne
//	align	2
//	nop
        //b |s_lne|ent||||entry point|14616
        C_GOTO(s_lne);
        } /* _l0467 */
        

        void s_lne() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exnul|||return null if lgt|14622
        extern void _l0468();
        C_JMS(lcomp,P_PRC_LCOMP,_l0468);
        } /* s_lne */
        

        void _l0468() {
        C_JMS_HANDLE_5(lcomp,(C_ERR(132)),(C_ERR(133)),C_GOTO(exnul),C_GOTO(exfal),C_GOTO(exnul));				// return null if lgt
        //b ||ejc|||||14623
        
//      ln
//	align	2
//	nop
        //b |s_lnf|ent||||entry point|14628
        C_GOTO(s_lnf);
        } /* _l0468 */
        

        void s_lnf() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||get argument|14629
        xr= C_POP();				// get argument
        //b ||err|1,306|26,ln argument not numeric|||14631
        C_JSR_1(gtrea,(C_ERR(306)));
        //b ||ldr|13,rcval(xr)|||load accumulator with argument|14632
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load accumulator with argument
        //b ||req|6,slnf1|||overflow if argument is 0|14633
        if (ra_it.d == 0.0)  C_GOTO(slnf1);				// overflow if argument is 0
        //b ||rlt|6,slnf2|||error if argument less than 0|14634
        if (ra_it.d < 0.0)  C_GOTO(slnf2);				// error if argument less than 0
        //b ||lnf||||take natural logarithm|14635
        {ra_it.d = log(ra_it.d);fl=(!isgoodnum(ra_it.d));}				// take natural logarithm
        //b ||rno|6,exrea|||if no overflow, return result in ra|14636
        if (fl==0) C_GOTO(exrea);				// if no overflow, return result in ra
// slnf1:
        //b |slnf1|erb|1,307|26,ln produced real overflow|||14637
        C_GOTO(slnf1);
        } /* s_lnf */
        

        void slnf1() {
        C_ERB(307)
//      here for bad argument
// slnf2:
        //b |slnf2|erb|1,315|26,ln argument negative|||14641
        } /* slnf1 */
        

        void slnf2() {
        C_ERB(315)
        //b ||ejc|||||14642
        
//      local
//	align	2
//	nop
        //b |s_loc|ent||||entry point|14647
        } /* slnf2 */
        

        void s_loc() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exfal|||fail if out of range|14650
        extern void _l0469();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0469);
        } /* s_loc */
        

        void _l0469() {
        C_JMS_HANDLE_2(gtsmi,(C_ERR(134)),C_GOTO(exfal));				// fail if out of range
        //b ||mov|8,wb|7,xr||save local number|14651
        wb= xr;				// save local number
        //b ||mov|7,xr|10,(xs)+||load first argument|14652
        xr= C_POP();				// load first argument
        //b ||ppm|6,sloc1|||jump if not variable name|14654
        C_JSR_1(gtnvr,C_GOTO(sloc1));				// jump if not variable name
        //b ||mov|7,xr|13,vrfnc(xr)||else load function pointer|14655
        xr= *((word *)(CFP_B*VRFNC + xr));				// else load function pointer
        //b ||bne|9,(xr)|22,=b_pfc|6,sloc1|jump if not program defined|14656
        if ((*(xr_it.wp)-(word)(b_pfc)) != 0) C_GOTO(sloc1);				// jump if not program defined
//      here if we have a program defined function name
        //b ||bze|8,wb|6,exfal||fail if second arg is zero|14660
        if ( !( wb) ) C_GOTO(exfal);				// fail if second arg is zero
        //b ||bgt|8,wb|13,pfnlo(xr)|6,exfal|or too large|14661
        if ((wb-*((word *)(CFP_B*PFNLO + xr))) > 0) C_GOTO(exfal);				// or too large
        //b ||add|8,wb|13,fargs(xr)||else adjust offset to include args|14662
        wb += *((word *)(CFP_B*FARGS + xr));				// else adjust offset to include args
        //b ||wtb|8,wb|||convert to bytes|14663
        wb <<= LOG_CFP_B;				// convert to bytes
        //b ||add|7,xr|8,wb||point to local pointer|14664
        xr += wb;				// point to local pointer
        //b ||mov|7,xr|13,pfagb(xr)||load vrblk pointer|14665
        xr= *((word *)(CFP_B*PFAGB + xr));				// load vrblk pointer
        //b ||brn|6,exvnm|||exit building nmblk|14666
         C_GOTO(exvnm);				// exit building nmblk
//      here if first argument is no good
// sloc1:
        //b |sloc1|erb|1,135|26,local first arg is not a program function name|||14670
        } /* _l0469 */
        

        void sloc1() {
        C_ERB(135)
        //b ||ejc|||||14673
        
//      load
//	align	2
//	nop
        //b |s_lod|ent||||entry point|14677
        } /* sloc1 */
        

        void s_lod() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,136|26,load second argument is not a string|||14679
        extern void _l0470();
        C_JMS(gtstg,P_PRC_GTSTG,_l0470);
        } /* s_lod */
        

        void _l0470() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(136)));
        //b ||mov|7,xl|7,xr||save library name|14680
        xl= xr;				// save library name
        //b ||err|1,138|26,load first argument is null|||14683
        extern void _l0471();
        C_JMS(xscni,P_PRC_XSCNI,_l0471);
        } /* _l0470 */
        

        void _l0471() {
        C_JMS_HANDLE_2(xscni,(C_ERR(137)),(C_ERR(138)));
        //b ||mov|11,-(xs)|7,xl||stack library name|14684
        C_PUSH(xl);				// stack library name
        //b ||mov|8,wc|18,=ch_pp||set delimiter one = left paren|14685
        wc= CH_PP;				// set delimiter one = left paren
        //b ||mov|7,xl|8,wc||set delimiter two = left paren|14686
        xl= wc;				// set delimiter two = left paren
        //b ||mnz|8,wa|||skip/trim blanks in prototype|14687
        wa = 0xffffffffffffffff;				// skip/trim blanks in prototype
        //b ||jsr|6,xscan|||scan function name|14688
        C_JSR(xscan);				// scan function name
        //b ||mov|11,-(xs)|7,xr||save ptr to function name|14689
        C_PUSH(xr);				// save ptr to function name
        //b ||bnz|8,wa|6,slod1||jump if left paren found|14690
        if (wa) C_GOTO(slod1);				// jump if left paren found
        //b ||erb|1,139|26,load first argument is missing a left paren|||14691
        C_ERB(139)
//      here after successfully scanning function name
// slod1:
        //b |slod1|jsr|6,gtnvr|||locate vrblk|14695
        } /* _l0471 */
        

        void slod1() {
        //b ||err|1,140|26,load first argument has null function name|||14696
        C_JSR_1(gtnvr,(C_ERR(140)));
        //b ||mov|3,lodfn|7,xr||save vrblk pointer|14697
        v.lodfn= xr;				// save vrblk pointer
        //b ||zer|3,lodna|||zero count of arguments|14698
        v.lodna=0;				// zero count of arguments
//      loop to scan argument datatype names
// slod2:
        //b |slod2|mov|8,wc|18,=ch_rp||delimiter one is right paren|14702
        C_GOTO(slod2);
        } /* slod1 */
        

        void slod2() {
        wc= CH_RP;				// delimiter one is right paren
        //b ||mov|7,xl|18,=ch_cm||delimiter two is comma|14703
        xl= CH_CM;				// delimiter two is comma
        //b ||mnz|8,wa|||skip/trim blanks in prototype|14704
        wa = 0xffffffffffffffff;				// skip/trim blanks in prototype
        //b ||jsr|6,xscan|||scan next argument name|14705
        C_JSR(xscan);				// scan next argument name
        //b ||icv|3,lodna|||bump argument count|14706
        (v.lodna)++;				// bump argument count
        //b ||bnz|8,wa|6,slod3||jump if ok delimiter was found|14707
        if (wa) C_GOTO(slod3);				// jump if ok delimiter was found
        //b ||erb|1,141|26,load first argument is missing a right paren|||14708
        C_ERB(141)
        //b ||ejc|||||14709
        
//      load (continued)
//      come here to analyze the datatype pointer in (xr). this
//      code is used both for arguments (wa=1,2) and for the
//      result datatype (with wa set to zero).
// slod3:
        //b |slod3|mov|11,-(xs)|7,xr||stack datatype name pointer|14725
        } /* slod2 */
        

        void slod3() {
        C_PUSH(xr);				// stack datatype name pointer
        //b ||mov|8,wb|18,=num01||set string code in case|14727
        wb= NUM01;				// set string code in case
        //b ||mov|7,xl|21,=scstr||point to /string/|14728
        xl= (word)(&c.scstr);				// point to /string/
        //b ||ppm|6,slod4|||jump if match|14730
        C_JSR_1(ident,C_GOTO(slod4));				// jump if match
        //b ||mov|7,xr|9,(xs)||else reload name|14731
        xr= *(xs_it.wp);				// else reload name
        //b ||add|8,wb|8,wb||set code for integer (2)|14732
        wb += wb;				// set code for integer (2)
        //b ||mov|7,xl|21,=scint||point to /integer/|14733
        xl= (word)(&c.scint);				// point to /integer/
        //b ||ppm|6,slod4|||jump if match|14735
        C_JSR_1(ident,C_GOTO(slod4));				// jump if match
        //b ||mov|7,xr|9,(xs)||else reload string pointer|14738
        xr= *(xs_it.wp);				// else reload string pointer
        //b ||icv|8,wb|||set code for real (3)|14739
        (wb)++;				// set code for real (3)
        //b ||mov|7,xl|21,=screa||point to /real/|14740
        xl= (word)(&c.screa);				// point to /real/
        //b ||ppm|6,slod4|||jump if match|14742
        C_JSR_1(ident,C_GOTO(slod4));				// jump if match
        //b ||mov|7,xr|9,(xs)||reload string pointer|14745
        xr= *(xs_it.wp);				// reload string pointer
        //b ||icv|8,wb|||code for file (4, or 3 if no reals)|14746
        (wb)++;				// code for file (4, or 3 if no reals)
        //b ||mov|7,xl|21,=scfil||point to /file/|14747
        xl= (word)(&c.scfil);				// point to /file/
        //b ||ppm|6,slod4|||jump if match|14749
        C_JSR_1(ident,C_GOTO(slod4));				// jump if match
        //b ||zer|8,wb|||else get code for no convert|14751
        wb=0;				// else get code for no convert
//      merge here with proper datatype code in wb
// slod4:
        //b |slod4|mov|9,(xs)|8,wb||store code on stack|14755
        C_GOTO(slod4);
        } /* slod3 */
        

        void slod4() {
        *(xs_it.wp)= wb;				// store code on stack
        //b ||beq|8,wa|18,=num02|6,slod2|loop back if arg stopped by comma|14756
        if ((wa-NUM02) == 0) C_GOTO(slod2);				// loop back if arg stopped by comma
        //b ||bze|8,wa|6,slod5||jump if that was the result type|14757
        if ( !( wa) ) C_GOTO(slod5);				// jump if that was the result type
//      here we scan out the result type (arg stopped by ) )
        //b ||mov|8,wc|3,mxlen||set dummy (impossible) delimiter 1|14761
        wc= v.mxlen;				// set dummy (impossible) delimiter 1
        //b ||mov|7,xl|8,wc||and delimiter two|14762
        xl= wc;				// and delimiter two
        //b ||mnz|8,wa|||skip/trim blanks in prototype|14763
        wa = 0xffffffffffffffff;				// skip/trim blanks in prototype
        //b ||jsr|6,xscan|||scan result name|14764
        C_JSR(xscan);				// scan result name
        //b ||zer|8,wa|||set code for processing result|14765
        wa=0;				// set code for processing result
        //b ||brn|6,slod3|||jump back to process result name|14766
         C_GOTO(slod3);				// jump back to process result name
        //b ||ejc|||||14767
        
//      load (continued)
//      here after processing all args and result
// slod5:
        //b |slod5|mov|8,wa|3,lodna||get number of arguments|14773
        } /* slod4 */
        

        void slod5() {
        wa= v.lodna;				// get number of arguments
        //b ||mov|8,wc|8,wa||copy for later|14774
        wc= wa;				// copy for later
        //b ||wtb|8,wa|||convert length to bytes|14775
        wa <<= LOG_CFP_B;				// convert length to bytes
        //b ||add|8,wa|19,*efsi_||add space for standard fields|14776
        wa += CFP_B*EFSI_;				// add space for standard fields
        //b ||jsr|6,alloc|||allocate efblk|14777
        C_JSR(alloc);				// allocate efblk
        //b ||mov|9,(xr)|22,=b_efc||set type word|14778
        *(xr_it.wp)= (word)(b_efc);				// set type word
        //b ||mov|13,fargs(xr)|8,wc||set number of arguments|14779
        *((word *)(CFP_B*FARGS + xr))= wc;				// set number of arguments
        //b ||zer|13,efuse(xr)|||set use count (dffnc will set to 1)|14780
        *((word *)(CFP_B*EFUSE + xr))=0;				// set use count (dffnc will set to 1)
        //b ||zer|13,efcod(xr)|||zero code pointer for now|14781
        *((word *)(CFP_B*EFCOD + xr))=0;				// zero code pointer for now
        //b ||mov|13,efrsl(xr)|10,(xs)+||store result type code|14782
        *((word *)(CFP_B*EFRSL + xr))= C_POP();				// store result type code
        //b ||mov|13,efvar(xr)|3,lodfn||store function vrblk pointer|14783
        *((word *)(CFP_B*EFVAR + xr))= v.lodfn;				// store function vrblk pointer
        //b ||mov|13,eflen(xr)|8,wa||store efblk length|14784
        *((word *)(CFP_B*EFLEN + xr))= wa;				// store efblk length
        //b ||mov|8,wb|7,xr||save efblk pointer|14785
        wb= xr;				// save efblk pointer
        //b ||add|7,xr|8,wa||point past end of efblk|14786
        xr += wa;				// point past end of efblk
        //b ||lct|8,wc|8,wc||set number of arguments for loop|14787
        wc= wc;				// set number of arguments for loop
//      loop to set argument type codes from stack
// slod6:
        //b |slod6|mov|11,-(xr)|10,(xs)+||store one type code from stack|14791
        C_GOTO(slod6);
        } /* slod5 */
        

        void slod6() {
        *(--xr_it.wp)= C_POP();				// store one type code from stack
        //b ||bct|8,wc|6,slod6||loop till all stored|14792
        if ((--wc))  C_GOTO(slod6);				// loop till all stored
//      now load the external function and perform definition
        //b ||mov|7,xr|10,(xs)+||load function string name|14796
        xr= C_POP();				// load function string name
        //b ||mov|7,xl|9,(xs)||load library name|14801
        xl= *(xs_it.wp);				// load library name
        //b ||mov|9,(xs)|8,wb||store efblk pointer|14802
        *(xs_it.wp)= wb;				// store efblk pointer
        //b ||err|1,328|26,load function - insufficient memory|||14806
        C_JSR_3(sysld,(C_ERR(142)),(C_ERR(143)),(C_ERR(328)));
        //b ||mov|7,xl|10,(xs)+||recall efblk pointer|14807
        xl= C_POP();				// recall efblk pointer
        //b ||mov|13,efcod(xl)|7,xr||store code pointer|14808
        *((word *)(CFP_B*EFCOD + xl))= xr;				// store code pointer
        //b ||mov|7,xr|3,lodfn||point to vrblk for function|14809
        xr= v.lodfn;				// point to vrblk for function
        //b ||jsr|6,dffnc|||perform function definition|14810
        C_JSR(dffnc);				// perform function definition
        //b ||brn|6,exnul|||return null result|14811
         C_GOTO(exnul);				// return null result
        //b ||ejc|||||14813
        
//      lpad
//	align	2
//	nop
        //b |s_lpd|ent||||entry point|14817
        } /* slod6 */
        

        void s_lpd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,144|26,lpad third argument is not a string|||14819
        extern void _l0476();
        C_JMS(gtstg,P_PRC_GTSTG,_l0476);
        } /* s_lpd */
        

        void _l0476() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(144)));
        //b ||plc|7,xr|||point to character (null is blank)|14820
        xr += CFP_F;				// point to character (null is blank)
        //b ||lch|8,wb|9,(xr)||load pad character|14821
        wb = *(xr_it.chp);				// load pad character
        //b ||ppm|6,slpd4|||skip if negative or large|14824
        extern void _l0477();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0477);
        } /* _l0476 */
        

        void _l0477() {
        C_JMS_HANDLE_2(gtsmi,(C_ERR(145)),C_GOTO(slpd4));				// skip if negative or large
//      merge to check first arg
// slpd1:
        //b |slpd1|jsr|6,gtstg|||get first argument (string to pad)|14828
        C_GOTO(slpd1);
        } /* _l0477 */
        

        void slpd1() {
        //b ||err|1,146|26,lpad first argument is not a string|||14829
        extern void _l0478();
        C_JMS(gtstg,P_PRC_GTSTG,_l0478);
        } /* slpd1 */
        

        void _l0478() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(146)));
        //b ||bge|8,wa|8,wc|6,exixr|return 1st arg if too long to pad|14830
        if ((wa-wc) >= 0) C_GOTO(exixr);				// return 1st arg if too long to pad
        //b ||mov|7,xl|7,xr||else move ptr to string to pad|14831
        xl= xr;				// else move ptr to string to pad
//      now we are ready for the pad
//      (xl)                  pointer to string to pad
//      (wb)                  pad character
//      (wc)                  length to pad string to
        //b ||mov|8,wa|8,wc||copy length|14839
        wa= wc;				// copy length
        //b ||jsr|6,alocs|||allocate scblk for new string|14840
        C_JSR(alocs);				// allocate scblk for new string
        //b ||mov|11,-(xs)|7,xr||save as result|14841
        C_PUSH(xr);				// save as result
        //b ||mov|8,wa|13,sclen(xl)||load length of argument|14842
        wa= *((word *)(CFP_B*SCLEN + xl));				// load length of argument
        //b ||sub|8,wc|8,wa||calculate number of pad characters|14843
        wc -= wa;				// calculate number of pad characters
        //b ||psc|7,xr|||point to chars in result string|14844
        xr += CFP_F;				// point to chars in result string
        //b ||lct|8,wc|8,wc||set counter for pad loop|14845
        wc= wc;				// set counter for pad loop
//      loop to perform pad
// slpd2:
        //b |slpd2|sch|8,wb|10,(xr)+||store pad character, bump ptr|14849
        C_GOTO(slpd2);
        } /* _l0478 */
        

        void slpd2() {
        *(xr_it.chp++) = wb;				// store pad character, bump ptr
        //b ||bct|8,wc|6,slpd2||loop till all pad chars stored|14850
        if ((--wc))  C_GOTO(slpd2);				// loop till all pad chars stored
//      now copy string
        //b ||csc|7,xr|||complete store characters|14851
        //b ||bze|8,wa|6,slpd3||exit if null string|14855
        if ( !( wa) ) C_GOTO(slpd3);				// exit if null string
        //b ||plc|7,xl|||else point to chars in argument|14856
        xl += CFP_F;				// else point to chars in argument
        //b ||mvc||||move characters to result string|14857
        do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);				// move characters to result string
        //b ||zer|7,xl|||clear garbage xl|14858
        xl=0;				// clear garbage xl
//      here to exit with result on stack
// slpd3:
        //b |slpd3|lcw|7,xr|||load next code word|14862
        C_GOTO(slpd3);
        } /* slpd2 */
        

        void slpd3() {
        xr  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|14863
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      here if 2nd arg is negative or large
// slpd4:
        //b |slpd4|zer|8,wc|||zero pad count|14867
        } /* slpd3 */
        

        void slpd4() {
        wc=0;				// zero pad count
        //b ||brn|6,slpd1|||merge|14868
         C_GOTO(slpd1);				// merge
        //b ||ejc|||||14869
        
//      lt
//	align	2
//	nop
        //b |s_ltf|ent||||entry point|14873
        } /* slpd4 */
        

        void s_ltf() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exfal|||fail if gt|14879
        extern void _l0481();
        C_JMS(acomp,P_PRC_ACOMP,_l0481);
        } /* s_ltf */
        

        void _l0481() {
        C_JMS_HANDLE_5(acomp,(C_ERR(147)),(C_ERR(148)),C_GOTO(exnul),C_GOTO(exfal),C_GOTO(exfal));				// fail if gt
        //b ||ejc|||||14880
        
//      ne
//	align	2
//	nop
        //b |s_nef|ent||||entry point|14884
        C_GOTO(s_nef);
        } /* _l0481 */
        

        void s_nef() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exnul|||return null if gt|14890
        extern void _l0482();
        C_JMS(acomp,P_PRC_ACOMP,_l0482);
        } /* s_nef */
        

        void _l0482() {
        C_JMS_HANDLE_5(acomp,(C_ERR(149)),(C_ERR(150)),C_GOTO(exnul),C_GOTO(exfal),C_GOTO(exnul));				// return null if gt
        //b ||ejc|||||14891
        
//      notany
//	align	2
//	nop
        //b |s_nay|ent||||entry point|14895
        C_GOTO(s_nay);
        } /* _l0482 */
        

        void s_nay() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_nas||set pcode for single char arg|14896
        wb= (word)(p_nas);				// set pcode for single char arg
        //b ||mov|7,xl|22,=p_nay||pcode for multi-char arg|14897
        xl= (word)(p_nay);				// pcode for multi-char arg
        //b ||mov|8,wc|22,=p_nad||set pcode for expr arg|14898
        wc= (word)(p_nad);				// set pcode for expr arg
        //b ||err|1,151|26,notany argument is not a string or expression|||14900
        extern void _l0483();
        C_JMS(patst,P_PRC_PATST,_l0483);
        } /* s_nay */
        

        void _l0483() {
        C_JMS_HANDLE_1(patst,(C_ERR(151)));
        //b ||mov|11,-(xs)|7,xr||stack result|14901
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|14902
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|14903
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||14904
        
//      opsyn
//	align	2
//	nop
        //b |s_ops|ent||||entry point|14908
        } /* _l0483 */
        

        void s_ops() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,153|26,opsyn third argument is negative or too large|||14911
        extern void _l0484();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0484);
        } /* s_ops */
        

        void _l0484() {
        C_JMS_HANDLE_2(gtsmi,(C_ERR(152)),(C_ERR(153)));
        //b ||mov|8,wb|8,wc||if ok, save third argumnet|14912
        wb= wc;				// if ok, save third argumnet
        //b ||mov|7,xr|10,(xs)+||load second argument|14913
        xr= C_POP();				// load second argument
        //b ||err|1,154|26,opsyn second arg is not natural variable name|||14915
        C_JSR_1(gtnvr,(C_ERR(154)));
        //b ||mov|7,xl|13,vrfnc(xr)||if ok, load function block pointer|14916
        xl= *((word *)(CFP_B*VRFNC + xr));				// if ok, load function block pointer
        //b ||bnz|8,wb|6,sops2||jump if operator opsyn case|14917
        if (wb) C_GOTO(sops2);				// jump if operator opsyn case
//      here for function opsyn (third arg zero)
        //b ||mov|7,xr|10,(xs)+||load first argument|14921
        xr= C_POP();				// load first argument
        //b ||err|1,155|26,opsyn first arg is not natural variable name|||14923
        C_JSR_1(gtnvr,(C_ERR(155)));
//      merge here to perform function definition
// sops1:
        //b |sops1|jsr|6,dffnc|||call function definer|14927
        C_GOTO(sops1);
        } /* _l0484 */
        

        void sops1() {
        C_JSR(dffnc);				// call function definer
        //b ||brn|6,exnul|||exit with null result|14928
         C_GOTO(exnul);				// exit with null result
//      here for operator opsyn (third arg non-zero)
// sops2:
        //b |sops2|jsr|6,gtstg|||get operator name|14932
        } /* sops1 */
        

        void sops2() {
        //b ||ppm|6,sops5|||jump if not string|14933
        extern void _l0485();
        C_JMS(gtstg,P_PRC_GTSTG,_l0485);
        } /* sops2 */
        

        void _l0485() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(sops5));				// jump if not string
        //b ||bne|8,wa|18,=num01|6,sops5|error if not one char long|14934
        if ((wa-NUM01) != 0) C_GOTO(sops5);				// error if not one char long
        //b ||plc|7,xr|||else point to character|14935
        xr += CFP_F;				// else point to character
        //b ||lch|8,wc|9,(xr)||load character name|14936
        wc = *(xr_it.chp);				// load character name
        //b ||ejc|||||14937
        
//      opsyn (continued)
//      now set to search for matching unary or binary operator
//      name as appropriate. note that there are =opbun undefined
//      binary operators and =opuun undefined unary operators.
        //b ||mov|8,wa|20,=r_uub||point to unop pointers in case|14945
        wa= (word)(&v.r_uub);				// point to unop pointers in case
        //b ||mov|7,xr|21,=opnsu||point to names of unary operators|14946
        xr= (word)(&c.opnsu);				// point to names of unary operators
        //b ||add|8,wb|18,=opbun||add no. of undefined binary ops|14947
        wb += OPBUN;				// add no. of undefined binary ops
        //b ||beq|8,wb|18,=opuun|6,sops3|jump if unop (third arg was 1)|14948
        if ((wb-OPUUN) == 0) C_GOTO(sops3);				// jump if unop (third arg was 1)
        //b ||mov|8,wa|20,=r_uba||else point to binary operator ptrs|14949
        wa= (word)(&v.r_uba);				// else point to binary operator ptrs
        //b ||mov|7,xr|21,=opsnb||point to names of binary operators|14950
        xr= (word)(&c.opsnb);				// point to names of binary operators
        //b ||mov|8,wb|18,=opbun||set number of undefined binops|14951
        wb= OPBUN;				// set number of undefined binops
//      merge here to check list (wb = number to check)
// sops3:
        //b |sops3|lct|8,wb|8,wb||set counter to control loop|14955
        C_GOTO(sops3);
        } /* _l0485 */
        

        void sops3() {
        wb= wb;				// set counter to control loop
//      loop to search for name match
// sops4:
        //b |sops4|beq|8,wc|9,(xr)|6,sops6|jump if names match|14959
        C_GOTO(sops4);
        } /* sops3 */
        

        void sops4() {
        if ((wc-*(xr_it.wp)) == 0) C_GOTO(sops6);				// jump if names match
        //b ||ica|8,wa|||else push pointer to function ptr|14960
        wa += CFP_B;				// else push pointer to function ptr
        //b ||ica|7,xr|||bump pointer|14961
        xr += CFP_B;				// bump pointer
        //b ||bct|8,wb|6,sops4||loop back till all checked|14962
        if ((--wb))  C_GOTO(sops4);				// loop back till all checked
//      here if bad operator name
// sops5:
        //b |sops5|erb|1,156|26,opsyn first arg is not correct operator name|||14966
        C_GOTO(sops5);
        } /* sops4 */
        

        void sops5() {
        C_ERB(156)
//      come here on finding a match in the operator name table
// sops6:
        //b |sops6|mov|7,xr|8,wa||copy pointer to function block ptr|14970
        } /* sops5 */
        

        void sops6() {
        xr= wa;				// copy pointer to function block ptr
        //b ||sub|7,xr|19,*vrfnc||make it look like dummy vrblk|14971
        xr -= CFP_B*VRFNC;				// make it look like dummy vrblk
        //b ||brn|6,sops1|||merge back to define operator|14972
         C_GOTO(sops1);				// merge back to define operator
        //b ||ejc|||||14973
        
//      output
//	align	2
//	nop
        //b |s_oup|ent||||entry point|14998
        } /* sops6 */
        

        void s_oup() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|18,=num03||output flag|14999
        wb= NUM03;				// output flag
        //b ||err|1,290|26,output channel currently in use|||15007
        extern void _l0486();
        C_JMS(ioput,P_PRC_IOPUT,_l0486);
        } /* s_oup */
        

        void _l0486() {
        C_JMS_HANDLE_7(ioput,(C_ERR(157)),(C_ERR(158)),(C_ERR(159)),(C_ERR(160)),C_GOTO(exfal),(C_ERR(161)),(C_ERR(290)));
        //b ||brn|6,exnul|||return null string|15008
         C_GOTO(exnul);				// return null string
        //b ||ejc|||||15009
        
//      pos
//	align	2
//	nop
        //b |s_pos|ent||||entry point|15013
        } /* _l0486 */
        

        void s_pos() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_pos||set pcode for integer arg case|15014
        wb= (word)(p_pos);				// set pcode for integer arg case
        //b ||mov|8,wa|22,=p_psd||set pcode for expression arg case|15015
        wa= (word)(p_psd);				// set pcode for expression arg case
        //b ||err|1,163|26,pos argument is negative or too large|||15018
        extern void _l0487();
        C_JMS(patin,P_PRC_PATIN,_l0487);
        } /* s_pos */
        

        void _l0487() {
        C_JMS_HANDLE_2(patin,(C_ERR(162)),(C_ERR(163)));
        //b ||mov|11,-(xs)|7,xr||stack result|15019
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|15020
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|15021
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||15022
        
//      prototype
//	align	2
//	nop
        //b |s_pro|ent||||entry point|15026
        } /* _l0487 */
        

        void s_pro() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load argument|15027
        xr= C_POP();				// load argument
        //b ||mov|8,wb|13,tblen(xr)||length if table, vector (=vclen)|15028
        wb= *((word *)(CFP_B*TBLEN + xr));				// length if table, vector (=vclen)
        //b ||btw|8,wb|||convert to words|15029
        wb >>= LOG_CFP_B;				// convert to words
        //b ||mov|8,wa|9,(xr)||load type word of argument block|15030
        wa= *(xr_it.wp);				// load type word of argument block
        //b ||beq|8,wa|22,=b_art|6,spro4|jump if array|15031
        if ((wa-(word)(b_art)) == 0) C_GOTO(spro4);				// jump if array
        //b ||beq|8,wa|22,=b_tbt|6,spro1|jump if table|15032
        if ((wa-(word)(b_tbt)) == 0) C_GOTO(spro1);				// jump if table
        //b ||beq|8,wa|22,=b_vct|6,spro3|jump if vector|15033
        if ((wa-(word)(b_vct)) == 0) C_GOTO(spro3);				// jump if vector
        //b ||erb|1,164|26,prototype argument is not valid object|||15038
        C_ERB(164)
//      here for table
// spro1:
        //b |spro1|sub|8,wb|18,=tbsi_||subtract standard fields|15042
        } /* s_pro */
        

        void spro1() {
        wb -= TBSI_;				// subtract standard fields
//      merge for vector
// spro2:
        //b |spro2|mti|8,wb|||convert to integer|15046
        C_GOTO(spro2);
        } /* spro1 */
        

        void spro2() {
        ia = (word)(wb);				// convert to integer
        //b ||brn|6,exint|||exit with integer result|15047
         C_GOTO(exint);				// exit with integer result
//      here for vector
// spro3:
        //b |spro3|sub|8,wb|18,=vcsi_||subtract standard fields|15051
        } /* spro2 */
        

        void spro3() {
        wb -= VCSI_;				// subtract standard fields
        //b ||brn|6,spro2|||merge|15052
         C_GOTO(spro2);				// merge
//      here for array
// spro4:
        //b |spro4|add|7,xr|13,arofs(xr)||point to prototype field|15056
        } /* spro3 */
        

        void spro4() {
        xr += *((word *)(CFP_B*AROFS + xr));				// point to prototype field
        //b ||mov|7,xr|9,(xr)||load prototype|15057
        xr= *(xr_it.wp);				// load prototype
        //b ||mov|11,-(xs)|7,xr||stack result|15058
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|15059
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|15060
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||15070
        
//      remdr
//	align	2
//	nop
        //b |s_rmd|ent||||entry point|15074
        } /* spro4 */
        

        void s_rmd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,srm06|||if real|15079
        extern void _l0488();
        C_JMS(arith,P_PRC_ARITH,_l0488);
        } /* s_rmd */
        

        void _l0488() {
        C_JMS_HANDLE_3(arith,(C_ERR(166)),(C_ERR(165)),C_GOTO(srm06));				// if real
//      both arguments integer
        //b ||zer|8,wb|||set positive flag|15096
        wb=0;				// set positive flag
        //b ||ldi|13,icval(xr)|||load left argument value|15097
        ia = *((word *)(CFP_B*ICVAL + xr));				// load left argument value
        //b ||ige|6,srm01|||jump if positive|15098
        if (ia >= 0)  C_GOTO(srm01);				// jump if positive
        //b ||mnz|8,wb|||set negative flag|15099
        wb = 0xffffffffffffffff;				// set negative flag
// srm01:
        //b |srm01|rmi|13,icval(xl)|||get remainder|15100
        C_GOTO(srm01);
        } /* _l0488 */
        

        void srm01() {
        ia=ia % *((word *)(CFP_B*ICVAL + xl));				// get remainder
        //b ||iov|6,srm05|||error if overflow|15101
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// error if overflow
//      make sign of result match sign of first argument
        //b ||bze|8,wb|6,srm03||if result should be positive|15105
        if ( !( wb) ) C_GOTO(srm03);				// if result should be positive
        //b ||ile|6,exint|||if should be negative, and is|15106
        if (ia <= 0)  C_GOTO(exint);				// if should be negative, and is
// srm02:
        //b |srm02|ngi||||adjust sign of result|15107
        C_GOTO(srm02);
        } /* srm01 */
        

        void srm02() {
        ia= -ia;				// adjust sign of result
        //b ||brn|6,exint|||return result|15108
         C_GOTO(exint);				// return result
// srm03:
        //b |srm03|ilt|6,srm02|||should be pos, and result negative|15109
        } /* srm02 */
        

        void srm03() {
        if (ia < 0)  C_GOTO(srm02);				// should be pos, and result negative
        //b ||brn|6,exint|||should be positive, and is|15110
         C_GOTO(exint);				// should be positive, and is
//      fail first argument
// srm04:
        //b |srm04|erb|1,166|26,remdr first argument is not numeric|||15114
        } /* srm03 */
        

        void srm04() {
        C_ERB(166)
//      fail if overflow
// srm05:
        //b |srm05|erb|1,167|26,remdr caused integer overflow|||15118
        } /* srm04 */
        

        void srm05() {
        C_ERB(167)
//      here with 1st argument in (xr), 2nd in (xl), both real
//      result = n1 - chop(n1/n2)*n2
// srm06:
        //b |srm06|zer|8,wb|||set positive flag|15125
        } /* srm05 */
        

        void srm06() {
        wb=0;				// set positive flag
        //b ||ldr|13,rcval(xr)|||load left argument value|15126
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load left argument value
        //b ||rge|6,srm07|||jump if positive|15127
        if (ra_it.d >= 0.0)  C_GOTO(srm07);				// jump if positive
        //b ||mnz|8,wb|||set negative flag|15128
        wb = 0xffffffffffffffff;				// set negative flag
// srm07:
        //b |srm07|dvr|13,rcval(xl)|||compute n1/n2|15129
        C_GOTO(srm07);
        } /* srm06 */
        

        void srm07() {
        {w0 = *((word *)(CFP_B*RCVAL + xl)); if (w0_it.d != 0.0) {ra_it.d /= w0_it.d;fl= (!isgoodnum(ra_it.d));} else {fl=1;}}				// compute n1/n2
        //b ||rov|6,srm10|||jump if overflow|15130
        if (fl) C_GOTO(srm10);				// jump if overflow
        //b ||chp||||chop result|15131
        {ra_it.d = (long)(ra_it.d);fl=(!isgoodnum(ra_it.d));}				// chop result
        //b ||mlr|13,rcval(xl)|||times n2|15132
        {w0 = *((word *)(CFP_B*RCVAL + xl));ra_it.d *=  w0_it.d;fl=(!isgoodnum(ra_it.d));}				// times n2
        //b ||sbr|13,rcval(xr)|||compute difference|15133
        {w0 = *((word *)(CFP_B*RCVAL + xr));ra_it.d -= w0_it.d;fl=(!isgoodnum(ra_it.d));}				// compute difference
//      make sign of result match sign of first argument
//      -result is in ra at this point
        //b ||bze|8,wb|6,srm09||if result should be positive|15138
        if ( !( wb) ) C_GOTO(srm09);				// if result should be positive
        //b ||rle|6,exrea|||if should be negative, and is|15139
        if (ra_it.d <= 0.0)  C_GOTO(exrea);				// if should be negative, and is
// srm08:
        //b |srm08|ngr||||adjust sign of result|15140
        C_GOTO(srm08);
        } /* srm07 */
        

        void srm08() {
        {ra_it.d = - ra_it.d;fl=(!isgoodnum(ra_it.d));}				// adjust sign of result
        //b ||brn|6,exrea|||return result|15141
         C_GOTO(exrea);				// return result
// srm09:
        //b |srm09|rlt|6,srm08|||should be pos, and result negative|15142
        } /* srm08 */
        

        void srm09() {
        if (ra_it.d < 0.0)  C_GOTO(srm08);				// should be pos, and result negative
        //b ||brn|6,exrea|||should be positive, and is|15143
         C_GOTO(exrea);				// should be positive, and is
//      fail if overflow
// srm10:
        //b |srm10|erb|1,312|26,remdr caused real overflow|||15147
        } /* srm09 */
        

        void srm10() {
        C_ERB(312)
        //b ||ejc|||||15149
        
//      replace
//      the actual replace operation uses an scblk whose cfp_a
//      chars contain the translated versions of all the chars.
//      the table pointer is remembered from call to call and
//      the table is only built when the arguments change.
//      we also perform an optimization gleaned from spitbol 370.
//      if the second argument is &alphabet, there is no need to
//      to build a replace table.  the third argument can be
//      used directly as the replace table.
//	align	2
//	nop
        //b |s_rpl|ent||||entry point|15163
        } /* srm10 */
        

        void s_rpl() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,168|26,replace third argument is not a string|||15165
        extern void _l0489();
        C_JMS(gtstg,P_PRC_GTSTG,_l0489);
        } /* s_rpl */
        

        void _l0489() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(168)));
        //b ||mov|7,xl|7,xr||save third arg ptr|15166
        xl= xr;				// save third arg ptr
        //b ||err|1,169|26,replace second argument is not a string|||15168
        extern void _l0490();
        C_JMS(gtstg,P_PRC_GTSTG,_l0490);
        } /* _l0489 */
        

        void _l0490() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(169)));
//      check to see if this is the same table as last time
        //b ||bne|7,xr|3,r_ra2|6,srpl1|jump if 2nd argument different|15172
        if ((xr-v.r_ra2) != 0) C_GOTO(srpl1);				// jump if 2nd argument different
        //b ||beq|7,xl|3,r_ra3|6,srpl4|jump if args same as last time|15173
        if ((xl-v.r_ra3) == 0) C_GOTO(srpl4);				// jump if args same as last time
//      here we build a new replace table (note wa = 2nd arg len)
// srpl1:
        //b |srpl1|mov|8,wb|13,sclen(xl)||load 3rd argument length|15177
        C_GOTO(srpl1);
        } /* _l0490 */
        

        void srpl1() {
        wb= *((word *)(CFP_B*SCLEN + xl));				// load 3rd argument length
        //b ||bne|8,wa|8,wb|6,srpl6|jump if arguments not same length|15178
        if ((wa-wb) != 0) C_GOTO(srpl6);				// jump if arguments not same length
        //b ||beq|7,xr|3,kvalp|6,srpl5|jump if 2nd arg is alphabet string|15179
        if ((xr-v.kvalp) == 0) C_GOTO(srpl5);				// jump if 2nd arg is alphabet string
        //b ||bze|8,wb|6,srpl6||jump if null 2nd argument|15180
        if ( !( wb) ) C_GOTO(srpl6);				// jump if null 2nd argument
        //b ||mov|3,r_ra3|7,xl||save third arg for next time in|15181
        v.r_ra3= xl;				// save third arg for next time in
        //b ||mov|3,r_ra2|7,xr||save second arg for next time in|15182
        v.r_ra2= xr;				// save second arg for next time in
        //b ||mov|7,xl|3,kvalp||point to alphabet string|15183
        xl= v.kvalp;				// point to alphabet string
        //b ||mov|8,wa|13,sclen(xl)||load alphabet scblk length|15184
        wa= *((word *)(CFP_B*SCLEN + xl));				// load alphabet scblk length
        //b ||mov|7,xr|3,r_rpt||point to current table (if any)|15185
        xr= v.r_rpt;				// point to current table (if any)
        //b ||bnz|7,xr|6,srpl2||jump if we already have a table|15186
        if (xr) C_GOTO(srpl2);				// jump if we already have a table
//      here we allocate a new table
        //b ||jsr|6,alocs|||allocate new table|15190
        C_JSR(alocs);				// allocate new table
        //b ||mov|8,wa|8,wc||keep scblk length|15191
        wa= wc;				// keep scblk length
        //b ||mov|3,r_rpt|7,xr||save table pointer for next time|15192
        v.r_rpt= xr;				// save table pointer for next time
//      merge here with pointer to new table block in (xr)
// srpl2:
        //b |srpl2|ctb|8,wa|2,scsi_||compute length of scblk|15196
        C_GOTO(srpl2);
        } /* srpl1 */
        

        void srpl2() {
        wa += (CFP_B-1)+CFP_B*SCSI_;				// compute length of scblk
        wa &= 0xfffffffffffffff8;
        //b ||mvw||||copy to get initial table values|15197
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// copy to get initial table values
        //b ||ejc|||||15198
        
//      replace (continued)
//      now we must plug selected entries as required. note that
//      we are short of index registers for the following loop.
//      hence the need to repeatedly re-initialise char ptr xl
        //b ||mov|7,xl|3,r_ra2||point to second argument|15206
        xl= v.r_ra2;				// point to second argument
        //b ||lct|8,wb|8,wb||number of chars to plug|15207
        wb= wb;				// number of chars to plug
        //b ||zer|8,wc|||zero char offset|15208
        wc=0;				// zero char offset
        //b ||mov|7,xr|3,r_ra3||point to 3rd arg|15209
        xr= v.r_ra3;				// point to 3rd arg
        //b ||plc|7,xr|||get char ptr for 3rd arg|15210
        xr += CFP_F;				// get char ptr for 3rd arg
//      loop to plug chars
// srpl3:
        //b |srpl3|mov|7,xl|3,r_ra2||point to 2nd arg|15214
        C_GOTO(srpl3);
        } /* srpl2 */
        

        void srpl3() {
        xl= v.r_ra2;				// point to 2nd arg
        //b ||plc|7,xl|8,wc||point to next char|15215
        xl_it.chp += CFP_F + wc;				// point to next char
        //b ||icv|8,wc|||increment offset|15216
        (wc)++;				// increment offset
        //b ||lch|8,wa|9,(xl)||get next char|15217
        wa = *(xl_it.chp);				// get next char
        //b ||mov|7,xl|3,r_rpt||point to translate table|15218
        xl= v.r_rpt;				// point to translate table
        //b ||psc|7,xl|8,wa||convert char to offset into table|15219
        xl_it.chp += CFP_F + wa;				// convert char to offset into table
        //b ||lch|8,wa|10,(xr)+||get translated char|15220
        wa = *(xr_it.chp++);				// get translated char
        //b ||sch|8,wa|9,(xl)||store in table|15221
        *(xl_it.chp) = wa;				// store in table
        //b ||csc|7,xl|||complete store characters|15222
        //b ||bct|8,wb|6,srpl3||loop till done|15223
        if ((--wb))  C_GOTO(srpl3);				// loop till done
        //b ||ejc|||||15224
        
//      replace (continued)
//      here to use r_rpt as replace table.
// srpl4:
        //b |srpl4|mov|7,xl|3,r_rpt||replace table to use|15230
        C_GOTO(srpl4);
        } /* srpl3 */
        

        void srpl4() {
        xl= v.r_rpt;				// replace table to use
//      here to perform translate using table in xl.
// srpl5:
        //b |srpl5|jsr|6,gtstg|||get first argument|15235
        C_GOTO(srpl5);
        } /* srpl4 */
        

        void srpl5() {
        //b ||err|1,170|26,replace first argument is not a string|||15236
        extern void _l0492();
        C_JMS(gtstg,P_PRC_GTSTG,_l0492);
        } /* srpl5 */
        

        void _l0492() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(170)));
        //b ||bze|8,wa|6,exnul||return null if null argument|15245
        if ( !( wa) ) C_GOTO(exnul);				// return null if null argument
        //b ||mov|11,-(xs)|7,xl||stack replace table to use|15246
        C_PUSH(xl);				// stack replace table to use
        //b ||mov|7,xl|7,xr||copy pointer|15247
        xl= xr;				// copy pointer
        //b ||mov|8,wc|8,wa||save length|15248
        wc= wa;				// save length
        //b ||ctb|8,wa|2,schar||get scblk length|15249
        wa += (CFP_B-1)+CFP_B*SCHAR;				// get scblk length
        wa &= 0xfffffffffffffff8;
        //b ||jsr|6,alloc|||allocate space for copy|15250
        C_JSR(alloc);				// allocate space for copy
        //b ||mov|8,wb|7,xr||save address of copy|15251
        wb= xr;				// save address of copy
        //b ||mvw||||move scblk contents to copy|15252
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// move scblk contents to copy
        //b ||mov|7,xr|10,(xs)+||unstack replace table|15253
        xr= C_POP();				// unstack replace table
        //b ||plc|7,xr|||point to chars of table|15254
        xr += CFP_F;				// point to chars of table
        //b ||mov|7,xl|8,wb||point to string to translate|15255
        xl= wb;				// point to string to translate
        //b ||plc|7,xl|||point to chars of string|15256
        xl += CFP_F;				// point to chars of string
        //b ||mov|8,wa|8,wc||set number of chars to translate|15257
        wa= wc;				// set number of chars to translate
        //b ||trc||||perform translation|15258
        while (wa) {				// perform translation
          *(xl_it.chp) = xr_it.chp[*(xl_it.chp)];xl++;wa--;} xr=0; xl=0;
// srpl8:
        //b |srpl8|mov|11,-(xs)|8,wb||stack result|15259
        C_GOTO(srpl8);
        } /* _l0492 */
        

        void srpl8() {
        C_PUSH(wb);				// stack result
        //b ||lcw|7,xr|||load next code word|15260
        xr  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|15261
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      error point
// srpl6:
        //b |srpl6|erb|1,171|26,null or unequally long 2nd, 3rd args to replace|||15265
        } /* srpl8 */
        

        void srpl6() {
        C_ERB(171)
        //b ||ejc|||||15280
        
//      rewind
//	align	2
//	nop
        //b |s_rew|ent||||entry point|15284
        } /* srpl6 */
        

        void s_rew() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,174|26,rewind file does not exist|||15288
        extern void _l0494();
        C_JMS(iofcb,P_PRC_IOFCB,_l0494);
        } /* s_rew */
        

        void _l0494() {
        C_JMS_HANDLE_3(iofcb,(C_ERR(172)),(C_ERR(173)),(C_ERR(174)));
        //b ||err|1,176|26,rewind caused non-recoverable error|||15292
        C_JSR_3(sysrw,(C_ERR(174)),(C_ERR(175)),(C_ERR(176)));
        //b ||brn|6,exnul|||exit with null result if no error|15293
         C_GOTO(exnul);				// exit with null result if no error
        //b ||ejc|||||15294
        
//      reverse
//	align	2
//	nop
        //b |s_rvs|ent||||entry point|15298
        } /* _l0494 */
        

        void s_rvs() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,177|26,reverse argument is not a string|||15301
        extern void _l0495();
        C_JMS(gtstg,P_PRC_GTSTG,_l0495);
        } /* s_rvs */
        

        void _l0495() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(177)));
        //b ||bze|8,wa|6,exixr||return argument if null|15307
        if ( !( wa) ) C_GOTO(exixr);				// return argument if null
        //b ||mov|7,xl|7,xr||else save pointer to string arg|15308
        xl= xr;				// else save pointer to string arg
        //b ||jsr|6,alocs|||allocate space for new scblk|15309
        C_JSR(alocs);				// allocate space for new scblk
        //b ||mov|11,-(xs)|7,xr||store scblk ptr on stack as result|15310
        C_PUSH(xr);				// store scblk ptr on stack as result
        //b ||psc|7,xr|||prepare to store in new scblk|15311
        xr += CFP_F;				// prepare to store in new scblk
        //b ||plc|7,xl|8,wc||point past last char in argument|15312
        xl_it.chp += CFP_F + wc;				// point past last char in argument
        //b ||lct|8,wc|8,wc||set loop counter|15313
        wc= wc;				// set loop counter
//      loop to move chars in reverse order
// srvs1:
        //b |srvs1|lch|8,wb|11,-(xl)||load next char from argument|15317
        C_GOTO(srvs1);
        } /* _l0495 */
        

        void srvs1() {
        wb = *(--xl_it.chp);				// load next char from argument
        //b ||sch|8,wb|10,(xr)+||store in result|15318
        *(xr_it.chp++) = wb;				// store in result
        //b ||bct|8,wc|6,srvs1||loop till all moved|15319
        if ((--wc))  C_GOTO(srvs1);				// loop till all moved
//      here when complete to execute next code word
// srvs4:
        //b |srvs4|csc|7,xr|||complete store characters|15323
        C_GOTO(srvs4);
        } /* srvs1 */
        

        void srvs4() {
        //b ||zer|7,xl|||clear garbage xl|15324
        xl=0;				// clear garbage xl
// srvs2:
        //b |srvs2|lcw|7,xr|||load next code word|15325
        C_GOTO(srvs2);
        } /* srvs4 */
        

        void srvs2() {
        xr  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|15326
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||15350
        
//      rpad
//	align	2
//	nop
        //b |s_rpd|ent||||entry point|15354
        } /* srvs2 */
        

        void s_rpd() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,178|26,rpad third argument is not a string|||15356
        extern void _l0498();
        C_JMS(gtstg,P_PRC_GTSTG,_l0498);
        } /* s_rpd */
        

        void _l0498() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(178)));
        //b ||plc|7,xr|||point to character (null is blank)|15357
        xr += CFP_F;				// point to character (null is blank)
        //b ||lch|8,wb|9,(xr)||load pad character|15358
        wb = *(xr_it.chp);				// load pad character
        //b ||ppm|6,srpd3|||skip if negative or large|15361
        extern void _l0499();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0499);
        } /* _l0498 */
        

        void _l0499() {
        C_JMS_HANDLE_2(gtsmi,(C_ERR(179)),C_GOTO(srpd3));				// skip if negative or large
//      merge to check first arg.
// srpd1:
        //b |srpd1|jsr|6,gtstg|||get first argument (string to pad)|15365
        C_GOTO(srpd1);
        } /* _l0499 */
        

        void srpd1() {
        //b ||err|1,180|26,rpad first argument is not a string|||15366
        extern void _l0500();
        C_JMS(gtstg,P_PRC_GTSTG,_l0500);
        } /* srpd1 */
        

        void _l0500() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(180)));
        //b ||bge|8,wa|8,wc|6,exixr|return 1st arg if too long to pad|15367
        if ((wa-wc) >= 0) C_GOTO(exixr);				// return 1st arg if too long to pad
        //b ||mov|7,xl|7,xr||else move ptr to string to pad|15368
        xl= xr;				// else move ptr to string to pad
//      now we are ready for the pad
//      (xl)                  pointer to string to pad
//      (wb)                  pad character
//      (wc)                  length to pad string to
        //b ||mov|8,wa|8,wc||copy length|15376
        wa= wc;				// copy length
        //b ||jsr|6,alocs|||allocate scblk for new string|15377
        C_JSR(alocs);				// allocate scblk for new string
        //b ||mov|11,-(xs)|7,xr||save as result|15378
        C_PUSH(xr);				// save as result
        //b ||mov|8,wa|13,sclen(xl)||load length of argument|15379
        wa= *((word *)(CFP_B*SCLEN + xl));				// load length of argument
        //b ||sub|8,wc|8,wa||calculate number of pad characters|15380
        wc -= wa;				// calculate number of pad characters
        //b ||psc|7,xr|||point to chars in result string|15381
        xr += CFP_F;				// point to chars in result string
        //b ||lct|8,wc|8,wc||set counter for pad loop|15382
        wc= wc;				// set counter for pad loop
//      copy argument string
        //b ||bze|8,wa|6,srpd2||jump if argument is null|15386
        if ( !( wa) ) C_GOTO(srpd2);				// jump if argument is null
        //b ||plc|7,xl|||else point to argument chars|15387
        xl += CFP_F;				// else point to argument chars
        //b ||mvc||||move characters to result string|15388
        do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);				// move characters to result string
        //b ||zer|7,xl|||clear garbage xl|15389
        xl=0;				// clear garbage xl
//      loop to supply pad characters
// srpd2:
        //b |srpd2|sch|8,wb|10,(xr)+||store pad character, bump ptr|15393
        C_GOTO(srpd2);
        } /* _l0500 */
        

        void srpd2() {
        *(xr_it.chp++) = wb;				// store pad character, bump ptr
        //b ||bct|8,wc|6,srpd2||loop till all pad chars stored|15394
        if ((--wc))  C_GOTO(srpd2);				// loop till all pad chars stored
        //b ||csc|7,xr|||complete character storing|15395
        //b ||lcw|7,xr|||load next code word|15396
        xr  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|15397
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      here if 2nd arg is negative or large
// srpd3:
        //b |srpd3|zer|8,wc|||zero pad count|15401
        } /* srpd2 */
        

        void srpd3() {
        wc=0;				// zero pad count
        //b ||brn|6,srpd1|||merge|15402
         C_GOTO(srpd1);				// merge
        //b ||ejc|||||15403
        
//      rtab
//	align	2
//	nop
        //b |s_rtb|ent||||entry point|15407
        } /* srpd3 */
        

        void s_rtb() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_rtb||set pcode for integer arg case|15408
        wb= (word)(p_rtb);				// set pcode for integer arg case
        //b ||mov|8,wa|22,=p_rtd||set pcode for expression arg case|15409
        wa= (word)(p_rtd);				// set pcode for expression arg case
        //b ||err|1,182|26,rtab argument is negative or too large|||15412
        extern void _l0503();
        C_JMS(patin,P_PRC_PATIN,_l0503);
        } /* s_rtb */
        

        void _l0503() {
        C_JMS_HANDLE_2(patin,(C_ERR(181)),(C_ERR(182)));
        //b ||mov|11,-(xs)|7,xr||stack result|15413
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|15414
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|15415
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||15416
        
//      tab
//	align	2
//	nop
        //b |s_tab|ent||||entry point|15457
        } /* _l0503 */
        

        void s_tab() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_tab||set pcode for integer arg case|15458
        wb= (word)(p_tab);				// set pcode for integer arg case
        //b ||mov|8,wa|22,=p_tbd||set pcode for expression arg case|15459
        wa= (word)(p_tbd);				// set pcode for expression arg case
        //b ||err|1,184|26,tab argument is negative or too large|||15462
        extern void _l0504();
        C_JMS(patin,P_PRC_PATIN,_l0504);
        } /* s_tab */
        

        void _l0504() {
        C_JMS_HANDLE_2(patin,(C_ERR(183)),(C_ERR(184)));
        //b ||mov|11,-(xs)|7,xr||stack result|15463
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|15464
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|15465
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||15466
        
//      rpos
//	align	2
//	nop
        //b |s_rps|ent||||entry point|15470
        } /* _l0504 */
        

        void s_rps() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_rps||set pcode for integer arg case|15471
        wb= (word)(p_rps);				// set pcode for integer arg case
        //b ||mov|8,wa|22,=p_rpd||set pcode for expression arg case|15472
        wa= (word)(p_rpd);				// set pcode for expression arg case
        //b ||err|1,186|26,rpos argument is negative or too large|||15475
        extern void _l0505();
        C_JMS(patin,P_PRC_PATIN,_l0505);
        } /* s_rps */
        

        void _l0505() {
        C_JMS_HANDLE_2(patin,(C_ERR(185)),(C_ERR(186)));
        //b ||mov|11,-(xs)|7,xr||stack result|15476
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|15477
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|15478
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||15481
        
//      rsort
//	align	2
//	nop
        //b |s_rsr|ent||||entry point|15485
        } /* _l0505 */
        

        void s_rsr() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mnz|8,wa|||mark as rsort|15486
        wa = 0xffffffffffffffff;				// mark as rsort
        //b ||ppm|6,exfal|||if conversion fails, so shall we|15488
        extern void _l0506();
        C_JMS(sorta,P_PRC_SORTA,_l0506);
        } /* s_rsr */
        

        void _l0506() {
        C_JMS_HANDLE_1(sorta,C_GOTO(exfal));				// if conversion fails, so shall we
        //b ||brn|6,exsid|||return, setting idval|15489
         C_GOTO(exsid);				// return, setting idval
        //b ||ejc|||||15491
        
//      setexit
//	align	2
//	nop
        //b |s_stx|ent||||entry point|15495
        } /* _l0506 */
        

        void s_stx() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load argument|15496
        xr= C_POP();				// load argument
        //b ||mov|8,wa|3,stxvr||load old vrblk pointer|15497
        wa= v.stxvr;				// load old vrblk pointer
        //b ||zer|7,xl|||load zero in case null arg|15498
        xl=0;				// load zero in case null arg
        //b ||beq|7,xr|21,=nulls|6,sstx1|jump if null argument (reset call)|15499
        if ((xr-(word)(&c.nulls)) == 0) C_GOTO(sstx1);				// jump if null argument (reset call)
        //b ||ppm|6,sstx2|||jump if not natural variable|15501
        C_JSR_1(gtnvr,C_GOTO(sstx2));				// jump if not natural variable
        //b ||mov|7,xl|13,vrlbl(xr)||else load label|15502
        xl= *((word *)(CFP_B*VRLBL + xr));				// else load label
        //b ||beq|7,xl|21,=stndl|6,sstx2|jump if label is not defined|15503
        if ((xl-(word)(&c.stndl)) == 0) C_GOTO(sstx2);				// jump if label is not defined
        //b ||bne|9,(xl)|22,=b_trt|6,sstx1|jump if not trapped|15504
        if ((*(xl_it.wp)-(word)(b_trt)) != 0) C_GOTO(sstx1);				// jump if not trapped
        //b ||mov|7,xl|13,trlbl(xl)||else load ptr to real label code|15505
        xl= *((word *)(CFP_B*TRLBL + xl));				// else load ptr to real label code
//      here to set/reset setexit trap
// sstx1:
        //b |sstx1|mov|3,stxvr|7,xr||store new vrblk pointer (or null)|15509
        C_GOTO(sstx1);
        } /* s_stx */
        

        void sstx1() {
        v.stxvr= xr;				// store new vrblk pointer (or null)
        //b ||mov|3,r_sxc|7,xl||store new code ptr (or zero)|15510
        v.r_sxc= xl;				// store new code ptr (or zero)
        //b ||beq|8,wa|21,=nulls|6,exnul|return null if null result|15511
        if ((wa-(word)(&c.nulls)) == 0) C_GOTO(exnul);				// return null if null result
        //b ||mov|7,xr|8,wa||else copy vrblk pointer|15512
        xr= wa;				// else copy vrblk pointer
        //b ||brn|6,exvnm|||and return building nmblk|15513
         C_GOTO(exvnm);				// and return building nmblk
//      here if bad argument
// sstx2:
        //b |sstx2|erb|1,187|26,setexit argument is not label name or null|||15517
        } /* sstx1 */
        

        void sstx2() {
        C_ERB(187)
//      sin
//	align	2
//	nop
        //b |s_sin|ent||||entry point|15522
        } /* sstx2 */
        

        void s_sin() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||get argument|15523
        xr= C_POP();				// get argument
        //b ||err|1,308|26,sin argument not numeric|||15525
        C_JSR_1(gtrea,(C_ERR(308)));
        //b ||ldr|13,rcval(xr)|||load accumulator with argument|15526
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load accumulator with argument
        //b ||sin||||take sine|15527
        {ra_it.d = sin(ra_it.d);fl=(!isgoodnum(ra_it.d));}				// take sine
        //b ||rno|6,exrea|||if no overflow, return result in ra|15528
        if (fl==0) C_GOTO(exrea);				// if no overflow, return result in ra
        //b ||erb|1,323|26,sin argument is out of range|||15529
        C_ERB(323)
        //b ||ejc|||||15530
        
//      sqrt
//	align	2
//	nop
        //b |s_sqr|ent||||entry point|15536
        } /* s_sin */
        

        void s_sqr() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||get argument|15537
        xr= C_POP();				// get argument
        //b ||err|1,313|26,sqrt argument not numeric|||15539
        C_JSR_1(gtrea,(C_ERR(313)));
        //b ||ldr|13,rcval(xr)|||load accumulator with argument|15540
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load accumulator with argument
        //b ||rlt|6,ssqr1|||negative number|15541
        if (ra_it.d < 0.0)  C_GOTO(ssqr1);				// negative number
        //b ||sqr||||take square root|15542
        {ra_it.d = sqrt(ra_it.d);fl=(!isgoodnum(ra_it.d));}				// take square root
        //b ||brn|6,exrea|||no overflow possible, result in ra|15543
         C_GOTO(exrea);				// no overflow possible, result in ra
//      here if bad argument
// ssqr1:
        //b |ssqr1|erb|1,314|26,sqrt argument negative|||15547
        } /* s_sqr */
        

        void ssqr1() {
        C_ERB(314)
        //b ||ejc|||||15548
        
        //b ||ejc|||||15552
        
//      sort
//	align	2
//	nop
        //b |s_srt|ent||||entry point|15556
        } /* ssqr1 */
        

        void s_srt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||zer|8,wa|||mark as sort|15557
        wa=0;				// mark as sort
        //b ||ppm|6,exfal|||if conversion fails, so shall we|15559
        extern void _l0507();
        C_JMS(sorta,P_PRC_SORTA,_l0507);
        } /* s_srt */
        

        void _l0507() {
        C_JMS_HANDLE_1(sorta,C_GOTO(exfal));				// if conversion fails, so shall we
        //b ||brn|6,exsid|||return, setting idval|15560
         C_GOTO(exsid);				// return, setting idval
        //b ||ejc|||||15562
        
//      span
//	align	2
//	nop
        //b |s_spn|ent||||entry point|15566
        } /* _l0507 */
        

        void s_spn() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|8,wb|22,=p_sps||set pcode for single char arg|15567
        wb= (word)(p_sps);				// set pcode for single char arg
        //b ||mov|7,xl|22,=p_spn||set pcode for multi-char arg|15568
        xl= (word)(p_spn);				// set pcode for multi-char arg
        //b ||mov|8,wc|22,=p_spd||set pcode for expression arg|15569
        wc= (word)(p_spd);				// set pcode for expression arg
        //b ||err|1,188|26,span argument is not a string or expression|||15571
        extern void _l0508();
        C_JMS(patst,P_PRC_PATST,_l0508);
        } /* s_spn */
        

        void _l0508() {
        C_JMS_HANDLE_1(patst,(C_ERR(188)));
        //b ||mov|11,-(xs)|7,xr||stack result|15572
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|15573
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|15574
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||15575
        
//      size
//	align	2
//	nop
        //b |s_si_|ent||||entry point|15579
        } /* _l0508 */
        

        void s_si_() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,189|26,size argument is not a string|||15582
        extern void _l0509();
        C_JMS(gtstg,P_PRC_GTSTG,_l0509);
        } /* s_si_ */
        

        void _l0509() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(189)));
//      merge with bfblk or scblk ptr in xr.  wa has length.
        //b ||mti|8,wa|||load length as integer|15590
        ia = (word)(wa);				// load length as integer
        //b ||brn|6,exint|||exit with integer result|15591
         C_GOTO(exint);				// exit with integer result
        //b ||ejc|||||15592
        
//      stoptr
//	align	2
//	nop
        //b |s_stt|ent||||entry point|15596
        } /* _l0509 */
        

        void s_stt() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||zer|7,xl|||indicate stoptr case|15597
        xl=0;				// indicate stoptr case
        //b ||err|1,191|26,stoptr second argument is not trace type|||15600
        extern void _l0510();
        C_JMS(trace,P_PRC_TRACE,_l0510);
        } /* s_stt */
        

        void _l0510() {
        C_JMS_HANDLE_2(trace,(C_ERR(190)),(C_ERR(191)));
        //b ||brn|6,exnul|||return null|15601
         C_GOTO(exnul);				// return null
        //b ||ejc|||||15602
        
//      substr
//	align	2
//	nop
        //b |s_sub|ent||||entry point|15606
        } /* _l0510 */
        

        void s_sub() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||ppm|6,exfal|||jump if negative or too large|15609
        extern void _l0511();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0511);
        } /* s_sub */
        

        void _l0511() {
        C_JMS_HANDLE_2(gtsmi,(C_ERR(192)),C_GOTO(exfal));				// jump if negative or too large
        //b ||mov|3,sbssv|7,xr||save third argument|15610
        v.sbssv= xr;				// save third argument
        //b ||ppm|6,exfal|||jump if out of range|15613
        extern void _l0512();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0512);
        } /* _l0511 */
        

        void _l0512() {
        C_JMS_HANDLE_2(gtsmi,(C_ERR(193)),C_GOTO(exfal));				// jump if out of range
        //b ||mov|8,wc|7,xr||save second argument|15614
        wc= xr;				// save second argument
        //b ||bze|8,wc|6,exfal||jump if second argument zero|15615
        if ( !( wc) ) C_GOTO(exfal);				// jump if second argument zero
        //b ||dcv|8,wc|||else decrement for ones origin|15616
        (wc)--;				// else decrement for ones origin
        //b ||err|1,194|26,substr first argument is not a string|||15619
        extern void _l0513();
        C_JMS(gtstg,P_PRC_GTSTG,_l0513);
        } /* _l0512 */
        

        void _l0513() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(194)));
//      merge with bfblk or scblk ptr in xr.  wa has length
        //b ||mov|8,wb|8,wc||copy second arg to wb|15627
        wb= wc;				// copy second arg to wb
        //b ||mov|8,wc|3,sbssv||reload third argument|15628
        wc= v.sbssv;				// reload third argument
        //b ||bnz|8,wc|6,ssub2||skip if third arg given|15629
        if (wc) C_GOTO(ssub2);				// skip if third arg given
        //b ||mov|8,wc|8,wa||else get string length|15630
        wc= wa;				// else get string length
        //b ||bgt|8,wb|8,wc|6,exfal|fail if improper|15631
        if ((wb-wc) > 0) C_GOTO(exfal);				// fail if improper
        //b ||sub|8,wc|8,wb||reduce by offset to start|15632
        wc -= wb;				// reduce by offset to start
//      merge
// ssub2:
        //b |ssub2|mov|7,xl|8,wa||save string length|15636
        C_GOTO(ssub2);
        } /* _l0513 */
        

        void ssub2() {
        xl= wa;				// save string length
        //b ||mov|8,wa|8,wc||set length of substring|15637
        wa= wc;				// set length of substring
        //b ||add|8,wc|8,wb||add 2nd arg to 3rd arg|15638
        wc += wb;				// add 2nd arg to 3rd arg
        //b ||bgt|8,wc|7,xl|6,exfal|jump if improper substring|15639
        if ((wc-xl) > 0) C_GOTO(exfal);				// jump if improper substring
        //b ||mov|7,xl|7,xr||copy pointer to first arg|15640
        xl= xr;				// copy pointer to first arg
        //b ||jsr|6,sbstr|||build substring|15641
        C_JSR(sbstr);				// build substring
        //b ||mov|11,-(xs)|7,xr||stack result|15642
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|15643
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|15644
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||15645
        
//      table
//	align	2
//	nop
        //b |s_tbl|ent||||entry point|15649
        } /* ssub2 */
        

        void s_tbl() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xl|10,(xs)+||get initial lookup value|15650
        xl= C_POP();				// get initial lookup value
        //b ||ica|7,xs|||pop second argument|15651
        xs += CFP_B;				// pop second argument
        //b ||err|1,196|26,table argument is out of range|||15654
        extern void _l0514();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0514);
        } /* s_tbl */
        

        void _l0514() {
        C_JMS_HANDLE_2(gtsmi,(C_ERR(195)),(C_ERR(196)));
        //b ||bnz|8,wc|6,stbl1||jump if non-zero|15655
        if (wc) C_GOTO(stbl1);				// jump if non-zero
        //b ||mov|8,wc|18,=tbnbk||else supply default value|15656
        wc= TBNBK;				// else supply default value
//      merge here with number of headers in wc
// stbl1:
        //b |stbl1|jsr|6,tmake|||make table|15660
        C_GOTO(stbl1);
        } /* _l0514 */
        

        void stbl1() {
        C_JSR(tmake);				// make table
        //b ||brn|6,exsid|||exit setting idval|15661
         C_GOTO(exsid);				// exit setting idval
        //b ||ejc|||||15662
        
//      tan
//	align	2
//	nop
        //b |s_tan|ent||||entry point|15667
        } /* stbl1 */
        

        void s_tan() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||get argument|15668
        xr= C_POP();				// get argument
        //b ||err|1,309|26,tan argument not numeric|||15670
        C_JSR_1(gtrea,(C_ERR(309)));
        //b ||ldr|13,rcval(xr)|||load accumulator with argument|15671
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load accumulator with argument
        //b ||tan||||take tangent|15672
        {ra_it.d = tan(ra_it.d);fl=(!isgoodnum(ra_it.d));}				// take tangent
        //b ||rno|6,exrea|||if no overflow, return result in ra|15673
        if (fl==0) C_GOTO(exrea);				// if no overflow, return result in ra
        //b ||erb|1,310|26,tan produced real overflow or argument is out of range|||15674
        C_ERB(310)
        //b ||ejc|||||15675
        
//      time
//	align	2
//	nop
        //b |s_tim|ent||||entry point|15680
        } /* s_tan */
        

        void s_tim() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||jsr|6,systm|||get timer value|15681
        C_JSR(systm);				// get timer value
        //b ||sbi|3,timsx|||subtract starting time|15682
        ia-=v.timsx;				// subtract starting time
        //b ||brn|6,exint|||exit with integer value|15683
         C_GOTO(exint);				// exit with integer value
        //b ||ejc|||||15684
        
//      trace
//	align	2
//	nop
        //b |s_tra|ent||||entry point|15688
        } /* s_tim */
        

        void s_tra() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||beq|13,num03(xs)|21,=nulls|6,str02|jump if first argument is null|15689
        if ((*((word *)(CFP_B*NUM03 + xs))-(word)(&c.nulls)) == 0) C_GOTO(str02);				// jump if first argument is null
        //b ||mov|7,xr|10,(xs)+||load fourth argument|15690
        xr= C_POP();				// load fourth argument
        //b ||zer|7,xl|||tentatively set zero pointer|15691
        xl=0;				// tentatively set zero pointer
        //b ||beq|7,xr|21,=nulls|6,str01|jump if 4th argument is null|15692
        if ((xr-(word)(&c.nulls)) == 0) C_GOTO(str01);				// jump if 4th argument is null
        //b ||ppm|6,str03|||jump if not variable name|15694
        C_JSR_1(gtnvr,C_GOTO(str03));				// jump if not variable name
        //b ||mov|7,xl|7,xr||else save vrblk in trfnc|15695
        xl= xr;				// else save vrblk in trfnc
//      here with vrblk or zero in xl
// str01:
        //b |str01|mov|7,xr|10,(xs)+||load third argument (tag)|15699
        C_GOTO(str01);
        } /* s_tra */
        

        void str01() {
        xr= C_POP();				// load third argument (tag)
        //b ||zer|8,wb|||set zero as trtyp value for now|15700
        wb=0;				// set zero as trtyp value for now
        //b ||jsr|6,trbld|||build trblk for trace call|15701
        C_JSR(trbld);				// build trblk for trace call
        //b ||mov|7,xl|7,xr||move trblk pointer for trace|15702
        xl= xr;				// move trblk pointer for trace
        //b ||err|1,199|26,trace second argument is not trace type|||15705
        extern void _l0515();
        C_JMS(trace,P_PRC_TRACE,_l0515);
        } /* str01 */
        

        void _l0515() {
        C_JMS_HANDLE_2(trace,(C_ERR(198)),(C_ERR(199)));
        //b ||brn|6,exnul|||return null|15706
         C_GOTO(exnul);				// return null
//      here to call system trace toggle routine
// str02:
        //b |str02|jsr|6,systt|||call it|15710
        } /* _l0515 */
        

        void str02() {
        C_JSR(systt);				// call it
        //b ||add|7,xs|19,*num04||pop trace arguments|15711
        xs += CFP_B*NUM04;				// pop trace arguments
        //b ||brn|6,exnul|||return|15712
         C_GOTO(exnul);				// return
//      here for bad fourth argument
// str03:
        //b |str03|erb|1,197|26,trace fourth arg is not function name or null|||15716
        } /* str02 */
        

        void str03() {
        C_ERB(197)
        //b ||ejc|||||15717
        
//      trim
//	align	2
//	nop
        //b |s_trm|ent||||entry point|15721
        } /* str03 */
        

        void s_trm() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||err|1,200|26,trim argument is not a string|||15724
        extern void _l0516();
        C_JMS(gtstg,P_PRC_GTSTG,_l0516);
        } /* s_trm */
        

        void _l0516() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(200)));
        //b ||bze|8,wa|6,exnul||return null if argument is null|15730
        if ( !( wa) ) C_GOTO(exnul);				// return null if argument is null
        //b ||mov|7,xl|7,xr||copy string pointer|15731
        xl= xr;				// copy string pointer
        //b ||ctb|8,wa|2,schar||get block length|15732
        wa += (CFP_B-1)+CFP_B*SCHAR;				// get block length
        wa &= 0xfffffffffffffff8;
        //b ||jsr|6,alloc|||allocate copy same size|15733
        C_JSR(alloc);				// allocate copy same size
        //b ||mov|8,wb|7,xr||save pointer to copy|15734
        wb= xr;				// save pointer to copy
        //b ||mvw||||copy old string block to new|15735
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// copy old string block to new
        //b ||mov|7,xr|8,wb||restore ptr to new block|15736
        xr= wb;				// restore ptr to new block
        //b ||jsr|6,trimr|||trim blanks (wb is non-zero)|15737
        C_JSR(trimr);				// trim blanks (wb is non-zero)
        //b ||mov|11,-(xs)|7,xr||stack result|15738
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|15739
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|15740
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||15783
        
//      unload
//	align	2
//	nop
        //b |s_unl|ent||||entry point|15787
        } /* _l0516 */
        

        void s_unl() {
        /* note that the entry is +1 byte instead of -1 byte so that we dont run out of scope or anything */
        // this needs to be an entry point - odd or some poo				// entry point
        //b ||mov|7,xr|10,(xs)+||load argument|15788
        xr= C_POP();				// load argument
        //b ||err|1,201|26,unload argument is not natural variable name|||15790
        C_JSR_1(gtnvr,(C_ERR(201)));
        //b ||mov|7,xl|21,=stndf||get ptr to undefined function|15791
        xl= (word)(&c.stndf);				// get ptr to undefined function
        //b ||jsr|6,dffnc|||undefine named function|15792
        C_JSR(dffnc);				// undefine named function
        //b ||brn|6,exnul|||return null as result|15793
         C_GOTO(exnul);				// return null as result
        //b ||ttl|27,s p i t b o l -- utility routines||||15815
        /* s p i t b o l -- utility routines*/
//      the following section contains utility routines used for
//      various purposes throughout the system. these differ
//      from the procedures in the utility procedures section in
//      they are not in procedure form and they do not return
//      to their callers. they are accessed with a branch type
//      instruction after setting the registers to appropriate
//      parameter values.
//      the register values required for each routine are
//      documented at the start of each routine. registers not
//      mentioned may contain any values except that xr,xl
//      can only contain proper collectable pointers.
//      some of these routines will tolerate garbage pointers
//      in xl,xr on entry. this is always documented and in
//      each case, the routine clears these garbage values before
//      exiting after completing its task.
//      the routines have names consisting of five letters
//      and are assembled in alphabetical order.
        //b ||ejc|||||15837
        
//      arref -- array reference
//      (xl)                  may be non-collectable
//      (xr)                  number of subscripts
//      (wb)                  set zero/nonzero for value/name
//                            the value in wb must be collectable
//      stack                 subscripts and array operand
//      brn  arref            jump to call function
//      arref continues by executing the next code word with
//      the result name or value placed on top of the stack.
//      to deal with the problem of accessing subscripts in the
//      order of stacking, xl is used as a subscript pointer
//      working below the stack pointer.
// arref:
        //b |arref|rtn|||||15853
        } /* s_unl */
        

        void arref() {
        //b ||mov|8,wa|7,xr||copy number of subscripts|15854
        wa= xr;				// copy number of subscripts
        //b ||mov|7,xt|7,xs||point to stack front|15855
        xt= xs;				// point to stack front
        //b ||wtb|7,xr|||convert to byte offset|15856
        xr <<= LOG_CFP_B;				// convert to byte offset
        //b ||add|7,xt|7,xr||point to array operand on stack|15857
        xt += xr;				// point to array operand on stack
        //b ||ica|7,xt|||final value for stack popping|15858
        xt += CFP_B;				// final value for stack popping
        //b ||mov|3,arfxs|7,xt||keep for later|15859
        v.arfxs= xt;				// keep for later
        //b ||mov|7,xr|11,-(xt)||load array operand pointer|15860
        xr= *(--xt_it.wp);				// load array operand pointer
        //b ||mov|3,r_arf|7,xr||keep array pointer|15861
        v.r_arf= xr;				// keep array pointer
        //b ||mov|7,xr|7,xt||save pointer to subscripts|15862
        xr= xt;				// save pointer to subscripts
        //b ||mov|7,xl|3,r_arf||point xl to possible vcblk or tbblk|15863
        xl= v.r_arf;				// point xl to possible vcblk or tbblk
        //b ||mov|8,wc|9,(xl)||load first word|15864
        wc= *(xl_it.wp);				// load first word
        //b ||beq|8,wc|22,=b_art|6,arf01|jump if arblk|15865
        if ((wc-(word)(b_art)) == 0) C_GOTO(arf01);				// jump if arblk
        //b ||beq|8,wc|22,=b_vct|6,arf07|jump if vcblk|15866
        if ((wc-(word)(b_vct)) == 0) C_GOTO(arf07);				// jump if vcblk
        //b ||beq|8,wc|22,=b_tbt|6,arf10|jump if tbblk|15867
        if ((wc-(word)(b_tbt)) == 0) C_GOTO(arf10);				// jump if tbblk
        //b ||erb|1,235|26,subscripted operand is not table or array|||15868
        C_ERB(235)
//      here for array (arblk)
// arf01:
        //b |arf01|bne|8,wa|13,arndm(xl)|6,arf09|jump if wrong number of dims|15872
        } /* arref */
        

        void arf01() {
        if ((wa-*((word *)(CFP_B*ARNDM + xl))) != 0) C_GOTO(arf09);				// jump if wrong number of dims
        //b ||ldi|4,intv0|||get initial subscript of zero|15873
        ia = c.intv0;				// get initial subscript of zero
        //b ||mov|7,xt|7,xr||point before subscripts|15874
        xt= xr;				// point before subscripts
        //b ||zer|8,wa|||initial offset to bounds|15875
        wa=0;				// initial offset to bounds
        //b ||brn|6,arf03|||jump into loop|15876
         C_GOTO(arf03);				// jump into loop
//      loop to compute subscripts by multiplications
// arf02:
        //b |arf02|mli|13,ardm2(xr)|||multiply total by next dimension|15880
        } /* arf01 */
        

        void arf02() {
        ia*=*((word *)(CFP_B*ARDM2 + xr));				// multiply total by next dimension
//      merge here first time
// arf03:
        //b |arf03|mov|7,xr|11,-(xt)||load next subscript|15884
        C_GOTO(arf03);
        } /* arf02 */
        

        void arf03() {
        xr= *(--xt_it.wp);				// load next subscript
        //b ||sti|3,arfsi|||save current subscript|15885
        v.arfsi= ia;				// save current subscript
        //b ||ldi|13,icval(xr)|||load integer value in case|15886
        ia = *((word *)(CFP_B*ICVAL + xr));				// load integer value in case
        //b ||beq|9,(xr)|22,=b_icl|6,arf04|jump if it was an integer|15887
        if ((*(xr_it.wp)-(word)(b_icl)) == 0) C_GOTO(arf04);				// jump if it was an integer
        //b ||ejc|||||15888
        
//      arref (continued)
        //b ||ppm|6,arf12|||jump if not integer|15894
        C_JSR_1(gtint,C_GOTO(arf12));				// jump if not integer
        //b ||ldi|13,icval(xr)|||if ok, load integer value|15895
        ia = *((word *)(CFP_B*ICVAL + xr));				// if ok, load integer value
//      here with integer subscript in (ia)
// arf04:
        //b |arf04|mov|7,xr|3,r_arf||point to array|15899
        C_GOTO(arf04);
        } /* arf03 */
        

        void arf04() {
        xr= v.r_arf;				// point to array
        //b ||add|7,xr|8,wa||offset to next bounds|15900
        xr += wa;				// offset to next bounds
        //b ||sbi|13,arlbd(xr)|||subtract low bound to compare|15901
        ia-=*((word *)(CFP_B*ARLBD + xr));				// subtract low bound to compare
        //b ||iov|6,arf13|||out of range fail if overflow|15902
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// out of range fail if overflow
        //b ||ilt|6,arf13|||out of range fail if too small|15903
        if (ia < 0)  C_GOTO(arf13);				// out of range fail if too small
        //b ||sbi|13,ardim(xr)|||subtract dimension|15904
        ia-=*((word *)(CFP_B*ARDIM + xr));				// subtract dimension
        //b ||ige|6,arf13|||out of range fail if too large|15905
        if (ia >= 0)  C_GOTO(arf13);				// out of range fail if too large
        //b ||adi|13,ardim(xr)|||else restore subscript offset|15906
        ia+=*((word *)(CFP_B*ARDIM + xr));				// else restore subscript offset
        //b ||adi|3,arfsi|||add to current total|15907
        ia+=v.arfsi;				// add to current total
        //b ||add|8,wa|19,*ardms||point to next bounds|15908
        wa += CFP_B*ARDMS;				// point to next bounds
        //b ||bne|7,xt|7,xs|6,arf02|loop back if more to go|15909
        if ((xt-xs) != 0) C_GOTO(arf02);				// loop back if more to go
//      here with integer subscript computed
        //b ||mfi|8,wa|||get as one word integer|15913
        wa = ia;				// get as one word integer
        //b ||wtb|8,wa|||convert to offset|15914
        wa <<= LOG_CFP_B;				// convert to offset
        //b ||mov|7,xl|3,r_arf||point to arblk|15915
        xl= v.r_arf;				// point to arblk
        //b ||add|8,wa|13,arofs(xl)||add offset past bounds|15916
        wa += *((word *)(CFP_B*AROFS + xl));				// add offset past bounds
        //b ||ica|8,wa|||adjust for arpro field|15917
        wa += CFP_B;				// adjust for arpro field
        //b ||bnz|8,wb|6,arf08||exit with name if name call|15918
        if (wb) C_GOTO(arf08);				// exit with name if name call
//      merge here to get value for value call
// arf05:
        //b |arf05|jsr|6,acess|||get value|15922
        C_GOTO(arf05);
        } /* arf04 */
        

        void arf05() {
        //b ||ppm|6,arf13|||fail if acess fails|15923
        C_JSR_1(acess,C_GOTO(arf13));				// fail if acess fails
//      return value
// arf06:
        //b |arf06|mov|7,xs|3,arfxs||pop stack entries|15927
        C_GOTO(arf06);
        } /* arf05 */
        

        void arf06() {
        xs= v.arfxs;				// pop stack entries
        //b ||zer|3,r_arf|||finished with array pointer|15928
        v.r_arf=0;				// finished with array pointer
        //b ||mov|11,-(xs)|7,xr||stack result|15929
        C_PUSH(xr);				// stack result
        //b ||lcw|7,xr|||get next code word|15930
        xr  = *((word *)reg_cp);				// get next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|15931
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||15932
        
//      arref (continued)
//      here for vector
// arf07:
        //b |arf07|bne|8,wa|18,=num01|6,arf09|error if more than 1 subscript|15938
        } /* arf06 */
        

        void arf07() {
        if ((wa-NUM01) != 0) C_GOTO(arf09);				// error if more than 1 subscript
        //b ||mov|7,xr|9,(xs)||else load subscript|15939
        xr= *(xs_it.wp);				// else load subscript
        //b ||ppm|6,arf12|||error if not integer|15941
        C_JSR_1(gtint,C_GOTO(arf12));				// error if not integer
        //b ||ldi|13,icval(xr)|||else load integer value|15942
        ia = *((word *)(CFP_B*ICVAL + xr));				// else load integer value
        //b ||sbi|4,intv1|||subtract for ones offset|15943
        ia-=c.intv1;				// subtract for ones offset
        //b ||mfi|8,wa|6,arf13||get subscript as one word|15944
        if (ia<0) C_GOTO( arf13);				// get subscript as one word
        wa = ia;
        //b ||add|8,wa|18,=vcvls||add offset for standard fields|15945
        wa += VCVLS;				// add offset for standard fields
        //b ||wtb|8,wa|||convert offset to bytes|15946
        wa <<= LOG_CFP_B;				// convert offset to bytes
        //b ||bge|8,wa|13,vclen(xl)|6,arf13|fail if out of range subscript|15947
        if ((wa-*((word *)(CFP_B*VCLEN + xl))) >= 0) C_GOTO(arf13);				// fail if out of range subscript
        //b ||bze|8,wb|6,arf05||back to get value if value call|15948
        if ( !( wb) ) C_GOTO(arf05);				// back to get value if value call
//      return name
// arf08:
        //b |arf08|mov|7,xs|3,arfxs||pop stack entries|15952
        C_GOTO(arf08);
        } /* arf07 */
        

        void arf08() {
        xs= v.arfxs;				// pop stack entries
        //b ||zer|3,r_arf|||finished with array pointer|15953
        v.r_arf=0;				// finished with array pointer
        //b ||brn|6,exnam|||else exit with name|15954
         C_GOTO(exnam);				// else exit with name
//      here if subscript count is wrong
// arf09:
        //b |arf09|erb|1,236|26,array referenced with wrong number of subscripts|||15958
        } /* arf08 */
        

        void arf09() {
        C_ERB(236)
//      table
// arf10:
        //b |arf10|bne|8,wa|18,=num01|6,arf11|error if more than 1 subscript|15962
        } /* arf09 */
        

        void arf10() {
        if ((wa-NUM01) != 0) C_GOTO(arf11);				// error if more than 1 subscript
        //b ||mov|7,xr|9,(xs)||else load subscript|15963
        xr= *(xs_it.wp);				// else load subscript
        //b ||ppm|6,arf13|||fail if failed|15965
        C_JSR_1(tfind,C_GOTO(arf13));				// fail if failed
        //b ||bnz|8,wb|6,arf08||exit with name if name call|15966
        if (wb) C_GOTO(arf08);				// exit with name if name call
        //b ||brn|6,arf06|||else exit with value|15967
         C_GOTO(arf06);				// else exit with value
//      here for bad table reference
// arf11:
        //b |arf11|erb|1,237|26,table referenced with more than one subscript|||15971
        } /* arf10 */
        

        void arf11() {
        C_ERB(237)
//      here for bad subscript
// arf12:
        //b |arf12|erb|1,238|26,array subscript is not integer|||15975
        } /* arf11 */
        

        void arf12() {
        C_ERB(238)
//      here to signal failure
// arf13:
        //b |arf13|zer|3,r_arf|||finished with array pointer|15979
        } /* arf12 */
        

        void arf13() {
        v.r_arf=0;				// finished with array pointer
        //b ||brn|6,exfal|||fail|15980
         C_GOTO(exfal);				// fail
        //b ||ejc|||||15981
        
//      cfunc -- call a function
//      cfunc is used to call a snobol level function. it is
//      used by the apply function (s_app), the function
//      trace routine (trxeq) and the main function call entry
//      (o_fnc, o_fns). in the latter cases, cfunc is used only
//      if the number of arguments is incorrect.
//      (xl)                  pointer to function block
//      (wa)                  actual number of arguments
//      (xs)                  points to stacked arguments
//      brn  cfunc            jump to call function
//      cfunc continues by executing the function
// cfunc:
        //b |cfunc|rtn|||||15998
        } /* arf13 */
        

        void cfunc() {
        //b ||blt|8,wa|13,fargs(xl)|6,cfnc1|jump if too few arguments|15999
        if ((wa-*((word *)(CFP_B*FARGS + xl))) < 0) C_GOTO(cfnc1);				// jump if too few arguments
        //b ||beq|8,wa|13,fargs(xl)|6,cfnc3|jump if correct number of args|16000
        if ((wa-*((word *)(CFP_B*FARGS + xl))) == 0) C_GOTO(cfnc3);				// jump if correct number of args
//      here if too many arguments supplied, pop them off
        //b ||mov|8,wb|8,wa||copy actual number|16004
        wb= wa;				// copy actual number
        //b ||sub|8,wb|13,fargs(xl)||get number of extra args|16005
        wb -= *((word *)(CFP_B*FARGS + xl));				// get number of extra args
        //b ||wtb|8,wb|||convert to bytes|16006
        wb <<= LOG_CFP_B;				// convert to bytes
        //b ||add|7,xs|8,wb||pop off unwanted arguments|16007
        xs += wb;				// pop off unwanted arguments
        //b ||brn|6,cfnc3|||jump to go off to function|16008
         C_GOTO(cfnc3);				// jump to go off to function
//      here if too few arguments
// cfnc1:
        //b |cfnc1|mov|8,wb|13,fargs(xl)||load required number of arguments|16012
        } /* cfunc */
        

        void cfnc1() {
        wb= *((word *)(CFP_B*FARGS + xl));				// load required number of arguments
        //b ||beq|8,wb|18,=nini9|6,cfnc3|jump if case of var num of args|16013
        if ((wb-NINI9) == 0) C_GOTO(cfnc3);				// jump if case of var num of args
        //b ||sub|8,wb|8,wa||calculate number missing|16014
        wb -= wa;				// calculate number missing
        //b ||lct|8,wb|8,wb||set counter to control loop|16015
        wb= wb;				// set counter to control loop
//      loop to supply extra null arguments
// cfnc2:
        //b |cfnc2|mov|11,-(xs)|21,=nulls||stack a null argument|16019
        C_GOTO(cfnc2);
        } /* cfnc1 */
        

        void cfnc2() {
        C_PUSH((word)(&c.nulls));				// stack a null argument
        //b ||bct|8,wb|6,cfnc2||loop till proper number stacked|16020
        if ((--wb))  C_GOTO(cfnc2);				// loop till proper number stacked
//      merge here to jump to function
// cfnc3:
        //b |cfnc3|bri|9,(xl)|||jump through fcode field|16024
        C_GOTO(cfnc3);
        } /* cfnc2 */
        

        void cfnc3() {
        w0 = xl_it.wp[0];				// jump through fcode field
        C_GOTO(w0_it.callp);
        //b ||ejc|||||16025
        
//      exfal -- exit signalling snobol failure
//      (xl,xr)               may be non-collectable
//      brn  exfal            jump to fail
//      exfal continues by executing the appropriate fail goto
// exfal:
        //b |exfal|rtn|||||16034
        } /* cfnc3 */
        

        void exfal() {
        //b ||mov|7,xs|3,flptr||pop stack|16035
        xs= v.flptr;				// pop stack
        //b ||mov|7,xr|9,(xs)||load failure offset|16036
        xr= *(xs_it.wp);				// load failure offset
        //b ||add|7,xr|3,r_cod||point to failure code location|16037
        xr += v.r_cod;				// point to failure code location
        //b ||lcp|7,xr|||set code pointer|16038
        reg_cp = xr;				// set code pointer
        //b ||lcw|7,xr|||load next code word|16039
        xr  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||mov|7,xl|9,(xr)||load entry address|16040
        xl= *(xr_it.wp);				// load entry address
        //b ||bri|7,xl|||jump to execute next code word|16041
        C_GOTO(xl_it.callp);				// jump to execute next code word
        //b ||ejc|||||16042
        
//      exint -- exit with integer result
//      (xl,xr)               may be non-collectable
//      (ia)                  integer value
//      brn  exint            jump to exit with integer
//      exint continues by executing the next code word
//      which it does by falling through to exixr
// exint:
        //b |exint|rtn|||||16053
        } /* exfal */
        

        void exint() {
        //b ||zer|7,xl|||clear dud value|16054
        xl=0;				// clear dud value
        //b ||jsr|6,icbld|||build icblk|16055
        C_JSR(icbld);				// build icblk
        //b ||ejc|||||16056
        
//      exixr -- exit with result in (xr)
//      (xr)                  result
//      (xl)                  may be non-collectable
//      brn  exixr            jump to exit with result in (xr)
//      exixr continues by executing the next code word
//      which it does by falling through to exits.
// exixr:
        //b |exixr|rtn|||||16065
        C_GOTO(exixr);
        } /* exint */
        

        void exixr() {
        //b ||mov|11,-(xs)|7,xr||stack result|16067
        C_PUSH(xr);				// stack result
//      exits -- exit with result if any stacked
//      (xr,xl)               may be non-collectable
//      brn  exits            enter exits routine
// exits:
        //b |exits|rtn|||||16076
        C_GOTO(exits);
        } /* exixr */
        

        void exits() {
        //b ||lcw|7,xr|||load next code word|16077
        xr  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||mov|7,xl|9,(xr)||load entry address|16078
        xl= *(xr_it.wp);				// load entry address
        //b ||bri|7,xl|||jump to execute next code word|16079
        C_GOTO(xl_it.callp);				// jump to execute next code word
        //b ||ejc|||||16080
        
//      exnam -- exit with name in (xl,wa)
//      (xl)                  name base
//      (wa)                  name offset
//      (xr)                  may be non-collectable
//      brn  exnam            jump to exit with name in (xl,wa)
//      exnam continues by executing the next code word
// exnam:
        //b |exnam|rtn|||||16091
        } /* exits */
        

        void exnam() {
        //b ||mov|11,-(xs)|7,xl||stack name base|16092
        C_PUSH(xl);				// stack name base
        //b ||mov|11,-(xs)|8,wa||stack name offset|16093
        C_PUSH(wa);				// stack name offset
        //b ||lcw|7,xr|||load next code word|16094
        xr  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|16095
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||16096
        
//      exnul -- exit with null result
//      (xl,xr)               may be non-collectable
//      brn  exnul            jump to exit with null value
//      exnul continues by executing the next code word
// exnul:
        //b |exnul|rtn|||||16105
        } /* exnam */
        

        void exnul() {
        //b ||mov|11,-(xs)|21,=nulls||stack null value|16106
        C_PUSH((word)(&c.nulls));				// stack null value
        //b ||lcw|7,xr|||load next code word|16107
        xr  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||mov|7,xl|9,(xr)||load entry address|16108
        xl= *(xr_it.wp);				// load entry address
        //b ||bri|7,xl|||jump to execute next code word|16109
        C_GOTO(xl_it.callp);				// jump to execute next code word
        //b ||ejc|||||16110
        
//      exrea -- exit with real result
//      (xl,xr)               may be non-collectable
//      (ra)                  real value
//      brn  exrea            jump to exit with real value
//      exrea continues by executing the next code word
// exrea:
        //b |exrea|rtn|||||16122
        } /* exnul */
        

        void exrea() {
        //b ||zer|7,xl|||clear dud value|16123
        xl=0;				// clear dud value
        //b ||jsr|6,rcbld|||build rcblk|16124
        C_JSR(rcbld);				// build rcblk
        //b ||brn|6,exixr|||jump to exit with result in xr|16125
         C_GOTO(exixr);				// jump to exit with result in xr
        //b ||ejc|||||16127
        
//      exsid -- exit setting id field
//      exsid is used to exit after building any of the following
//      blocks (arblk, tbblk, pdblk, vcblk). it sets the idval.
//      (xr)                  ptr to block with idval field
//      (xl)                  may be non-collectable
//      brn  exsid            jump to exit after setting id field
//      exsid continues by executing the next code word
// exsid:
        //b |exsid|rtn|||||16140
        } /* exrea */
        

        void exsid() {
        //b ||mov|8,wa|3,curid||load current id value|16141
        wa= v.curid;				// load current id value
        //b ||bne|8,wa|3,mxint|6,exsi1|jump if no overflow|16142
        if ((wa-v.mxint) != 0) C_GOTO(exsi1);				// jump if no overflow
        //b ||zer|8,wa|||else reset for wraparound|16143
        wa=0;				// else reset for wraparound
//      here with old idval in wa
// exsi1:
        //b |exsi1|icv|8,wa|||bump id value|16147
        C_GOTO(exsi1);
        } /* exsid */
        

        void exsi1() {
        (wa)++;				// bump id value
        //b ||mov|3,curid|8,wa||store for next time|16148
        v.curid= wa;				// store for next time
        //b ||mov|13,idval(xr)|8,wa||store id value|16149
        *((word *)(CFP_B*IDVAL + xr))= wa;				// store id value
        //b ||brn|6,exixr|||exit with result in (xr)|16150
         C_GOTO(exixr);				// exit with result in (xr)
        //b ||ejc|||||16151
        
//      exvnm -- exit with name of variable
//      exvnm exits after stacking a value which is a nmblk
//      referencing the name of a given natural variable.
//      (xr)                  vrblk pointer
//      (xl)                  may be non-collectable
//      brn  exvnm            exit with vrblk pointer in xr
// exvnm:
        //b |exvnm|rtn|||||16162
        } /* exsi1 */
        

        void exvnm() {
        //b ||mov|7,xl|7,xr||copy name base pointer|16163
        xl= xr;				// copy name base pointer
        //b ||mov|8,wa|19,*nmsi_||set size of nmblk|16164
        wa= CFP_B*NMSI_;				// set size of nmblk
        //b ||jsr|6,alloc|||allocate nmblk|16165
        C_JSR(alloc);				// allocate nmblk
        //b ||mov|9,(xr)|22,=b_nml||store type word|16166
        *(xr_it.wp)= (word)(b_nml);				// store type word
        //b ||mov|13,nmbas(xr)|7,xl||store name base|16167
        *((word *)(CFP_B*NMBAS + xr))= xl;				// store name base
        //b ||mov|13,nmofs(xr)|19,*vrval||store name offset|16168
        *((word *)(CFP_B*NMOFS + xr))= CFP_B*VRVAL;				// store name offset
        //b ||brn|6,exixr|||exit with result in xr|16169
         C_GOTO(exixr);				// exit with result in xr
        //b ||ejc|||||16170
        
//      flpop -- fail and pop in pattern matching
//      flpop pops the node and cursor on the stack and then
//      drops through into failp to cause pattern failure
//      (xl,xr)               may be non-collectable
//      brn  flpop            jump to fail and pop stack
// flpop:
        //b |flpop|rtn|||||16180
        } /* exvnm */
        

        void flpop() {
        //b ||add|7,xs|19,*num02||pop two entries off stack|16181
        xs += CFP_B*NUM02;				// pop two entries off stack
        //b ||ejc|||||16182
        
//      failp -- failure in matching pattern node
//      failp is used after failing to match a pattern node.
//      see pattern match routines for details of use.
//      (xl,xr)               may be non-collectable
//      brn  failp            signal failure to match
//      failp continues by matching an alternative from the stack
// failp:
        //b |failp|rtn|||||16194
        C_GOTO(failp);
        } /* flpop */
        

        void failp() {
        //b ||mov|7,xr|10,(xs)+||load alternative node pointer|16195
        xr= C_POP();				// load alternative node pointer
        //b ||mov|8,wb|10,(xs)+||restore old cursor|16196
        wb= C_POP();				// restore old cursor
        //b ||mov|7,xl|9,(xr)||load pcode entry pointer|16197
        xl= *(xr_it.wp);				// load pcode entry pointer
        //b ||bri|7,xl|||jump to execute code for node|16198
        C_GOTO(xl_it.callp);				// jump to execute code for node
        //b ||ejc|||||16199
        
//      indir -- compute indirect reference
//      (wb)                  nonzero/zero for by name/value
//      brn  indir            jump to get indirect ref on stack
//      indir continues by executing the next code word
// indir:
        //b |indir|rtn|||||16208
        } /* failp */
        

        void indir() {
        //b ||mov|7,xr|10,(xs)+||load argument|16209
        xr= C_POP();				// load argument
        //b ||beq|9,(xr)|22,=b_nml|6,indr2|jump if a name|16210
        if ((*(xr_it.wp)-(word)(b_nml)) == 0) C_GOTO(indr2);				// jump if a name
        //b ||err|1,239|26,indirection operand is not name|||16212
        C_JSR_1(gtnvr,(C_ERR(239)));
        //b ||bze|8,wb|6,indr1||skip if by value|16213
        if ( !( wb) ) C_GOTO(indr1);				// skip if by value
        //b ||mov|11,-(xs)|7,xr||else stack vrblk ptr|16214
        C_PUSH(xr);				// else stack vrblk ptr
        //b ||mov|11,-(xs)|19,*vrval||stack name offset|16215
        C_PUSH(CFP_B*VRVAL);				// stack name offset
        //b ||lcw|7,xr|||load next code word|16216
        xr  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||mov|7,xl|9,(xr)||load entry address|16217
        xl= *(xr_it.wp);				// load entry address
        //b ||bri|7,xl|||jump to execute next code word|16218
        C_GOTO(xl_it.callp);				// jump to execute next code word
//      here to get value of natural variable
// indr1:
        //b |indr1|bri|9,(xr)|||jump through vrget field of vrblk|16222
        } /* indir */
        

        void indr1() {
        w0 = xr_it.wp[0];				// jump through vrget field of vrblk
        C_GOTO(w0_it.callp);
//      here if operand is a name
// indr2:
        //b |indr2|mov|7,xl|13,nmbas(xr)||load name base|16226
        } /* indr1 */
        

        void indr2() {
        xl= *((word *)(CFP_B*NMBAS + xr));				// load name base
        //b ||mov|8,wa|13,nmofs(xr)||load name offset|16227
        wa= *((word *)(CFP_B*NMOFS + xr));				// load name offset
        //b ||bnz|8,wb|6,exnam||exit if called by name|16228
        if (wb) C_GOTO(exnam);				// exit if called by name
        //b ||ppm|6,exfal|||fail if access fails|16230
        C_JSR_1(acess,C_GOTO(exfal));				// fail if access fails
        //b ||brn|6,exixr|||else return with value in xr|16231
         C_GOTO(exixr);				// else return with value in xr
        //b ||ejc|||||16232
        
//      match -- initiate pattern match
//      (wb)                  match type code
//      brn  match            jump to initiate pattern match
//      match continues by executing the pattern match. see
//      pattern match routines (p_xxx) for full details.
// match:
        //b |match|rtn|||||16242
        } /* indr2 */
        

        void match() {
        //b ||mov|7,xr|10,(xs)+||load pattern operand|16243
        xr= C_POP();				// load pattern operand
        //b ||err|1,240|26,pattern match right operand is not pattern|||16245
        C_JSR_1(gtpat,(C_ERR(240)));
        //b ||mov|7,xl|7,xr||if ok, save pattern pointer|16246
        xl= xr;				// if ok, save pattern pointer
        //b ||bnz|8,wb|6,mtch1||jump if not match by name|16247
        if (wb) C_GOTO(mtch1);				// jump if not match by name
        //b ||mov|8,wa|9,(xs)||else load name offset|16248
        wa= *(xs_it.wp);				// else load name offset
        //b ||mov|11,-(xs)|7,xl||save pattern pointer|16249
        C_PUSH(xl);				// save pattern pointer
        //b ||mov|7,xl|13,num02(xs)||load name base|16250
        xl= *((word *)(CFP_B*NUM02 + xs));				// load name base
        //b ||ppm|6,exfal|||fail if access fails|16252
        C_JSR_1(acess,C_GOTO(exfal));				// fail if access fails
        //b ||mov|7,xl|9,(xs)||restore pattern pointer|16253
        xl= *(xs_it.wp);				// restore pattern pointer
        //b ||mov|9,(xs)|7,xr||stack subject string val for merge|16254
        *(xs_it.wp)= xr;				// stack subject string val for merge
        //b ||zer|8,wb|||restore type code|16255
        wb=0;				// restore type code
//      merge here with subject value on stack
// mtch1:
        //b |mtch1|jsr|6,gtstg|||convert subject to string|16260
        C_GOTO(mtch1);
        } /* match */
        

        void mtch1() {
        //b ||err|1,241|26,pattern match left operand is not a string|||16261
        extern void _l0521();
        C_JMS(gtstg,P_PRC_GTSTG,_l0521);
        } /* mtch1 */
        

        void _l0521() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(241)));
        //b ||mov|11,-(xs)|8,wb||stack match type code|16262
        C_PUSH(wb);				// stack match type code
        //b ||mov|3,r_pms|7,xr||if ok, store subject string pointer|16270
        v.r_pms= xr;				// if ok, store subject string pointer
        //b ||mov|3,pmssl|8,wa||and length|16271
        v.pmssl= wa;				// and length
        //b ||zer|11,-(xs)|||stack initial cursor (zero)|16272
        *(--xs_it.wp)=0;				// stack initial cursor (zero)
        //b ||zer|8,wb|||set initial cursor|16273
        wb=0;				// set initial cursor
        //b ||mov|3,pmhbs|7,xs||set history stack base ptr|16274
        v.pmhbs= xs;				// set history stack base ptr
        //b ||zer|3,pmdfl|||reset pattern assignment flag|16275
        v.pmdfl=0;				// reset pattern assignment flag
        //b ||mov|7,xr|7,xl||set initial node pointer|16276
        xr= xl;				// set initial node pointer
        //b ||bnz|3,kvanc|6,mtch2||jump if anchored|16277
        if (v.kvanc) C_GOTO(mtch2);				// jump if anchored
//      here for unanchored
        //b ||mov|11,-(xs)|7,xr||stack initial node pointer|16281
        C_PUSH(xr);				// stack initial node pointer
        //b ||mov|11,-(xs)|21,=nduna||stack pointer to anchor move node|16282
        C_PUSH((word)(&c.nduna));				// stack pointer to anchor move node
        //b ||bri|9,(xr)|||start match of first node|16283
        w0 = xr_it.wp[0];				// start match of first node
        C_GOTO(w0_it.callp);
//      here in anchored mode
// mtch2:
        //b |mtch2|zer|11,-(xs)|||dummy cursor value|16287
        } /* _l0521 */
        

        void mtch2() {
        *(--xs_it.wp)=0;				// dummy cursor value
        //b ||mov|11,-(xs)|21,=ndabo||stack pointer to abort node|16288
        C_PUSH((word)(&c.ndabo));				// stack pointer to abort node
        //b ||bri|9,(xr)|||start match of first node|16289
        w0 = xr_it.wp[0];				// start match of first node
        C_GOTO(w0_it.callp);
        //b ||ejc|||||16290
        
//      retrn -- return from function
//      (wa)                  string pointer for return type
//      brn  retrn            jump to return from (snobol) func
//      retrn continues by executing the code at the return point
//      the stack is cleaned of any garbage left by other
//      routines which may have altered flptr since function
//      entry by using flprt, reserved for use only by
//      function call and return.
// retrn:
        //b |retrn|rtn|||||16303
        } /* mtch2 */
        

        void retrn() {
        //b ||bnz|3,kvfnc|6,rtn01||jump if not level zero|16304
        if (v.kvfnc) C_GOTO(rtn01);				// jump if not level zero
        //b ||erb|1,242|26,function return from level zero|||16305
        C_ERB(242)
//      here if not level zero return
// rtn01:
        //b |rtn01|mov|7,xs|3,flprt||pop stack|16309
        } /* retrn */
        

        void rtn01() {
        xs= v.flprt;				// pop stack
        //b ||ica|7,xs|||remove failure offset|16310
        xs += CFP_B;				// remove failure offset
        //b ||mov|7,xr|10,(xs)+||pop pfblk pointer|16311
        xr= C_POP();				// pop pfblk pointer
        //b ||mov|3,flptr|10,(xs)+||pop failure pointer|16312
        v.flptr= C_POP();				// pop failure pointer
        //b ||mov|3,flprt|10,(xs)+||pop old flprt|16313
        v.flprt= C_POP();				// pop old flprt
        //b ||mov|8,wb|10,(xs)+||pop code pointer offset|16314
        wb= C_POP();				// pop code pointer offset
        //b ||mov|8,wc|10,(xs)+||pop old code block pointer|16315
        wc= C_POP();				// pop old code block pointer
        //b ||add|8,wb|8,wc||make old code pointer absolute|16316
        wb += wc;				// make old code pointer absolute
        //b ||lcp|8,wb|||restore old code pointer|16317
        reg_cp = wb;				// restore old code pointer
        //b ||mov|3,r_cod|8,wc||restore old code block pointer|16318
        v.r_cod= wc;				// restore old code block pointer
        //b ||dcv|3,kvfnc|||decrement function level|16319
        (v.kvfnc)--;				// decrement function level
        //b ||mov|8,wb|3,kvtra||load trace|16320
        wb= v.kvtra;				// load trace
        //b ||add|8,wb|3,kvftr||add ftrace|16321
        wb += v.kvftr;				// add ftrace
        //b ||bze|8,wb|6,rtn06||jump if no tracing possible|16322
        if ( !( wb) ) C_GOTO(rtn06);				// jump if no tracing possible
//      here if there may be a trace
        //b ||mov|11,-(xs)|8,wa||save function return type|16326
        C_PUSH(wa);				// save function return type
        //b ||mov|11,-(xs)|7,xr||save pfblk pointer|16327
        C_PUSH(xr);				// save pfblk pointer
        //b ||mov|3,kvrtn|8,wa||set rtntype for trace function|16328
        v.kvrtn= wa;				// set rtntype for trace function
        //b ||mov|7,xl|3,r_fnc||load fnclevel trblk ptr (if any)|16329
        xl= v.r_fnc;				// load fnclevel trblk ptr (if any)
        //b ||jsr|6,ktrex|||execute possible fnclevel trace|16330
        C_JSR(ktrex);				// execute possible fnclevel trace
        //b ||mov|7,xl|13,pfvbl(xr)||load vrblk ptr (sgd13)|16331
        xl= *((word *)(CFP_B*PFVBL + xr));				// load vrblk ptr (sgd13)
        //b ||bze|3,kvtra|6,rtn02||jump if trace is off|16332
        if ( !( v.kvtra) ) C_GOTO(rtn02);				// jump if trace is off
        //b ||mov|7,xr|13,pfrtr(xr)||else load return trace trblk ptr|16333
        xr= *((word *)(CFP_B*PFRTR + xr));				// else load return trace trblk ptr
        //b ||bze|7,xr|6,rtn02||jump if not return traced|16334
        if ( !( xr) ) C_GOTO(rtn02);				// jump if not return traced
        //b ||dcv|3,kvtra|||else decrement trace count|16335
        (v.kvtra)--;				// else decrement trace count
        //b ||bze|13,trfnc(xr)|6,rtn03||jump if print trace|16336
        if ( !( *((word *)(CFP_B*TRFNC + xr))) ) C_GOTO(rtn03);				// jump if print trace
        //b ||mov|8,wa|19,*vrval||else set name offset|16337
        wa= CFP_B*VRVAL;				// else set name offset
        //b ||mov|3,kvrtn|13,num01(xs)||make sure rtntype is set right|16338
        v.kvrtn= *((word *)(CFP_B*NUM01 + xs));				// make sure rtntype is set right
        //b ||jsr|6,trxeq|||execute full trace|16339
        C_JSR(trxeq);				// execute full trace
        //b ||ejc|||||16340
        
//      retrn (continued)
//      here to test for ftrace
// rtn02:
        //b |rtn02|bze|3,kvftr|6,rtn05||jump if ftrace is off|16346
        C_GOTO(rtn02);
        } /* rtn01 */
        

        void rtn02() {
        if ( !( v.kvftr) ) C_GOTO(rtn05);				// jump if ftrace is off
        //b ||dcv|3,kvftr|||else decrement ftrace|16347
        (v.kvftr)--;				// else decrement ftrace
//      here for print trace of function return
// rtn03:
        //b |rtn03|jsr|6,prtsn|||print statement number|16351
        C_GOTO(rtn03);
        } /* rtn02 */
        

        void rtn03() {
        C_JSR(prtsn);				// print statement number
        //b ||mov|7,xr|13,num01(xs)||load return type|16352
        xr= *((word *)(CFP_B*NUM01 + xs));				// load return type
        //b ||jsr|6,prtst|||print it|16353
        C_JSR(prtst);				// print it
        //b ||mov|8,wa|18,=ch_bl||load blank|16354
        wa= CH_BL;				// load blank
        //b ||jsr|6,prtch|||print it|16355
        C_JSR(prtch);				// print it
        //b ||mov|7,xl|12,0(xs)||load pfblk ptr|16356
        xl= *((word *)(CFP_B*0 + xs));				// load pfblk ptr
        //b ||mov|7,xl|13,pfvbl(xl)||load function vrblk ptr|16357
        xl= *((word *)(CFP_B*PFVBL + xl));				// load function vrblk ptr
        //b ||mov|8,wa|19,*vrval||set vrblk name offset|16358
        wa= CFP_B*VRVAL;				// set vrblk name offset
        //b ||bne|7,xr|21,=scfrt|6,rtn04|jump if not freturn case|16359
        if ((xr-(word)(&c.scfrt)) != 0) C_GOTO(rtn04);				// jump if not freturn case
//      for freturn, just print function name
        //b ||jsr|6,prtnm|||print name|16363
        C_JSR(prtnm);				// print name
        //b ||jsr|6,prtnl|||terminate print line|16364
        C_JSR(prtnl);				// terminate print line
        //b ||brn|6,rtn05|||merge|16365
         C_GOTO(rtn05);				// merge
//      here for return or nreturn, print function name = value
// rtn04:
        //b |rtn04|jsr|6,prtnv|||print name = value|16369
        } /* rtn03 */
        

        void rtn04() {
        C_JSR(prtnv);				// print name = value
//      here after completing trace
// rtn05:
        //b |rtn05|mov|7,xr|10,(xs)+||pop pfblk pointer|16373
        C_GOTO(rtn05);
        } /* rtn04 */
        

        void rtn05() {
        xr= C_POP();				// pop pfblk pointer
        //b ||mov|8,wa|10,(xs)+||pop return type string|16374
        wa= C_POP();				// pop return type string
//      merge here if no trace required
// rtn06:
        //b |rtn06|mov|3,kvrtn|8,wa||set rtntype keyword|16378
        C_GOTO(rtn06);
        } /* rtn05 */
        

        void rtn06() {
        v.kvrtn= wa;				// set rtntype keyword
        //b ||mov|7,xl|13,pfvbl(xr)||load pointer to fn vrblk|16379
        xl= *((word *)(CFP_B*PFVBL + xr));				// load pointer to fn vrblk
        //b ||ejc|||||16380
        
//      retrn (continued)
//      get value of function
// rtn07:
        //b |rtn07|mov|3,rtnbp|7,xl||save block pointer|16385
        C_GOTO(rtn07);
        } /* rtn06 */
        

        void rtn07() {
        v.rtnbp= xl;				// save block pointer
        //b ||mov|7,xl|13,vrval(xl)||load value|16386
        xl= *((word *)(CFP_B*VRVAL + xl));				// load value
        //b ||beq|9,(xl)|22,=b_trt|6,rtn07|loop back if trapped|16387
        if ((*(xl_it.wp)-(word)(b_trt)) == 0) C_GOTO(rtn07);				// loop back if trapped
        //b ||mov|3,rtnfv|7,xl||else save function result value|16388
        v.rtnfv= xl;				// else save function result value
        //b ||mov|3,rtnsv|10,(xs)+||save original function value|16389
        v.rtnsv= C_POP();				// save original function value
        //b ||mov|7,xl|10,(xs)+||pop saved pointer|16393
        xl= C_POP();				// pop saved pointer
        //b ||bze|7,xl|6,rtn7c||no action if none|16394
        if ( !( xl) ) C_GOTO(rtn7c);				// no action if none
        //b ||bze|3,kvpfl|6,rtn7c||jump if no profiling|16395
        if ( !( v.kvpfl) ) C_GOTO(rtn7c);				// jump if no profiling
        //b ||jsr|6,prflu|||else profile last func stmt|16396
        C_JSR(prflu);				// else profile last func stmt
        //b ||beq|3,kvpfl|18,=num02|6,rtn7a|branch on value of profile keywd|16397
        if ((v.kvpfl-NUM02) == 0) C_GOTO(rtn7a);				// branch on value of profile keywd
//      here if &profile = 1. start time must be frigged to
//      appear earlier than it actually is, by amount used before
//      the call.
        //b ||ldi|3,pfstm|||load current time|16403
        ia = v.pfstm;				// load current time
        //b ||sbi|13,icval(xl)|||frig by subtracting saved amount|16404
        ia-=*((word *)(CFP_B*ICVAL + xl));				// frig by subtracting saved amount
        //b ||brn|6,rtn7b|||and merge|16405
         C_GOTO(rtn7b);				// and merge
//      here if &profile = 2
// rtn7a:
        //b |rtn7a|ldi|13,icval(xl)|||load saved time|16409
        } /* rtn07 */
        

        void rtn7a() {
        ia = *((word *)(CFP_B*ICVAL + xl));				// load saved time
//      both profile types merge here
// rtn7b:
        //b |rtn7b|sti|3,pfstm|||store back correct start time|16413
        C_GOTO(rtn7b);
        } /* rtn7a */
        

        void rtn7b() {
        v.pfstm= ia;				// store back correct start time
//      merge here if no profiling
// rtn7c:
        //b |rtn7c|mov|8,wb|13,fargs(xr)||get number of args|16417
        C_GOTO(rtn7c);
        } /* rtn7b */
        

        void rtn7c() {
        wb= *((word *)(CFP_B*FARGS + xr));				// get number of args
        //b ||add|8,wb|13,pfnlo(xr)||add number of locals|16419
        wb += *((word *)(CFP_B*PFNLO + xr));				// add number of locals
        //b ||bze|8,wb|6,rtn10||jump if no args/locals|16420
        if ( !( wb) ) C_GOTO(rtn10);				// jump if no args/locals
        //b ||lct|8,wb|8,wb||else set loop counter|16421
        wb= wb;				// else set loop counter
        //b ||add|7,xr|13,pflen(xr)||and point to end of pfblk|16422
        xr += *((word *)(CFP_B*PFLEN + xr));				// and point to end of pfblk
//      loop to restore functions and locals
// rtn08:
        //b |rtn08|mov|7,xl|11,-(xr)||load next vrblk pointer|16426
        C_GOTO(rtn08);
        } /* rtn7c */
        

        void rtn08() {
        xl= *(--xr_it.wp);				// load next vrblk pointer
//      loop to find value block
// rtn09:
        //b |rtn09|mov|8,wa|7,xl||save block pointer|16430
        C_GOTO(rtn09);
        } /* rtn08 */
        

        void rtn09() {
        wa= xl;				// save block pointer
        //b ||mov|7,xl|13,vrval(xl)||load pointer to next value|16431
        xl= *((word *)(CFP_B*VRVAL + xl));				// load pointer to next value
        //b ||beq|9,(xl)|22,=b_trt|6,rtn09|loop back if trapped|16432
        if ((*(xl_it.wp)-(word)(b_trt)) == 0) C_GOTO(rtn09);				// loop back if trapped
        //b ||mov|7,xl|8,wa||else restore last block pointer|16433
        xl= wa;				// else restore last block pointer
        //b ||mov|13,vrval(xl)|10,(xs)+||restore old variable value|16434
        *((word *)(CFP_B*VRVAL + xl))= C_POP();				// restore old variable value
        //b ||bct|8,wb|6,rtn08||loop till all processed|16435
        if ((--wb))  C_GOTO(rtn08);				// loop till all processed
//      now restore function value and exit
// rtn10:
        //b |rtn10|mov|7,xl|3,rtnbp||restore ptr to last function block|16439
        C_GOTO(rtn10);
        } /* rtn09 */
        

        void rtn10() {
        xl= v.rtnbp;				// restore ptr to last function block
        //b ||mov|13,vrval(xl)|3,rtnsv||restore old function value|16440
        *((word *)(CFP_B*VRVAL + xl))= v.rtnsv;				// restore old function value
        //b ||mov|7,xr|3,rtnfv||reload function result|16441
        xr= v.rtnfv;				// reload function result
        //b ||mov|7,xl|3,r_cod||point to new code block|16442
        xl= v.r_cod;				// point to new code block
        //b ||mov|3,kvlst|3,kvstn||set lastno from stno|16443
        v.kvlst= v.kvstn;				// set lastno from stno
        //b ||mov|3,kvstn|13,cdstm(xl)||reset proper stno value|16444
        v.kvstn= *((word *)(CFP_B*CDSTM + xl));				// reset proper stno value
        //b ||mov|3,kvlln|3,kvlin||set lastline from line|16446
        v.kvlln= v.kvlin;				// set lastline from line
        //b ||mov|3,kvlin|13,cdsln(xl)||reset proper line value|16447
        v.kvlin= *((word *)(CFP_B*CDSLN + xl));				// reset proper line value
        //b ||mov|8,wa|3,kvrtn||load return type|16449
        wa= v.kvrtn;				// load return type
        //b ||beq|8,wa|21,=scrtn|6,exixr|exit with result in xr if return|16450
        if ((wa-(word)(&c.scrtn)) == 0) C_GOTO(exixr);				// exit with result in xr if return
        //b ||beq|8,wa|21,=scfrt|6,exfal|fail if freturn|16451
        if ((wa-(word)(&c.scfrt)) == 0) C_GOTO(exfal);				// fail if freturn
        //b ||ejc|||||16452
        
//      retrn (continued)
//      here for nreturn
        //b ||beq|9,(xr)|22,=b_nml|6,rtn11|jump if is a name|16458
        if ((*(xr_it.wp)-(word)(b_nml)) == 0) C_GOTO(rtn11);				// jump if is a name
        //b ||err|1,243|26,function result in nreturn is not name|||16460
        C_JSR_1(gtnvr,(C_ERR(243)));
        //b ||mov|7,xl|7,xr||if ok, copy vrblk (name base) ptr|16461
        xl= xr;				// if ok, copy vrblk (name base) ptr
        //b ||mov|8,wa|19,*vrval||set name offset|16462
        wa= CFP_B*VRVAL;				// set name offset
        //b ||brn|6,rtn12|||and merge|16463
         C_GOTO(rtn12);				// and merge
//      here if returned result is a name
// rtn11:
        //b |rtn11|mov|7,xl|13,nmbas(xr)||load name base|16467
        } /* rtn10 */
        

        void rtn11() {
        xl= *((word *)(CFP_B*NMBAS + xr));				// load name base
        //b ||mov|8,wa|13,nmofs(xr)||load name offset|16468
        wa= *((word *)(CFP_B*NMOFS + xr));				// load name offset
//      merge here with returned name in (xl,wa)
// rtn12:
        //b |rtn12|mov|7,xr|7,xl||preserve xl|16472
        C_GOTO(rtn12);
        } /* rtn11 */
        

        void rtn12() {
        xr= xl;				// preserve xl
        //b ||lcw|8,wb|||load next word|16473
        wb  = *((word *)reg_cp);				// load next word
          reg_cp += CFP_B;
        //b ||mov|7,xl|7,xr||restore xl|16474
        xl= xr;				// restore xl
        //b ||beq|8,wb|21,=ofne_|6,exnam|exit if called by name|16475
        if ((wb-(word)(&c.ofne_)) == 0) C_GOTO(exnam);				// exit if called by name
        //b ||mov|11,-(xs)|8,wb||else save code word|16476
        C_PUSH(wb);				// else save code word
        //b ||ppm|6,exfal|||fail if access fails|16478
        C_JSR_1(acess,C_GOTO(exfal));				// fail if access fails
        //b ||mov|7,xl|7,xr||if ok, copy result|16479
        xl= xr;				// if ok, copy result
        //b ||mov|7,xr|9,(xs)||reload next code word|16480
        xr= *(xs_it.wp);				// reload next code word
        //b ||mov|9,(xs)|7,xl||store result on stack|16481
        *(xs_it.wp)= xl;				// store result on stack
        //b ||mov|7,xl|9,(xr)||load routine address|16482
        xl= *(xr_it.wp);				// load routine address
        //b ||bri|7,xl|||jump to execute next code word|16483
        C_GOTO(xl_it.callp);				// jump to execute next code word
        //b ||ejc|||||16484
        
//      stcov -- signal statement counter overflow
//      brn  stcov            jump to signal statement count oflo
//      permit up to 10 more statements to be obeyed so that
//      setexit trap can regain control.
//      stcov continues by issuing the error message
// stcov:
        //b |stcov|rtn|||||16494
        } /* rtn12 */
        

        void stcov() {
        //b ||icv|3,errft|||fatal error|16495
        (v.errft)++;				// fatal error
        //b ||ldi|4,intvt|||get 10|16496
        ia = c.intvt;				// get 10
        //b ||adi|3,kvstl|||add to former limit|16497
        ia+=v.kvstl;				// add to former limit
        //b ||sti|3,kvstl|||store as new stlimit|16498
        v.kvstl= ia;				// store as new stlimit
        //b ||ldi|4,intvt|||get 10|16499
        ia = c.intvt;				// get 10
        //b ||sti|3,kvstc|||set as new count|16500
        v.kvstc= ia;				// set as new count
        //b ||jsr|6,stgcc|||recompute countdown counters|16501
        C_JSR(stgcc);				// recompute countdown counters
        //b ||erb|1,244|26,statement count exceeds value of stlimit keyword|||16502
        C_ERB(244)
        //b ||ejc|||||16503
        
//      stmgo -- start execution of new statement
//      (xr)                  pointer to cdblk for new statement
//      brn  stmgo            jump to execute new statement
//      stmgo continues by executing the next statement
// stmgo:
        //b |stmgo|rtn|||||16512
        } /* stcov */
        

        void stmgo() {
        //b ||mov|3,r_cod|7,xr||set new code block pointer|16513
        v.r_cod= xr;				// set new code block pointer
        //b ||dcv|3,stmct|||see if time to check something|16514
        (v.stmct)--;				// see if time to check something
        //b ||bze|3,stmct|6,stgo2||jump if so|16515
        if ( !( v.stmct) ) C_GOTO(stgo2);				// jump if so
        //b ||mov|3,kvlst|3,kvstn||set lastno|16516
        v.kvlst= v.kvstn;				// set lastno
        //b ||mov|3,kvstn|13,cdstm(xr)||set stno|16517
        v.kvstn= *((word *)(CFP_B*CDSTM + xr));				// set stno
        //b ||mov|3,kvlln|3,kvlin||set lastline|16519
        v.kvlln= v.kvlin;				// set lastline
        //b ||mov|3,kvlin|13,cdsln(xr)||set line|16520
        v.kvlin= *((word *)(CFP_B*CDSLN + xr));				// set line
        //b ||add|7,xr|19,*cdcod||point to first code word|16522
        xr += CFP_B*CDCOD;				// point to first code word
        //b ||lcp|7,xr|||set code pointer|16523
        reg_cp = xr;				// set code pointer
//      here to execute first code word of statement
// stgo1:
        //b |stgo1|lcw|7,xr|||load next code word|16527
        C_GOTO(stgo1);
        } /* stmgo */
        

        void stgo1() {
        xr  = *((word *)reg_cp);				// load next code word
          reg_cp += CFP_B;
        //b ||zer|7,xl|||clear garbage xl|16528
        xl=0;				// clear garbage xl
        //b ||bri|9,(xr)|||execute it|16529
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
//      check profiling, polling, stlimit, statement tracing
// stgo2:
        //b |stgo2|bze|3,kvpfl|6,stgo3||skip if no profiling|16533
        } /* stgo1 */
        

        void stgo2() {
        if ( !( v.kvpfl) ) C_GOTO(stgo3);				// skip if no profiling
        //b ||jsr|6,prflu|||else profile the statement in kvstn|16534
        C_JSR(prflu);				// else profile the statement in kvstn
//      here when finished with profiling
// stgo3:
        //b |stgo3|mov|3,kvlst|3,kvstn||set lastno|16538
        C_GOTO(stgo3);
        } /* stgo2 */
        

        void stgo3() {
        v.kvlst= v.kvstn;				// set lastno
        //b ||mov|3,kvstn|13,cdstm(xr)||set stno|16539
        v.kvstn= *((word *)(CFP_B*CDSTM + xr));				// set stno
        //b ||mov|3,kvlln|3,kvlin||set lastline|16541
        v.kvlln= v.kvlin;				// set lastline
        //b ||mov|3,kvlin|13,cdsln(xr)||set line|16542
        v.kvlin= *((word *)(CFP_B*CDSLN + xr));				// set line
        //b ||add|7,xr|19,*cdcod||point to first code word|16544
        xr += CFP_B*CDCOD;				// point to first code word
        //b ||lcp|7,xr|||set code pointer|16545
        reg_cp = xr;				// set code pointer
//      here to check for polling
        //b ||mov|11,-(xs)|3,stmcs||save present count start on stack|16550
        C_PUSH(v.stmcs);				// save present count start on stack
        //b ||dcv|3,polct|||poll interval within stmct|16551
        (v.polct)--;				// poll interval within stmct
        //b ||bnz|3,polct|6,stgo4||jump if not poll time yet|16552
        if (v.polct) C_GOTO(stgo4);				// jump if not poll time yet
        //b ||zer|8,wa|||=0 for poll|16553
        wa=0;				// =0 for poll
        //b ||mov|8,wb|3,kvstn||statement number|16554
        wb= v.kvstn;				// statement number
        //b ||mov|7,xl|7,xr||make collectable|16555
        xl= xr;				// make collectable
        //b ||ppm||||expression evaluation|16559
        C_JSR_3(syspl,(C_ERR(320)),(C_ERR(299)),(C_ERR(299)));				// expression evaluation
        //b ||mov|7,xr|7,xl||restore code block pointer|16560
        xr= xl;				// restore code block pointer
        //b ||mov|3,polcs|8,wa||poll interval start value|16561
        v.polcs= wa;				// poll interval start value
        //b ||jsr|6,stgcc|||recompute counter values|16562
        C_JSR(stgcc);				// recompute counter values
//      check statement limit
// stgo4:
        //b |stgo4|ldi|3,kvstc|||get stmt count|16567
        C_GOTO(stgo4);
        } /* stgo3 */
        

        void stgo4() {
        ia = v.kvstc;				// get stmt count
        //b ||ilt|6,stgo5|||omit counting if negative|16568
        if (ia < 0)  C_GOTO(stgo5);				// omit counting if negative
        //b ||mti|10,(xs)+|||reload start value of counter|16569
        ia = C_POP();				// reload start value of counter
        //b ||ngi||||negate|16570
        ia= -ia;				// negate
        //b ||adi|3,kvstc|||stmt count minus counter|16571
        ia+=v.kvstc;				// stmt count minus counter
        //b ||sti|3,kvstc|||replace it|16572
        v.kvstc= ia;				// replace it
        //b ||ile|6,stcov|||fail if stlimit reached|16573
        if (ia <= 0)  C_GOTO(stcov);				// fail if stlimit reached
        //b ||bze|3,r_stc|6,stgo5||jump if no statement trace|16574
        if ( !( v.r_stc) ) C_GOTO(stgo5);				// jump if no statement trace
        //b ||zer|7,xr|||clear garbage value in xr|16575
        xr=0;				// clear garbage value in xr
        //b ||mov|7,xl|3,r_stc||load pointer to stcount trblk|16576
        xl= v.r_stc;				// load pointer to stcount trblk
        //b ||jsr|6,ktrex|||execute keyword trace|16577
        C_JSR(ktrex);				// execute keyword trace
//      reset stmgo counter
// stgo5:
        //b |stgo5|mov|3,stmct|3,stmcs||reset counter|16581
        C_GOTO(stgo5);
        } /* stgo4 */
        

        void stgo5() {
        v.stmct= v.stmcs;				// reset counter
        //b ||brn|6,stgo1|||fetch next code word|16582
         C_GOTO(stgo1);				// fetch next code word
        //b ||ejc|||||16583
        
//      stopr -- terminate run
//      (xr)                  points to ending message
//      brn stopr             jump to terminate run
//      terminate run and print statistics.  on entry xr points
//      to ending message or is zero if message  printed already.
// stopr:
        //b |stopr|rtn|||||16593
        } /* stgo5 */
        

        void stopr() {
        //b ||bze|7,xr|6,stpra||skip if sysax already called|16595
        if ( !( xr) ) C_GOTO(stpra);				// skip if sysax already called
        //b ||jsr|6,sysax|||call after execution proc|16596
        C_JSR(sysax);				// call after execution proc
// stpra:
        //b |stpra|add|3,dname|3,rsmem||use the reserve memory|16597
        C_GOTO(stpra);
        } /* stopr */
        

        void stpra() {
        v.dname += v.rsmem;				// use the reserve memory
        //b ||bne|7,xr|21,=endms|6,stpr0|skip if not normal end message|16601
        if ((xr-(word)(&c.endms)) != 0) C_GOTO(stpr0);				// skip if not normal end message
        //b ||bnz|3,exsts|6,stpr3||skip if exec stats suppressed|16602
        if (v.exsts) C_GOTO(stpr3);				// skip if exec stats suppressed
        //b ||zer|3,erich|||clear errors to int.ch. flag|16603
        v.erich=0;				// clear errors to int.ch. flag
//      look to see if an ending message is supplied
// stpr0:
        //b |stpr0|jsr|6,prtpg|||eject printer|16607
        C_GOTO(stpr0);
        } /* stpra */
        

        void stpr0() {
        C_JSR(prtpg);				// eject printer
        //b ||bze|7,xr|6,stpr1||skip if no message|16608
        if ( !( xr) ) C_GOTO(stpr1);				// skip if no message
        //b ||jsr|6,prtst|||print message|16609
        C_JSR(prtst);				// print message
//      merge here if no message to print
// stpr1:
        //b |stpr1|jsr|6,prtis|||print blank line|16613
        C_GOTO(stpr1);
        } /* stpr0 */
        

        void stpr1() {
        C_JSR(prtis);				// print blank line
        //b ||bnz|3,gbcfl|6,stpr5||if in garbage collection, skip|16615
        if (v.gbcfl) C_GOTO(stpr5);				// if in garbage collection, skip
        //b ||mov|7,xr|21,=stpm6||point to message /in file xxx/|16616
        xr= (word)(&c.stpm6);				// point to message /in file xxx/
        //b ||jsr|6,prtst|||print it|16617
        C_JSR(prtst);				// print it
        //b ||mov|3,profs|18,=prtmf||set column offset|16618
        v.profs= PRTMF;				// set column offset
        //b ||mov|8,wc|3,kvstn||get statement number|16619
        wc= v.kvstn;				// get statement number
        //b ||jsr|6,filnm|||get file name|16620
        C_JSR(filnm);				// get file name
        //b ||mov|7,xr|7,xl||prepare to print|16621
        xr= xl;				// prepare to print
        //b ||jsr|6,prtst|||print file name|16622
        C_JSR(prtst);				// print file name
        //b ||jsr|6,prtis|||print to interactive channel|16623
        C_JSR(prtis);				// print to interactive channel
        //b ||mov|7,xr|3,r_cod||get code pointer|16630
        xr= v.r_cod;				// get code pointer
        //b ||mti|13,cdsln(xr)|||get source line number|16631
        ia = (word)(*((word *)(CFP_B*CDSLN + xr)));				// get source line number
        //b ||mov|7,xr|21,=stpm4||point to message /in line xxx/|16632
        xr= (word)(&c.stpm4);				// point to message /in line xxx/
        //b ||jsr|6,prtmx|||print it|16633
        C_JSR(prtmx);				// print it
// stpr5:
        //b |stpr5|mti|3,kvstn|||get statement number|16635
        C_GOTO(stpr5);
        } /* stpr1 */
        

        void stpr5() {
        ia = (word)(v.kvstn);				// get statement number
        //b ||mov|7,xr|21,=stpm1||point to message /in statement xxx/|16636
        xr= (word)(&c.stpm1);				// point to message /in statement xxx/
        //b ||jsr|6,prtmx|||print it|16637
        C_JSR(prtmx);				// print it
        //b ||ldi|3,kvstl|||get statement limit|16638
        ia = v.kvstl;				// get statement limit
        //b ||ilt|6,stpr2|||skip if negative|16639
        if (ia < 0)  C_GOTO(stpr2);				// skip if negative
        //b ||sbi|3,kvstc|||minus counter = course count|16640
        ia-=v.kvstc;				// minus counter = course count
        //b ||sti|3,stpsi|||save|16641
        v.stpsi= ia;				// save
        //b ||mov|8,wa|3,stmcs||refine with counter start value|16642
        wa= v.stmcs;				// refine with counter start value
        //b ||sub|8,wa|3,stmct||minus current counter|16643
        wa -= v.stmct;				// minus current counter
        //b ||mti|8,wa|||convert to integer|16644
        ia = (word)(wa);				// convert to integer
        //b ||adi|3,stpsi|||add in course count|16645
        ia+=v.stpsi;				// add in course count
        //b ||sti|3,stpsi|||save|16646
        v.stpsi= ia;				// save
        //b ||mov|7,xr|21,=stpm2||point to message /stmts executed/|16647
        xr= (word)(&c.stpm2);				// point to message /stmts executed/
        //b ||jsr|6,prtmx|||print it|16648
        C_JSR(prtmx);				// print it
        //b ||jsr|6,systm|||get current time|16649
        C_JSR(systm);				// get current time
        //b ||sbi|3,timsx|||minus start time = elapsed exec tim in nanosec|16650
        ia-=v.timsx;				// minus start time = elapsed exec tim in nanosec
        //b ||sti|3,stpti|||save for later|16651
        v.stpti= ia;				// save for later
        //b ||dvi|4,intth|||divide by 1000 to convert to microseconds|16652
        ia=ia / c.intth;				// divide by 1000 to convert to microseconds
        //b ||iov|6,stpr2|||jump if we cannot compute|16653
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// jump if we cannot compute
        //b ||dvi|4,intth|||divide by 1000 to convert to milliseconds|16654
        ia=ia / c.intth;				// divide by 1000 to convert to milliseconds
        //b ||iov|6,stpr2|||jump if we cannot compute|16655
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// jump if we cannot compute
        //b ||sti|3,stpti|||save elapsed time in milliseconds|16656
        v.stpti= ia;				// save elapsed time in milliseconds
        //b ||mov|7,xr|21,=stpm3||point to msg /execution time msec /|16657
        xr= (word)(&c.stpm3);				// point to msg /execution time msec /
        //b ||jsr|6,prtmx|||print it|16658
        C_JSR(prtmx);				// print it
//      Only list peformance statistics giving stmts / millisec, etc.
//      if program ran for more than one millisecond.
        //b ||ldi|3,stpti|||reload execution time in milliseconds|16663
        ia = v.stpti;				// reload execution time in milliseconds
        //b ||ile|6,stpr2|||jump if exection time less than a millisecond|16664
        if (ia <= 0)  C_GOTO(stpr2);				// jump if exection time less than a millisecond
        //b ||ldi|3,stpsi|||load statement count|16668
        ia = v.stpsi;				// load statement count
        //b ||dvi|3,stpti|||divide to get stmts per millisecond|16669
        ia=ia / v.stpti;				// divide to get stmts per millisecond
        //b ||iov|6,stpr2|||jump if we cannot compute|16670
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// jump if we cannot compute
        //b ||dvi|4,intth|||divide to get stmts per microsecond|16671
        ia=ia / c.intth;				// divide to get stmts per microsecond
        //b ||iov|6,stpr2|||jump if we cannot compute|16672
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// jump if we cannot compute
        //b ||mov|7,xr|21,=stpm7||point to msg (stmt / microsec)|16673
        xr= (word)(&c.stpm7);				// point to msg (stmt / microsec)
        //b ||jsr|6,prtmx|||print it|16674
        C_JSR(prtmx);				// print it
        //b ||ldi|3,stpsi|||reload statement count|16676
        ia = v.stpsi;				// reload statement count
        //b ||dvi|3,stpti|||divide to get stmts per millisecond|16677
        ia=ia / v.stpti;				// divide to get stmts per millisecond
        //b ||iov|6,stpr2|||jump if we cannot compute|16678
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// jump if we cannot compute
        //b ||mov|7,xr|21,=stpm8||point to msg (stmt / millisec )|16679
        xr= (word)(&c.stpm8);				// point to msg (stmt / millisec )
        //b ||jsr|6,prtmx|||print it|16680
        C_JSR(prtmx);				// print it
        //b ||ldi|3,stpsi|||reload statement count|16682
        ia = v.stpsi;				// reload statement count
        //b ||dvi|3,stpti|||divide to get stmts per millisecond|16683
        ia=ia / v.stpti;				// divide to get stmts per millisecond
        //b ||iov|6,stpr2|||jump if we cannot compute|16684
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// jump if we cannot compute
        //b ||mli|4,intth|||multiply by 1000 to get stmts per microsecond|16685
        ia*=c.intth;				// multiply by 1000 to get stmts per microsecond
        //b ||iov|6,stpr2|||jump if overflow|16686
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// jump if overflow
        //b ||mov|7,xr|21,=stpm9||point to msg ( stmt / second )|16687
        xr= (word)(&c.stpm9);				// point to msg ( stmt / second )
        //b ||jsr|6,prtmx|||print it|16688
        C_JSR(prtmx);				// print it
        //b ||ejc|||||16690
        
//      stopr (continued)
//      merge to skip message (overflow or negative stlimit)
// stpr2:
        //b |stpr2|mti|3,gbcnt|||load count of collections|16696
        C_GOTO(stpr2);
        } /* stpr5 */
        

        void stpr2() {
        ia = (word)(v.gbcnt);				// load count of collections
        //b ||mov|7,xr|21,=stpm4||point to message /regenerations /|16697
        xr= (word)(&c.stpm4);				// point to message /regenerations /
        //b ||jsr|6,prtmx|||print it|16698
        C_JSR(prtmx);				// print it
        //b ||jsr|6,prtmm|||print memory usage|16699
        C_JSR(prtmm);				// print memory usage
        //b ||jsr|6,prtis|||one more blank for luck|16700
        C_JSR(prtis);				// one more blank for luck
//      check if dump requested
// stpr3:
        //b |stpr3|jsr|6,prflr|||print profile if wanted|16707
        C_GOTO(stpr3);
        } /* stpr2 */
        

        void stpr3() {
        C_JSR(prflr);				// print profile if wanted
        //b ||mov|7,xr|3,kvdmp||load dump keyword|16709
        xr= v.kvdmp;				// load dump keyword
        //b ||jsr|6,dumpr|||execute dump if requested|16711
        C_JSR(dumpr);				// execute dump if requested
        //b ||mov|7,xl|3,r_fcb||get fcblk chain head|16712
        xl= v.r_fcb;				// get fcblk chain head
        //b ||mov|8,wa|3,kvabe||load abend value|16713
        wa= v.kvabe;				// load abend value
        //b ||mov|8,wb|3,kvcod||load code value|16714
        wb= v.kvcod;				// load code value
        //b ||jsr|6,sysej|||exit to system|16715
        C_JSR(sysej);				// exit to system
//      here after sysea call and suppressing error msg print
// stpr4:
        //b |stpr4|rtn|||||16720
        C_GOTO(stpr4);
        } /* stpr3 */
        

        void stpr4() {
        //b ||add|3,dname|3,rsmem||use the reserve memory|16721
        v.dname += v.rsmem;				// use the reserve memory
        //b ||bze|3,exsts|6,stpr1||if execution stats requested|16722
        if ( !( v.exsts) ) C_GOTO(stpr1);				// if execution stats requested
        //b ||brn|6,stpr3|||check if dump or profile needed|16723
         C_GOTO(stpr3);				// check if dump or profile needed
        //b ||ejc|||||16726
        
//      succp -- signal successful match of a pattern node
//      see pattern match routines for details
//      (xr)                  current node
//      (wb)                  current cursor
//      (xl)                  may be non-collectable
//      brn  succp            signal successful pattern match
//      succp continues by matching the successor node
// succp:
        //b |succp|rtn|||||16739
        } /* stpr4 */
        

        void succp() {
        //b ||mov|7,xr|13,pthen(xr)||load successor node|16740
        xr= *((word *)(CFP_B*PTHEN + xr));				// load successor node
        //b ||mov|7,xl|9,(xr)||load node code entry address|16741
        xl= *(xr_it.wp);				// load node code entry address
        //b ||bri|7,xl|||jump to match successor node|16742
        C_GOTO(xl_it.callp);				// jump to match successor node
        //b ||ejc|||||16743
        
//      sysab -- print /abnormal end/ and terminate
// sysab:
        //b |sysab|rtn|||||16747
        } /* succp */
        

        void sysab() {
        //b ||mov|7,xr|21,=endab||point to message|16748
        xr= (word)(&c.endab);				// point to message
        //b ||mov|3,kvabe|18,=num01||set abend flag|16749
        v.kvabe= NUM01;				// set abend flag
        //b ||jsr|6,prtnl|||skip to new line|16750
        C_JSR(prtnl);				// skip to new line
        //b ||brn|6,stopr|||jump to pack up|16751
         C_GOTO(stopr);				// jump to pack up
        //b ||ejc|||||16752
        
//      systu -- print /time up/ and terminate
// systu:
        //b |systu|rtn|||||16756
        } /* sysab */
        

        void systu() {
        //b ||mov|7,xr|21,=endtu||point to message|16757
        xr= (word)(&c.endtu);				// point to message
        //b ||mov|8,wa|4,strtu||get chars /tu/|16758
        wa= c.strtu;				// get chars /tu/
        //b ||mov|3,kvcod|8,wa||put in kvcod|16759
        v.kvcod= wa;				// put in kvcod
        //b ||mov|8,wa|3,timup||check state of timeup switch|16760
        wa= v.timup;				// check state of timeup switch
        //b ||mnz|3,timup|||set switch|16761
        v.timup = 0xffffffffffffffff;				// set switch
        //b ||bnz|8,wa|6,stopr||stop run if already set|16762
        if (wa) C_GOTO(stopr);				// stop run if already set
        //b ||erb|1,245|26,translation/execution time expired|||16763
        C_ERB(245)
        //b ||ttl|27,s p i t b o l -- utility procedures||||16764
        /* s p i t b o l -- utility procedures*/
//      the following section contains procedures which are
//      used for various purposes throughout the system.
//      each procedure is preceded by a description of the
//      calling sequence. usually the arguments are in registers
//      but arguments can also occur on the stack and as
//      parameters assembled after the jsr instruction.
//      the following considerations apply to these descriptions.
//      1)   the stack pointer (xs) is not changed unless the
//           change is explicitly documented in the call.
//      2)   registers whose entry values are not mentioned
//           may contain any value except that xl,xr may only
//           contain proper (collectable) pointer values.
//           this condition on means that the called routine
//           may if it chooses preserve xl,xr by stacking.
//      3)   registers not mentioned on exit contain the same
//           values as they did on entry except that values in
//           xr,xl may have been relocated by the collector.
//      4)   registers which are destroyed on exit may contain
//           any value except that values in xl,xr are proper
//           (collectable) pointers.
//      5)   the code pointer register points to the current
//           code location on entry and is unchanged on exit.
//      in the above description, a collectable pointer is one
//      which either points outside the dynamic region or
//      points to the start of a block in the dynamic region.
//      in those cases where the calling sequence contains
//      parameters which are used as alternate return points,
//      these parameters may be replaced by error codes
//      assembled with the err instruction. this will result
//      in the posting of the error if the return is taken.
//      the procedures all have names consisting of five letters
//      and are in alphabetical order by their names.
        //b ||ejc|||||16808
        
//      acess - access variable value with trace/input checks
//      acess loads the value of a variable. trace and input
//      associations are tested for and executed as required.
//      acess also handles the special cases of pseudo-variables.
//      (xl)                  variable name base
//      (wa)                  variable name offset
//      jsr  acess            call to access value
//      ppm  loc              transfer loc if access failure
//      (xr)                  variable value
//      (wa,wb,wc)            destroyed
//      (xl,ra)               destroyed
//      failure can occur if an input association causes an end
//      of file condition or if the evaluation of an expression
//      associated with an expression variable fails.
// acess:
        //b |acess|prc|25,r|1,1||entry point (recursive)|16828
        } /* systu */
        

        void acess() {
        //b ||mov|7,xr|7,xl||copy name base|16829
        xr= xl;				// copy name base
        //b ||add|7,xr|8,wa||point to variable location|16830
        xr += wa;				// point to variable location
        //b ||mov|7,xr|9,(xr)||load variable value|16831
        xr= *(xr_it.wp);				// load variable value
//      loop here to check for successive trblks
// acs02:
        //b |acs02|bne|9,(xr)|22,=b_trt|6,acs18|jump if not trapped|16835
        C_GOTO(acs02);
        } /* acess */
        

        void acs02() {
        if ((*(xr_it.wp)-(word)(b_trt)) != 0) C_GOTO(acs18);				// jump if not trapped
//      here if trapped
        //b ||beq|7,xr|21,=trbkv|6,acs12|jump if keyword variable|16839
        if ((xr-(word)(&c.trbkv)) == 0) C_GOTO(acs12);				// jump if keyword variable
        //b ||bne|7,xr|21,=trbev|6,acs05|jump if not expression variable|16840
        if ((xr-(word)(&c.trbev)) != 0) C_GOTO(acs05);				// jump if not expression variable
//      here for expression variable, evaluate variable
        //b ||mov|7,xr|13,evexp(xl)||load expression pointer|16844
        xr= *((word *)(CFP_B*EVEXP + xl));				// load expression pointer
        //b ||zer|8,wb|||evaluate by value|16845
        wb=0;				// evaluate by value
        //b ||ppm|6,acs04|||jump if evaluation failure|16847
        C_JSR_1(evalx,C_GOTO(acs04));				// jump if evaluation failure
        //b ||brn|6,acs02|||check value for more trblks|16848
         C_GOTO(acs02);				// check value for more trblks
        //b ||ejc|||||16849
        
//      acess (continued)
//      here on reading end of file
// acs03:
        //b |acs03|add|7,xs|19,*num03||pop trblk ptr, name base and offset|16855
        } /* acs02 */
        

        void acs03() {
        xs += CFP_B*NUM03;				// pop trblk ptr, name base and offset
        //b ||mov|3,dnamp|7,xr||pop unused scblk|16856
        v.dnamp= xr;				// pop unused scblk
//      merge here when evaluation of expression fails
// acs04:
        //b |acs04|exi|1,1|||take alternate (failure) return|16860
        C_GOTO(acs04);
        } /* acs03 */
        

        void acs04() {
        C_EXIT(1);				// take alternate (failure) return
//      here if not keyword or expression variable
// acs05:
        //b |acs05|mov|8,wb|13,trtyp(xr)||load trap type code|16864
        } /* acs04 */
        

        void acs05() {
        wb= *((word *)(CFP_B*TRTYP + xr));				// load trap type code
        //b ||bnz|8,wb|6,acs10||jump if not input association|16865
        if (wb) C_GOTO(acs10);				// jump if not input association
        //b ||bze|3,kvinp|6,acs09||ignore input assoc if input is off|16866
        if ( !( v.kvinp) ) C_GOTO(acs09);				// ignore input assoc if input is off
//      here for input association
        //b ||mov|11,-(xs)|7,xl||stack name base|16870
        C_PUSH(xl);				// stack name base
        //b ||mov|11,-(xs)|8,wa||stack name offset|16871
        C_PUSH(wa);				// stack name offset
        //b ||mov|11,-(xs)|7,xr||stack trblk pointer|16872
        C_PUSH(xr);				// stack trblk pointer
        //b ||mov|3,actrm|3,kvtrm||temp to hold trim keyword|16873
        v.actrm= v.kvtrm;				// temp to hold trim keyword
        //b ||mov|7,xl|13,trfpt(xr)||get file ctrl blk ptr or zero|16874
        xl= *((word *)(CFP_B*TRFPT + xr));				// get file ctrl blk ptr or zero
        //b ||bnz|7,xl|6,acs06||jump if not standard input file|16875
        if (xl) C_GOTO(acs06);				// jump if not standard input file
        //b ||beq|13,trter(xr)|21,=v_ter|6,acs21|jump if terminal|16876
        if ((*((word *)(CFP_B*TRTER + xr))-(word)(&c.v_ter)) == 0) C_GOTO(acs21);				// jump if terminal
//      here to read from standard input file
        //b ||mov|8,wa|3,cswin||length for read buffer|16880
        wa= v.cswin;				// length for read buffer
        //b ||jsr|6,alocs|||build string of appropriate length|16881
        C_JSR(alocs);				// build string of appropriate length
        //b ||ppm|6,acs03|||jump to fail exit if end of file|16883
        C_JSR_1(sysrd,C_GOTO(acs03));				// jump to fail exit if end of file
        //b ||brn|6,acs07|||else merge with other file case|16884
         C_GOTO(acs07);				// else merge with other file case
//      here for input from other than standard input file
// acs06:
        //b |acs06|mov|8,wa|7,xl||fcblk ptr|16888
        } /* acs05 */
        

        void acs06() {
        wa= xl;				// fcblk ptr
        //b ||jsr|6,sysil|||get input record max length (to wa)|16889
        C_JSR(sysil);				// get input record max length (to wa)
        //b ||bnz|8,wc|6,acs6a||jump if not binary file|16890
        if (wc) C_GOTO(acs6a);				// jump if not binary file
        //b ||mov|3,actrm|8,wc||disable trim for binary file|16891
        v.actrm= wc;				// disable trim for binary file
// acs6a:
        //b |acs6a|jsr|6,alocs|||allocate string of correct size|16892
        C_GOTO(acs6a);
        } /* acs06 */
        

        void acs6a() {
        C_JSR(alocs);				// allocate string of correct size
        //b ||mov|8,wa|7,xl||fcblk ptr|16893
        wa= xl;				// fcblk ptr
        //b ||ppm|6,acs23|||error|16897
        C_JSR_3(sysin,C_GOTO(acs03),C_GOTO(acs22),C_GOTO(acs23));				// error
        //b ||ejc|||||16898
        
//      acess (continued)
//      merge here after obtaining input record
// acs07:
        //b |acs07|mov|8,wb|3,actrm||load trim indicator|16904
        C_GOTO(acs07);
        } /* acs6a */
        

        void acs07() {
        wb= v.actrm;				// load trim indicator
        //b ||jsr|6,trimr|||trim record as required|16905
        C_JSR(trimr);				// trim record as required
        //b ||mov|8,wb|7,xr||copy result pointer|16906
        wb= xr;				// copy result pointer
        //b ||mov|7,xr|9,(xs)||reload pointer to trblk|16907
        xr= *(xs_it.wp);				// reload pointer to trblk
//      loop to chase to end of trblk chain and store value
// acs08:
        //b |acs08|mov|7,xl|7,xr||save pointer to this trblk|16911
        C_GOTO(acs08);
        } /* acs07 */
        

        void acs08() {
        xl= xr;				// save pointer to this trblk
        //b ||mov|7,xr|13,trnxt(xr)||load forward pointer|16912
        xr= *((word *)(CFP_B*TRNXT + xr));				// load forward pointer
        //b ||beq|9,(xr)|22,=b_trt|6,acs08|loop if this is another trblk|16913
        if ((*(xr_it.wp)-(word)(b_trt)) == 0) C_GOTO(acs08);				// loop if this is another trblk
        //b ||mov|13,trnxt(xl)|8,wb||else store result at end of chain|16914
        *((word *)(CFP_B*TRNXT + xl))= wb;				// else store result at end of chain
        //b ||mov|7,xr|10,(xs)+||restore initial trblk pointer|16915
        xr= C_POP();				// restore initial trblk pointer
        //b ||mov|8,wa|10,(xs)+||restore name offset|16916
        wa= C_POP();				// restore name offset
        //b ||mov|7,xl|10,(xs)+||restore name base pointer|16917
        xl= C_POP();				// restore name base pointer
//      come here to move to next trblk
// acs09:
        //b |acs09|mov|7,xr|13,trnxt(xr)||load forward ptr to next value|16921
        C_GOTO(acs09);
        } /* acs08 */
        

        void acs09() {
        xr= *((word *)(CFP_B*TRNXT + xr));				// load forward ptr to next value
        //b ||brn|6,acs02|||back to check if trapped|16922
         C_GOTO(acs02);				// back to check if trapped
//      here to check for access trace trblk
// acs10:
        //b |acs10|bne|8,wb|18,=trtac|6,acs09|loop back if not access trace|16926
        } /* acs09 */
        

        void acs10() {
        if ((wb-TRTAC) != 0) C_GOTO(acs09);				// loop back if not access trace
        //b ||bze|3,kvtra|6,acs09||ignore access trace if trace off|16927
        if ( !( v.kvtra) ) C_GOTO(acs09);				// ignore access trace if trace off
        //b ||dcv|3,kvtra|||else decrement trace count|16928
        (v.kvtra)--;				// else decrement trace count
        //b ||bze|13,trfnc(xr)|6,acs11||jump if print trace|16929
        if ( !( *((word *)(CFP_B*TRFNC + xr))) ) C_GOTO(acs11);				// jump if print trace
        //b ||ejc|||||16930
        
//      acess (continued)
//      here for full function trace
        //b ||jsr|6,trxeq|||call routine to execute trace|16936
        C_JSR(trxeq);				// call routine to execute trace
        //b ||brn|6,acs09|||jump for next trblk|16937
         C_GOTO(acs09);				// jump for next trblk
//      here for case of print trace
// acs11:
        //b |acs11|jsr|6,prtsn|||print statement number|16941
        } /* acs10 */
        

        void acs11() {
        C_JSR(prtsn);				// print statement number
        //b ||jsr|6,prtnv|||print name = value|16942
        C_JSR(prtnv);				// print name = value
        //b ||brn|6,acs09|||jump back for next trblk|16943
         C_GOTO(acs09);				// jump back for next trblk
//      here for keyword variable
// acs12:
        //b |acs12|mov|7,xr|13,kvnum(xl)||load keyword number|16947
        } /* acs11 */
        

        void acs12() {
        xr= *((word *)(CFP_B*KVNUM + xl));				// load keyword number
        //b ||bge|7,xr|18,=k_v__|6,acs14|jump if not one word value|16948
        if ((xr-K_V__) >= 0) C_GOTO(acs14);				// jump if not one word value
        //b ||mti|15,kvabe(xr)|||else load value as integer|16949
        ia = (word)(*((word *)( ((word)&v.kvabe) + xr)));				// else load value as integer
//      common exit with keyword value as integer in (ia)
// acs13:
        //b |acs13|jsr|6,icbld|||build icblk|16953
        C_GOTO(acs13);
        } /* acs12 */
        

        void acs13() {
        C_JSR(icbld);				// build icblk
        //b ||brn|6,acs18|||jump to exit|16954
         C_GOTO(acs18);				// jump to exit
//      here if not one word keyword value
// acs14:
        //b |acs14|bge|7,xr|18,=k_s__|6,acs15|jump if special case|16958
        } /* acs13 */
        

        void acs14() {
        if ((xr-K_S__) >= 0) C_GOTO(acs15);				// jump if special case
        //b ||sub|7,xr|18,=k_v__||else get offset|16959
        xr -= K_V__;				// else get offset
        //b ||wtb|7,xr|||convert to byte offset|16960
        xr <<= LOG_CFP_B;				// convert to byte offset
        //b ||add|7,xr|21,=ndabo||point to pattern value|16961
        xr += (word)(&c.ndabo);				// point to pattern value
        //b ||brn|6,acs18|||jump to exit|16962
         C_GOTO(acs18);				// jump to exit
//      here if special keyword case
// acs15:
        //b |acs15|mov|7,xl|3,kvrtn||load rtntype in case|16966
        } /* acs14 */
        

        void acs15() {
        xl= v.kvrtn;				// load rtntype in case
        //b ||ldi|3,kvstl|||load stlimit in case|16967
        ia = v.kvstl;				// load stlimit in case
        //b ||sub|7,xr|18,=k_s__||get case number|16968
        xr -= K_S__;				// get case number
        //b ||bsw|7,xr|2,k__n_||switch on keyword number|16969
        extern word _l0530 [];				// switch on keyword number
        { w0 = ((word *)_l0530)[xr];  C_GOTO(w0_it.callp);}
        }  /* acs15 */
        

        word  _l0530 [] = {
        //b ||iff|2,k__al|6,acs16||jump if alphabet|16983
        	(word)((word)(acs16)),				// jump if alphabet
        //b ||iff|2,k__rt|6,acs17||rtntype|16983
        	(word)((word)(acs17)),				// rtntype
        //b ||iff|2,k__sc|6,acs19||stcount|16983
        	(word)((word)(acs19)),				// stcount
        //b ||iff|2,k__et|6,acs20||errtext|16983
        	(word)((word)(acs20)),				// errtext
        //b ||iff|2,k__fl|6,acs26||file|16983
        	(word)((word)(acs26)),				// file
        //b ||iff|2,k__lf|6,acs27||lastfile|16983
        	(word)((word)(acs27)),				// lastfile
        //b ||iff|2,k__sl|6,acs13||stlimit|16983
        	(word)((word)(acs13)),				// stlimit
        //b ||iff|2,k__lc|6,acs24||lcase|16983
        	(word)((word)(acs24)),				// lcase
        //b ||iff|2,k__uc|6,acs25||ucase|16983
        	(word)((word)(acs25)),				// ucase
        //b ||esw||||end switch on keyword number|16983
             }; /* bsw list for _l0530 */				// end switch on keyword number
        //b ||ejc|||||16984
        
//      acess (continued)
//      lcase
// acs24:
        //b |acs24|mov|7,xr|21,=lcase||load pointer to lcase string|16991
        void acs24() {
        xr= (word)(&c.lcase);				// load pointer to lcase string
        //b ||brn|6,acs18|||common return|16992
         C_GOTO(acs18);				// common return
//      ucase
// acs25:
        //b |acs25|mov|7,xr|21,=ucase||load pointer to ucase string|16996
        } /* acs24 */
        

        void acs25() {
        xr= (word)(&c.ucase);				// load pointer to ucase string
        //b ||brn|6,acs18|||common return|16997
         C_GOTO(acs18);				// common return
//      file
// acs26:
        //b |acs26|mov|8,wc|3,kvstn||load current stmt number|17003
        } /* acs25 */
        

        void acs26() {
        wc= v.kvstn;				// load current stmt number
        //b ||brn|6,acs28|||merge to obtain file name|17004
         C_GOTO(acs28);				// merge to obtain file name
//      lastfile
// acs27:
        //b |acs27|mov|8,wc|3,kvlst||load last stmt number|17008
        } /* acs26 */
        

        void acs27() {
        wc= v.kvlst;				// load last stmt number
//      merge here to map statement number in wc to file name
// acs28:
        //b |acs28|jsr|6,filnm|||obtain file name for this stmt|17012
        C_GOTO(acs28);
        } /* acs27 */
        

        void acs28() {
        C_JSR(filnm);				// obtain file name for this stmt
        //b ||brn|6,acs17|||merge to return string in xl|17013
         C_GOTO(acs17);				// merge to return string in xl
//      alphabet
// acs16:
        //b |acs16|mov|7,xl|3,kvalp||load pointer to alphabet string|17017
        } /* acs28 */
        

        void acs16() {
        xl= v.kvalp;				// load pointer to alphabet string
//      rtntype merges here
// acs17:
        //b |acs17|mov|7,xr|7,xl||copy string ptr to proper reg|17021
        C_GOTO(acs17);
        } /* acs16 */
        

        void acs17() {
        xr= xl;				// copy string ptr to proper reg
//      common return point
// acs18:
        //b |acs18|exi||||return to acess caller|17025
        C_GOTO(acs18);
        } /* acs17 */
        

        void acs18() {
        C_EXIT(0);				// return to acess caller
//      here for stcount (ia has stlimit)
// acs19:
        //b |acs19|ilt|6,acs29|||if counting suppressed|17029
        } /* acs18 */
        

        void acs19() {
        if (ia < 0)  C_GOTO(acs29);				// if counting suppressed
        //b ||mov|8,wa|3,stmcs||refine with counter start value|17030
        wa= v.stmcs;				// refine with counter start value
        //b ||sub|8,wa|3,stmct||minus current counter|17031
        wa -= v.stmct;				// minus current counter
        //b ||mti|8,wa|||convert to integer|17032
        ia = (word)(wa);				// convert to integer
        //b ||adi|3,kvstl|||add stlimit|17033
        ia+=v.kvstl;				// add stlimit
// acs29:
        //b |acs29|sbi|3,kvstc|||stcount = limit - left|17034
        C_GOTO(acs29);
        } /* acs19 */
        

        void acs29() {
        ia-=v.kvstc;				// stcount = limit - left
        //b ||brn|6,acs13|||merge back with integer result|17035
         C_GOTO(acs13);				// merge back with integer result
//      errtext
// acs20:
        //b |acs20|mov|7,xr|3,r_etx||get errtext string|17039
        } /* acs29 */
        

        void acs20() {
        xr= v.r_etx;				// get errtext string
        //b ||brn|6,acs18|||merge with result|17040
         C_GOTO(acs18);				// merge with result
//      here to read a record from terminal
// acs21:
        //b |acs21|mov|8,wa|18,=rilen||buffer length|17044
        } /* acs20 */
        

        void acs21() {
        wa= RILEN;				// buffer length
        //b ||jsr|6,alocs|||allocate buffer|17045
        C_JSR(alocs);				// allocate buffer
        //b ||ppm|6,acs03|||endfile|17047
        C_JSR_1(sysri,C_GOTO(acs03));				// endfile
        //b ||brn|6,acs07|||merge with record read|17048
         C_GOTO(acs07);				// merge with record read
//      error returns
// acs22:
        //b |acs22|mov|3,dnamp|7,xr||pop unused scblk|17052
        } /* acs21 */
        

        void acs22() {
        v.dnamp= xr;				// pop unused scblk
        //b ||erb|1,202|26,input from file caused non-recoverable error|||17053
        C_ERB(202)
// acs23:
        //b |acs23|mov|3,dnamp|7,xr||pop unused scblk|17055
        } /* acs22 */
        

        void acs23() {
        v.dnamp= xr;				// pop unused scblk
        //b ||erb|1,203|26,input file record has incorrect format|||17056
        C_ERB(203)
        //b ||ejc|||||17058
        
//      acomp -- compare two arithmetic values
//      1(xs)                 first argument
//      0(xs)                 second argument
//      jsr  acomp            call to compare values
//      ppm  loc              transfer loc if arg1 is non-numeric
//      ppm  loc              transfer loc if arg2 is non-numeric
//      ppm  loc              transfer loc for arg1 lt arg2
//      ppm  loc              transfer loc for arg1 eq arg2
//      ppm  loc              transfer loc for arg1 gt arg2
//      (normal return is never given)
//      (wa,wb,wc,ia,ra)      destroyed
//      (xl,xr)               destroyed
// acomp:
        //b |acomp|prc|25,n|1,5||entry point|17074
        } /* acs23 */
        

        void acomp() {
        //b ||ppm|6,acmp4|||jump if real arguments|17080
        extern void _l0531();
        C_JMS(arith,P_PRC_ARITH,_l0531);
        } /* acomp */
        

        void _l0531() {
        C_JMS_HANDLE_3(arith,C_GOTO(acmp7),C_GOTO(acmp8),C_GOTO(acmp4));				// jump if real arguments
//      here for integer arguments
        //b ||sbi|13,icval(xl)|||subtract to compare|17085
        ia-=*((word *)(CFP_B*ICVAL + xl));				// subtract to compare
        //b ||iov|6,acmp3|||jump if overflow|17086
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// jump if overflow
        //b ||ilt|6,acmp5|||else jump if arg1 lt arg2|17087
        if (ia < 0)  C_GOTO(acmp5);				// else jump if arg1 lt arg2
        //b ||ieq|6,acmp2|||jump if arg1 eq arg2|17088
        if (ia == 0)  C_GOTO(acmp2);				// jump if arg1 eq arg2
//      here if arg1 gt arg2
// acmp1:
        //b |acmp1|exi|1,5|||take gt exit|17092
        C_GOTO(acmp1);
        } /* _l0531 */
        

        void acmp1() {
        C_NEXIT(P_PRC_ACOMP,5);				// take gt exit
//      here if arg1 eq arg2
// acmp2:
        //b |acmp2|exi|1,4|||take eq exit|17096
        } /* acmp1 */
        

        void acmp2() {
        C_NEXIT(P_PRC_ACOMP,4);				// take eq exit
        //b ||ejc|||||17097
        
//      acomp (continued)
//      here for integer overflow on subtract
// acmp3:
        //b |acmp3|ldi|13,icval(xl)|||load second argument|17103
        } /* acmp2 */
        

        void acmp3() {
        ia = *((word *)(CFP_B*ICVAL + xl));				// load second argument
        //b ||ilt|6,acmp1|||gt if negative|17104
        if (ia < 0)  C_GOTO(acmp1);				// gt if negative
        //b ||brn|6,acmp5|||else lt|17105
         C_GOTO(acmp5);				// else lt
//      here for real operands
// acmp4:
        //b |acmp4|sbr|13,rcval(xl)|||subtract to compare|17111
        } /* acmp3 */
        

        void acmp4() {
        {w0 = *((word *)(CFP_B*RCVAL + xl));ra_it.d -= w0_it.d;fl=(!isgoodnum(ra_it.d));}				// subtract to compare
        //b ||rov|6,acmp6|||jump if overflow|17112
        if (fl) C_GOTO(acmp6);				// jump if overflow
        //b ||rgt|6,acmp1|||else jump if arg1 gt|17113
        if (ra_it.d > 0.0)  C_GOTO(acmp1);				// else jump if arg1 gt
        //b ||req|6,acmp2|||jump if arg1 eq arg2|17114
        if (ra_it.d == 0.0)  C_GOTO(acmp2);				// jump if arg1 eq arg2
//      here if arg1 lt arg2
// acmp5:
        //b |acmp5|exi|1,3|||take lt exit|17119
        C_GOTO(acmp5);
        } /* acmp4 */
        

        void acmp5() {
        C_NEXIT(P_PRC_ACOMP,3);				// take lt exit
//      here if overflow on real subtraction
// acmp6:
        //b |acmp6|ldr|13,rcval(xl)|||reload arg2|17125
        } /* acmp5 */
        

        void acmp6() {
        {ra_it.d = *((word *)(CFP_B*RCVAL + xl));fl=(!isgoodnum(ra_it.d));}				// reload arg2
        //b ||rlt|6,acmp1|||gt if negative|17126
        if (ra_it.d < 0.0)  C_GOTO(acmp1);				// gt if negative
        //b ||brn|6,acmp5|||else lt|17127
         C_GOTO(acmp5);				// else lt
//      here if arg1 non-numeric
// acmp7:
        //b |acmp7|exi|1,1|||take error exit|17132
        } /* acmp6 */
        

        void acmp7() {
        C_NEXIT(P_PRC_ACOMP,1);				// take error exit
//      here if arg2 non-numeric
// acmp8:
        //b |acmp8|exi|1,2|||take error exit|17136
        } /* acmp7 */
        

        void acmp8() {
        C_NEXIT(P_PRC_ACOMP,2);				// take error exit
        //b ||ejc|||||17138
        
//      alloc                 allocate block of dynamic storage
//      (wa)                  length required in bytes
//      jsr  alloc            call to allocate block
//      (xr)                  pointer to allocated block
//      a possible alternative to aov ... and following stmt is -
//      mov  dname,xr .  sub  wa,xr .  blo xr,dnamp,aloc2 .
//      mov  dnamp,xr .  add  wa,xr
// alloc:
        //b |alloc|prc|25,e|1,0||entry point|17150
        } /* acmp8 */
        

        void alloc() {
//      common exit point
// aloc1:
        //b |aloc1|mov|7,xr|3,dnamp||point to next available loc|17154
        C_GOTO(aloc1);
        } /* alloc */
        

        void aloc1() {
        xr= v.dnamp;				// point to next available loc
        //b ||aov|8,wa|7,xr|6,aloc2|point past allocated block|17155
        xr+=wa;				// point past allocated block
        //b ||bgt|7,xr|3,dname|6,aloc2|jump if not enough room|17156
        if ((xr-v.dname) > 0) C_GOTO(aloc2);				// jump if not enough room
        //b ||mov|3,dnamp|7,xr||store new pointer|17157
        v.dnamp= xr;				// store new pointer
        //b ||sub|7,xr|8,wa||point back to start of allocated bk|17158
        xr -= wa;				// point back to start of allocated bk
        //b ||exi||||return to caller|17159
        C_EXIT(0);				// return to caller
//      here if insufficient room, try a garbage collection
// aloc2:
        //b |aloc2|mov|3,allsv|8,wb||save wb|17163
        } /* aloc1 */
        

        void aloc2() {
        v.allsv= wb;				// save wb
// alc2a:
        //b |alc2a|zer|8,wb|||set no upward move for gbcol|17164
        C_GOTO(alc2a);
        } /* aloc2 */
        

        void alc2a() {
        wb=0;				// set no upward move for gbcol
        //b ||jsr|6,gbcol|||garbage collect|17165
        C_JSR(gbcol);				// garbage collect
        //b ||mov|8,wb|7,xr||remember new sediment size|17167
        wb= xr;				// remember new sediment size
//      see if room after gbcol or sysmm call
// aloc3:
        //b |aloc3|mov|7,xr|3,dnamp||point to first available loc|17172
        C_GOTO(aloc3);
        } /* alc2a */
        

        void aloc3() {
        xr= v.dnamp;				// point to first available loc
        //b ||aov|8,wa|7,xr|6,alc3a|point past new block|17173
        xr+=wa;				// point past new block
        //b ||blo|7,xr|3,dname|6,aloc4|jump if there is room now|17174
        if ((xr-v.dname) < 0) C_GOTO(aloc4);				// jump if there is room now
//      failed again, see if we can get more core
// alc3a:
        //b |alc3a|jsr|6,sysmm|||try to get more memory|17178
        C_GOTO(alc3a);
        } /* aloc3 */
        

        void alc3a() {
        C_JSR(sysmm);				// try to get more memory
        //b ||wtb|7,xr|||convert to baus (sgd05)|17179
        xr <<= LOG_CFP_B;				// convert to baus (sgd05)
        //b ||add|3,dname|7,xr||bump ptr by amount obtained|17180
        v.dname += xr;				// bump ptr by amount obtained
        //b ||bnz|7,xr|6,aloc3||jump if got more core|17181
        if (xr) C_GOTO(aloc3);				// jump if got more core
        //b ||bze|3,dnams|6,alc3b||jump if there was no sediment|17183
        if ( !( v.dnams) ) C_GOTO(alc3b);				// jump if there was no sediment
        //b ||zer|3,dnams|||try collecting the sediment|17184
        v.dnams=0;				// try collecting the sediment
        //b ||brn|6,alc2a||||17185
         C_GOTO(alc2a);
//      sysmm failed and there was no sediment to collect
// alc3b:
        //b |alc3b|add|3,dname|3,rsmem||get the reserve memory|17189
        } /* alc3a */
        

        void alc3b() {
        v.dname += v.rsmem;				// get the reserve memory
        //b ||zer|3,rsmem|||only permissible once|17193
        v.rsmem=0;				// only permissible once
        //b ||icv|3,errft|||fatal error|17194
        (v.errft)++;				// fatal error
        //b ||erb|1,204|26,memory overflow|||17195
        C_ERB(204)
        //b ||ejc|||||17196
        
//      here after successful garbage collection
// aloc4:
        //b |aloc4|sti|3,allia|||save ia|17200
        } /* alc3b */
        

        void aloc4() {
        v.allia= ia;				// save ia
        //b ||mov|3,dnams|8,wb||record new sediment size|17202
        v.dnams= wb;				// record new sediment size
        //b ||mov|8,wb|3,dname||get dynamic end adrs|17204
        wb= v.dname;				// get dynamic end adrs
        //b ||sub|8,wb|3,dnamp||compute free store|17205
        wb -= v.dnamp;				// compute free store
        //b ||btw|8,wb|||convert bytes to words|17206
        wb >>= LOG_CFP_B;				// convert bytes to words
        //b ||mti|8,wb|||put free store in ia|17207
        ia = (word)(wb);				// put free store in ia
        //b ||mli|3,alfsf|||multiply by free store factor|17208
        ia*=v.alfsf;				// multiply by free store factor
        //b ||iov|6,aloc5|||jump if overflowed|17209
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// jump if overflowed
        //b ||mov|8,wb|3,dname||dynamic end adrs|17210
        wb= v.dname;				// dynamic end adrs
        //b ||sub|8,wb|3,dnamb||compute total amount of dynamic|17211
        wb -= v.dnamb;				// compute total amount of dynamic
        //b ||btw|8,wb|||convert to words|17212
        wb >>= LOG_CFP_B;				// convert to words
        //b ||mov|3,aldyn|8,wb||store it|17213
        v.aldyn= wb;				// store it
        //b ||sbi|3,aldyn|||subtract from scaled up free store|17214
        ia-=v.aldyn;				// subtract from scaled up free store
        //b ||igt|6,aloc5|||jump if sufficient free store|17215
        if (ia > 0)  C_GOTO(aloc5);				// jump if sufficient free store
        //b ||jsr|6,sysmm|||try to get more store|17216
        C_JSR(sysmm);				// try to get more store
        //b ||wtb|7,xr|||convert to baus (sgd05)|17217
        xr <<= LOG_CFP_B;				// convert to baus (sgd05)
        //b ||add|3,dname|7,xr||adjust dynamic end adrs|17218
        v.dname += xr;				// adjust dynamic end adrs
//      merge to restore ia and wb
// aloc5:
        //b |aloc5|ldi|3,allia|||recover ia|17222
        C_GOTO(aloc5);
        } /* aloc4 */
        

        void aloc5() {
        ia = v.allia;				// recover ia
        //b ||mov|8,wb|3,allsv||restore wb|17223
        wb= v.allsv;				// restore wb
        //b ||brn|6,aloc1|||jump back to exit|17224
         C_GOTO(aloc1);				// jump back to exit
        //b ||ejc|||||17226
        
//      alocs -- allocate string block
//      alocs is used to build a frame for a string block into
//      which the actual characters are placed by the caller.
//      all strings are created with a call to alocs (the
//      exceptions occur in trimr and s_rpl procedures).
//      (wa)                  length of string to be allocated
//      jsr  alocs            call to allocate scblk
//      (xr)                  pointer to resulting scblk
//      (wa)                  destroyed
//      (wc)                  character count (entry value of wa)
//      the resulting scblk has the type word and the length
//      filled in and the last word is cleared to zero characters
//      to ensure correct right padding of the final word.
// alocs:
        //b |alocs|prc|25,e|1,0||entry point|17286
        } /* aloc5 */
        

        void alocs() {
        //b ||bgt|8,wa|3,kvmxl|6,alcs2|jump if length exceeds maxlength|17287
        if ((wa-v.kvmxl) > 0) C_GOTO(alcs2);				// jump if length exceeds maxlength
        //b ||mov|8,wc|8,wa||else copy length|17288
        wc= wa;				// else copy length
        //b ||ctb|8,wa|2,scsi_||compute length of scblk in bytes|17289
        wa += (CFP_B-1)+CFP_B*SCSI_;				// compute length of scblk in bytes
        wa &= 0xfffffffffffffff8;
        //b ||mov|7,xr|3,dnamp||point to next available location|17290
        xr= v.dnamp;				// point to next available location
        //b ||aov|8,wa|7,xr|6,alcs0|point past block|17291
        xr+=wa;				// point past block
        //b ||blo|7,xr|3,dname|6,alcs1|jump if there is room|17292
        if ((xr-v.dname) < 0) C_GOTO(alcs1);				// jump if there is room
//      insufficient memory
// alcs0:
        //b |alcs0|zer|7,xr|||else clear garbage xr value|17296
        C_GOTO(alcs0);
        } /* alocs */
        

        void alcs0() {
        xr=0;				// else clear garbage xr value
        //b ||jsr|6,alloc|||and use standard allocator|17297
        C_JSR(alloc);				// and use standard allocator
        //b ||add|7,xr|8,wa||point past end of block to merge|17298
        xr += wa;				// point past end of block to merge
//      merge here with xr pointing beyond new block
// alcs1:
        //b |alcs1|mov|3,dnamp|7,xr||set updated storage pointer|17302
        C_GOTO(alcs1);
        } /* alcs0 */
        

        void alcs1() {
        v.dnamp= xr;				// set updated storage pointer
        //b ||zer|11,-(xr)|||store zero chars in last word|17303
        *(--xr_it.wp)=0;				// store zero chars in last word
        //b ||dca|8,wa|||decrement length|17304
        wa -= CFP_B;				// decrement length
        //b ||sub|7,xr|8,wa||point back to start of block|17305
        xr -= wa;				// point back to start of block
        //b ||mov|9,(xr)|22,=b_scl||set type word|17306
        *(xr_it.wp)= (word)(b_scl);				// set type word
        //b ||mov|13,sclen(xr)|8,wc||store length in chars|17307
        *((word *)(CFP_B*SCLEN + xr))= wc;				// store length in chars
        //b ||exi||||return to alocs caller|17308
        C_EXIT(0);				// return to alocs caller
//      come here if string is too long
// alcs2:
        //b |alcs2|erb|1,205|26,string length exceeds value of maxlngth keyword|||17312
        } /* alcs1 */
        

        void alcs2() {
        C_ERB(205)
        //b ||ejc|||||17314
        
//      alost -- allocate space in static region
//      (wa)                  length required in bytes
//      jsr  alost            call to allocate space
//      (xr)                  pointer to allocated block
//      (wb)                  destroyed
//      note that the coding ensures that the resulting value
//      of state is always less than dnamb. this fact is used
//      in testing a variable name for being in the static region
// alost:
        //b |alost|prc|25,e|1,0||entry point|17327
        } /* alcs2 */
        

        void alost() {
//      merge back here after allocating new chunk
// alst1:
        //b |alst1|mov|7,xr|3,state||point to current end of area|17331
        C_GOTO(alst1);
        } /* alost */
        

        void alst1() {
        xr= v.state;				// point to current end of area
        //b ||aov|8,wa|7,xr|6,alst2|point beyond proposed block|17332
        xr+=wa;				// point beyond proposed block
        //b ||bge|7,xr|3,dnamb|6,alst2|jump if overlap with dynamic area|17333
        if ((xr-v.dnamb) >= 0) C_GOTO(alst2);				// jump if overlap with dynamic area
        //b ||mov|3,state|7,xr||else store new pointer|17334
        v.state= xr;				// else store new pointer
        //b ||sub|7,xr|8,wa||point back to start of block|17335
        xr -= wa;				// point back to start of block
        //b ||exi||||return to alost caller|17336
        C_EXIT(0);				// return to alost caller
//      here if no room, prepare to move dynamic storage up
// alst2:
        //b |alst2|mov|3,alsta|8,wa||save wa|17340
        } /* alst1 */
        

        void alst2() {
        v.alsta= wa;				// save wa
        //b ||bge|8,wa|19,*e_sts|6,alst3|skip if requested chunk is large|17341
        if ((wa-CFP_B*E_STS) >= 0) C_GOTO(alst3);				// skip if requested chunk is large
        //b ||mov|8,wa|19,*e_sts||else set to get large enough chunk|17342
        wa= CFP_B*E_STS;				// else set to get large enough chunk
//      here with amount to move up in wa
// alst3:
        //b |alst3|jsr|6,alloc|||allocate block to ensure room|17346
        C_GOTO(alst3);
        } /* alst2 */
        

        void alst3() {
        C_JSR(alloc);				// allocate block to ensure room
        //b ||mov|3,dnamp|7,xr||and delete it|17347
        v.dnamp= xr;				// and delete it
        //b ||mov|8,wb|8,wa||copy move up amount|17348
        wb= wa;				// copy move up amount
        //b ||jsr|6,gbcol|||call gbcol to move dynamic area up|17349
        C_JSR(gbcol);				// call gbcol to move dynamic area up
        //b ||mov|3,dnams|7,xr||remember new sediment size|17351
        v.dnams= xr;				// remember new sediment size
        //b ||mov|8,wa|3,alsta||restore wa|17353
        wa= v.alsta;				// restore wa
        //b ||brn|6,alst1|||loop back to try again|17354
         C_GOTO(alst1);				// loop back to try again
        //b ||ejc|||||17356
        
//      arith -- fetch arithmetic operands
//      arith is used by functions and operators which expect
//      two numeric arguments (operands) which must both be
//      integer or both be real. arith fetches two arguments from
//      the stack and performs any necessary conversions.
//      1(xs)                 first argument (left operand)
//      0(xs)                 second argument (right operand)
//      jsr  arith            call to fetch numeric arguments
//      ppm  loc              transfer loc for opnd 1 non-numeric
//      ppm  loc              transfer loc for opnd 2 non-numeric
//      ppm  loc              transfer loc for real operands
//      for integer args, control returns past the parameters
//      (ia)                  left operand value
//      (xr)                  ptr to icblk for left operand
//      (xl)                  ptr to icblk for right operand
//      (xs)                  popped twice
//      (wa,wb,ra)            destroyed
//      for real arguments, control returns to the location
//      specified by the third parameter.
//      (ra)                  left operand value
//      (xr)                  ptr to rcblk for left operand
//      (xl)                  ptr to rcblk for right operand
//      (wa,wb,wc)            destroyed
//      (xs)                  popped twice
        //b ||ejc|||||17430
        
//      arith (continued)
//      entry point
// arith:
        //b |arith|prc|25,n|1,3||entry point|17439
        } /* alst3 */
        

        void arith() {
        //b ||mov|7,xl|10,(xs)+||load right operand|17441
        xl= C_POP();				// load right operand
        //b ||mov|7,xr|10,(xs)+||load left operand|17442
        xr= C_POP();				// load left operand
        //b ||mov|8,wa|9,(xl)||get right operand type word|17443
        wa= *(xl_it.wp);				// get right operand type word
        //b ||beq|8,wa|22,=b_icl|6,arth1|jump if integer|17444
        if ((wa-(word)(b_icl)) == 0) C_GOTO(arth1);				// jump if integer
        //b ||beq|8,wa|22,=b_rcl|6,arth4|jump if real|17447
        if ((wa-(word)(b_rcl)) == 0) C_GOTO(arth4);				// jump if real
        //b ||mov|11,-(xs)|7,xr||else replace left arg on stack|17449
        C_PUSH(xr);				// else replace left arg on stack
        //b ||mov|7,xr|7,xl||copy left arg pointer|17450
        xr= xl;				// copy left arg pointer
        //b ||ppm|6,arth6|||jump if unconvertible|17452
        C_JSR_1(gtnum,C_GOTO(arth6));				// jump if unconvertible
        //b ||mov|7,xl|7,xr||else copy converted result|17453
        xl= xr;				// else copy converted result
        //b ||mov|8,wa|9,(xl)||get right operand type word|17454
        wa= *(xl_it.wp);				// get right operand type word
        //b ||mov|7,xr|10,(xs)+||reload left argument|17455
        xr= C_POP();				// reload left argument
        //b ||beq|8,wa|22,=b_rcl|6,arth4|jump if right arg is real|17458
        if ((wa-(word)(b_rcl)) == 0) C_GOTO(arth4);				// jump if right arg is real
//      here if right arg is an integer
// arth1:
        //b |arth1|bne|9,(xr)|22,=b_icl|6,arth3|jump if left arg not integer|17463
        C_GOTO(arth1);
        } /* arith */
        

        void arth1() {
        if ((*(xr_it.wp)-(word)(b_icl)) != 0) C_GOTO(arth3);				// jump if left arg not integer
//      exit for integer case
// arth2:
        //b |arth2|ldi|13,icval(xr)|||load left operand value|17467
        C_GOTO(arth2);
        } /* arth1 */
        

        void arth2() {
        ia = *((word *)(CFP_B*ICVAL + xr));				// load left operand value
        //b ||exi||||return to arith caller|17468
        C_NEXIT(P_PRC_ARITH,0);				// return to arith caller
//      here for right operand integer, left operand not
// arth3:
        //b |arth3|jsr|6,gtnum|||convert left arg to numeric|17472
        } /* arth2 */
        

        void arth3() {
        //b ||ppm|6,arth7|||jump if not convertible|17473
        C_JSR_1(gtnum,C_GOTO(arth7));				// jump if not convertible
        //b ||beq|8,wa|22,=b_icl|6,arth2|jump back if integer-integer|17474
        if ((wa-(word)(b_icl)) == 0) C_GOTO(arth2);				// jump back if integer-integer
//      here we must convert real-integer to real-real
        //b ||mov|11,-(xs)|7,xr||put left arg back on stack|17480
        C_PUSH(xr);				// put left arg back on stack
        //b ||ldi|13,icval(xl)|||load right argument value|17481
        ia = *((word *)(CFP_B*ICVAL + xl));				// load right argument value
        //b ||itr||||convert to real|17482
        ra =  (double) (ia);				// convert to real
        //b ||jsr|6,rcbld|||get real block for right arg, merge|17483
        C_JSR(rcbld);				// get real block for right arg, merge
        //b ||mov|7,xl|7,xr||copy right arg ptr|17484
        xl= xr;				// copy right arg ptr
        //b ||mov|7,xr|10,(xs)+||load left argument|17485
        xr= C_POP();				// load left argument
        //b ||brn|6,arth5|||merge for real-real case|17486
         C_GOTO(arth5);				// merge for real-real case
        //b ||ejc|||||17487
        
//      arith (continued)
//      here if right argument is real
// arth4:
        //b |arth4|beq|9,(xr)|22,=b_rcl|6,arth5|jump if left arg real|17493
        } /* arth3 */
        

        void arth4() {
        if ((*(xr_it.wp)-(word)(b_rcl)) == 0) C_GOTO(arth5);				// jump if left arg real
        //b ||ppm|6,arth7|||error if unconvertible|17495
        C_JSR_1(gtrea,C_GOTO(arth7));				// error if unconvertible
//      here for real-real
// arth5:
        //b |arth5|ldr|13,rcval(xr)|||load left operand value|17499
        C_GOTO(arth5);
        } /* arth4 */
        

        void arth5() {
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load left operand value
        //b ||exi|1,3|||take real-real exit|17500
        C_NEXIT(P_PRC_ARITH,3);				// take real-real exit
//      here for error converting right argument
// arth6:
        //b |arth6|ica|7,xs|||pop unwanted left arg|17505
        } /* arth5 */
        

        void arth6() {
        xs += CFP_B;				// pop unwanted left arg
        //b ||exi|1,2|||take appropriate error exit|17506
        C_NEXIT(P_PRC_ARITH,2);				// take appropriate error exit
//      here for error converting left operand
// arth7:
        //b |arth7|exi|1,1|||take appropriate error return|17510
        } /* arth6 */
        

        void arth7() {
        C_NEXIT(P_PRC_ARITH,1);				// take appropriate error return
        //b ||ejc|||||17512
        
//      asign -- perform assignment
//      asign performs the assignment of a value to a variable
//      with appropriate checks for output associations and
//      value trace associations which are executed as required.
//      asign also handles the special cases of assignment to
//      pattern and expression variables.
//      (wb)                  value to be assigned
//      (xl)                  base pointer for variable
//      (wa)                  offset for variable
//      jsr  asign            call to assign value to variable
//      ppm  loc              transfer loc for failure
//      (xr,xl,wa,wb,wc)      destroyed
//      (ra)                  destroyed
//      failure occurs if the evaluation of an expression
//      associated with an expression variable fails.
// asign:
        //b |asign|prc|25,r|1,1||entry point (recursive)|17533
        } /* arth7 */
        

        void asign() {
//      merge back here to assign result to expression variable.
// asg01:
        //b |asg01|add|7,xl|8,wa||point to variable value|17537
        C_GOTO(asg01);
        } /* asign */
        

        void asg01() {
        xl += wa;				// point to variable value
        //b ||mov|7,xr|9,(xl)||load variable value|17538
        xr= *(xl_it.wp);				// load variable value
        //b ||beq|9,(xr)|22,=b_trt|6,asg02|jump if trapped|17539
        if ((*(xr_it.wp)-(word)(b_trt)) == 0) C_GOTO(asg02);				// jump if trapped
        //b ||mov|9,(xl)|8,wb||else perform assignment|17540
        *(xl_it.wp)= wb;				// else perform assignment
        //b ||zer|7,xl|||clear garbage value in xl|17541
        xl=0;				// clear garbage value in xl
        //b ||exi||||and return to asign caller|17542
        C_EXIT(0);				// and return to asign caller
//      here if value is trapped
// asg02:
        //b |asg02|sub|7,xl|8,wa||restore name base|17546
        } /* asg01 */
        

        void asg02() {
        xl -= wa;				// restore name base
        //b ||beq|7,xr|21,=trbkv|6,asg14|jump if keyword variable|17547
        if ((xr-(word)(&c.trbkv)) == 0) C_GOTO(asg14);				// jump if keyword variable
        //b ||bne|7,xr|21,=trbev|6,asg04|jump if not expression variable|17548
        if ((xr-(word)(&c.trbev)) != 0) C_GOTO(asg04);				// jump if not expression variable
//      here for assignment to expression variable
        //b ||mov|7,xr|13,evexp(xl)||point to expression|17552
        xr= *((word *)(CFP_B*EVEXP + xl));				// point to expression
        //b ||mov|11,-(xs)|8,wb||store value to assign on stack|17553
        C_PUSH(wb);				// store value to assign on stack
        //b ||mov|8,wb|18,=num01||set for evaluation by name|17554
        wb= NUM01;				// set for evaluation by name
        //b ||ppm|6,asg03|||jump if evaluation fails|17556
        C_JSR_1(evalx,C_GOTO(asg03));				// jump if evaluation fails
        //b ||mov|8,wb|10,(xs)+||else reload value to assign|17557
        wb= C_POP();				// else reload value to assign
        //b ||brn|6,asg01|||loop back to perform assignment|17558
         C_GOTO(asg01);				// loop back to perform assignment
        //b ||ejc|||||17559
        
//      asign (continued)
//      here for failure during expression evaluation
// asg03:
        //b |asg03|ica|7,xs|||remove stacked value entry|17565
        } /* asg02 */
        

        void asg03() {
        xs += CFP_B;				// remove stacked value entry
        //b ||exi|1,1|||take failure exit|17566
        C_EXIT(1);				// take failure exit
//      here if not keyword or expression variable
// asg04:
        //b |asg04|mov|11,-(xs)|7,xr||save ptr to first trblk|17570
        } /* asg03 */
        

        void asg04() {
        C_PUSH(xr);				// save ptr to first trblk
//      loop to chase down trblk chain and assign value at end
// asg05:
        //b |asg05|mov|8,wc|7,xr||save ptr to this trblk|17574
        C_GOTO(asg05);
        } /* asg04 */
        

        void asg05() {
        wc= xr;				// save ptr to this trblk
        //b ||mov|7,xr|13,trnxt(xr)||point to next trblk|17575
        xr= *((word *)(CFP_B*TRNXT + xr));				// point to next trblk
        //b ||beq|9,(xr)|22,=b_trt|6,asg05|loop back if another trblk|17576
        if ((*(xr_it.wp)-(word)(b_trt)) == 0) C_GOTO(asg05);				// loop back if another trblk
        //b ||mov|7,xr|8,wc||else point back to last trblk|17577
        xr= wc;				// else point back to last trblk
        //b ||mov|13,trval(xr)|8,wb||store value at end of chain|17578
        *((word *)(CFP_B*TRVAL + xr))= wb;				// store value at end of chain
        //b ||mov|7,xr|10,(xs)+||restore ptr to first trblk|17579
        xr= C_POP();				// restore ptr to first trblk
//      loop to process trblk entries on chain
// asg06:
        //b |asg06|mov|8,wb|13,trtyp(xr)||load type code of trblk|17583
        C_GOTO(asg06);
        } /* asg05 */
        

        void asg06() {
        wb= *((word *)(CFP_B*TRTYP + xr));				// load type code of trblk
        //b ||beq|8,wb|18,=trtvl|6,asg08|jump if value trace|17584
        if ((wb-TRTVL) == 0) C_GOTO(asg08);				// jump if value trace
        //b ||beq|8,wb|18,=trtou|6,asg10|jump if output association|17585
        if ((wb-TRTOU) == 0) C_GOTO(asg10);				// jump if output association
//      here to move to next trblk on chain
// asg07:
        //b |asg07|mov|7,xr|13,trnxt(xr)||point to next trblk on chain|17589
        C_GOTO(asg07);
        } /* asg06 */
        

        void asg07() {
        xr= *((word *)(CFP_B*TRNXT + xr));				// point to next trblk on chain
        //b ||beq|9,(xr)|22,=b_trt|6,asg06|loop back if another trblk|17590
        if ((*(xr_it.wp)-(word)(b_trt)) == 0) C_GOTO(asg06);				// loop back if another trblk
        //b ||exi||||else end of chain, return to caller|17591
        C_EXIT(0);				// else end of chain, return to caller
//      here to process value trace
// asg08:
        //b |asg08|bze|3,kvtra|6,asg07||ignore value trace if trace off|17595
        } /* asg07 */
        

        void asg08() {
        if ( !( v.kvtra) ) C_GOTO(asg07);				// ignore value trace if trace off
        //b ||dcv|3,kvtra|||else decrement trace count|17596
        (v.kvtra)--;				// else decrement trace count
        //b ||bze|13,trfnc(xr)|6,asg09||jump if print trace|17597
        if ( !( *((word *)(CFP_B*TRFNC + xr))) ) C_GOTO(asg09);				// jump if print trace
        //b ||jsr|6,trxeq|||else execute function trace|17598
        C_JSR(trxeq);				// else execute function trace
        //b ||brn|6,asg07|||and loop back|17599
         C_GOTO(asg07);				// and loop back
        //b ||ejc|||||17600
        
//      asign (continued)
//      here for print trace
// asg09:
        //b |asg09|jsr|6,prtsn|||print statement number|17606
        } /* asg08 */
        

        void asg09() {
        C_JSR(prtsn);				// print statement number
        //b ||jsr|6,prtnv|||print name = value|17607
        C_JSR(prtnv);				// print name = value
        //b ||brn|6,asg07|||loop back for next trblk|17608
         C_GOTO(asg07);				// loop back for next trblk
//      here for output association
// asg10:
        //b |asg10|bze|3,kvoup|6,asg07||ignore output assoc if output off|17612
        } /* asg09 */
        

        void asg10() {
        if ( !( v.kvoup) ) C_GOTO(asg07);				// ignore output assoc if output off
// asg1b:
        //b |asg1b|mov|7,xl|7,xr||copy trblk pointer|17613
        C_GOTO(asg1b);
        } /* asg10 */
        

        void asg1b() {
        xl= xr;				// copy trblk pointer
        //b ||mov|7,xr|13,trnxt(xr)||point to next trblk|17614
        xr= *((word *)(CFP_B*TRNXT + xr));				// point to next trblk
        //b ||beq|9,(xr)|22,=b_trt|6,asg1b|loop back if another trblk|17615
        if ((*(xr_it.wp)-(word)(b_trt)) == 0) C_GOTO(asg1b);				// loop back if another trblk
        //b ||mov|7,xr|7,xl||else point back to last trblk|17616
        xr= xl;				// else point back to last trblk
        //b ||mov|11,-(xs)|13,trval(xr)||stack value to output|17618
        C_PUSH(*((word *)(CFP_B*TRVAL + xr)));				// stack value to output
        //b ||ppm|6,asg12|||get datatype name if unconvertible|17625
        extern void _l0534();
        C_JMS(gtstg,P_PRC_GTSTG,_l0534);
        } /* asg1b */
        

        void _l0534() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(asg12));				// get datatype name if unconvertible
//      merge with string or buffer to output in xr
// asg11:
        //b |asg11|mov|8,wa|13,trfpt(xl)||fcblk ptr|17629
        C_GOTO(asg11);
        } /* _l0534 */
        

        void asg11() {
        wa= *((word *)(CFP_B*TRFPT + xl));				// fcblk ptr
        //b ||bze|8,wa|6,asg13||jump if standard output file|17630
        if ( !( wa) ) C_GOTO(asg13);				// jump if standard output file
//      here for output to file
// asg1a:
        //b |asg1a|jsr|6,sysou|||call system output routine|17634
        C_GOTO(asg1a);
        } /* asg11 */
        

        void asg1a() {
        //b ||err|1,207|26,output caused non-recoverable error|||17636
        C_JSR_2(sysou,(C_ERR(206)),(C_ERR(207)));
        //b ||exi||||else all done, return to caller|17637
        C_EXIT(0);				// else all done, return to caller
//      if not printable, get datatype name instead
// asg12:
        //b |asg12|jsr|6,dtype|||call datatype routine|17641
        } /* asg1a */
        

        void asg12() {
        C_JSR(dtype);				// call datatype routine
        //b ||brn|6,asg11|||merge|17642
         C_GOTO(asg11);				// merge
//      here to print a string to standard output or terminal
// asg13:
        //b |asg13|beq|13,trter(xl)|21,=v_ter|6,asg1a|jump if terminal output|17647
        } /* asg12 */
        

        void asg13() {
        if ((*((word *)(CFP_B*TRTER + xl))-(word)(&c.v_ter)) == 0) C_GOTO(asg1a);				// jump if terminal output
        //b ||icv|8,wa|||signal standard output|17648
        (wa)++;				// signal standard output
        //b ||brn|6,asg1a|||use sysou to perform output|17649
         C_GOTO(asg1a);				// use sysou to perform output
        //b ||ejc|||||17664
        
//      asign (continued)
//      here for keyword assignment
// asg14:
        //b |asg14|mov|7,xl|13,kvnum(xl)||load keyword number|17670
        } /* asg13 */
        

        void asg14() {
        xl= *((word *)(CFP_B*KVNUM + xl));				// load keyword number
        //b ||beq|7,xl|18,=k_etx|6,asg19|jump if errtext|17671
        if ((xl-K_ETX) == 0) C_GOTO(asg19);				// jump if errtext
        //b ||mov|7,xr|8,wb||copy value to be assigned|17672
        xr= wb;				// copy value to be assigned
        //b ||err|1,208|26,keyword value assigned is not integer|||17674
        C_JSR_1(gtint,(C_ERR(208)));
        //b ||ldi|13,icval(xr)|||else load value|17675
        ia = *((word *)(CFP_B*ICVAL + xr));				// else load value
        //b ||beq|7,xl|18,=k_stl|6,asg16|jump if special case of stlimit|17676
        if ((xl-K_STL) == 0) C_GOTO(asg16);				// jump if special case of stlimit
        //b ||mfi|8,wa|6,asg18||else get addr integer, test ovflow|17677
        if (ia<0) C_GOTO( asg18);				// else get addr integer, test ovflow
        wa = ia;
        //b ||bgt|8,wa|3,mxlen|6,asg18|fail if too large|17678
        if ((wa-v.mxlen) > 0) C_GOTO(asg18);				// fail if too large
        //b ||beq|7,xl|18,=k_ert|6,asg17|jump if special case of errtype|17679
        if ((xl-K_ERT) == 0) C_GOTO(asg17);				// jump if special case of errtype
        //b ||beq|7,xl|18,=k_pfl|6,asg21|jump if special case of profile|17682
        if ((xl-K_PFL) == 0) C_GOTO(asg21);				// jump if special case of profile
        //b ||beq|7,xl|18,=k_mxl|6,asg24|jump if special case of maxlngth|17684
        if ((xl-K_MXL) == 0) C_GOTO(asg24);				// jump if special case of maxlngth
        //b ||beq|7,xl|18,=k_fls|6,asg26|jump if special case of fullscan|17685
        if ((xl-K_FLS) == 0) C_GOTO(asg26);				// jump if special case of fullscan
        //b ||blt|7,xl|18,=k_p__|6,asg15|jump unless protected|17686
        if ((xl-K_P__) < 0) C_GOTO(asg15);				// jump unless protected
        //b ||erb|1,209|26,keyword in assignment is protected|||17687
        C_ERB(209)
//      here to do assignment if not protected
// asg15:
        //b |asg15|mov|15,kvabe(xl)|8,wa||store new value|17691
        } /* asg14 */
        

        void asg15() {
        *((word *)( ((word)&v.kvabe) + xl))= wa;				// store new value
        //b ||exi||||return to asign caller|17692
        C_EXIT(0);				// return to asign caller
//      here for special case of stlimit
//      since stcount is maintained as (stlimit-stcount)
//      it is also necessary to modify stcount appropriately.
// asg16:
        //b |asg16|sbi|3,kvstl|||subtract old limit|17699
        } /* asg15 */
        

        void asg16() {
        ia-=v.kvstl;				// subtract old limit
        //b ||adi|3,kvstc|||add old counter|17700
        ia+=v.kvstc;				// add old counter
        //b ||sti|3,kvstc|||store course counter value|17701
        v.kvstc= ia;				// store course counter value
        //b ||ldi|3,kvstl|||check if counting suppressed|17702
        ia = v.kvstl;				// check if counting suppressed
        //b ||ilt|6,asg25|||do not refine if so|17703
        if (ia < 0)  C_GOTO(asg25);				// do not refine if so
        //b ||mov|8,wa|3,stmcs||refine with counter breakout|17704
        wa= v.stmcs;				// refine with counter breakout
        //b ||sub|8,wa|3,stmct||values|17705
        wa -= v.stmct;				// values
        //b ||mti|8,wa|||convert to integer|17706
        ia = (word)(wa);				// convert to integer
        //b ||ngi||||current-start value|17707
        ia= -ia;				// current-start value
        //b ||adi|3,kvstc|||add in course counter value|17708
        ia+=v.kvstc;				// add in course counter value
        //b ||sti|3,kvstc|||save refined value|17709
        v.kvstc= ia;				// save refined value
// asg25:
        //b |asg25|ldi|13,icval(xr)|||reload new limit value|17710
        C_GOTO(asg25);
        } /* asg16 */
        

        void asg25() {
        ia = *((word *)(CFP_B*ICVAL + xr));				// reload new limit value
        //b ||sti|3,kvstl|||store new limit value|17711
        v.kvstl= ia;				// store new limit value
        //b ||jsr|6,stgcc|||recompute countdown counters|17712
        C_JSR(stgcc);				// recompute countdown counters
        //b ||exi||||return to asign caller|17713
        C_EXIT(0);				// return to asign caller
//      here for special case of errtype
// asg17:
        //b |asg17|ble|8,wa|18,=nini9|6,error|ok to signal if in range|17717
        } /* asg25 */
        

        void asg17() {
        if ((wa-NINI9) <= 0) C_GOTO(ezzor);				// ok to signal if in range
//      here if value assigned is out of range
// asg18:
        //b |asg18|erb|1,210|26,keyword value assigned is negative or too large|||17721
        C_GOTO(asg18);
        } /* asg17 */
        

        void asg18() {
        C_ERB(210)
//      here for special case of errtext
// asg19:
        //b |asg19|mov|11,-(xs)|8,wb||stack value|17725
        } /* asg18 */
        

        void asg19() {
        C_PUSH(wb);				// stack value
        //b ||err|1,211|26,value assigned to keyword errtext not a string|||17727
        extern void _l0535();
        C_JMS(gtstg,P_PRC_GTSTG,_l0535);
        } /* asg19 */
        

        void _l0535() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(211)));
        //b ||mov|3,r_etx|7,xr||make assignment|17728
        v.r_etx= xr;				// make assignment
        //b ||exi||||return to caller|17729
        C_EXIT(0);				// return to caller
//      here for keyword profile
// asg21:
        //b |asg21|bgt|8,wa|18,=num02|6,asg18|moan if not 0,1, or 2|17743
        } /* _l0535 */
        

        void asg21() {
        if ((wa-NUM02) > 0) C_GOTO(asg18);				// moan if not 0,1, or 2
        //b ||bze|8,wa|6,asg15||just assign if zero|17744
        if ( !( wa) ) C_GOTO(asg15);				// just assign if zero
        //b ||bze|3,pfdmp|6,asg22||branch if first assignment|17745
        if ( !( v.pfdmp) ) C_GOTO(asg22);				// branch if first assignment
        //b ||beq|8,wa|3,pfdmp|6,asg23|also if same value as before|17746
        if ((wa-v.pfdmp) == 0) C_GOTO(asg23);				// also if same value as before
        //b ||erb|1,268|26,inconsistent value assigned to keyword profile|||17747
        C_ERB(268)
// asg22:
        //b |asg22|mov|3,pfdmp|8,wa||note value on first assignment|17749
        } /* asg21 */
        

        void asg22() {
        v.pfdmp= wa;				// note value on first assignment
// asg23:
        //b |asg23|mov|3,kvpfl|8,wa||store new value|17750
        C_GOTO(asg23);
        } /* asg22 */
        

        void asg23() {
        v.kvpfl= wa;				// store new value
        //b ||jsr|6,stgcc|||recompute countdown counts|17751
        C_JSR(stgcc);				// recompute countdown counts
        //b ||jsr|6,systm|||get the time|17752
        C_JSR(systm);				// get the time
        //b ||sti|3,pfstm|||fudge some kind of start time|17753
        v.pfstm= ia;				// fudge some kind of start time
        //b ||exi||||return to asign caller|17754
        C_EXIT(0);				// return to asign caller
//      here for keyword maxlngth
// asg24:
        //b |asg24|bge|8,wa|18,=mnlen|6,asg15|if acceptable value|17759
        } /* asg23 */
        

        void asg24() {
        if ((wa-MNLEN) >= 0) C_GOTO(asg15);				// if acceptable value
        //b ||erb|1,287|26,value assigned to keyword maxlngth is too small|||17760
        C_ERB(287)
//      here for keyword fullscan
// asg26:
        //b |asg26|bnz|8,wa|6,asg15||if acceptable value|17764
        } /* asg24 */
        

        void asg26() {
        if (wa) C_GOTO(asg15);				// if acceptable value
        //b ||erb|1,274|26,value assigned to keyword fullscan is zero|||17765
        C_ERB(274)
        //b ||ejc|||||17768
        
//      asinp -- assign during pattern match
//      asinp is like asign and has a similar calling sequence
//      and effect. the difference is that the global pattern
//      variables are saved and restored if required.
//      (xl)                  base pointer for variable
//      (wa)                  offset for variable
//      (wb)                  value to be assigned
//      jsr  asinp            call to assign value to variable
//      ppm  loc              transfer loc if failure
//      (xr,xl)               destroyed
//      (wa,wb,wc,ra)         destroyed
// asinp:
        //b |asinp|prc|25,r|1,1||entry point, recursive|17784
        } /* asg26 */
        

        void asinp() {
        //b ||add|7,xl|8,wa||point to variable|17785
        xl += wa;				// point to variable
        //b ||mov|7,xr|9,(xl)||load current contents|17786
        xr= *(xl_it.wp);				// load current contents
        //b ||beq|9,(xr)|22,=b_trt|6,asnp1|jump if trapped|17787
        if ((*(xr_it.wp)-(word)(b_trt)) == 0) C_GOTO(asnp1);				// jump if trapped
        //b ||mov|9,(xl)|8,wb||else perform assignment|17788
        *(xl_it.wp)= wb;				// else perform assignment
        //b ||zer|7,xl|||clear garbage value in xl|17789
        xl=0;				// clear garbage value in xl
        //b ||exi||||return to asinp caller|17790
        C_EXIT(0);				// return to asinp caller
//      here if variable is trapped
// asnp1:
        //b |asnp1|sub|7,xl|8,wa||restore base pointer|17794
        } /* asinp */
        

        void asnp1() {
        xl -= wa;				// restore base pointer
        //b ||mov|11,-(xs)|3,pmssl||stack subject string length|17795
        C_PUSH(v.pmssl);				// stack subject string length
        //b ||mov|11,-(xs)|3,pmhbs||stack history stack base ptr|17796
        C_PUSH(v.pmhbs);				// stack history stack base ptr
        //b ||mov|11,-(xs)|3,r_pms||stack subject string pointer|17797
        C_PUSH(v.r_pms);				// stack subject string pointer
        //b ||mov|11,-(xs)|3,pmdfl||stack dot flag|17798
        C_PUSH(v.pmdfl);				// stack dot flag
        //b ||ppm|6,asnp2|||jump if failure|17800
        C_JSR_1(asign,C_GOTO(asnp2));				// jump if failure
        //b ||mov|3,pmdfl|10,(xs)+||restore dot flag|17801
        v.pmdfl= C_POP();				// restore dot flag
        //b ||mov|3,r_pms|10,(xs)+||restore subject string pointer|17802
        v.r_pms= C_POP();				// restore subject string pointer
        //b ||mov|3,pmhbs|10,(xs)+||restore history stack base pointer|17803
        v.pmhbs= C_POP();				// restore history stack base pointer
        //b ||mov|3,pmssl|10,(xs)+||restore subject string length|17804
        v.pmssl= C_POP();				// restore subject string length
        //b ||exi||||return to asinp caller|17805
        C_EXIT(0);				// return to asinp caller
//      here if failure in asign call
// asnp2:
        //b |asnp2|mov|3,pmdfl|10,(xs)+||restore dot flag|17809
        } /* asnp1 */
        

        void asnp2() {
        v.pmdfl= C_POP();				// restore dot flag
        //b ||mov|3,r_pms|10,(xs)+||restore subject string pointer|17810
        v.r_pms= C_POP();				// restore subject string pointer
        //b ||mov|3,pmhbs|10,(xs)+||restore history stack base pointer|17811
        v.pmhbs= C_POP();				// restore history stack base pointer
        //b ||mov|3,pmssl|10,(xs)+||restore subject string length|17812
        v.pmssl= C_POP();				// restore subject string length
        //b ||exi|1,1|||take failure exit|17813
        C_EXIT(1);				// take failure exit
        //b ||ejc|||||17815
        
//      blkln -- determine length of block
//      blkln determines the length of a block in dynamic store.
//      (wa)                  first word of block
//      (xr)                  pointer to block
//      jsr  blkln            call to get block length
//      (wa)                  length of block in bytes
//      (xl)                  destroyed
//      blkln is used by the garbage collector and is not
//      permitted to call gbcol directly or indirectly.
//      the first word stored in the block (i.e. at xr) may
//      be anything, but the contents of wa must be correct.
// blkln:
        //b |blkln|prc|25,e|1,0||entry point|17833
        } /* asnp2 */
        

        void blkln() {
        //b ||mov|7,xl|8,wa||copy first word|17834
        xl= wa;				// copy first word
        //b ||lei|7,xl|||get entry id (bl_xx)|17835
        xl = find_elab(xl);    /* get entry code */				// get entry id (bl_xx)
        //b ||bsw|7,xl|2,bl___|6,bln00|switch on block type|17836
        if (xl - (word)(BL___) >=0 )  { C_GOTO(bln00);}				// switch on block type
        extern word _l0544 [];
        { w0 = ((word *)_l0544)[xl];  C_GOTO(w0_it.callp);}
        }  /* blkln */
        

        word  _l0544 [] = {
        //b ||iff|2,bl_ar|6,bln01||arblk|17876
        	(word)((word)(bln01)),				// arblk
        //b ||iff|2,bl_cd|6,bln12||cdblk|17876
        	(word)((word)(bln12)),				// cdblk
        //b ||iff|2,bl_ex|6,bln12||exblk|17876
        	(word)((word)(bln12)),				// exblk
        //b ||iff|2,bl_ic|6,bln07||icblk|17876
        	(word)((word)(bln07)),				// icblk
        //b ||iff|2,bl_nm|6,bln03||nmblk|17876
        	(word)((word)(bln03)),				// nmblk
        //b ||iff|2,bl_p0|6,bln02||p0blk|17876
        	(word)((word)(bln02)),				// p0blk
        //b ||iff|2,bl_p1|6,bln03||p1blk|17876
        	(word)((word)(bln03)),				// p1blk
        //b ||iff|2,bl_p2|6,bln04||p2blk|17876
        	(word)((word)(bln04)),				// p2blk
        //b ||iff|2,bl_rc|6,bln09||rcblk|17876
        	(word)((word)(bln09)),				// rcblk
        //b ||iff|2,bl_sc|6,bln10||scblk|17876
        	(word)((word)(bln10)),				// scblk
        //b ||iff|2,bl_se|6,bln02||seblk|17876
        	(word)((word)(bln02)),				// seblk
        //b ||iff|2,bl_tb|6,bln01||tbblk|17876
        	(word)((word)(bln01)),				// tbblk
        //b ||iff|2,bl_vc|6,bln01||vcblk|17876
        	(word)((word)(bln01)),				// vcblk
        //b ||iff|1,13|6,bln00|||17876
        	(word)((word)(bln00)),
        //b ||iff|1,14|6,bln00|||17876
        	(word)((word)(bln00)),
        //b ||iff|1,15|6,bln00|||17876
        	(word)((word)(bln00)),
        //b ||iff|2,bl_pd|6,bln08||pdblk|17876
        	(word)((word)(bln08)),				// pdblk
        //b ||iff|2,bl_tr|6,bln05||trblk|17876
        	(word)((word)(bln05)),				// trblk
        //b ||iff|1,18|6,bln00|||17876
        	(word)((word)(bln00)),
        //b ||iff|1,19|6,bln00|||17876
        	(word)((word)(bln00)),
        //b ||iff|1,20|6,bln00|||17876
        	(word)((word)(bln00)),
        //b ||iff|2,bl_ct|6,bln06||ctblk|17876
        	(word)((word)(bln06)),				// ctblk
        //b ||iff|2,bl_df|6,bln01||dfblk|17876
        	(word)((word)(bln01)),				// dfblk
        //b ||iff|2,bl_ef|6,bln01||efblk|17876
        	(word)((word)(bln01)),				// efblk
        //b ||iff|2,bl_ev|6,bln03||evblk|17876
        	(word)((word)(bln03)),				// evblk
        //b ||iff|2,bl_ff|6,bln05||ffblk|17876
        	(word)((word)(bln05)),				// ffblk
        //b ||iff|2,bl_kv|6,bln03||kvblk|17876
        	(word)((word)(bln03)),				// kvblk
        //b ||iff|2,bl_pf|6,bln01||pfblk|17876
        	(word)((word)(bln01)),				// pfblk
        //b ||iff|2,bl_te|6,bln04||teblk|17876
        	(word)((word)(bln04)),				// teblk
        //b ||esw||||end of jump table on block type|17876
             }; /* bsw list for _l0544 */				// end of jump table on block type
        //b ||ejc|||||17877
        
//      blkln (continued)
//      here for blocks with length in second word
// bln00:
        //b |bln00|mov|8,wa|13,num01(xr)||load length|17883
        void bln00() {
        wa= *((word *)(CFP_B*NUM01 + xr));				// load length
        //b ||exi||||return to blkln caller|17884
        C_EXIT(0);				// return to blkln caller
//      here for length in third word (ar,cd,df,ef,ex,pf,tb,vc)
// bln01:
        //b |bln01|mov|8,wa|13,num02(xr)||load length from third word|17888
        } /* bln00 */
        

        void bln01() {
        wa= *((word *)(CFP_B*NUM02 + xr));				// load length from third word
        //b ||exi||||return to blkln caller|17889
        C_EXIT(0);				// return to blkln caller
//      here for two word blocks (p0,se)
// bln02:
        //b |bln02|mov|8,wa|19,*num02||load length (two words)|17893
        } /* bln01 */
        

        void bln02() {
        wa= CFP_B*NUM02;				// load length (two words)
        //b ||exi||||return to blkln caller|17894
        C_EXIT(0);				// return to blkln caller
//      here for three word blocks (nm,p1,ev,kv)
// bln03:
        //b |bln03|mov|8,wa|19,*num03||load length (three words)|17898
        } /* bln02 */
        

        void bln03() {
        wa= CFP_B*NUM03;				// load length (three words)
        //b ||exi||||return to blkln caller|17899
        C_EXIT(0);				// return to blkln caller
//      here for four word blocks (p2,te,bc)
// bln04:
        //b |bln04|mov|8,wa|19,*num04||load length (four words)|17903
        } /* bln03 */
        

        void bln04() {
        wa= CFP_B*NUM04;				// load length (four words)
        //b ||exi||||return to blkln caller|17904
        C_EXIT(0);				// return to blkln caller
//      here for five word blocks (ff,tr)
// bln05:
        //b |bln05|mov|8,wa|19,*num05||load length|17908
        } /* bln04 */
        

        void bln05() {
        wa= CFP_B*NUM05;				// load length
        //b ||exi||||return to blkln caller|17909
        C_EXIT(0);				// return to blkln caller
        //b ||ejc|||||17910
        
//      blkln (continued)
//      here for ctblk
// bln06:
        //b |bln06|mov|8,wa|19,*ctsi_||set size of ctblk|17916
        } /* bln05 */
        

        void bln06() {
        wa= CFP_B*CTSI_;				// set size of ctblk
        //b ||exi||||return to blkln caller|17917
        C_EXIT(0);				// return to blkln caller
//      here for icblk
// bln07:
        //b |bln07|mov|8,wa|19,*icsi_||set size of icblk|17921
        } /* bln06 */
        

        void bln07() {
        wa= CFP_B*ICSI_;				// set size of icblk
        //b ||exi||||return to blkln caller|17922
        C_EXIT(0);				// return to blkln caller
//      here for pdblk
// bln08:
        //b |bln08|mov|7,xl|13,pddfp(xr)||point to dfblk|17926
        } /* bln07 */
        

        void bln08() {
        xl= *((word *)(CFP_B*PDDFP + xr));				// point to dfblk
        //b ||mov|8,wa|13,dfpdl(xl)||load pdblk length from dfblk|17927
        wa= *((word *)(CFP_B*DFPDL + xl));				// load pdblk length from dfblk
        //b ||exi||||return to blkln caller|17928
        C_EXIT(0);				// return to blkln caller
//      here for rcblk
// bln09:
        //b |bln09|mov|8,wa|19,*rcsi_||set size of rcblk|17934
        } /* bln08 */
        

        void bln09() {
        wa= CFP_B*RCSI_;				// set size of rcblk
        //b ||exi||||return to blkln caller|17935
        C_EXIT(0);				// return to blkln caller
//      here for scblk
// bln10:
        //b |bln10|mov|8,wa|13,sclen(xr)||load length in characters|17940
        } /* bln09 */
        

        void bln10() {
        wa= *((word *)(CFP_B*SCLEN + xr));				// load length in characters
        //b ||ctb|8,wa|2,scsi_||calculate length in bytes|17941
        wa += (CFP_B-1)+CFP_B*SCSI_;				// calculate length in bytes
        wa &= 0xfffffffffffffff8;
        //b ||exi||||return to blkln caller|17942
        C_EXIT(0);				// return to blkln caller
//      here for length in fourth word (cd,ex)
// bln12:
        //b |bln12|mov|8,wa|13,num03(xr)||load length from cdlen/exlen|17956
        } /* bln10 */
        

        void bln12() {
        wa= *((word *)(CFP_B*NUM03 + xr));				// load length from cdlen/exlen
        //b ||exi||||return to blkln caller|17957
        C_EXIT(0);				// return to blkln caller
        //b ||ejc|||||17960
        
//      copyb -- copy a block
//      (xs)                  block to be copied
//      jsr  copyb            call to copy block
//      ppm  loc              return if block has no idval field
//                            normal return if idval field
//      (xr)                  copy of block
//      (xs)                  popped
//      (xl,wa,wb,wc)         destroyed
// copyb:
        //b |copyb|prc|25,n|1,1||entry point|17972
        } /* bln12 */
        

        void copyb() {
        //b ||mov|7,xr|9,(xs)||load argument|17973
        xr= *(xs_it.wp);				// load argument
        //b ||beq|7,xr|21,=nulls|6,cop10|return argument if it is null|17974
        if ((xr-(word)(&c.nulls)) == 0) C_GOTO(cop10);				// return argument if it is null
        //b ||mov|8,wa|9,(xr)||else load type word|17975
        wa= *(xr_it.wp);				// else load type word
        //b ||mov|8,wb|8,wa||copy type word|17976
        wb= wa;				// copy type word
        //b ||jsr|6,blkln|||get length of argument block|17977
        C_JSR(blkln);				// get length of argument block
        //b ||mov|7,xl|7,xr||copy pointer|17978
        xl= xr;				// copy pointer
        //b ||jsr|6,alloc|||allocate block of same size|17979
        C_JSR(alloc);				// allocate block of same size
        //b ||mov|9,(xs)|7,xr||store pointer to copy|17980
        *(xs_it.wp)= xr;				// store pointer to copy
        //b ||mvw||||copy contents of old block to new|17981
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// copy contents of old block to new
        //b ||zer|7,xl|||clear garbage xl|17982
        xl=0;				// clear garbage xl
        //b ||mov|7,xr|9,(xs)||reload pointer to start of copy|17983
        xr= *(xs_it.wp);				// reload pointer to start of copy
        //b ||beq|8,wb|22,=b_tbt|6,cop05|jump if table|17984
        if ((wb-(word)(b_tbt)) == 0) C_GOTO(cop05);				// jump if table
        //b ||beq|8,wb|22,=b_vct|6,cop01|jump if vector|17985
        if ((wb-(word)(b_vct)) == 0) C_GOTO(cop01);				// jump if vector
        //b ||beq|8,wb|22,=b_pdt|6,cop01|jump if program defined|17986
        if ((wb-(word)(b_pdt)) == 0) C_GOTO(cop01);				// jump if program defined
        //b ||bne|8,wb|22,=b_art|6,cop10|return copy if not array|17991
        if ((wb-(word)(b_art)) != 0) C_GOTO(cop10);				// return copy if not array
//      here for array (arblk)
        //b ||add|7,xr|13,arofs(xr)||point to prototype field|17995
        xr += *((word *)(CFP_B*AROFS + xr));				// point to prototype field
        //b ||brn|6,cop02|||jump to merge|17996
         C_GOTO(cop02);				// jump to merge
//      here for vector, program defined
// cop01:
        //b |cop01|add|7,xr|19,*pdfld||point to pdfld = vcvls|18000
        } /* copyb */
        

        void cop01() {
        xr += CFP_B*PDFLD;				// point to pdfld = vcvls
//      merge here for arblk, vcblk, pdblk to delete trap
//      blocks from all value fields (the copy is untrapped)
// cop02:
        //b |cop02|mov|7,xl|9,(xr)||load next pointer|18005
        C_GOTO(cop02);
        } /* cop01 */
        

        void cop02() {
        xl= *(xr_it.wp);				// load next pointer
//      loop to get value at end of trblk chain
// cop03:
        //b |cop03|bne|9,(xl)|22,=b_trt|6,cop04|jump if not trapped|18009
        C_GOTO(cop03);
        } /* cop02 */
        

        void cop03() {
        if ((*(xl_it.wp)-(word)(b_trt)) != 0) C_GOTO(cop04);				// jump if not trapped
        //b ||mov|7,xl|13,trval(xl)||else point to next value|18010
        xl= *((word *)(CFP_B*TRVAL + xl));				// else point to next value
        //b ||brn|6,cop03|||and loop back|18011
         C_GOTO(cop03);				// and loop back
        //b ||ejc|||||18012
        
//      copyb (continued)
//      here with untrapped value in xl
// cop04:
        //b |cop04|mov|10,(xr)+|7,xl||store real value, bump pointer|18018
        } /* cop03 */
        

        void cop04() {
        *(xr_it.wp++)= xl;				// store real value, bump pointer
        //b ||bne|7,xr|3,dnamp|6,cop02|loop back if more to go|18019
        if ((xr-v.dnamp) != 0) C_GOTO(cop02);				// loop back if more to go
        //b ||brn|6,cop09|||else jump to exit|18020
         C_GOTO(cop09);				// else jump to exit
//      here to copy a table
// cop05:
        //b |cop05|zer|13,idval(xr)|||zero id to stop dump blowing up|18024
        } /* cop04 */
        

        void cop05() {
        *((word *)(CFP_B*IDVAL + xr))=0;				// zero id to stop dump blowing up
        //b ||mov|8,wa|19,*tesi_||set size of teblk|18025
        wa= CFP_B*TESI_;				// set size of teblk
        //b ||mov|8,wc|19,*tbbuk||set initial offset|18026
        wc= CFP_B*TBBUK;				// set initial offset
//      loop through buckets in table
// cop06:
        //b |cop06|mov|7,xr|9,(xs)||load table pointer|18030
        C_GOTO(cop06);
        } /* cop05 */
        

        void cop06() {
        xr= *(xs_it.wp);				// load table pointer
        //b ||beq|8,wc|13,tblen(xr)|6,cop09|jump to exit if all done|18031
        if ((wc-*((word *)(CFP_B*TBLEN + xr))) == 0) C_GOTO(cop09);				// jump to exit if all done
        //b ||mov|8,wb|8,wc||else copy offset|18032
        wb= wc;				// else copy offset
        //b ||sub|8,wb|19,*tenxt||subtract link offset to merge|18033
        wb -= CFP_B*TENXT;				// subtract link offset to merge
        //b ||add|7,xr|8,wb||next bucket header less link offset|18034
        xr += wb;				// next bucket header less link offset
        //b ||ica|8,wc|||bump offset|18035
        wc += CFP_B;				// bump offset
//      loop through teblks on one chain
// cop07:
        //b |cop07|mov|7,xl|13,tenxt(xr)||load pointer to next teblk|18039
        C_GOTO(cop07);
        } /* cop06 */
        

        void cop07() {
        xl= *((word *)(CFP_B*TENXT + xr));				// load pointer to next teblk
        //b ||mov|13,tenxt(xr)|9,(xs)||set end of chain pointer in case|18040
        *((word *)(CFP_B*TENXT + xr))= *(xs_it.wp);				// set end of chain pointer in case
        //b ||beq|9,(xl)|22,=b_tbt|6,cop06|back for next bucket if chain end|18041
        if ((*(xl_it.wp)-(word)(b_tbt)) == 0) C_GOTO(cop06);				// back for next bucket if chain end
        //b ||sub|7,xr|8,wb||point to head of previous block|18042
        xr -= wb;				// point to head of previous block
        //b ||mov|11,-(xs)|7,xr||stack ptr to previous block|18043
        C_PUSH(xr);				// stack ptr to previous block
        //b ||mov|8,wa|19,*tesi_||set size of teblk|18044
        wa= CFP_B*TESI_;				// set size of teblk
        //b ||jsr|6,alloc|||allocate new teblk|18045
        C_JSR(alloc);				// allocate new teblk
        //b ||mov|11,-(xs)|7,xr||stack ptr to new teblk|18046
        C_PUSH(xr);				// stack ptr to new teblk
        //b ||mvw||||copy old teblk to new teblk|18047
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// copy old teblk to new teblk
        //b ||mov|7,xr|10,(xs)+||restore pointer to new teblk|18048
        xr= C_POP();				// restore pointer to new teblk
        //b ||mov|7,xl|10,(xs)+||restore pointer to previous block|18049
        xl= C_POP();				// restore pointer to previous block
        //b ||add|7,xl|8,wb||add offset back in|18050
        xl += wb;				// add offset back in
        //b ||mov|13,tenxt(xl)|7,xr||link new block to previous|18051
        *((word *)(CFP_B*TENXT + xl))= xr;				// link new block to previous
        //b ||mov|7,xl|7,xr||copy pointer to new block|18052
        xl= xr;				// copy pointer to new block
//      loop to set real value after removing trap chain
// cop08:
        //b |cop08|mov|7,xl|13,teval(xl)||load value|18056
        C_GOTO(cop08);
        } /* cop07 */
        

        void cop08() {
        xl= *((word *)(CFP_B*TEVAL + xl));				// load value
        //b ||beq|9,(xl)|22,=b_trt|6,cop08|loop back if trapped|18057
        if ((*(xl_it.wp)-(word)(b_trt)) == 0) C_GOTO(cop08);				// loop back if trapped
        //b ||mov|13,teval(xr)|7,xl||store untrapped value in teblk|18058
        *((word *)(CFP_B*TEVAL + xr))= xl;				// store untrapped value in teblk
        //b ||zer|8,wb|||zero offset within teblk|18059
        wb=0;				// zero offset within teblk
        //b ||brn|6,cop07|||back for next teblk|18060
         C_GOTO(cop07);				// back for next teblk
//      common exit point
// cop09:
        //b |cop09|mov|7,xr|10,(xs)+||load pointer to block|18064
        } /* cop08 */
        

        void cop09() {
        xr= C_POP();				// load pointer to block
        //b ||exi||||return|18065
        C_NEXIT(P_PRC_COPYB,0);				// return
//      alternative return
// cop10:
        //b |cop10|exi|1,1|||return|18069
        } /* cop09 */
        

        void cop10() {
        C_NEXIT(P_PRC_COPYB,1);				// return
        //b ||ejc|||||18070
        
//      cdgcg -- generate code for complex goto
//      used by cmpil to process complex goto tree
//      (wb)                  must be collectable
//      (xr)                  expression pointer
//      jsr  cdgcg            call to generate complex goto
//      (xl,xr,wa)            destroyed
// cdgcg:
        //b |cdgcg|prc|25,e|1,0||entry point|18099
        } /* cop10 */
        

        void cdgcg() {
        //b ||mov|7,xl|13,cmopn(xr)||get unary goto operator|18100
        xl= *((word *)(CFP_B*CMOPN + xr));				// get unary goto operator
        //b ||mov|7,xr|13,cmrop(xr)||point to goto operand|18101
        xr= *((word *)(CFP_B*CMROP + xr));				// point to goto operand
        //b ||beq|7,xl|21,=opdvd|6,cdgc2|jump if direct goto|18102
        if ((xl-(word)(&c.opdvd)) == 0) C_GOTO(cdgc2);				// jump if direct goto
        //b ||jsr|6,cdgnm|||generate opnd by name if not direct|18103
        C_JSR(cdgnm);				// generate opnd by name if not direct
//      return point
// cdgc1:
        //b |cdgc1|mov|8,wa|7,xl||goto operator|18107
        C_GOTO(cdgc1);
        } /* cdgcg */
        

        void cdgc1() {
        wa= xl;				// goto operator
        //b ||jsr|6,cdwrd|||generate it|18108
        C_JSR(cdwrd);				// generate it
        //b ||exi||||return to caller|18109
        C_EXIT(0);				// return to caller
//      direct goto
// cdgc2:
        //b |cdgc2|jsr|6,cdgvl|||generate operand by value|18113
        } /* cdgc1 */
        

        void cdgc2() {
        C_JSR(cdgvl);				// generate operand by value
        //b ||brn|6,cdgc1|||merge to return|18114
         C_GOTO(cdgc1);				// merge to return
        //b ||ejc|||||18116
        
//      cdgex -- build expression block
//      cdgex is passed a pointer to an expression tree (see
//      expan) and returns an expression (seblk or exblk).
//      (wa)                  0 if by value, 1 if by name
//      (wc)                  some collectable value
//      (wb)                  integer in range 0 le x le mxlen
//      (xl)                  ptr to expression tree
//      jsr  cdgex            call to build expression
//      (xr)                  ptr to seblk or exblk
//      (xl,wa,wb)            destroyed
// cdgex:
        //b |cdgex|prc|25,r|1,0||entry point, recursive|18133
        } /* cdgc2 */
        

        void cdgex() {
        //b ||blo|9,(xl)|22,=b_vr_|6,cdgx1|jump if not variable|18134
        if ((*(xl_it.wp)-(word)(b_vr_)) < 0) C_GOTO(cdgx1);				// jump if not variable
//      here for natural variable, build seblk
        //b ||mov|8,wa|19,*sesi_||set size of seblk|18138
        wa= CFP_B*SESI_;				// set size of seblk
        //b ||jsr|6,alloc|||allocate space for seblk|18139
        C_JSR(alloc);				// allocate space for seblk
        //b ||mov|9,(xr)|22,=b_sel||set type word|18140
        *(xr_it.wp)= (word)(b_sel);				// set type word
        //b ||mov|13,sevar(xr)|7,xl||store vrblk pointer|18141
        *((word *)(CFP_B*SEVAR + xr))= xl;				// store vrblk pointer
        //b ||exi||||return to cdgex caller|18142
        C_EXIT(0);				// return to cdgex caller
//      here if not variable, build exblk
// cdgx1:
        //b |cdgx1|mov|7,xr|7,xl||copy tree pointer|18146
        } /* cdgex */
        

        void cdgx1() {
        xr= xl;				// copy tree pointer
        //b ||mov|11,-(xs)|8,wc||save wc|18147
        C_PUSH(wc);				// save wc
        //b ||mov|7,xl|3,cwcof||save current offset|18148
        xl= v.cwcof;				// save current offset
        //b ||bze|8,wa|6,cdgx2||jump if by value|18150
        if ( !( wa) ) C_GOTO(cdgx2);				// jump if by value
        //b ||mov|8,wa|9,(xr)||get type word|18152
        wa= *(xr_it.wp);				// get type word
        //b ||bne|8,wa|22,=b_cmt|6,cdgx2|call by value if not cmblk|18153
        if ((wa-(word)(b_cmt)) != 0) C_GOTO(cdgx2);				// call by value if not cmblk
        //b ||bge|13,cmtyp(xr)|18,=c__nm|6,cdgx2|jump if cmblk only by value|18154
        if ((*((word *)(CFP_B*CMTYP + xr))-C__NM) >= 0) C_GOTO(cdgx2);				// jump if cmblk only by value
        //b ||ejc|||||18155
        
//      cdgex (continued)
//      here if expression can be evaluated by name
        //b ||jsr|6,cdgnm|||generate code by name|18161
        C_JSR(cdgnm);				// generate code by name
        //b ||mov|8,wa|21,=ornm_||load return by name word|18162
        wa= (word)(&c.ornm_);				// load return by name word
        //b ||brn|6,cdgx3|||merge with value case|18163
         C_GOTO(cdgx3);				// merge with value case
//      here if expression can only be evaluated by value
// cdgx2:
        //b |cdgx2|jsr|6,cdgvl|||generate code by value|18167
        } /* cdgx1 */
        

        void cdgx2() {
        C_JSR(cdgvl);				// generate code by value
        //b ||mov|8,wa|21,=orvl_||load return by value word|18168
        wa= (word)(&c.orvl_);				// load return by value word
//      merge here to construct exblk
// cdgx3:
        //b |cdgx3|jsr|6,cdwrd|||generate return word|18172
        C_GOTO(cdgx3);
        } /* cdgx2 */
        

        void cdgx3() {
        C_JSR(cdwrd);				// generate return word
        //b ||jsr|6,exbld|||build exblk|18173
        C_JSR(exbld);				// build exblk
        //b ||mov|8,wc|10,(xs)+||restore wc|18174
        wc= C_POP();				// restore wc
        //b ||exi||||return to cdgex caller|18175
        C_EXIT(0);				// return to cdgex caller
        //b ||ejc|||||18177
        
//      cdgnm -- generate code by name
//      cdgnm is called during the compilation process to
//      generate code by name for an expression. see cdblk
//      description for details of code generated. the input
//      to cdgnm is an expression tree as generated by expan.
//      cdgnm is a recursive procedure which proceeds by making
//      recursive calls to generate code for operands.
//      (wb)                  integer in range 0 le n le dnamb
//      (xr)                  ptr to tree generated by expan
//      (wc)                  constant flag (see below)
//      jsr  cdgnm            call to generate code by name
//      (xr,wa)               destroyed
//      (wc)                  set non-zero if non-constant
//      wc is set to a non-zero (collectable) value if the
//      expression for which code is generated cannot be
//      evaluated at compile time, otherwise wc is unchanged.
//      the code is generated in the current ccblk (see cdwrd).
// cdgnm:
        //b |cdgnm|prc|25,r|1,0||entry point, recursive|18202
        } /* cdgx3 */
        

        void cdgnm() {
        //b ||mov|11,-(xs)|7,xl||save entry xl|18203
        C_PUSH(xl);				// save entry xl
        //b ||mov|11,-(xs)|8,wb||save entry wb|18204
        C_PUSH(wb);				// save entry wb
        //b ||chk||||check for stack overflow|18205
        if(xs<v.lowspmin) { C_GOTO(sec06); } /* stack overflow check */				// check for stack overflow
        //b ||mov|8,wa|9,(xr)||load type word|18206
        wa= *(xr_it.wp);				// load type word
        //b ||beq|8,wa|22,=b_cmt|6,cgn04|jump if cmblk|18207
        if ((wa-(word)(b_cmt)) == 0) C_GOTO(cgn04);				// jump if cmblk
        //b ||bhi|8,wa|22,=b_vr_|6,cgn02|jump if simple variable|18208
        if ((wa-(word)(b_vr_)) > 0) C_GOTO(cgn02);				// jump if simple variable
//      merge here for operand yielding value (e.g. constant)
// cgn01:
        //b |cgn01|erb|1,212|26,syntax error: value used where name is required|||18212
        C_GOTO(cgn01);
        } /* cdgnm */
        

        void cgn01() {
        C_ERB(212)
//      here for natural variable reference
// cgn02:
        //b |cgn02|mov|8,wa|21,=olvn_||load variable load call|18216
        } /* cgn01 */
        

        void cgn02() {
        wa= (word)(&c.olvn_);				// load variable load call
        //b ||jsr|6,cdwrd|||generate it|18217
        C_JSR(cdwrd);				// generate it
        //b ||mov|8,wa|7,xr||copy vrblk pointer|18218
        wa= xr;				// copy vrblk pointer
        //b ||jsr|6,cdwrd|||generate vrblk pointer|18219
        C_JSR(cdwrd);				// generate vrblk pointer
        //b ||ejc|||||18220
        
//      cdgnm (continued)
//      here to exit with wc set correctly
// cgn03:
        //b |cgn03|mov|8,wb|10,(xs)+||restore entry wb|18226
        C_GOTO(cgn03);
        } /* cgn02 */
        

        void cgn03() {
        wb= C_POP();				// restore entry wb
        //b ||mov|7,xl|10,(xs)+||restore entry xl|18227
        xl= C_POP();				// restore entry xl
        //b ||exi||||return to cdgnm caller|18228
        C_EXIT(0);				// return to cdgnm caller
//      here for cmblk
// cgn04:
        //b |cgn04|mov|7,xl|7,xr||copy cmblk pointer|18232
        } /* cgn03 */
        

        void cgn04() {
        xl= xr;				// copy cmblk pointer
        //b ||mov|7,xr|13,cmtyp(xr)||load cmblk type|18233
        xr= *((word *)(CFP_B*CMTYP + xr));				// load cmblk type
        //b ||bge|7,xr|18,=c__nm|6,cgn01|error if not name operand|18234
        if ((xr-C__NM) >= 0) C_GOTO(cgn01);				// error if not name operand
        //b ||bsw|7,xr|2,c__nm||else switch on type|18235
        extern word _l0546 [];				// else switch on type
        { w0 = ((word *)_l0546)[xr];  C_GOTO(w0_it.callp);}
        }  /* cgn04 */
        

        word  _l0546 [] = {
        //b ||iff|2,c_arr|6,cgn05||array reference|18243
        	(word)((word)(cgn05)),				// array reference
        //b ||iff|2,c_fnc|6,cgn08||function call|18243
        	(word)((word)(cgn08)),				// function call
        //b ||iff|2,c_def|6,cgn09||deferred expression|18243
        	(word)((word)(cgn09)),				// deferred expression
        //b ||iff|2,c_ind|6,cgn10||indirect reference|18243
        	(word)((word)(cgn10)),				// indirect reference
        //b ||iff|2,c_key|6,cgn11||keyword reference|18243
        	(word)((word)(cgn11)),				// keyword reference
        //b ||iff|2,c_ubo|6,cgn08||undefined binary op|18243
        	(word)((word)(cgn08)),				// undefined binary op
        //b ||iff|2,c_uuo|6,cgn08||undefined unary op|18243
        	(word)((word)(cgn08)),				// undefined unary op
        //b ||esw||||end switch on cmblk type|18243
             }; /* bsw list for _l0546 */				// end switch on cmblk type
//      here to generate code for array reference
// cgn05:
        //b |cgn05|mov|8,wb|19,*cmopn||point to array operand|18247
        void cgn05() {
        wb= CFP_B*CMOPN;				// point to array operand
//      loop to generate code for array operand and subscripts
// cgn06:
        //b |cgn06|jsr|6,cmgen|||generate code for next operand|18251
        C_GOTO(cgn06);
        } /* cgn05 */
        

        void cgn06() {
        C_JSR(cmgen);				// generate code for next operand
        //b ||mov|8,wc|13,cmlen(xl)||load length of cmblk|18252
        wc= *((word *)(CFP_B*CMLEN + xl));				// load length of cmblk
        //b ||blt|8,wb|8,wc|6,cgn06|loop till all generated|18253
        if ((wb-wc) < 0) C_GOTO(cgn06);				// loop till all generated
//      generate appropriate array call
        //b ||mov|8,wa|21,=oaon_||load one-subscript case call|18257
        wa= (word)(&c.oaon_);				// load one-subscript case call
        //b ||beq|8,wc|19,*cmar1|6,cgn07|jump to exit if one subscript case|18258
        if ((wc-CFP_B*CMAR1) == 0) C_GOTO(cgn07);				// jump to exit if one subscript case
        //b ||mov|8,wa|21,=oamn_||else load multi-subscript case call|18259
        wa= (word)(&c.oamn_);				// else load multi-subscript case call
        //b ||jsr|6,cdwrd|||generate call|18260
        C_JSR(cdwrd);				// generate call
        //b ||mov|8,wa|8,wc||copy cmblk length|18261
        wa= wc;				// copy cmblk length
        //b ||btw|8,wa|||convert to words|18262
        wa >>= LOG_CFP_B;				// convert to words
        //b ||sub|8,wa|18,=cmvls||calculate number of subscripts|18263
        wa -= CMVLS;				// calculate number of subscripts
        //b ||ejc|||||18264
        
//      cdgnm (continued)
//      here to exit generating word (non-constant)
// cgn07:
        //b |cgn07|mnz|8,wc|||set result non-constant|18270
        C_GOTO(cgn07);
        } /* cgn06 */
        

        void cgn07() {
        wc = 0xffffffffffffffff;				// set result non-constant
        //b ||jsr|6,cdwrd|||generate word|18271
        C_JSR(cdwrd);				// generate word
        //b ||brn|6,cgn03|||back to exit|18272
         C_GOTO(cgn03);				// back to exit
//      here to generate code for functions and undefined oprs
// cgn08:
        //b |cgn08|mov|7,xr|7,xl||copy cmblk pointer|18276
        } /* cgn07 */
        

        void cgn08() {
        xr= xl;				// copy cmblk pointer
        //b ||jsr|6,cdgvl|||gen code by value for call|18277
        C_JSR(cdgvl);				// gen code by value for call
        //b ||mov|8,wa|21,=ofne_||get extra call for by name|18278
        wa= (word)(&c.ofne_);				// get extra call for by name
        //b ||brn|6,cgn07|||back to generate and exit|18279
         C_GOTO(cgn07);				// back to generate and exit
//      here to generate code for defered expression
// cgn09:
        //b |cgn09|mov|7,xr|13,cmrop(xl)||check if variable|18283
        } /* cgn08 */
        

        void cgn09() {
        xr= *((word *)(CFP_B*CMROP + xl));				// check if variable
        //b ||bhi|9,(xr)|22,=b_vr_|6,cgn02|treat *variable as simple var|18284
        if ((*(xr_it.wp)-(word)(b_vr_)) > 0) C_GOTO(cgn02);				// treat *variable as simple var
        //b ||mov|7,xl|7,xr||copy ptr to expression tree|18285
        xl= xr;				// copy ptr to expression tree
        //b ||mov|8,wa|18,=num01||return name|18287
        wa= NUM01;				// return name
        //b ||jsr|6,cdgex|||else build exblk|18289
        C_JSR(cdgex);				// else build exblk
        //b ||mov|8,wa|21,=olex_||set call to load expr by name|18290
        wa= (word)(&c.olex_);				// set call to load expr by name
        //b ||jsr|6,cdwrd|||generate it|18291
        C_JSR(cdwrd);				// generate it
        //b ||mov|8,wa|7,xr||copy exblk pointer|18292
        wa= xr;				// copy exblk pointer
        //b ||jsr|6,cdwrd|||generate exblk pointer|18293
        C_JSR(cdwrd);				// generate exblk pointer
        //b ||brn|6,cgn03|||back to exit|18294
         C_GOTO(cgn03);				// back to exit
//      here to generate code for indirect reference
// cgn10:
        //b |cgn10|mov|7,xr|13,cmrop(xl)||get operand|18298
        } /* cgn09 */
        

        void cgn10() {
        xr= *((word *)(CFP_B*CMROP + xl));				// get operand
        //b ||jsr|6,cdgvl|||generate code by value for it|18299
        C_JSR(cdgvl);				// generate code by value for it
        //b ||mov|8,wa|21,=oinn_||load call for indirect by name|18300
        wa= (word)(&c.oinn_);				// load call for indirect by name
        //b ||brn|6,cgn12|||merge|18301
         C_GOTO(cgn12);				// merge
//      here to generate code for keyword reference
// cgn11:
        //b |cgn11|mov|7,xr|13,cmrop(xl)||get operand|18305
        } /* cgn10 */
        

        void cgn11() {
        xr= *((word *)(CFP_B*CMROP + xl));				// get operand
        //b ||jsr|6,cdgnm|||generate code by name for it|18306
        C_JSR(cdgnm);				// generate code by name for it
        //b ||mov|8,wa|21,=okwn_||load call for keyword by name|18307
        wa= (word)(&c.okwn_);				// load call for keyword by name
//      keyword, indirect merge here
// cgn12:
        //b |cgn12|jsr|6,cdwrd|||generate code for operator|18311
        C_GOTO(cgn12);
        } /* cgn11 */
        

        void cgn12() {
        C_JSR(cdwrd);				// generate code for operator
        //b ||brn|6,cgn03|||exit|18312
         C_GOTO(cgn03);				// exit
        //b ||ejc|||||18314
        
//      cdgvl -- generate code by value
//      cdgvl is called during the compilation process to
//      generate code by value for an expression. see cdblk
//      description for details of the code generated. the input
//      to cdgvl is an expression tree as generated by expan.
//      cdgvl is a recursive procedure which proceeds by making
//      recursive calls to generate code for operands.
//      (wb)                  integer in range 0 le n le dnamb
//      (xr)                  ptr to tree generated by expan
//      (wc)                  constant flag (see below)
//      jsr  cdgvl            call to generate code by value
//      (xr,wa)               destroyed
//      (wc)                  set non-zero if non-constant
//      wc is set to a non-zero (collectable) value if the
//      expression for which code is generated cannot be
//      evaluated at compile time, otherwise wc is unchanged.
//      if wc is non-zero on entry, then preevaluation is not
//      allowed regardless of the nature of the operand.
//      the code is generated in the current ccblk (see cdwrd).
// cdgvl:
        //b |cdgvl|prc|25,r|1,0||entry point, recursive|18342
        } /* cgn12 */
        

        void cdgvl() {
        //b ||mov|8,wa|9,(xr)||load type word|18343
        wa= *(xr_it.wp);				// load type word
        //b ||beq|8,wa|22,=b_cmt|6,cgv01|jump if cmblk|18344
        if ((wa-(word)(b_cmt)) == 0) C_GOTO(cgv01);				// jump if cmblk
        //b ||blt|8,wa|22,=b_vra|6,cgv00|jump if icblk, rcblk, scblk|18345
        if ((wa-(word)(b_vra)) < 0) C_GOTO(cgv00);				// jump if icblk, rcblk, scblk
        //b ||bnz|13,vrlen(xr)|6,cgvl0||jump if not system variable|18346
        if (*((word *)(CFP_B*VRLEN + xr))) C_GOTO(cgvl0);				// jump if not system variable
        //b ||mov|11,-(xs)|7,xr||stack xr|18347
        C_PUSH(xr);				// stack xr
        //b ||mov|7,xr|13,vrsvp(xr)||point to svblk|18348
        xr= *((word *)(CFP_B*VRSVP + xr));				// point to svblk
        //b ||mov|8,wa|13,svbit(xr)||get svblk property bits|18349
        wa= *((word *)(CFP_B*SVBIT + xr));				// get svblk property bits
        //b ||mov|7,xr|10,(xs)+||recover xr|18350
        xr= C_POP();				// recover xr
        //b ||anb|8,wa|4,btkwv||check if constant keyword value|18351
        wa &= c.btkwv;				// check if constant keyword value
        //b ||beq|8,wa|4,btkwv|6,cgv00|jump if constant keyword value|18352
        if ((wa-c.btkwv) == 0) C_GOTO(cgv00);				// jump if constant keyword value
//      here for variable value reference
// cgvl0:
        //b |cgvl0|mnz|8,wc|||indicate non-constant value|18356
        C_GOTO(cgvl0);
        } /* cdgvl */
        

        void cgvl0() {
        wc = 0xffffffffffffffff;				// indicate non-constant value
//      merge here for simple constant (icblk,rcblk,scblk)
//      and for variables corresponding to constant keywords.
// cgv00:
        //b |cgv00|mov|8,wa|7,xr||copy ptr to var or constant|18361
        C_GOTO(cgv00);
        } /* cgvl0 */
        

        void cgv00() {
        wa= xr;				// copy ptr to var or constant
        //b ||jsr|6,cdwrd|||generate as code word|18362
        C_JSR(cdwrd);				// generate as code word
        //b ||exi||||return to caller|18363
        C_EXIT(0);				// return to caller
        //b ||ejc|||||18364
        
//      cdgvl (continued)
//      here for tree node (cmblk)
// cgv01:
        //b |cgv01|mov|11,-(xs)|8,wb||save entry wb|18370
        } /* cgv00 */
        

        void cgv01() {
        C_PUSH(wb);				// save entry wb
        //b ||mov|11,-(xs)|7,xl||save entry xl|18371
        C_PUSH(xl);				// save entry xl
        //b ||mov|11,-(xs)|8,wc||save entry constant flag|18372
        C_PUSH(wc);				// save entry constant flag
        //b ||mov|11,-(xs)|3,cwcof||save initial code offset|18373
        C_PUSH(v.cwcof);				// save initial code offset
        //b ||chk||||check for stack overflow|18374
        if(xs<v.lowspmin) { C_GOTO(sec06); } /* stack overflow check */				// check for stack overflow
//      prepare to generate code for cmblk. wc is set to the
//      value of cswno (zero if -optimise, 1 if -noopt) to
//      start with and is reset non-zero for any non-constant
//      code generated. if it is still zero after generating all
//      the cmblk code, then its value is computed as the result.
        //b ||mov|7,xl|7,xr||copy cmblk pointer|18382
        xl= xr;				// copy cmblk pointer
        //b ||mov|7,xr|13,cmtyp(xr)||load cmblk type|18383
        xr= *((word *)(CFP_B*CMTYP + xr));				// load cmblk type
        //b ||mov|8,wc|3,cswno||reset constant flag|18384
        wc= v.cswno;				// reset constant flag
        //b ||ble|7,xr|18,=c_pr_|6,cgv02|jump if not predicate value|18385
        if ((xr-C_PR_) <= 0) C_GOTO(cgv02);				// jump if not predicate value
        //b ||mnz|8,wc|||else force non-constant case|18386
        wc = 0xffffffffffffffff;				// else force non-constant case
//      here with wc set appropriately
// cgv02:
        //b |cgv02|bsw|7,xr|2,c__nv||switch to appropriate generator|18390
        C_GOTO(cgv02);
        } /* cgv01 */
        

        void cgv02() {
        extern word _l0547 [];				// switch to appropriate generator
        { w0 = ((word *)_l0547)[xr];  C_GOTO(w0_it.callp);}
        }  /* cgv02 */
        

        word  _l0547 [] = {
        //b ||iff|2,c_arr|6,cgv03||array reference|18410
        	(word)((word)(cgv03)),				// array reference
        //b ||iff|2,c_fnc|6,cgv05||function call|18410
        	(word)((word)(cgv05)),				// function call
        //b ||iff|2,c_def|6,cgv14||deferred expression|18410
        	(word)((word)(cgv14)),				// deferred expression
        //b ||iff|2,c_ind|6,cgv31||indirect reference|18410
        	(word)((word)(cgv31)),				// indirect reference
        //b ||iff|2,c_key|6,cgv27||keyword reference|18410
        	(word)((word)(cgv27)),				// keyword reference
        //b ||iff|2,c_ubo|6,cgv29||undefined binop|18410
        	(word)((word)(cgv29)),				// undefined binop
        //b ||iff|2,c_uuo|6,cgv30||undefined unop|18410
        	(word)((word)(cgv30)),				// undefined unop
        //b ||iff|2,c_bvl|6,cgv18||binops with val opds|18410
        	(word)((word)(cgv18)),				// binops with val opds
        //b ||iff|2,c_uvl|6,cgv19||unops with valu opnd|18410
        	(word)((word)(cgv19)),				// unops with valu opnd
        //b ||iff|2,c_alt|6,cgv18||alternation|18410
        	(word)((word)(cgv18)),				// alternation
        //b ||iff|2,c_cnc|6,cgv24||concatenation|18410
        	(word)((word)(cgv24)),				// concatenation
        //b ||iff|2,c_cnp|6,cgv24||concatenation (not pattern match)|18410
        	(word)((word)(cgv24)),				// concatenation (not pattern match)
        //b ||iff|2,c_unm|6,cgv27||unops with name opnd|18410
        	(word)((word)(cgv27)),				// unops with name opnd
        //b ||iff|2,c_bvn|6,cgv26||binary _ and .|18410
        	(word)((word)(cgv26)),				// binary _ and .
        //b ||iff|2,c_ass|6,cgv21||assignment|18410
        	(word)((word)(cgv21)),				// assignment
        //b ||iff|2,c_int|6,cgv31||interrogation|18410
        	(word)((word)(cgv31)),				// interrogation
        //b ||iff|2,c_neg|6,cgv28||negation|18410
        	(word)((word)(cgv28)),				// negation
        //b ||iff|2,c_sel|6,cgv15||selection|18410
        	(word)((word)(cgv15)),				// selection
        //b ||iff|2,c_pmt|6,cgv18||pattern match|18410
        	(word)((word)(cgv18)),				// pattern match
        //b ||esw||||end switch on cmblk type|18410
             }; /* bsw list for _l0547 */				// end switch on cmblk type
        //b ||ejc|||||18411
        
//      cdgvl (continued)
//      here to generate code for array reference
// cgv03:
        //b |cgv03|mov|8,wb|19,*cmopn||set offset to array operand|18417
        void cgv03() {
        wb= CFP_B*CMOPN;				// set offset to array operand
//      loop to generate code for array operand and subscripts
// cgv04:
        //b |cgv04|jsr|6,cmgen|||gen value code for next operand|18421
        C_GOTO(cgv04);
        } /* cgv03 */
        

        void cgv04() {
        C_JSR(cmgen);				// gen value code for next operand
        //b ||mov|8,wc|13,cmlen(xl)||load cmblk length|18422
        wc= *((word *)(CFP_B*CMLEN + xl));				// load cmblk length
        //b ||blt|8,wb|8,wc|6,cgv04|loop back if more to go|18423
        if ((wb-wc) < 0) C_GOTO(cgv04);				// loop back if more to go
//      generate call to appropriate array reference routine
        //b ||mov|8,wa|21,=oaov_||set one subscript call in case|18427
        wa= (word)(&c.oaov_);				// set one subscript call in case
        //b ||beq|8,wc|19,*cmar1|6,cgv32|jump to exit if 1-sub case|18428
        if ((wc-CFP_B*CMAR1) == 0) C_GOTO(cgv32);				// jump to exit if 1-sub case
        //b ||mov|8,wa|21,=oamv_||else set call for multi-subscripts|18429
        wa= (word)(&c.oamv_);				// else set call for multi-subscripts
        //b ||jsr|6,cdwrd|||generate call|18430
        C_JSR(cdwrd);				// generate call
        //b ||mov|8,wa|8,wc||copy length of cmblk|18431
        wa= wc;				// copy length of cmblk
        //b ||sub|8,wa|19,*cmvls||subtract standard length|18432
        wa -= CFP_B*CMVLS;				// subtract standard length
        //b ||btw|8,wa|||get number of words|18433
        wa >>= LOG_CFP_B;				// get number of words
        //b ||brn|6,cgv32|||jump to generate subscript count|18434
         C_GOTO(cgv32);				// jump to generate subscript count
//      here to generate code for function call
// cgv05:
        //b |cgv05|mov|8,wb|19,*cmvls||set offset to first argument|18438
        } /* cgv04 */
        

        void cgv05() {
        wb= CFP_B*CMVLS;				// set offset to first argument
//      loop to generate code for arguments
// cgv06:
        //b |cgv06|beq|8,wb|13,cmlen(xl)|6,cgv07|jump if all generated|18442
        C_GOTO(cgv06);
        } /* cgv05 */
        

        void cgv06() {
        if ((wb-*((word *)(CFP_B*CMLEN + xl))) == 0) C_GOTO(cgv07);				// jump if all generated
        //b ||jsr|6,cmgen|||else gen value code for next arg|18443
        C_JSR(cmgen);				// else gen value code for next arg
        //b ||brn|6,cgv06|||back to generate next argument|18444
         C_GOTO(cgv06);				// back to generate next argument
//      here to generate actual function call
// cgv07:
        //b |cgv07|sub|8,wb|19,*cmvls||get number of arg ptrs (bytes)|18448
        } /* cgv06 */
        

        void cgv07() {
        wb -= CFP_B*CMVLS;				// get number of arg ptrs (bytes)
        //b ||btw|8,wb|||convert bytes to words|18449
        wb >>= LOG_CFP_B;				// convert bytes to words
        //b ||mov|7,xr|13,cmopn(xl)||load function vrblk pointer|18450
        xr= *((word *)(CFP_B*CMOPN + xl));				// load function vrblk pointer
        //b ||bnz|13,vrlen(xr)|6,cgv12||jump if not system function|18451
        if (*((word *)(CFP_B*VRLEN + xr))) C_GOTO(cgv12);				// jump if not system function
        //b ||mov|7,xl|13,vrsvp(xr)||load svblk ptr if system var|18452
        xl= *((word *)(CFP_B*VRSVP + xr));				// load svblk ptr if system var
        //b ||mov|8,wa|13,svbit(xl)||load bit mask|18453
        wa= *((word *)(CFP_B*SVBIT + xl));				// load bit mask
        //b ||anb|8,wa|4,btffc||test for fast function call allowed|18454
        wa &= c.btffc;				// test for fast function call allowed
        //b ||zrb|8,wa|6,cgv12||jump if not|18455
        if (!(wa)) C_GOTO(cgv12);				// jump if not
        //b ||ejc|||||18456
        
//      cdgvl (continued)
//      here if fast function call is allowed
        //b ||mov|8,wa|13,svbit(xl)||reload bit indicators|18462
        wa= *((word *)(CFP_B*SVBIT + xl));				// reload bit indicators
        //b ||anb|8,wa|4,btpre||test for preevaluation ok|18463
        wa &= c.btpre;				// test for preevaluation ok
        //b ||nzb|8,wa|6,cgv08||jump if preevaluation permitted|18464
        if (wa) C_GOTO(cgv08);				// jump if preevaluation permitted
        //b ||mnz|8,wc|||else set result non-constant|18465
        wc = 0xffffffffffffffff;				// else set result non-constant
//      test for correct number of args for fast call
// cgv08:
        //b |cgv08|mov|7,xl|13,vrfnc(xr)||load ptr to svfnc field|18469
        C_GOTO(cgv08);
        } /* cgv07 */
        

        void cgv08() {
        xl= *((word *)(CFP_B*VRFNC + xr));				// load ptr to svfnc field
        //b ||mov|8,wa|13,fargs(xl)||load svnar field value|18470
        wa= *((word *)(CFP_B*FARGS + xl));				// load svnar field value
        //b ||beq|8,wa|8,wb|6,cgv11|jump if argument count is correct|18471
        if ((wa-wb) == 0) C_GOTO(cgv11);				// jump if argument count is correct
        //b ||bhi|8,wa|8,wb|6,cgv09|jump if too few arguments given|18472
        if ((wa-wb) > 0) C_GOTO(cgv09);				// jump if too few arguments given
//      here if too many arguments, prepare to generate o_pops
        //b ||sub|8,wb|8,wa||get number of extra args|18476
        wb -= wa;				// get number of extra args
        //b ||lct|8,wb|8,wb||set as count to control loop|18477
        wb= wb;				// set as count to control loop
        //b ||mov|8,wa|21,=opop_||set pop call|18478
        wa= (word)(&c.opop_);				// set pop call
        //b ||brn|6,cgv10|||jump to common loop|18479
         C_GOTO(cgv10);				// jump to common loop
//      here if too few arguments, prepare to generate nulls
// cgv09:
        //b |cgv09|sub|8,wa|8,wb||get number of missing arguments|18483
        } /* cgv08 */
        

        void cgv09() {
        wa -= wb;				// get number of missing arguments
        //b ||lct|8,wb|8,wa||load as count to control loop|18484
        wb= wa;				// load as count to control loop
        //b ||mov|8,wa|21,=nulls||load ptr to null constant|18485
        wa= (word)(&c.nulls);				// load ptr to null constant
//      loop to generate calls to fix argument count
// cgv10:
        //b |cgv10|jsr|6,cdwrd|||generate one call|18489
        C_GOTO(cgv10);
        } /* cgv09 */
        

        void cgv10() {
        C_JSR(cdwrd);				// generate one call
        //b ||bct|8,wb|6,cgv10||loop till all generated|18490
        if ((--wb))  C_GOTO(cgv10);				// loop till all generated
//      here after adjusting arg count as required
// cgv11:
        //b |cgv11|mov|8,wa|7,xl||copy pointer to svfnc field|18494
        C_GOTO(cgv11);
        } /* cgv10 */
        

        void cgv11() {
        wa= xl;				// copy pointer to svfnc field
        //b ||brn|6,cgv36|||jump to generate call|18495
         C_GOTO(cgv36);				// jump to generate call
        //b ||ejc|||||18496
        
//      cdgvl (continued)
//      come here if fast call is not permitted
// cgv12:
        //b |cgv12|mov|8,wa|21,=ofns_||set one arg call in case|18502
        } /* cgv11 */
        

        void cgv12() {
        wa= (word)(&c.ofns_);				// set one arg call in case
        //b ||beq|8,wb|18,=num01|6,cgv13|jump if one arg case|18503
        if ((wb-NUM01) == 0) C_GOTO(cgv13);				// jump if one arg case
        //b ||mov|8,wa|21,=ofnc_||else load call for more than 1 arg|18504
        wa= (word)(&c.ofnc_);				// else load call for more than 1 arg
        //b ||jsr|6,cdwrd|||generate it|18505
        C_JSR(cdwrd);				// generate it
        //b ||mov|8,wa|8,wb||copy argument count|18506
        wa= wb;				// copy argument count
//      one arg case merges here
// cgv13:
        //b |cgv13|jsr|6,cdwrd|||generate =o_fns or arg count|18510
        C_GOTO(cgv13);
        } /* cgv12 */
        

        void cgv13() {
        C_JSR(cdwrd);				// generate =o_fns or arg count
        //b ||mov|8,wa|7,xr||copy vrblk pointer|18511
        wa= xr;				// copy vrblk pointer
        //b ||brn|6,cgv32|||jump to generate vrblk ptr|18512
         C_GOTO(cgv32);				// jump to generate vrblk ptr
//      here for deferred expression
// cgv14:
        //b |cgv14|mov|7,xl|13,cmrop(xl)||point to expression tree|18516
        } /* cgv13 */
        

        void cgv14() {
        xl= *((word *)(CFP_B*CMROP + xl));				// point to expression tree
        //b ||zer|8,wa|||return value|18518
        wa=0;				// return value
        //b ||jsr|6,cdgex|||build exblk or seblk|18520
        C_JSR(cdgex);				// build exblk or seblk
        //b ||mov|8,wa|7,xr||copy block ptr|18521
        wa= xr;				// copy block ptr
        //b ||jsr|6,cdwrd|||generate ptr to exblk or seblk|18522
        C_JSR(cdwrd);				// generate ptr to exblk or seblk
        //b ||brn|6,cgv34|||jump to exit, constant test|18523
         C_GOTO(cgv34);				// jump to exit, constant test
//      here to generate code for selection
// cgv15:
        //b |cgv15|zer|11,-(xs)|||zero ptr to chain of forward jumps|18527
        } /* cgv14 */
        

        void cgv15() {
        *(--xs_it.wp)=0;				// zero ptr to chain of forward jumps
        //b ||zer|11,-(xs)|||zero ptr to prev o_slc forward ptr|18528
        *(--xs_it.wp)=0;				// zero ptr to prev o_slc forward ptr
        //b ||mov|8,wb|19,*cmvls||point to first alternative|18529
        wb= CFP_B*CMVLS;				// point to first alternative
        //b ||mov|8,wa|21,=osla_||set initial code word|18530
        wa= (word)(&c.osla_);				// set initial code word
//      0(xs)                 is the offset to the previous word
//                            which requires filling in with an
//                            offset to the following o_slc,o_sld
//      1(xs)                 is the head of a chain of offset
//                            pointers indicating those locations
//                            to be filled with offsets past
//                            the end of all the alternatives
// cgv16:
        //b |cgv16|jsr|6,cdwrd|||generate o_slc (o_sla first time)|18541
        C_GOTO(cgv16);
        } /* cgv15 */
        

        void cgv16() {
        C_JSR(cdwrd);				// generate o_slc (o_sla first time)
        //b ||mov|9,(xs)|3,cwcof||set current loc as ptr to fill in|18542
        *(xs_it.wp)= v.cwcof;				// set current loc as ptr to fill in
        //b ||jsr|6,cdwrd|||generate garbage word there for now|18543
        C_JSR(cdwrd);				// generate garbage word there for now
        //b ||jsr|6,cmgen|||gen value code for alternative|18544
        C_JSR(cmgen);				// gen value code for alternative
        //b ||mov|8,wa|21,=oslb_||load o_slb pointer|18545
        wa= (word)(&c.oslb_);				// load o_slb pointer
        //b ||jsr|6,cdwrd|||generate o_slb call|18546
        C_JSR(cdwrd);				// generate o_slb call
        //b ||mov|8,wa|13,num01(xs)||load old chain ptr|18547
        wa= *((word *)(CFP_B*NUM01 + xs));				// load old chain ptr
        //b ||mov|13,num01(xs)|3,cwcof||set current loc as new chain head|18548
        *((word *)(CFP_B*NUM01 + xs))= v.cwcof;				// set current loc as new chain head
        //b ||jsr|6,cdwrd|||generate forward chain link|18549
        C_JSR(cdwrd);				// generate forward chain link
        //b ||ejc|||||18550
        
//      cdgvl (continued)
//      now to fill in the skip offset to o_slc,o_sld
        //b ||mov|7,xr|9,(xs)||load offset to word to plug|18556
        xr= *(xs_it.wp);				// load offset to word to plug
        //b ||add|7,xr|3,r_ccb||point to actual location to plug|18557
        xr += v.r_ccb;				// point to actual location to plug
        //b ||mov|9,(xr)|3,cwcof||plug proper offset in|18558
        *(xr_it.wp)= v.cwcof;				// plug proper offset in
        //b ||mov|8,wa|21,=oslc_||load o_slc ptr for next alternative|18559
        wa= (word)(&c.oslc_);				// load o_slc ptr for next alternative
        //b ||mov|7,xr|8,wb||copy offset (destroy garbage xr)|18560
        xr= wb;				// copy offset (destroy garbage xr)
        //b ||ica|7,xr|||bump extra time for test|18561
        xr += CFP_B;				// bump extra time for test
        //b ||blt|7,xr|13,cmlen(xl)|6,cgv16|loop back if not last alternative|18562
        if ((xr-*((word *)(CFP_B*CMLEN + xl))) < 0) C_GOTO(cgv16);				// loop back if not last alternative
//      here to generate code for last alternative
        //b ||mov|8,wa|21,=osld_||get header call|18566
        wa= (word)(&c.osld_);				// get header call
        //b ||jsr|6,cdwrd|||generate o_sld call|18567
        C_JSR(cdwrd);				// generate o_sld call
        //b ||jsr|6,cmgen|||generate code for last alternative|18568
        C_JSR(cmgen);				// generate code for last alternative
        //b ||ica|7,xs|||pop offset ptr|18569
        xs += CFP_B;				// pop offset ptr
        //b ||mov|7,xr|10,(xs)+||load chain ptr|18570
        xr= C_POP();				// load chain ptr
//      loop to plug offsets past structure
// cgv17:
        //b |cgv17|add|7,xr|3,r_ccb||make next ptr absolute|18574
        C_GOTO(cgv17);
        } /* cgv16 */
        

        void cgv17() {
        xr += v.r_ccb;				// make next ptr absolute
        //b ||mov|8,wa|9,(xr)||load forward ptr|18575
        wa= *(xr_it.wp);				// load forward ptr
        //b ||mov|9,(xr)|3,cwcof||plug required offset|18576
        *(xr_it.wp)= v.cwcof;				// plug required offset
        //b ||mov|7,xr|8,wa||copy forward ptr|18577
        xr= wa;				// copy forward ptr
        //b ||bnz|8,wa|6,cgv17||loop back if more to go|18578
        if (wa) C_GOTO(cgv17);				// loop back if more to go
        //b ||brn|6,cgv33|||else jump to exit (not constant)|18579
         C_GOTO(cgv33);				// else jump to exit (not constant)
//      here for binary ops with value operands
// cgv18:
        //b |cgv18|mov|7,xr|13,cmlop(xl)||load left operand pointer|18583
        } /* cgv17 */
        

        void cgv18() {
        xr= *((word *)(CFP_B*CMLOP + xl));				// load left operand pointer
        //b ||jsr|6,cdgvl|||gen value code for left operand|18584
        C_JSR(cdgvl);				// gen value code for left operand
//      here for unary ops with value operand (binops merge)
// cgv19:
        //b |cgv19|mov|7,xr|13,cmrop(xl)||load right (only) operand ptr|18588
        C_GOTO(cgv19);
        } /* cgv18 */
        

        void cgv19() {
        xr= *((word *)(CFP_B*CMROP + xl));				// load right (only) operand ptr
        //b ||jsr|6,cdgvl|||gen code by value|18589
        C_JSR(cdgvl);				// gen code by value
        //b ||ejc|||||18590
        
//      cdgvl (continued)
//      merge here to generate operator call from cmopn field
// cgv20:
        //b |cgv20|mov|8,wa|13,cmopn(xl)||load operator call pointer|18596
        C_GOTO(cgv20);
        } /* cgv19 */
        

        void cgv20() {
        wa= *((word *)(CFP_B*CMOPN + xl));				// load operator call pointer
        //b ||brn|6,cgv36|||jump to generate it with cons test|18597
         C_GOTO(cgv36);				// jump to generate it with cons test
//      here for assignment
// cgv21:
        //b |cgv21|mov|7,xr|13,cmlop(xl)||load left operand pointer|18601
        } /* cgv20 */
        

        void cgv21() {
        xr= *((word *)(CFP_B*CMLOP + xl));				// load left operand pointer
        //b ||blo|9,(xr)|22,=b_vr_|6,cgv22|jump if not variable|18602
        if ((*(xr_it.wp)-(word)(b_vr_)) < 0) C_GOTO(cgv22);				// jump if not variable
//      here for assignment to simple variable
        //b ||mov|7,xr|13,cmrop(xl)||load right operand ptr|18606
        xr= *((word *)(CFP_B*CMROP + xl));				// load right operand ptr
        //b ||jsr|6,cdgvl|||generate code by value|18607
        C_JSR(cdgvl);				// generate code by value
        //b ||mov|8,wa|13,cmlop(xl)||reload left operand vrblk ptr|18608
        wa= *((word *)(CFP_B*CMLOP + xl));				// reload left operand vrblk ptr
        //b ||add|8,wa|19,*vrsto||point to vrsto field|18609
        wa += CFP_B*VRSTO;				// point to vrsto field
        //b ||brn|6,cgv32|||jump to generate store ptr|18610
         C_GOTO(cgv32);				// jump to generate store ptr
//      here if not simple variable assignment
// cgv22:
        //b |cgv22|jsr|6,expap|||test for pattern match on left side|18614
        } /* cgv21 */
        

        void cgv22() {
        //b ||ppm|6,cgv23|||jump if not pattern match|18615
        C_JSR_1(expap,C_GOTO(cgv23));				// jump if not pattern match
//      here for pattern replacement
        //b ||mov|13,cmlop(xl)|13,cmrop(xr)||save pattern ptr in safe place|18619
        *((word *)(CFP_B*CMLOP + xl))= *((word *)(CFP_B*CMROP + xr));				// save pattern ptr in safe place
        //b ||mov|7,xr|13,cmlop(xr)||load subject ptr|18620
        xr= *((word *)(CFP_B*CMLOP + xr));				// load subject ptr
        //b ||jsr|6,cdgnm|||gen code by name for subject|18621
        C_JSR(cdgnm);				// gen code by name for subject
        //b ||mov|7,xr|13,cmlop(xl)||load pattern ptr|18622
        xr= *((word *)(CFP_B*CMLOP + xl));				// load pattern ptr
        //b ||jsr|6,cdgvl|||gen code by value for pattern|18623
        C_JSR(cdgvl);				// gen code by value for pattern
        //b ||mov|8,wa|21,=opmn_||load match by name call|18624
        wa= (word)(&c.opmn_);				// load match by name call
        //b ||jsr|6,cdwrd|||generate it|18625
        C_JSR(cdwrd);				// generate it
        //b ||mov|7,xr|13,cmrop(xl)||load replacement value ptr|18626
        xr= *((word *)(CFP_B*CMROP + xl));				// load replacement value ptr
        //b ||jsr|6,cdgvl|||gen code by value|18627
        C_JSR(cdgvl);				// gen code by value
        //b ||mov|8,wa|21,=orpl_||load replace call|18628
        wa= (word)(&c.orpl_);				// load replace call
        //b ||brn|6,cgv32|||jump to gen and exit (not constant)|18629
         C_GOTO(cgv32);				// jump to gen and exit (not constant)
//      here for assignment to complex variable
// cgv23:
        //b |cgv23|mnz|8,wc|||inhibit pre-evaluation|18633
        } /* cgv22 */
        

        void cgv23() {
        wc = 0xffffffffffffffff;				// inhibit pre-evaluation
        //b ||jsr|6,cdgnm|||gen code by name for left side|18634
        C_JSR(cdgnm);				// gen code by name for left side
        //b ||brn|6,cgv31|||merge with unop circuit|18635
         C_GOTO(cgv31);				// merge with unop circuit
        //b ||ejc|||||18636
        
//      cdgvl (continued)
//      here for concatenation
// cgv24:
        //b |cgv24|mov|7,xr|13,cmlop(xl)||load left operand ptr|18642
        } /* cgv23 */
        

        void cgv24() {
        xr= *((word *)(CFP_B*CMLOP + xl));				// load left operand ptr
        //b ||bne|9,(xr)|22,=b_cmt|6,cgv18|ordinary binop if not cmblk|18643
        if ((*(xr_it.wp)-(word)(b_cmt)) != 0) C_GOTO(cgv18);				// ordinary binop if not cmblk
        //b ||mov|8,wb|13,cmtyp(xr)||load cmblk type code|18644
        wb= *((word *)(CFP_B*CMTYP + xr));				// load cmblk type code
        //b ||beq|8,wb|18,=c_int|6,cgv25|special case if interrogation|18645
        if ((wb-C_INT) == 0) C_GOTO(cgv25);				// special case if interrogation
        //b ||beq|8,wb|18,=c_neg|6,cgv25|or negation|18646
        if ((wb-C_NEG) == 0) C_GOTO(cgv25);				// or negation
        //b ||bne|8,wb|18,=c_fnc|6,cgv18|else ordinary binop if not function|18647
        if ((wb-C_FNC) != 0) C_GOTO(cgv18);				// else ordinary binop if not function
        //b ||mov|7,xr|13,cmopn(xr)||else load function vrblk ptr|18648
        xr= *((word *)(CFP_B*CMOPN + xr));				// else load function vrblk ptr
        //b ||bnz|13,vrlen(xr)|6,cgv18||ordinary binop if not system var|18649
        if (*((word *)(CFP_B*VRLEN + xr))) C_GOTO(cgv18);				// ordinary binop if not system var
        //b ||mov|7,xr|13,vrsvp(xr)||else point to svblk|18650
        xr= *((word *)(CFP_B*VRSVP + xr));				// else point to svblk
        //b ||mov|8,wa|13,svbit(xr)||load bit indicators|18651
        wa= *((word *)(CFP_B*SVBIT + xr));				// load bit indicators
        //b ||anb|8,wa|4,btprd||test for predicate function|18652
        wa &= c.btprd;				// test for predicate function
        //b ||zrb|8,wa|6,cgv18||ordinary binop if not|18653
        if (!(wa)) C_GOTO(cgv18);				// ordinary binop if not
//      here if left arg of concatenation is predicate function
// cgv25:
        //b |cgv25|mov|7,xr|13,cmlop(xl)||reload left arg|18657
        C_GOTO(cgv25);
        } /* cgv24 */
        

        void cgv25() {
        xr= *((word *)(CFP_B*CMLOP + xl));				// reload left arg
        //b ||jsr|6,cdgvl|||gen code by value|18658
        C_JSR(cdgvl);				// gen code by value
        //b ||mov|8,wa|21,=opop_||load pop call|18659
        wa= (word)(&c.opop_);				// load pop call
        //b ||jsr|6,cdwrd|||generate it|18660
        C_JSR(cdwrd);				// generate it
        //b ||mov|7,xr|13,cmrop(xl)||load right operand|18661
        xr= *((word *)(CFP_B*CMROP + xl));				// load right operand
        //b ||jsr|6,cdgvl|||gen code by value as result code|18662
        C_JSR(cdgvl);				// gen code by value as result code
        //b ||brn|6,cgv33|||exit (not constant)|18663
         C_GOTO(cgv33);				// exit (not constant)
//      here to generate code for pattern, immediate assignment
// cgv26:
        //b |cgv26|mov|7,xr|13,cmlop(xl)||load left operand|18667
        } /* cgv25 */
        

        void cgv26() {
        xr= *((word *)(CFP_B*CMLOP + xl));				// load left operand
        //b ||jsr|6,cdgvl|||gen code by value, merge|18668
        C_JSR(cdgvl);				// gen code by value, merge
//      here for unops with arg by name (binary _ . merge)
// cgv27:
        //b |cgv27|mov|7,xr|13,cmrop(xl)||load right operand ptr|18672
        C_GOTO(cgv27);
        } /* cgv26 */
        

        void cgv27() {
        xr= *((word *)(CFP_B*CMROP + xl));				// load right operand ptr
        //b ||jsr|6,cdgnm|||gen code by name for right arg|18673
        C_JSR(cdgnm);				// gen code by name for right arg
        //b ||mov|7,xr|13,cmopn(xl)||get operator code word|18674
        xr= *((word *)(CFP_B*CMOPN + xl));				// get operator code word
        //b ||bne|9,(xr)|22,=o_kwv|6,cgv20|gen call unless keyword value|18675
        if ((*(xr_it.wp)-(word)(o_kwv)) != 0) C_GOTO(cgv20);				// gen call unless keyword value
        //b ||ejc|||||18676
        
//      cdgvl (continued)
//      here for keyword by value. this is constant only if
//      the operand is one of the special system variables with
//      the svckw bit set to indicate a constant keyword value.
//      note that the only constant operand by name is a variable
        //b ||bnz|8,wc|6,cgv20||gen call if non-constant (not var)|18685
        if (wc) C_GOTO(cgv20);				// gen call if non-constant (not var)
        //b ||mnz|8,wc|||else set non-constant in case|18686
        wc = 0xffffffffffffffff;				// else set non-constant in case
        //b ||mov|7,xr|13,cmrop(xl)||load ptr to operand vrblk|18687
        xr= *((word *)(CFP_B*CMROP + xl));				// load ptr to operand vrblk
        //b ||bnz|13,vrlen(xr)|6,cgv20||gen (non-constant) if not sys var|18688
        if (*((word *)(CFP_B*VRLEN + xr))) C_GOTO(cgv20);				// gen (non-constant) if not sys var
        //b ||mov|7,xr|13,vrsvp(xr)||else load ptr to svblk|18689
        xr= *((word *)(CFP_B*VRSVP + xr));				// else load ptr to svblk
        //b ||mov|8,wa|13,svbit(xr)||load bit mask|18690
        wa= *((word *)(CFP_B*SVBIT + xr));				// load bit mask
        //b ||anb|8,wa|4,btckw||test for constant keyword|18691
        wa &= c.btckw;				// test for constant keyword
        //b ||zrb|8,wa|6,cgv20||go gen if not constant|18692
        if (!(wa)) C_GOTO(cgv20);				// go gen if not constant
        //b ||zer|8,wc|||else set result constant|18693
        wc=0;				// else set result constant
        //b ||brn|6,cgv20|||and jump back to generate call|18694
         C_GOTO(cgv20);				// and jump back to generate call
//      here to generate code for negation
// cgv28:
        //b |cgv28|mov|8,wa|21,=onta_||get initial word|18698
        } /* cgv27 */
        

        void cgv28() {
        wa= (word)(&c.onta_);				// get initial word
        //b ||jsr|6,cdwrd|||generate it|18699
        C_JSR(cdwrd);				// generate it
        //b ||mov|8,wb|3,cwcof||save next offset|18700
        wb= v.cwcof;				// save next offset
        //b ||jsr|6,cdwrd|||generate gunk word for now|18701
        C_JSR(cdwrd);				// generate gunk word for now
        //b ||mov|7,xr|13,cmrop(xl)||load right operand ptr|18702
        xr= *((word *)(CFP_B*CMROP + xl));				// load right operand ptr
        //b ||jsr|6,cdgvl|||gen code by value|18703
        C_JSR(cdgvl);				// gen code by value
        //b ||mov|8,wa|21,=ontb_||load end of evaluation call|18704
        wa= (word)(&c.ontb_);				// load end of evaluation call
        //b ||jsr|6,cdwrd|||generate it|18705
        C_JSR(cdwrd);				// generate it
        //b ||mov|7,xr|8,wb||copy offset to word to plug|18706
        xr= wb;				// copy offset to word to plug
        //b ||add|7,xr|3,r_ccb||point to actual word to plug|18707
        xr += v.r_ccb;				// point to actual word to plug
        //b ||mov|9,(xr)|3,cwcof||plug word with current offset|18708
        *(xr_it.wp)= v.cwcof;				// plug word with current offset
        //b ||mov|8,wa|21,=ontc_||load final call|18709
        wa= (word)(&c.ontc_);				// load final call
        //b ||brn|6,cgv32|||jump to generate it (not constant)|18710
         C_GOTO(cgv32);				// jump to generate it (not constant)
//      here to generate code for undefined binary operator
// cgv29:
        //b |cgv29|mov|7,xr|13,cmlop(xl)||load left operand ptr|18714
        } /* cgv28 */
        

        void cgv29() {
        xr= *((word *)(CFP_B*CMLOP + xl));				// load left operand ptr
        //b ||jsr|6,cdgvl|||generate code by value|18715
        C_JSR(cdgvl);				// generate code by value
        //b ||ejc|||||18716
        
//      cdgvl (continued)
//      here to generate code for undefined unary operator
// cgv30:
        //b |cgv30|mov|8,wb|18,=c_uo_||set unop code + 1|18722
        C_GOTO(cgv30);
        } /* cgv29 */
        

        void cgv30() {
        wb= C_UO_;				// set unop code + 1
        //b ||sub|8,wb|13,cmtyp(xl)||set number of args (1 or 2)|18723
        wb -= *((word *)(CFP_B*CMTYP + xl));				// set number of args (1 or 2)
//      merge here for undefined operators
        //b ||mov|7,xr|13,cmrop(xl)||load right (only) operand pointer|18727
        xr= *((word *)(CFP_B*CMROP + xl));				// load right (only) operand pointer
        //b ||jsr|6,cdgvl|||gen value code for right operand|18728
        C_JSR(cdgvl);				// gen value code for right operand
        //b ||mov|7,xr|13,cmopn(xl)||load pointer to operator dv|18729
        xr= *((word *)(CFP_B*CMOPN + xl));				// load pointer to operator dv
        //b ||mov|7,xr|13,dvopn(xr)||load pointer offset|18730
        xr= *((word *)(CFP_B*DVOPN + xr));				// load pointer offset
        //b ||wtb|7,xr|||convert word offset to bytes|18731
        xr <<= LOG_CFP_B;				// convert word offset to bytes
        //b ||add|7,xr|20,=r_uba||point to proper function ptr|18732
        xr += (word)(&v.r_uba);				// point to proper function ptr
        //b ||sub|7,xr|19,*vrfnc||set standard function offset|18733
        xr -= CFP_B*VRFNC;				// set standard function offset
        //b ||brn|6,cgv12|||merge with function call circuit|18734
         C_GOTO(cgv12);				// merge with function call circuit
//      here to generate code for interrogation, indirection
// cgv31:
        //b |cgv31|mnz|8,wc|||set non constant|18738
        } /* cgv30 */
        

        void cgv31() {
        wc = 0xffffffffffffffff;				// set non constant
        //b ||brn|6,cgv19|||merge|18739
         C_GOTO(cgv19);				// merge
//      here to exit generating a word, result not constant
// cgv32:
        //b |cgv32|jsr|6,cdwrd|||generate word, merge|18743
        } /* cgv31 */
        

        void cgv32() {
        C_JSR(cdwrd);				// generate word, merge
//      here to exit with no word generated, not constant
// cgv33:
        //b |cgv33|mnz|8,wc|||indicate result is not constant|18747
        C_GOTO(cgv33);
        } /* cgv32 */
        

        void cgv33() {
        wc = 0xffffffffffffffff;				// indicate result is not constant
//      common exit point
// cgv34:
        //b |cgv34|ica|7,xs|||pop initial code offset|18751
        C_GOTO(cgv34);
        } /* cgv33 */
        

        void cgv34() {
        xs += CFP_B;				// pop initial code offset
        //b ||mov|8,wa|10,(xs)+||restore old constant flag|18752
        wa= C_POP();				// restore old constant flag
        //b ||mov|7,xl|10,(xs)+||restore entry xl|18753
        xl= C_POP();				// restore entry xl
        //b ||mov|8,wb|10,(xs)+||restore entry wb|18754
        wb= C_POP();				// restore entry wb
        //b ||bnz|8,wc|6,cgv35||jump if not constant|18755
        if (wc) C_GOTO(cgv35);				// jump if not constant
        //b ||mov|8,wc|8,wa||else restore entry constant flag|18756
        wc= wa;				// else restore entry constant flag
//      here to return after dealing with wc setting
// cgv35:
        //b |cgv35|exi||||return to cdgvl caller|18760
        C_GOTO(cgv35);
        } /* cgv34 */
        

        void cgv35() {
        C_EXIT(0);				// return to cdgvl caller
//      exit here to generate word and test for constant
// cgv36:
        //b |cgv36|jsr|6,cdwrd|||generate word|18764
        } /* cgv35 */
        

        void cgv36() {
        C_JSR(cdwrd);				// generate word
        //b ||bnz|8,wc|6,cgv34||jump to exit if not constant|18765
        if (wc) C_GOTO(cgv34);				// jump to exit if not constant
        //b ||ejc|||||18766
        
//      cdgvl (continued)
//      here to preevaluate constant sub-expression
        //b ||mov|8,wa|21,=orvl_||load call to return value|18772
        wa= (word)(&c.orvl_);				// load call to return value
        //b ||jsr|6,cdwrd|||generate it|18773
        C_JSR(cdwrd);				// generate it
        //b ||mov|7,xl|9,(xs)||load initial code offset|18774
        xl= *(xs_it.wp);				// load initial code offset
        //b ||jsr|6,exbld|||build exblk for expression|18775
        C_JSR(exbld);				// build exblk for expression
        //b ||zer|8,wb|||set to evaluate by value|18776
        wb=0;				// set to evaluate by value
        //b ||ppm||||should not fail|18778
        C_JSR_1(evalx,(C_ERR(299)));				// should not fail
        //b ||mov|8,wa|9,(xr)||load type word of result|18779
        wa= *(xr_it.wp);				// load type word of result
        //b ||blo|8,wa|22,=p_aaa|6,cgv37|jump if not pattern|18780
        if ((wa-(word)(p_aaa)) < 0) C_GOTO(cgv37);				// jump if not pattern
        //b ||mov|8,wa|21,=olpt_||else load special pattern load call|18781
        wa= (word)(&c.olpt_);				// else load special pattern load call
        //b ||jsr|6,cdwrd|||generate it|18782
        C_JSR(cdwrd);				// generate it
//      merge here to generate pointer to resulting constant
// cgv37:
        //b |cgv37|mov|8,wa|7,xr||copy constant pointer|18786
        C_GOTO(cgv37);
        } /* cgv36 */
        

        void cgv37() {
        wa= xr;				// copy constant pointer
        //b ||jsr|6,cdwrd|||generate ptr|18787
        C_JSR(cdwrd);				// generate ptr
        //b ||zer|8,wc|||set result constant|18788
        wc=0;				// set result constant
        //b ||brn|6,cgv34|||jump back to exit|18789
         C_GOTO(cgv34);				// jump back to exit
        //b ||ejc|||||18791
        
//      cdwrd -- generate one word of code
//      cdwrd writes one word into the current code block under
//      construction. a new, larger, block is allocated if there
//      is insufficient room in the current block. cdwrd ensures
//      that there are at least four words left in the block
//      after entering the new word. this guarantees that any
//      extra space at the end can be split off as a ccblk.
//      (wa)                  word to be generated
//      jsr  cdwrd            call to generate word
// cdwrd:
        //b |cdwrd|prc|25,e|1,0||entry point|18809
        } /* cgv37 */
        

        void cdwrd() {
        //b ||mov|11,-(xs)|7,xr||save entry xr|18810
        C_PUSH(xr);				// save entry xr
        //b ||mov|11,-(xs)|8,wa||save code word to be generated|18811
        C_PUSH(wa);				// save code word to be generated
//      merge back here after allocating larger block
// cdwd1:
        //b |cdwd1|mov|7,xr|3,r_ccb||load ptr to ccblk being built|18815
        C_GOTO(cdwd1);
        } /* cdwrd */
        

        void cdwd1() {
        xr= v.r_ccb;				// load ptr to ccblk being built
        //b ||bnz|7,xr|6,cdwd2||jump if block allocated|18816
        if (xr) C_GOTO(cdwd2);				// jump if block allocated
//      here we allocate an entirely fresh block
        //b ||mov|8,wa|19,*e_cbs||load initial length|18820
        wa= CFP_B*E_CBS;				// load initial length
        //b ||jsr|6,alloc|||allocate ccblk|18821
        C_JSR(alloc);				// allocate ccblk
        //b ||mov|9,(xr)|22,=b_cct||store type word|18822
        *(xr_it.wp)= (word)(b_cct);				// store type word
        //b ||mov|3,cwcof|19,*cccod||set initial offset|18823
        v.cwcof= CFP_B*CCCOD;				// set initial offset
        //b ||mov|13,cclen(xr)|8,wa||store block length|18824
        *((word *)(CFP_B*CCLEN + xr))= wa;				// store block length
        //b ||zer|13,ccsln(xr)|||zero line number|18826
        *((word *)(CFP_B*CCSLN + xr))=0;				// zero line number
        //b ||mov|3,r_ccb|7,xr||store ptr to new block|18828
        v.r_ccb= xr;				// store ptr to new block
//      here we have a block we can use
// cdwd2:
        //b |cdwd2|mov|8,wa|3,cwcof||load current offset|18832
        C_GOTO(cdwd2);
        } /* cdwd1 */
        

        void cdwd2() {
        wa= v.cwcof;				// load current offset
        //b ||add|8,wa|19,*num05||adjust for test (five words)|18834
        wa += CFP_B*NUM05;				// adjust for test (five words)
        //b ||blo|8,wa|13,cclen(xr)|6,cdwd4|jump if room in this block|18838
        if ((wa-*((word *)(CFP_B*CCLEN + xr))) < 0) C_GOTO(cdwd4);				// jump if room in this block
//      here if no room in current block
        //b ||bge|8,wa|3,mxlen|6,cdwd5|jump if already at max size|18842
        if ((wa-v.mxlen) >= 0) C_GOTO(cdwd5);				// jump if already at max size
        //b ||add|8,wa|19,*e_cbs||else get new size|18843
        wa += CFP_B*E_CBS;				// else get new size
        //b ||mov|11,-(xs)|7,xl||save entry xl|18844
        C_PUSH(xl);				// save entry xl
        //b ||mov|7,xl|7,xr||copy pointer|18845
        xl= xr;				// copy pointer
        //b ||blt|8,wa|3,mxlen|6,cdwd3|jump if not too large|18846
        if ((wa-v.mxlen) < 0) C_GOTO(cdwd3);				// jump if not too large
        //b ||mov|8,wa|3,mxlen||else reset to max allowed size|18847
        wa= v.mxlen;				// else reset to max allowed size
        //b ||ejc|||||18848
        
//      cdwrd (continued)
//      here with new block size in wa
// cdwd3:
        //b |cdwd3|jsr|6,alloc|||allocate new block|18854
        C_GOTO(cdwd3);
        } /* cdwd2 */
        

        void cdwd3() {
        C_JSR(alloc);				// allocate new block
        //b ||mov|3,r_ccb|7,xr||store pointer to new block|18855
        v.r_ccb= xr;				// store pointer to new block
        //b ||mov|10,(xr)+|22,=b_cct||store type word in new block|18856
        *(xr_it.wp++)= (word)(b_cct);				// store type word in new block
        //b ||mov|10,(xr)+|8,wa||store block length|18857
        *(xr_it.wp++)= wa;				// store block length
        //b ||mov|10,(xr)+|13,ccsln(xl)||copy source line number word|18859
        *(xr_it.wp++)= *((word *)(CFP_B*CCSLN + xl));				// copy source line number word
        //b ||add|7,xl|19,*ccuse||point to ccuse,cccod fields in old|18861
        xl += CFP_B*CCUSE;				// point to ccuse,cccod fields in old
        //b ||mov|8,wa|9,(xl)||load ccuse value|18862
        wa= *(xl_it.wp);				// load ccuse value
        //b ||mvw||||copy useful words from old block|18863
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// copy useful words from old block
        //b ||mov|7,xl|10,(xs)+||restore xl|18864
        xl= C_POP();				// restore xl
        //b ||brn|6,cdwd1|||merge back to try again|18865
         C_GOTO(cdwd1);				// merge back to try again
//      here with room in current block
// cdwd4:
        //b |cdwd4|mov|8,wa|3,cwcof||load current offset|18869
        } /* cdwd3 */
        

        void cdwd4() {
        wa= v.cwcof;				// load current offset
        //b ||ica|8,wa|||get new offset|18870
        wa += CFP_B;				// get new offset
        //b ||mov|3,cwcof|8,wa||store new offset|18871
        v.cwcof= wa;				// store new offset
        //b ||mov|13,ccuse(xr)|8,wa||store in ccblk for gbcol|18872
        *((word *)(CFP_B*CCUSE + xr))= wa;				// store in ccblk for gbcol
        //b ||dca|8,wa|||restore ptr to this word|18873
        wa -= CFP_B;				// restore ptr to this word
        //b ||add|7,xr|8,wa||point to current entry|18874
        xr += wa;				// point to current entry
        //b ||mov|8,wa|10,(xs)+||reload word to generate|18875
        wa= C_POP();				// reload word to generate
        //b ||mov|9,(xr)|8,wa||store word in block|18876
        *(xr_it.wp)= wa;				// store word in block
        //b ||mov|7,xr|10,(xs)+||restore entry xr|18877
        xr= C_POP();				// restore entry xr
        //b ||exi||||return to caller|18878
        C_EXIT(0);				// return to caller
//      here if compiled code is too long for cdblk
// cdwd5:
        //b |cdwd5|erb|1,213|26,syntax error: statement is too complicated.|||18882
        } /* cdwd4 */
        

        void cdwd5() {
        C_ERB(213)
        //b ||ejc|||||18884
        
//      cmgen -- generate code for cmblk ptr
//      cmgen is a subsidiary procedure used to generate value
//      code for a cmblk ptr from the main code generators.
//      (xl)                  cmblk pointer
//      (wb)                  offset to pointer in cmblk
//      jsr  cmgen            call to generate code
//      (xr,wa)               destroyed
//      (wb)                  bumped by one word
// cmgen:
        //b |cmgen|prc|25,r|1,0||entry point, recursive|18897
        } /* cdwd5 */
        

        void cmgen() {
        //b ||mov|7,xr|7,xl||copy cmblk pointer|18898
        xr= xl;				// copy cmblk pointer
        //b ||add|7,xr|8,wb||point to cmblk pointer|18899
        xr += wb;				// point to cmblk pointer
        //b ||mov|7,xr|9,(xr)||load cmblk pointer|18900
        xr= *(xr_it.wp);				// load cmblk pointer
        //b ||jsr|6,cdgvl|||generate code by value|18901
        C_JSR(cdgvl);				// generate code by value
        //b ||ica|8,wb|||bump offset|18902
        wb += CFP_B;				// bump offset
        //b ||exi||||return to caller|18903
        C_EXIT(0);				// return to caller
        //b ||ejc|||||18905
        
//      cmpil (compile source code)
//      cmpil is used to convert snobol4 source code to internal
//      form (see cdblk format). it is used both for the initial
//      compile and at run time by the code and convert functions
//      this procedure has control for the entire duration of
//      initial compilation. an error in any procedure called
//      during compilation will lead first to the error section
//      and ultimately back here for resumed compilation. the
//      re-entry points after an error are specially labelled -
//      cmpce                 resume after control card error
//      cmple                 resume after label error
//      cmpse                 resume after statement error
//      jsr  cmpil            call to compile code
//      (xr)                  ptr to cdblk for entry statement
//      (xl,wa,wb,wc,ra)      destroyed
//      the following global variables are referenced
//      cmpln                 line number of first line of
//                            statement to be compiled
//      cmpsn                 number of next statement
//                            to be compiled.
//      cswxx                 control card switch values are
//                            changed when relevant control
//                            cards are met.
//      cwcof                 offset to next word in code block
//                            being built (see cdwrd).
//      lstsn                 number of statement most recently
//                            compiled (initially set to zero).
//      r_cim                 current (initial) compiler image
//                            (zero for initial compile call)
//      r_cni                 used to point to following image.
//                            (see readr procedure).
//      scngo                 goto switch for scane procedure
//      scnil                 length of current image excluding
//                            characters removed by -input.
//      scnpt                 current scan offset, see scane.
//      scnrs                 rescan switch for scane procedure.
//      scnse                 offset (in r_cim) of most recently
//                            scanned element. set zero if not
//                            currently scanning items
        //b ||ejc|||||18962
        
//      cmpil (continued)
//      stage               stgic  initial compile in progress
//                          stgxc  code/convert compile
//                          stgev  building exblk for eval
//                          stgxt  execute time (outside compile)
//                          stgce  initial compile after end line
//                          stgxe  execute compile after end line
//      cmpil also uses a fixed number of locations on the
//      main stack as follows. (the definitions of the actual
//      offsets are in the definitions section).
//      cmstm(xs)             pointer to expan tree for body of
//                            statement (see expan procedure).
//      cmsgo(xs)             pointer to tree representation of
//                            success goto (see procedure scngo)
//                            zero if no success goto is given
//      cmfgo(xs)             like cmsgo for failure goto.
//      cmcgo(xs)             set non-zero only if there is a
//                            conditional goto. used for -fail,
//                            -nofail code generation.
//      cmpcd(xs)             pointer to cdblk for previous
//                            statement. zero for 1st statement.
//      cmffp(xs)             set non-zero if cdfal in previous
//                            cdblk needs filling with forward
//                            pointer, else set to zero.
//      cmffc(xs)             same as cmffp for current cdblk
//      cmsop(xs)             offset to word in previous cdblk
//                            to be filled in with forward ptr
//                            to next cdblk for success goto.
//                            zero if no fill in is required.
//      cmsoc(xs)             same as cmsop for current cdblk.
//      cmlbl(xs)             pointer to vrblk for label of
//                            current statement. zero if no label
//      cmtra(xs)             pointer to cdblk for entry stmnt.
        //b ||ejc|||||19010
        
//      cmpil (continued)
//      entry point
// cmpil:
        //b |cmpil|prc|25,e|1,0||entry point|19016
        } /* cmgen */
        

        void cmpil() {
        //b ||lct|8,wb|18,=cmnen||set number of stack work locations|19017
        wb= CMNEN;				// set number of stack work locations
//      loop to initialize stack working locations
// cmp00:
        //b |cmp00|zer|11,-(xs)|||store a zero, make one entry|19021
        C_GOTO(cmp00);
        } /* cmpil */
        

        void cmp00() {
        *(--xs_it.wp)=0;				// store a zero, make one entry
        //b ||bct|8,wb|6,cmp00||loop back until all set|19022
        if ((--wb))  C_GOTO(cmp00);				// loop back until all set
        //b ||mov|3,cmpxs|7,xs||save stack pointer for error sec|19023
        v.cmpxs= xs;				// save stack pointer for error sec
//      loop through statements
// cmp01:
        //b |cmp01|mov|8,wb|3,scnpt||set scan pointer offset|19028
        C_GOTO(cmp01);
        } /* cmp00 */
        

        void cmp01() {
        wb= v.scnpt;				// set scan pointer offset
        //b ||mov|3,scnse|8,wb||set start of element location|19029
        v.scnse= wb;				// set start of element location
        //b ||mov|8,wa|21,=ocer_||point to compile error call|19030
        wa= (word)(&c.ocer_);				// point to compile error call
        //b ||jsr|6,cdwrd|||generate as temporary cdfal|19031
        C_JSR(cdwrd);				// generate as temporary cdfal
        //b ||blt|8,wb|3,scnil|6,cmp04|jump if chars left on this image|19032
        if ((wb-v.scnil) < 0) C_GOTO(cmp04);				// jump if chars left on this image
//      loop here after comment or control card
//      also special entry after control card error
// cmpce:
        //b |cmpce|zer|7,xr|||clear possible garbage xr value|19037
        C_GOTO(cmpce);
        } /* cmp01 */
        

        void cmpce() {
        xr=0;				// clear possible garbage xr value
        //b ||bnz|3,cnind|6,cmpc2||if within include file|19039
        if (v.cnind) C_GOTO(cmpc2);				// if within include file
        //b ||bne|3,stage|18,=stgic|6,cmp02|skip unless initial compile|19041
        if ((v.stage-STGIC) != 0) C_GOTO(cmp02);				// skip unless initial compile
// cmpc2:
        //b |cmpc2|jsr|6,readr|||read next input image|19042
        C_GOTO(cmpc2);
        } /* cmpce */
        

        void cmpc2() {
        C_JSR(readr);				// read next input image
        //b ||bze|7,xr|6,cmp09||jump if no input available|19043
        if ( !( xr) ) C_GOTO(cmp09);				// jump if no input available
        //b ||jsr|6,nexts|||acquire next source image|19044
        C_JSR(nexts);				// acquire next source image
        //b ||mov|3,lstsn|3,cmpsn||store stmt no for use by listr|19045
        v.lstsn= v.cmpsn;				// store stmt no for use by listr
        //b ||mov|3,cmpln|3,rdcln||store line number at start of stmt|19046
        v.cmpln= v.rdcln;				// store line number at start of stmt
        //b ||zer|3,scnpt|||reset scan pointer|19047
        v.scnpt=0;				// reset scan pointer
        //b ||brn|6,cmp04|||go process image|19048
         C_GOTO(cmp04);				// go process image
//      for execute time compile, permit embedded control cards
//      and comments (by skipping to next semi-colon)
// cmp02:
        //b |cmp02|mov|7,xr|3,r_cim||get current image|19053
        } /* cmpc2 */
        

        void cmp02() {
        xr= v.r_cim;				// get current image
        //b ||mov|8,wb|3,scnpt||get current offset|19054
        wb= v.scnpt;				// get current offset
        //b ||plc|7,xr|8,wb||prepare to get chars|19055
        xr_it.chp += CFP_F + wb;				// prepare to get chars
//      skip to semi-colon
// cmp03:
        //b |cmp03|bge|3,scnpt|3,scnil|6,cmp09|end loop if end of image|19059
        C_GOTO(cmp03);
        } /* cmp02 */
        

        void cmp03() {
        if ((v.scnpt-v.scnil) >= 0) C_GOTO(cmp09);				// end loop if end of image
        //b ||lch|8,wc|10,(xr)+||get char|19060
        wc = *(xr_it.chp++);				// get char
        //b ||icv|3,scnpt|||advance offset|19061
        (v.scnpt)++;				// advance offset
        //b ||bne|8,wc|18,=ch_sm|6,cmp03|loop if not semi-colon|19062
        if ((wc-CH_SM) != 0) C_GOTO(cmp03);				// loop if not semi-colon
        //b ||ejc|||||19063
        
//      cmpil (continued)
//      here with image available to scan. note that if the input
//      string is null, then everything is ok since null is
//      actually assembled as a word of blanks.
// cmp04:
        //b |cmp04|mov|7,xr|3,r_cim||point to current image|19071
        C_GOTO(cmp04);
        } /* cmp03 */
        

        void cmp04() {
        xr= v.r_cim;				// point to current image
        //b ||mov|8,wb|3,scnpt||load current offset|19072
        wb= v.scnpt;				// load current offset
        //b ||mov|8,wa|8,wb||copy for label scan|19073
        wa= wb;				// copy for label scan
        //b ||plc|7,xr|8,wb||point to first character|19074
        xr_it.chp += CFP_F + wb;				// point to first character
        //b ||lch|8,wc|10,(xr)+||load first character|19075
        wc = *(xr_it.chp++);				// load first character
        //b ||beq|8,wc|18,=ch_sm|6,cmp12|no label if semicolon|19076
        if ((wc-CH_SM) == 0) C_GOTO(cmp12);				// no label if semicolon
        //b ||beq|8,wc|18,=ch_as|6,cmpce|loop back if comment card|19077
        if ((wc-CH_AS) == 0) C_GOTO(cmpce);				// loop back if comment card
        //b ||beq|8,wc|18,=ch_mn|6,cmp32|jump if control card|19078
        if ((wc-CH_MN) == 0) C_GOTO(cmp32);				// jump if control card
        //b ||mov|3,r_cmp|3,r_cim||about to destroy r_cim|19079
        v.r_cmp= v.r_cim;				// about to destroy r_cim
        //b ||mov|7,xl|20,=cmlab||point to label work string|19080
        xl= (word)(&v.cmlab);				// point to label work string
        //b ||mov|3,r_cim|7,xl||scane is to scan work string|19081
        v.r_cim= xl;				// scane is to scan work string
        //b ||psc|7,xl|||point to first character position|19082
        xl += CFP_F;				// point to first character position
        //b ||sch|8,wc|10,(xl)+||store char just loaded|19083
        *(xl_it.chp++) = wc;				// store char just loaded
        //b ||mov|8,wc|18,=ch_sm||get a semicolon|19084
        wc= CH_SM;				// get a semicolon
        //b ||sch|8,wc|9,(xl)||store after first char|19085
        *(xl_it.chp) = wc;				// store after first char
        //b ||csc|7,xl|||finished character storing|19086
        //b ||zer|7,xl|||clear pointer|19087
        xl=0;				// clear pointer
        //b ||zer|3,scnpt|||start at first character|19088
        v.scnpt=0;				// start at first character
        //b ||mov|11,-(xs)|3,scnil||preserve image length|19089
        C_PUSH(v.scnil);				// preserve image length
        //b ||mov|3,scnil|18,=num02||read 2 chars at most|19090
        v.scnil= NUM02;				// read 2 chars at most
        //b ||jsr|6,scane|||scan first char for type|19091
        C_JSR(scane);				// scan first char for type
        //b ||mov|3,scnil|10,(xs)+||restore image length|19092
        v.scnil= C_POP();				// restore image length
        //b ||mov|8,wc|7,xl||note return code|19093
        wc= xl;				// note return code
        //b ||mov|7,xl|3,r_cmp||get old r_cim|19094
        xl= v.r_cmp;				// get old r_cim
        //b ||mov|3,r_cim|7,xl||put it back|19095
        v.r_cim= xl;				// put it back
        //b ||mov|3,scnpt|8,wb||reinstate offset|19096
        v.scnpt= wb;				// reinstate offset
        //b ||bnz|3,scnbl|6,cmp12||blank seen - cant be label|19097
        if (v.scnbl) C_GOTO(cmp12);				// blank seen - cant be label
        //b ||mov|7,xr|7,xl||point to current image|19098
        xr= xl;				// point to current image
        //b ||plc|7,xr|8,wb||point to first char again|19099
        xr_it.chp += CFP_F + wb;				// point to first char again
        //b ||beq|8,wc|18,=t_var|6,cmp06|ok if letter|19100
        if ((wc-T_VAR) == 0) C_GOTO(cmp06);				// ok if letter
        //b ||beq|8,wc|18,=t_con|6,cmp06|ok if digit|19101
        if ((wc-T_CON) == 0) C_GOTO(cmp06);				// ok if digit
//      drop in or jump from error section if scane failed
// cmple:
        //b |cmple|mov|3,r_cim|3,r_cmp||point to bad line|19105
        C_GOTO(cmple);
        } /* cmp04 */
        

        void cmple() {
        v.r_cim= v.r_cmp;				// point to bad line
        //b ||erb|1,214|26,bad label or misplaced continuation line|||19106
        C_ERB(214)
//      loop to scan label
// cmp05:
        //b |cmp05|beq|8,wc|18,=ch_sm|6,cmp07|skip if semicolon|19110
        } /* cmple */
        

        void cmp05() {
        if ((wc-CH_SM) == 0) C_GOTO(cmp07);				// skip if semicolon
        //b ||icv|8,wa|||bump offset|19111
        (wa)++;				// bump offset
        //b ||beq|8,wa|3,scnil|6,cmp07|jump if end of image (label end)|19112
        if ((wa-v.scnil) == 0) C_GOTO(cmp07);				// jump if end of image (label end)
        //b ||ejc|||||19113
        
//      cmpil (continued)
//      enter loop at this point
// cmp06:
        //b |cmp06|lch|8,wc|10,(xr)+||else load next character|19119
        C_GOTO(cmp06);
        } /* cmp05 */
        

        void cmp06() {
        wc = *(xr_it.chp++);				// else load next character
        //b ||beq|8,wc|18,=ch_ht|6,cmp07|jump if horizontal tab|19121
        if ((wc-CH_HT) == 0) C_GOTO(cmp07);				// jump if horizontal tab
        //b ||bne|8,wc|18,=ch_bl|6,cmp05|loop back if non-blank|19126
        if ((wc-CH_BL) != 0) C_GOTO(cmp05);				// loop back if non-blank
//      here after scanning out label
// cmp07:
        //b |cmp07|mov|3,scnpt|8,wa||save updated scan offset|19130
        C_GOTO(cmp07);
        } /* cmp06 */
        

        void cmp07() {
        v.scnpt= wa;				// save updated scan offset
        //b ||sub|8,wa|8,wb||get length of label|19131
        wa -= wb;				// get length of label
        //b ||bze|8,wa|6,cmp12||skip if label length zero|19132
        if ( !( wa) ) C_GOTO(cmp12);				// skip if label length zero
        //b ||zer|7,xr|||clear garbage xr value|19133
        xr=0;				// clear garbage xr value
        //b ||jsr|6,sbstr|||build scblk for label name|19134
        C_JSR(sbstr);				// build scblk for label name
        //b ||ppm||||dummy (impossible) error return|19136
        C_JSR_1(gtnvr,(C_ERR(299)));				// dummy (impossible) error return
        //b ||mov|13,cmlbl(xs)|7,xr||store label pointer|19137
        *((word *)(CFP_B*CMLBL + xs))= xr;				// store label pointer
        //b ||bnz|13,vrlen(xr)|6,cmp11||jump if not system label|19138
        if (*((word *)(CFP_B*VRLEN + xr))) C_GOTO(cmp11);				// jump if not system label
        //b ||bne|13,vrsvp(xr)|21,=v_end|6,cmp11|jump if not end label|19139
        if ((*((word *)(CFP_B*VRSVP + xr))-(word)(&c.v_end)) != 0) C_GOTO(cmp11);				// jump if not end label
//      here for end label scanned out
        //b ||add|3,stage|18,=stgnd||adjust stage appropriately|19143
        v.stage += STGND;				// adjust stage appropriately
        //b ||jsr|6,scane|||scan out next element|19144
        C_JSR(scane);				// scan out next element
        //b ||beq|7,xl|18,=t_smc|6,cmp10|jump if end of image|19145
        if ((xl-T_SMC) == 0) C_GOTO(cmp10);				// jump if end of image
        //b ||bne|7,xl|18,=t_var|6,cmp08|else error if not variable|19146
        if ((xl-T_VAR) != 0) C_GOTO(cmp08);				// else error if not variable
//      here check for valid initial transfer
        //b ||beq|13,vrlbl(xr)|21,=stndl|6,cmp08|jump if not defined (error)|19150
        if ((*((word *)(CFP_B*VRLBL + xr))-(word)(&c.stndl)) == 0) C_GOTO(cmp08);				// jump if not defined (error)
        //b ||mov|13,cmtra(xs)|13,vrlbl(xr)||else set initial entry pointer|19151
        *((word *)(CFP_B*CMTRA + xs))= *((word *)(CFP_B*VRLBL + xr));				// else set initial entry pointer
        //b ||jsr|6,scane|||scan next element|19152
        C_JSR(scane);				// scan next element
        //b ||beq|7,xl|18,=t_smc|6,cmp10|jump if ok (end of image)|19153
        if ((xl-T_SMC) == 0) C_GOTO(cmp10);				// jump if ok (end of image)
//      here for bad transfer label
// cmp08:
        //b |cmp08|erb|1,215|26,syntax error: undefined or erroneous entry label|||19157
        C_GOTO(cmp08);
        } /* cmp07 */
        

        void cmp08() {
        C_ERB(215)
//      here for end of input (no end label detected)
// cmp09:
        //b |cmp09|zer|7,xr|||clear garbage xr value|19161
        } /* cmp08 */
        

        void cmp09() {
        xr=0;				// clear garbage xr value
        //b ||add|3,stage|18,=stgnd||adjust stage appropriately|19162
        v.stage += STGND;				// adjust stage appropriately
        //b ||beq|3,stage|18,=stgxe|6,cmp10|jump if code call (ok)|19163
        if ((v.stage-STGXE) == 0) C_GOTO(cmp10);				// jump if code call (ok)
        //b ||erb|1,216|26,syntax error: missing end line|||19164
        C_ERB(216)
//      here after processing end line (merge here on end error)
// cmp10:
        //b |cmp10|mov|8,wa|21,=ostp_||set stop call pointer|19168
        } /* cmp09 */
        

        void cmp10() {
        wa= (word)(&c.ostp_);				// set stop call pointer
        //b ||jsr|6,cdwrd|||generate as statement call|19169
        C_JSR(cdwrd);				// generate as statement call
        //b ||brn|6,cmpse|||jump to generate as failure|19170
         C_GOTO(cmpse);				// jump to generate as failure
        //b ||ejc|||||19171
        
//      cmpil (continued)
//      here after processing label other than end
// cmp11:
        //b |cmp11|bne|3,stage|18,=stgic|6,cmp12|jump if code call - redef. ok|19177
        } /* cmp10 */
        

        void cmp11() {
        if ((v.stage-STGIC) != 0) C_GOTO(cmp12);				// jump if code call - redef. ok
        //b ||beq|13,vrlbl(xr)|21,=stndl|6,cmp12|else check for redefinition|19178
        if ((*((word *)(CFP_B*VRLBL + xr))-(word)(&c.stndl)) == 0) C_GOTO(cmp12);				// else check for redefinition
        //b ||zer|13,cmlbl(xs)|||leave first label decln undisturbed|19179
        *((word *)(CFP_B*CMLBL + xs))=0;				// leave first label decln undisturbed
        //b ||erb|1,217|26,syntax error: duplicate label|||19180
        C_ERB(217)
//      here after dealing with label
//      null statements and statements just containing a
//      constant subject are optimized out by resetting the
//      current ccblk to empty.
// cmp12:
        //b |cmp12|zer|8,wb|||set flag for statement body|19187
        } /* cmp11 */
        

        void cmp12() {
        wb=0;				// set flag for statement body
        //b ||jsr|6,expan|||get tree for statement body|19188
        C_JSR(expan);				// get tree for statement body
        //b ||mov|13,cmstm(xs)|7,xr||store for later use|19189
        *((word *)(CFP_B*CMSTM + xs))= xr;				// store for later use
        //b ||zer|13,cmsgo(xs)|||clear success goto pointer|19190
        *((word *)(CFP_B*CMSGO + xs))=0;				// clear success goto pointer
        //b ||zer|13,cmfgo(xs)|||clear failure goto pointer|19191
        *((word *)(CFP_B*CMFGO + xs))=0;				// clear failure goto pointer
        //b ||zer|13,cmcgo(xs)|||clear conditional goto flag|19192
        *((word *)(CFP_B*CMCGO + xs))=0;				// clear conditional goto flag
        //b ||jsr|6,scane|||scan next element|19193
        C_JSR(scane);				// scan next element
        //b ||beq|7,xl|18,=t_col|6,cmp13|jump if colon (goto)|19194
        if ((xl-T_COL) == 0) C_GOTO(cmp13);				// jump if colon (goto)
        //b ||bnz|3,cswno|6,cmp18||jump if not optimizing|19195
        if (v.cswno) C_GOTO(cmp18);				// jump if not optimizing
        //b ||bnz|13,cmlbl(xs)|6,cmp18||jump if label present|19196
        if (*((word *)(CFP_B*CMLBL + xs))) C_GOTO(cmp18);				// jump if label present
        //b ||mov|7,xr|13,cmstm(xs)||load tree ptr for statement body|19197
        xr= *((word *)(CFP_B*CMSTM + xs));				// load tree ptr for statement body
        //b ||mov|8,wa|9,(xr)||load type word|19198
        wa= *(xr_it.wp);				// load type word
        //b ||beq|8,wa|22,=b_cmt|6,cmp18|jump if cmblk|19199
        if ((wa-(word)(b_cmt)) == 0) C_GOTO(cmp18);				// jump if cmblk
        //b ||bge|8,wa|22,=b_vra|6,cmp18|jump if not icblk, scblk, or rcblk|19200
        if ((wa-(word)(b_vra)) >= 0) C_GOTO(cmp18);				// jump if not icblk, scblk, or rcblk
        //b ||mov|7,xl|3,r_ccb||load ptr to ccblk|19201
        xl= v.r_ccb;				// load ptr to ccblk
        //b ||mov|13,ccuse(xl)|19,*cccod||reset use offset in ccblk|19202
        *((word *)(CFP_B*CCUSE + xl))= CFP_B*CCCOD;				// reset use offset in ccblk
        //b ||mov|3,cwcof|19,*cccod||and in global|19203
        v.cwcof= CFP_B*CCCOD;				// and in global
        //b ||icv|3,cmpsn|||bump statement number|19204
        (v.cmpsn)++;				// bump statement number
        //b ||brn|6,cmp01|||generate no code for statement|19205
         C_GOTO(cmp01);				// generate no code for statement
//      loop to process goto fields
// cmp13:
        //b |cmp13|mnz|3,scngo|||set goto flag|19209
        } /* cmp12 */
        

        void cmp13() {
        v.scngo = 0xffffffffffffffff;				// set goto flag
        //b ||jsr|6,scane|||scan next element|19210
        C_JSR(scane);				// scan next element
        //b ||beq|7,xl|18,=t_smc|6,cmp31|jump if no fields left|19211
        if ((xl-T_SMC) == 0) C_GOTO(cmp31);				// jump if no fields left
        //b ||beq|7,xl|18,=t_sgo|6,cmp14|jump if s for success goto|19212
        if ((xl-T_SGO) == 0) C_GOTO(cmp14);				// jump if s for success goto
        //b ||beq|7,xl|18,=t_fgo|6,cmp16|jump if f for failure goto|19213
        if ((xl-T_FGO) == 0) C_GOTO(cmp16);				// jump if f for failure goto
//      here for unconditional goto (i.e. not f or s)
        //b ||mnz|3,scnrs|||set to rescan element not f,s|19217
        v.scnrs = 0xffffffffffffffff;				// set to rescan element not f,s
        //b ||jsr|6,scngf|||scan out goto field|19218
        C_JSR(scngf);				// scan out goto field
        //b ||bnz|13,cmfgo(xs)|6,cmp17||error if fgoto already|19219
        if (*((word *)(CFP_B*CMFGO + xs))) C_GOTO(cmp17);				// error if fgoto already
        //b ||mov|13,cmfgo(xs)|7,xr||else set as fgoto|19220
        *((word *)(CFP_B*CMFGO + xs))= xr;				// else set as fgoto
        //b ||brn|6,cmp15|||merge with sgoto circuit|19221
         C_GOTO(cmp15);				// merge with sgoto circuit
//      here for success goto
// cmp14:
        //b |cmp14|jsr|6,scngf|||scan success goto field|19225
        } /* cmp13 */
        

        void cmp14() {
        C_JSR(scngf);				// scan success goto field
        //b ||mov|13,cmcgo(xs)|18,=num01||set conditional goto flag|19226
        *((word *)(CFP_B*CMCGO + xs))= NUM01;				// set conditional goto flag
//      uncontional goto merges here
// cmp15:
        //b |cmp15|bnz|13,cmsgo(xs)|6,cmp17||error if sgoto already given|19230
        C_GOTO(cmp15);
        } /* cmp14 */
        

        void cmp15() {
        if (*((word *)(CFP_B*CMSGO + xs))) C_GOTO(cmp17);				// error if sgoto already given
        //b ||mov|13,cmsgo(xs)|7,xr||else set sgoto|19231
        *((word *)(CFP_B*CMSGO + xs))= xr;				// else set sgoto
        //b ||brn|6,cmp13|||loop back for next goto field|19232
         C_GOTO(cmp13);				// loop back for next goto field
//      here for failure goto
// cmp16:
        //b |cmp16|jsr|6,scngf|||scan goto field|19236
        } /* cmp15 */
        

        void cmp16() {
        C_JSR(scngf);				// scan goto field
        //b ||mov|13,cmcgo(xs)|18,=num01||set conditonal goto flag|19237
        *((word *)(CFP_B*CMCGO + xs))= NUM01;				// set conditonal goto flag
        //b ||bnz|13,cmfgo(xs)|6,cmp17||error if fgoto already given|19238
        if (*((word *)(CFP_B*CMFGO + xs))) C_GOTO(cmp17);				// error if fgoto already given
        //b ||mov|13,cmfgo(xs)|7,xr||else store fgoto pointer|19239
        *((word *)(CFP_B*CMFGO + xs))= xr;				// else store fgoto pointer
        //b ||brn|6,cmp13|||loop back for next field|19240
         C_GOTO(cmp13);				// loop back for next field
        //b ||ejc|||||19241
        
//      cmpil (continued)
//      here for duplicated goto field
// cmp17:
        //b |cmp17|erb|1,218|26,syntax error: duplicated goto field|||19247
        } /* cmp16 */
        

        void cmp17() {
        C_ERB(218)
//      here to generate code
// cmp18:
        //b |cmp18|zer|3,scnse|||stop positional error flags|19251
        } /* cmp17 */
        

        void cmp18() {
        v.scnse=0;				// stop positional error flags
        //b ||mov|7,xr|13,cmstm(xs)||load tree ptr for statement body|19252
        xr= *((word *)(CFP_B*CMSTM + xs));				// load tree ptr for statement body
        //b ||zer|8,wb|||collectable value for wb for cdgvl|19253
        wb=0;				// collectable value for wb for cdgvl
        //b ||zer|8,wc|||reset constant flag for cdgvl|19254
        wc=0;				// reset constant flag for cdgvl
        //b ||ppm|6,cmp19|||jump if not pattern match|19256
        C_JSR_1(expap,C_GOTO(cmp19));				// jump if not pattern match
        //b ||mov|13,cmopn(xr)|21,=opms_||else set pattern match pointer|19257
        *((word *)(CFP_B*CMOPN + xr))= (word)(&c.opms_);				// else set pattern match pointer
        //b ||mov|13,cmtyp(xr)|18,=c_pmt|||19258
        *((word *)(CFP_B*CMTYP + xr))= C_PMT;
//      here after dealing with special pattern match case
// cmp19:
        //b |cmp19|jsr|6,cdgvl|||generate code for body of statement|19262
        C_GOTO(cmp19);
        } /* cmp18 */
        

        void cmp19() {
        C_JSR(cdgvl);				// generate code for body of statement
        //b ||mov|7,xr|13,cmsgo(xs)||load sgoto pointer|19263
        xr= *((word *)(CFP_B*CMSGO + xs));				// load sgoto pointer
        //b ||mov|8,wa|7,xr||copy it|19264
        wa= xr;				// copy it
        //b ||bze|7,xr|6,cmp21||jump if no success goto|19265
        if ( !( xr) ) C_GOTO(cmp21);				// jump if no success goto
        //b ||zer|13,cmsoc(xs)|||clear success offset fillin ptr|19266
        *((word *)(CFP_B*CMSOC + xs))=0;				// clear success offset fillin ptr
        //b ||bhi|7,xr|3,state|6,cmp20|jump if complex goto|19267
        if ((xr-v.state) > 0) C_GOTO(cmp20);				// jump if complex goto
//      here for simple success goto (label)
        //b ||add|8,wa|19,*vrtra||point to vrtra field as required|19271
        wa += CFP_B*VRTRA;				// point to vrtra field as required
        //b ||jsr|6,cdwrd|||generate success goto|19272
        C_JSR(cdwrd);				// generate success goto
        //b ||brn|6,cmp22|||jump to deal with fgoto|19273
         C_GOTO(cmp22);				// jump to deal with fgoto
//      here for complex success goto
// cmp20:
        //b |cmp20|beq|7,xr|13,cmfgo(xs)|6,cmp22|no code if same as fgoto|19277
        } /* cmp19 */
        

        void cmp20() {
        if ((xr-*((word *)(CFP_B*CMFGO + xs))) == 0) C_GOTO(cmp22);				// no code if same as fgoto
        //b ||zer|8,wb|||else set ok value for cdgvl in wb|19278
        wb=0;				// else set ok value for cdgvl in wb
        //b ||jsr|6,cdgcg|||generate code for success goto|19279
        C_JSR(cdgcg);				// generate code for success goto
        //b ||brn|6,cmp22|||jump to deal with fgoto|19280
         C_GOTO(cmp22);				// jump to deal with fgoto
//      here for no success goto
// cmp21:
        //b |cmp21|mov|13,cmsoc(xs)|3,cwcof||set success fill in offset|19284
        } /* cmp20 */
        

        void cmp21() {
        *((word *)(CFP_B*CMSOC + xs))= v.cwcof;				// set success fill in offset
        //b ||mov|8,wa|21,=ocer_||point to compile error call|19285
        wa= (word)(&c.ocer_);				// point to compile error call
        //b ||jsr|6,cdwrd|||generate as temporary value|19286
        C_JSR(cdwrd);				// generate as temporary value
        //b ||ejc|||||19287
        
//      cmpil (continued)
//      here to deal with failure goto
// cmp22:
        //b |cmp22|mov|7,xr|13,cmfgo(xs)||load failure goto pointer|19293
        C_GOTO(cmp22);
        } /* cmp21 */
        

        void cmp22() {
        xr= *((word *)(CFP_B*CMFGO + xs));				// load failure goto pointer
        //b ||mov|8,wa|7,xr||copy it|19294
        wa= xr;				// copy it
        //b ||zer|13,cmffc(xs)|||set no fill in required yet|19295
        *((word *)(CFP_B*CMFFC + xs))=0;				// set no fill in required yet
        //b ||bze|7,xr|6,cmp23||jump if no failure goto given|19296
        if ( !( xr) ) C_GOTO(cmp23);				// jump if no failure goto given
        //b ||add|8,wa|19,*vrtra||point to vrtra field in case|19297
        wa += CFP_B*VRTRA;				// point to vrtra field in case
        //b ||blo|7,xr|3,state|6,cmpse|jump to gen if simple fgoto|19298
        if ((xr-v.state) < 0) C_GOTO(cmpse);				// jump to gen if simple fgoto
//      here for complex failure goto
        //b ||mov|8,wb|3,cwcof||save offset to o_gof call|19302
        wb= v.cwcof;				// save offset to o_gof call
        //b ||mov|8,wa|21,=ogof_||point to failure goto call|19303
        wa= (word)(&c.ogof_);				// point to failure goto call
        //b ||jsr|6,cdwrd|||generate|19304
        C_JSR(cdwrd);				// generate
        //b ||mov|8,wa|21,=ofif_||point to fail in fail word|19305
        wa= (word)(&c.ofif_);				// point to fail in fail word
        //b ||jsr|6,cdwrd|||generate|19306
        C_JSR(cdwrd);				// generate
        //b ||jsr|6,cdgcg|||generate code for failure goto|19307
        C_JSR(cdgcg);				// generate code for failure goto
        //b ||mov|8,wa|8,wb||copy offset to o_gof for cdfal|19308
        wa= wb;				// copy offset to o_gof for cdfal
        //b ||mov|8,wb|22,=b_cdc||set complex case cdtyp|19309
        wb= (word)(b_cdc);				// set complex case cdtyp
        //b ||brn|6,cmp25|||jump to build cdblk|19310
         C_GOTO(cmp25);				// jump to build cdblk
//      here if no failure goto given
// cmp23:
        //b |cmp23|mov|8,wa|21,=ounf_||load unexpected failure call in cas|19314
        } /* cmp22 */
        

        void cmp23() {
        wa= (word)(&c.ounf_);				// load unexpected failure call in cas
        //b ||mov|8,wc|3,cswfl||get -nofail flag|19315
        wc= v.cswfl;				// get -nofail flag
        //b ||orb|8,wc|13,cmcgo(xs)||check if conditional goto|19316
        wc |= *((word *)(CFP_B*CMCGO + xs));				// check if conditional goto
        //b ||zrb|8,wc|6,cmpse||jump if -nofail and no cond. goto|19317
        if (!(wc)) C_GOTO(cmpse);				// jump if -nofail and no cond. goto
        //b ||mnz|13,cmffc(xs)|||else set fill in flag|19318
        *((word *)(CFP_B*CMFFC + xs)) = 0xffffffffffffffff;				// else set fill in flag
        //b ||mov|8,wa|21,=ocer_||and set compile error for temporary|19319
        wa= (word)(&c.ocer_);				// and set compile error for temporary
//      merge here with cdfal value in wa, simple cdblk
//      also special entry after statement error
// cmpse:
        //b |cmpse|mov|8,wb|22,=b_cds||set cdtyp for simple case|19324
        C_GOTO(cmpse);
        } /* cmp23 */
        

        void cmpse() {
        wb= (word)(b_cds);				// set cdtyp for simple case
        //b ||ejc|||||19325
        
//      cmpil (continued)
//      merge here to build cdblk
//      (wa)                  cdfal value to be generated
//      (wb)                  cdtyp value to be generated
//      at this stage, we chop off an appropriate chunk of the
//      current ccblk and convert it into a cdblk. the remainder
//      of the ccblk is reformatted to be the new ccblk.
// cmp25:
        //b |cmp25|mov|7,xr|3,r_ccb||point to ccblk|19338
        C_GOTO(cmp25);
        } /* cmpse */
        

        void cmp25() {
        xr= v.r_ccb;				// point to ccblk
        //b ||mov|7,xl|13,cmlbl(xs)||get possible label pointer|19339
        xl= *((word *)(CFP_B*CMLBL + xs));				// get possible label pointer
        //b ||bze|7,xl|6,cmp26||skip if no label|19340
        if ( !( xl) ) C_GOTO(cmp26);				// skip if no label
        //b ||zer|13,cmlbl(xs)|||clear flag for next statement|19341
        *((word *)(CFP_B*CMLBL + xs))=0;				// clear flag for next statement
        //b ||mov|13,vrlbl(xl)|7,xr||put cdblk ptr in vrblk label field|19342
        *((word *)(CFP_B*VRLBL + xl))= xr;				// put cdblk ptr in vrblk label field
//      merge after doing label
// cmp26:
        //b |cmp26|mov|9,(xr)|8,wb||set type word for new cdblk|19346
        C_GOTO(cmp26);
        } /* cmp25 */
        

        void cmp26() {
        *(xr_it.wp)= wb;				// set type word for new cdblk
        //b ||mov|13,cdfal(xr)|8,wa||set failure word|19347
        *((word *)(CFP_B*CDFAL + xr))= wa;				// set failure word
        //b ||mov|7,xl|7,xr||copy pointer to ccblk|19348
        xl= xr;				// copy pointer to ccblk
        //b ||mov|8,wb|13,ccuse(xr)||load length gen (= new cdlen)|19349
        wb= *((word *)(CFP_B*CCUSE + xr));				// load length gen (= new cdlen)
        //b ||mov|8,wc|13,cclen(xr)||load total ccblk length|19350
        wc= *((word *)(CFP_B*CCLEN + xr));				// load total ccblk length
        //b ||add|7,xl|8,wb||point past cdblk|19351
        xl += wb;				// point past cdblk
        //b ||sub|8,wc|8,wb||get length left for chop off|19352
        wc -= wb;				// get length left for chop off
        //b ||mov|9,(xl)|22,=b_cct||set type code for new ccblk at end|19353
        *(xl_it.wp)= (word)(b_cct);				// set type code for new ccblk at end
        //b ||mov|13,ccuse(xl)|19,*cccod||set initial code offset|19354
        *((word *)(CFP_B*CCUSE + xl))= CFP_B*CCCOD;				// set initial code offset
        //b ||mov|3,cwcof|19,*cccod||reinitialise cwcof|19355
        v.cwcof= CFP_B*CCCOD;				// reinitialise cwcof
        //b ||mov|13,cclen(xl)|8,wc||set new length|19356
        *((word *)(CFP_B*CCLEN + xl))= wc;				// set new length
        //b ||mov|3,r_ccb|7,xl||set new ccblk pointer|19357
        v.r_ccb= xl;				// set new ccblk pointer
        //b ||zer|13,ccsln(xl)|||initialize new line number|19359
        *((word *)(CFP_B*CCSLN + xl))=0;				// initialize new line number
        //b ||mov|13,cdsln(xr)|3,cmpln||set line number in old block|19360
        *((word *)(CFP_B*CDSLN + xr))= v.cmpln;				// set line number in old block
        //b ||mov|13,cdstm(xr)|3,cmpsn||set statement number|19362
        *((word *)(CFP_B*CDSTM + xr))= v.cmpsn;				// set statement number
        //b ||icv|3,cmpsn|||bump statement number|19363
        (v.cmpsn)++;				// bump statement number
//      set pointers in previous code block as required
        //b ||mov|7,xl|13,cmpcd(xs)||load ptr to previous cdblk|19367
        xl= *((word *)(CFP_B*CMPCD + xs));				// load ptr to previous cdblk
        //b ||bze|13,cmffp(xs)|6,cmp27||jump if no failure fill in required|19368
        if ( !( *((word *)(CFP_B*CMFFP + xs))) ) C_GOTO(cmp27);				// jump if no failure fill in required
        //b ||mov|13,cdfal(xl)|7,xr||else set failure ptr in previous|19369
        *((word *)(CFP_B*CDFAL + xl))= xr;				// else set failure ptr in previous
//      here to deal with success forward pointer
// cmp27:
        //b |cmp27|mov|8,wa|13,cmsop(xs)||load success offset|19373
        C_GOTO(cmp27);
        } /* cmp26 */
        

        void cmp27() {
        wa= *((word *)(CFP_B*CMSOP + xs));				// load success offset
        //b ||bze|8,wa|6,cmp28||jump if no fill in required|19374
        if ( !( wa) ) C_GOTO(cmp28);				// jump if no fill in required
        //b ||add|7,xl|8,wa||else point to fill in location|19375
        xl += wa;				// else point to fill in location
        //b ||mov|9,(xl)|7,xr||store forward pointer|19376
        *(xl_it.wp)= xr;				// store forward pointer
        //b ||zer|7,xl|||clear garbage xl value|19377
        xl=0;				// clear garbage xl value
        //b ||ejc|||||19378
        
//      cmpil (continued)
//      now set fill in pointers for this statement
// cmp28:
        //b |cmp28|mov|13,cmffp(xs)|13,cmffc(xs)||copy failure fill in flag|19384
        C_GOTO(cmp28);
        } /* cmp27 */
        

        void cmp28() {
        *((word *)(CFP_B*CMFFP + xs))= *((word *)(CFP_B*CMFFC + xs));				// copy failure fill in flag
        //b ||mov|13,cmsop(xs)|13,cmsoc(xs)||copy success fill in offset|19385
        *((word *)(CFP_B*CMSOP + xs))= *((word *)(CFP_B*CMSOC + xs));				// copy success fill in offset
        //b ||mov|13,cmpcd(xs)|7,xr||save ptr to this cdblk|19386
        *((word *)(CFP_B*CMPCD + xs))= xr;				// save ptr to this cdblk
        //b ||bnz|13,cmtra(xs)|6,cmp29||jump if initial entry already set|19387
        if (*((word *)(CFP_B*CMTRA + xs))) C_GOTO(cmp29);				// jump if initial entry already set
        //b ||mov|13,cmtra(xs)|7,xr||else set ptr here as default|19388
        *((word *)(CFP_B*CMTRA + xs))= xr;				// else set ptr here as default
//      here after compiling one statement
// cmp29:
        //b |cmp29|blt|3,stage|18,=stgce|6,cmp01|jump if not end line just done|19392
        C_GOTO(cmp29);
        } /* cmp28 */
        

        void cmp29() {
        if ((v.stage-STGCE) < 0) C_GOTO(cmp01);				// jump if not end line just done
        //b ||bze|3,cswls|6,cmp30||skip if -nolist|19393
        if ( !( v.cswls) ) C_GOTO(cmp30);				// skip if -nolist
        //b ||jsr|6,listr|||list last line|19394
        C_JSR(listr);				// list last line
//      return
// cmp30:
        //b |cmp30|mov|7,xr|13,cmtra(xs)||load initial entry cdblk pointer|19398
        C_GOTO(cmp30);
        } /* cmp29 */
        

        void cmp30() {
        xr= *((word *)(CFP_B*CMTRA + xs));				// load initial entry cdblk pointer
        //b ||add|7,xs|19,*cmnen||pop work locations off stack|19399
        xs += CFP_B*CMNEN;				// pop work locations off stack
        //b ||exi||||and return to cmpil caller|19400
        C_EXIT(0);				// and return to cmpil caller
//      here at end of goto field
// cmp31:
        //b |cmp31|mov|8,wb|13,cmfgo(xs)||get fail goto|19404
        } /* cmp30 */
        

        void cmp31() {
        wb= *((word *)(CFP_B*CMFGO + xs));				// get fail goto
        //b ||orb|8,wb|13,cmsgo(xs)||or in success goto|19405
        wb |= *((word *)(CFP_B*CMSGO + xs));				// or in success goto
        //b ||bnz|8,wb|6,cmp18||ok if non-null field|19406
        if (wb) C_GOTO(cmp18);				// ok if non-null field
        //b ||erb|1,219|26,syntax error: empty goto field|||19407
        C_ERB(219)
//      control card found
// cmp32:
        //b |cmp32|icv|8,wb|||point past ch_mn|19411
        } /* cmp31 */
        

        void cmp32() {
        (wb)++;				// point past ch_mn
        //b ||jsr|6,cncrd|||process control card|19412
        C_JSR(cncrd);				// process control card
        //b ||zer|3,scnse|||clear start of element loc.|19413
        v.scnse=0;				// clear start of element loc.
        //b ||brn|6,cmpce|||loop for next statement|19414
         C_GOTO(cmpce);				// loop for next statement
        //b ||ejc|||||19416
        
//      cncrd -- control card processor
//      called to deal with control cards
//      r_cim                 points to current image
//      (wb)                  offset to 1st char of control card
//      jsr  cncrd            call to process control cards
//      (xl,xr,wa,wb,wc,ia)   destroyed
// cncrd:
        //b |cncrd|prc|25,e|1,0||entry point|19427
        } /* cmp32 */
        

        void cncrd() {
        //b ||mov|3,scnpt|8,wb||offset for control card scan|19428
        v.scnpt= wb;				// offset for control card scan
        //b ||mov|8,wa|18,=ccnoc||number of chars for comparison|19429
        wa= CCNOC;				// number of chars for comparison
        //b ||ctw|8,wa|1,0||convert to word count|19430
        wa = (wa+(CFP_C-1)+CFP_C* 0) >> LOG_CFP_C;				// convert to word count
        //b ||mov|3,cnswc|8,wa||save word count|19431
        v.cnswc= wa;				// save word count
//      loop here if more than one control card
// cnc01:
        //b |cnc01|bge|3,scnpt|3,scnil|6,cnc09|return if end of image|19435
        C_GOTO(cnc01);
        } /* cncrd */
        

        void cnc01() {
        if ((v.scnpt-v.scnil) >= 0) C_GOTO(cnc09);				// return if end of image
        //b ||mov|7,xr|3,r_cim||point to image|19436
        xr= v.r_cim;				// point to image
        //b ||plc|7,xr|3,scnpt||char ptr for first char|19437
        xr_it.chp += CFP_F + v.scnpt;				// char ptr for first char
        //b ||lch|8,wa|10,(xr)+||get first char|19438
        wa = *(xr_it.chp++);				// get first char
        //b ||beq|8,wa|18,=ch_li|6,cnc07|special case of -inxxx|19442
        if ((wa-CH_LI) == 0) C_GOTO(cnc07);				// special case of -inxxx
// cnc0a:
        //b |cnc0a|mnz|3,scncc|||set flag for scane|19443
        C_GOTO(cnc0a);
        } /* cnc01 */
        

        void cnc0a() {
        v.scncc = 0xffffffffffffffff;				// set flag for scane
        //b ||jsr|6,scane|||scan card name|19444
        C_JSR(scane);				// scan card name
        //b ||zer|3,scncc|||clear scane flag|19445
        v.scncc=0;				// clear scane flag
        //b ||bnz|7,xl|6,cnc06||fail unless control card name|19446
        if (xl) C_GOTO(cnc06);				// fail unless control card name
        //b ||mov|8,wa|18,=ccnoc||no. of chars to be compared|19447
        wa= CCNOC;				// no. of chars to be compared
        //b ||blt|13,sclen(xr)|8,wa|6,cnc08|fail if too few chars|19449
        if ((*((word *)(CFP_B*SCLEN + xr))-wa) < 0) C_GOTO(cnc08);				// fail if too few chars
        //b ||mov|7,xl|7,xr||point to control card name|19453
        xl= xr;				// point to control card name
        //b ||zer|8,wb|||zero offset for substring|19454
        wb=0;				// zero offset for substring
        //b ||jsr|6,sbstr|||extract substring for comparison|19455
        C_JSR(sbstr);				// extract substring for comparison
        //b ||mov|3,cnscc|7,xr||keep control card substring ptr|19460
        v.cnscc= xr;				// keep control card substring ptr
        //b ||mov|7,xr|21,=ccnms||point to list of standard names|19461
        xr= (word)(&c.ccnms);				// point to list of standard names
        //b ||zer|8,wb|||initialise name offset|19462
        wb=0;				// initialise name offset
        //b ||lct|8,wc|18,=cc_nc||number of standard names|19463
        wc= CC_NC;				// number of standard names
//      try to match name
// cnc02:
        //b |cnc02|mov|7,xl|3,cnscc||point to name|19467
        C_GOTO(cnc02);
        } /* cnc0a */
        

        void cnc02() {
        xl= v.cnscc;				// point to name
        //b ||lct|8,wa|3,cnswc||counter for inner loop|19468
        wa= v.cnswc;				// counter for inner loop
        //b ||brn|6,cnc04|||jump into loop|19469
         C_GOTO(cnc04);				// jump into loop
//      inner loop to match card name chars
// cnc03:
        //b |cnc03|ica|7,xr|||bump standard names ptr|19473
        } /* cnc02 */
        

        void cnc03() {
        xr += CFP_B;				// bump standard names ptr
        //b ||ica|7,xl|||bump name pointer|19474
        xl += CFP_B;				// bump name pointer
//      here to initiate the loop
// cnc04:
        //b |cnc04|cne|13,schar(xl)|9,(xr)|6,cnc05|comp. up to cfp_c chars at once|19478
        C_GOTO(cnc04);
        } /* cnc03 */
        

        void cnc04() {
        if ((*((word *)(CFP_B*SCHAR + xl)) - *(xr_it.wp))!= 0) C_GOTO(cnc05);				// comp. up to cfp_c chars at once
        //b ||bct|8,wa|6,cnc03||loop if more words to compare|19479
        if ((--wa))  C_GOTO(cnc03);				// loop if more words to compare
        //b ||ejc|||||19480
        
//      cncrd (continued)
//      matched - branch on card offset
        //b ||mov|7,xl|8,wb||get name offset|19486
        xl= wb;				// get name offset
        //b ||bsw|7,xl|2,cc_nc|6,cnc08|switch|19488
        if (xl - (word)(CC_NC) >=0 )  { C_GOTO(cnc08);}				// switch
        extern word _l0560 [];
        { w0 = ((word *)_l0560)[xl];  C_GOTO(w0_it.callp);}
        }  /* cnc04 */
        

        word  _l0560 [] = {
        //b ||iff|2,cc_do|6,cnc10||-double|19527
        	(word)((word)(cnc10)),				// -double
        //b ||iff|1,1|6,cnc08|||19527
        	(word)((word)(cnc08)),
        //b ||iff|2,cc_du|6,cnc11||-dump|19527
        	(word)((word)(cnc11)),				// -dump
        //b ||iff|2,cc_cp|6,cnc41||-copy|19527
        	(word)((word)(cnc41)),				// -copy
        //b ||iff|2,cc_ej|6,cnc12||-eject|19527
        	(word)((word)(cnc12)),				// -eject
        //b ||iff|2,cc_er|6,cnc13||-errors|19527
        	(word)((word)(cnc13)),				// -errors
        //b ||iff|2,cc_ex|6,cnc14||-execute|19527
        	(word)((word)(cnc14)),				// -execute
        //b ||iff|2,cc_fa|6,cnc15||-fail|19527
        	(word)((word)(cnc15)),				// -fail
        //b ||iff|2,cc_in|6,cnc41||-include|19527
        	(word)((word)(cnc41)),				// -include
        //b ||iff|2,cc_ln|6,cnc44||-line|19527
        	(word)((word)(cnc44)),				// -line
        //b ||iff|2,cc_li|6,cnc16||-list|19527
        	(word)((word)(cnc16)),				// -list
        //b ||iff|2,cc_nr|6,cnc17||-noerrors|19527
        	(word)((word)(cnc17)),				// -noerrors
        //b ||iff|2,cc_nx|6,cnc18||-noexecute|19527
        	(word)((word)(cnc18)),				// -noexecute
        //b ||iff|2,cc_nf|6,cnc19||-nofail|19527
        	(word)((word)(cnc19)),				// -nofail
        //b ||iff|2,cc_nl|6,cnc20||-nolist|19527
        	(word)((word)(cnc20)),				// -nolist
        //b ||iff|2,cc_no|6,cnc21||-noopt|19527
        	(word)((word)(cnc21)),				// -noopt
        //b ||iff|2,cc_np|6,cnc22||-noprint|19527
        	(word)((word)(cnc22)),				// -noprint
        //b ||iff|2,cc_op|6,cnc24||-optimise|19527
        	(word)((word)(cnc24)),				// -optimise
        //b ||iff|2,cc_pr|6,cnc25||-print|19527
        	(word)((word)(cnc25)),				// -print
        //b ||iff|2,cc_si|6,cnc27||-single|19527
        	(word)((word)(cnc27)),				// -single
        //b ||iff|2,cc_sp|6,cnc28||-space|19527
        	(word)((word)(cnc28)),				// -space
        //b ||iff|2,cc_st|6,cnc31||-stitle|19527
        	(word)((word)(cnc31)),				// -stitle
        //b ||iff|2,cc_ti|6,cnc32||-title|19527
        	(word)((word)(cnc32)),				// -title
        //b ||iff|2,cc_tr|6,cnc36||-trace|19527
        	(word)((word)(cnc36)),				// -trace
        //b ||esw||||end switch|19527
             }; /* bsw list for _l0560 */				// end switch
//      not matched yet. align std names ptr and try again
// cnc05:
        //b |cnc05|ica|7,xr|||bump standard names ptr|19531
        void cnc05() {
        xr += CFP_B;				// bump standard names ptr
        //b ||bct|8,wa|6,cnc05||loop|19532
        if ((--wa))  C_GOTO(cnc05);				// loop
        //b ||icv|8,wb|||bump names offset|19533
        (wb)++;				// bump names offset
        //b ||bct|8,wc|6,cnc02||continue if more names|19534
        if ((--wc))  C_GOTO(cnc02);				// continue if more names
        //b ||brn|6,cnc08|||ignore unrecognized control card|19536
         C_GOTO(cnc08);				// ignore unrecognized control card
//      invalid control card name
// cnc06:
        //b |cnc06|erb|1,247|26,invalid control statement|||19541
        } /* cnc05 */
        

        void cnc06() {
        C_ERB(247)
//      special processing for -inxxx
// cnc07:
        //b |cnc07|lch|8,wa|10,(xr)+||get next char|19545
        } /* cnc06 */
        

        void cnc07() {
        wa = *(xr_it.chp++);				// get next char
        //b ||bne|8,wa|18,=ch_ln|6,cnc0a|if not letter n|19549
        if ((wa-CH_LN) != 0) C_GOTO(cnc0a);				// if not letter n
        //b ||lch|8,wa|9,(xr)||get third char|19550
        wa = *(xr_it.chp);				// get third char
        //b ||blt|8,wa|18,=ch_d0|6,cnc0a|if not digit|19551
        if ((wa-CH_D0) < 0) C_GOTO(cnc0a);				// if not digit
        //b ||bgt|8,wa|18,=ch_d9|6,cnc0a|if not digit|19552
        if ((wa-CH_D9) > 0) C_GOTO(cnc0a);				// if not digit
        //b ||add|3,scnpt|18,=num02||bump offset past -in|19553
        v.scnpt += NUM02;				// bump offset past -in
        //b ||jsr|6,scane|||scan integer after -in|19554
        C_JSR(scane);				// scan integer after -in
        //b ||mov|11,-(xs)|7,xr||stack scanned item|19555
        C_PUSH(xr);				// stack scanned item
        //b ||ppm|6,cnc06|||fail if negative or large|19558
        extern void _l0562();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0562);
        } /* cnc07 */
        

        void _l0562() {
        C_JMS_HANDLE_2(gtsmi,C_GOTO(cnc06),C_GOTO(cnc06));				// fail if negative or large
        //b ||mov|3,cswin|7,xr||keep integer|19559
        v.cswin= xr;				// keep integer
        //b ||ejc|||||19560
        
//      cncrd (continued)
//      check for more control cards before returning
// cnc08:
        //b |cnc08|mov|8,wa|3,scnpt||preserve in case xeq time compile|19566
        C_GOTO(cnc08);
        } /* _l0562 */
        

        void cnc08() {
        wa= v.scnpt;				// preserve in case xeq time compile
        //b ||jsr|6,scane|||look for comma|19567
        C_JSR(scane);				// look for comma
        //b ||beq|7,xl|18,=t_cma|6,cnc01|loop if comma found|19568
        if ((xl-T_CMA) == 0) C_GOTO(cnc01);				// loop if comma found
        //b ||mov|3,scnpt|8,wa||restore scnpt in case xeq time|19569
        v.scnpt= wa;				// restore scnpt in case xeq time
//      return point
// cnc09:
        //b |cnc09|exi||||return|19573
        C_GOTO(cnc09);
        } /* cnc08 */
        

        void cnc09() {
        C_EXIT(0);				// return
//      -double
// cnc10:
        //b |cnc10|mnz|3,cswdb|||set switch|19577
        } /* cnc09 */
        

        void cnc10() {
        v.cswdb = 0xffffffffffffffff;				// set switch
        //b ||brn|6,cnc08|||merge|19578
         C_GOTO(cnc08);				// merge
//      -dump
//      this is used for system debugging . it has the effect of
//      producing a core dump at compilation time
// cnc11:
        //b |cnc11|jsr|6,sysdm|||call dumper|19584
        } /* cnc10 */
        

        void cnc11() {
        C_JSR(sysdm);				// call dumper
        //b ||brn|6,cnc09|||finished|19585
         C_GOTO(cnc09);				// finished
//      -eject
// cnc12:
        //b |cnc12|bze|3,cswls|6,cnc09||return if -nolist|19589
        } /* cnc11 */
        

        void cnc12() {
        if ( !( v.cswls) ) C_GOTO(cnc09);				// return if -nolist
        //b ||jsr|6,prtps|||eject|19590
        C_JSR(prtps);				// eject
        //b ||jsr|6,listt|||list title|19591
        C_JSR(listt);				// list title
        //b ||brn|6,cnc09|||finished|19592
         C_GOTO(cnc09);				// finished
//      -errors
// cnc13:
        //b |cnc13|zer|3,cswer|||clear switch|19596
        } /* cnc12 */
        

        void cnc13() {
        v.cswer=0;				// clear switch
        //b ||brn|6,cnc08|||merge|19597
         C_GOTO(cnc08);				// merge
//      -execute
// cnc14:
        //b |cnc14|zer|3,cswex|||clear switch|19601
        } /* cnc13 */
        

        void cnc14() {
        v.cswex=0;				// clear switch
        //b ||brn|6,cnc08|||merge|19602
         C_GOTO(cnc08);				// merge
//      -fail
// cnc15:
        //b |cnc15|mnz|3,cswfl|||set switch|19606
        } /* cnc14 */
        

        void cnc15() {
        v.cswfl = 0xffffffffffffffff;				// set switch
        //b ||brn|6,cnc08|||merge|19607
         C_GOTO(cnc08);				// merge
//      -list
// cnc16:
        //b |cnc16|mnz|3,cswls|||set switch|19611
        } /* cnc15 */
        

        void cnc16() {
        v.cswls = 0xffffffffffffffff;				// set switch
        //b ||beq|3,stage|18,=stgic|6,cnc08|done if compile time|19612
        if ((v.stage-STGIC) == 0) C_GOTO(cnc08);				// done if compile time
//      list code line if execute time compile
        //b ||zer|3,lstpf|||permit listing|19616
        v.lstpf=0;				// permit listing
        //b ||jsr|6,listr|||list line|19617
        C_JSR(listr);				// list line
        //b ||brn|6,cnc08|||merge|19618
         C_GOTO(cnc08);				// merge
        //b ||ejc|||||19619
        
//      cncrd (continued)
//      -noerrors
// cnc17:
        //b |cnc17|mnz|3,cswer|||set switch|19625
        } /* cnc16 */
        

        void cnc17() {
        v.cswer = 0xffffffffffffffff;				// set switch
        //b ||brn|6,cnc08|||merge|19626
         C_GOTO(cnc08);				// merge
//      -noexecute
// cnc18:
        //b |cnc18|mnz|3,cswex|||set switch|19630
        } /* cnc17 */
        

        void cnc18() {
        v.cswex = 0xffffffffffffffff;				// set switch
        //b ||brn|6,cnc08|||merge|19631
         C_GOTO(cnc08);				// merge
//      -nofail
// cnc19:
        //b |cnc19|zer|3,cswfl|||clear switch|19635
        } /* cnc18 */
        

        void cnc19() {
        v.cswfl=0;				// clear switch
        //b ||brn|6,cnc08|||merge|19636
         C_GOTO(cnc08);				// merge
//      -nolist
// cnc20:
        //b |cnc20|zer|3,cswls|||clear switch|19640
        } /* cnc19 */
        

        void cnc20() {
        v.cswls=0;				// clear switch
        //b ||brn|6,cnc08|||merge|19641
         C_GOTO(cnc08);				// merge
//      -nooptimise
// cnc21:
        //b |cnc21|mnz|3,cswno|||set switch|19645
        } /* cnc20 */
        

        void cnc21() {
        v.cswno = 0xffffffffffffffff;				// set switch
        //b ||brn|6,cnc08|||merge|19646
         C_GOTO(cnc08);				// merge
//      -noprint
// cnc22:
        //b |cnc22|zer|3,cswpr|||clear switch|19650
        } /* cnc21 */
        

        void cnc22() {
        v.cswpr=0;				// clear switch
        //b ||brn|6,cnc08|||merge|19651
         C_GOTO(cnc08);				// merge
//      -optimise
// cnc24:
        //b |cnc24|zer|3,cswno|||clear switch|19655
        } /* cnc22 */
        

        void cnc24() {
        v.cswno=0;				// clear switch
        //b ||brn|6,cnc08|||merge|19656
         C_GOTO(cnc08);				// merge
//      -print
// cnc25:
        //b |cnc25|mnz|3,cswpr|||set switch|19660
        } /* cnc24 */
        

        void cnc25() {
        v.cswpr = 0xffffffffffffffff;				// set switch
        //b ||brn|6,cnc08|||merge|19661
         C_GOTO(cnc08);				// merge
        //b ||ejc|||||19662
        
//      cncrd (continued)
//      -single
// cnc27:
        //b |cnc27|zer|3,cswdb|||clear switch|19668
        } /* cnc25 */
        

        void cnc27() {
        v.cswdb=0;				// clear switch
        //b ||brn|6,cnc08|||merge|19669
         C_GOTO(cnc08);				// merge
//      -space
// cnc28:
        //b |cnc28|bze|3,cswls|6,cnc09||return if -nolist|19673
        } /* cnc27 */
        

        void cnc28() {
        if ( !( v.cswls) ) C_GOTO(cnc09);				// return if -nolist
        //b ||jsr|6,scane|||scan integer after -space|19674
        C_JSR(scane);				// scan integer after -space
        //b ||mov|8,wc|18,=num01||1 space in case|19675
        wc= NUM01;				// 1 space in case
        //b ||beq|7,xr|18,=t_smc|6,cnc29|jump if no integer|19676
        if ((xr-T_SMC) == 0) C_GOTO(cnc29);				// jump if no integer
        //b ||mov|11,-(xs)|7,xr||stack it|19677
        C_PUSH(xr);				// stack it
        //b ||ppm|6,cnc06|||fail if negative or large|19680
        extern void _l0563();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0563);
        } /* cnc28 */
        

        void _l0563() {
        C_JMS_HANDLE_2(gtsmi,C_GOTO(cnc06),C_GOTO(cnc06));				// fail if negative or large
        //b ||bnz|8,wc|6,cnc29||jump if non zero|19681
        if (wc) C_GOTO(cnc29);				// jump if non zero
        //b ||mov|8,wc|18,=num01||else 1 space|19682
        wc= NUM01;				// else 1 space
//      merge with count of lines to skip
// cnc29:
        //b |cnc29|add|3,lstlc|8,wc||bump line count|19686
        C_GOTO(cnc29);
        } /* _l0563 */
        

        void cnc29() {
        v.lstlc += wc;				// bump line count
        //b ||lct|8,wc|8,wc||convert to loop counter|19687
        wc= wc;				// convert to loop counter
        //b ||blt|3,lstlc|3,lstnp|6,cnc30|jump if fits on page|19688
        if ((v.lstlc-v.lstnp) < 0) C_GOTO(cnc30);				// jump if fits on page
        //b ||jsr|6,prtps|||eject|19689
        C_JSR(prtps);				// eject
        //b ||jsr|6,listt|||list title|19690
        C_JSR(listt);				// list title
        //b ||brn|6,cnc09|||merge|19691
         C_GOTO(cnc09);				// merge
//      skip lines
// cnc30:
        //b |cnc30|jsr|6,prtnl|||print a blank|19695
        } /* cnc29 */
        

        void cnc30() {
        C_JSR(prtnl);				// print a blank
        //b ||bct|8,wc|6,cnc30||loop|19696
        if ((--wc))  C_GOTO(cnc30);				// loop
        //b ||brn|6,cnc09|||merge|19697
         C_GOTO(cnc09);				// merge
        //b ||ejc|||||19698
        
//      cncrd (continued)
//      -stitl
// cnc31:
        //b |cnc31|mov|3,cnr_t|20,=r_stl||ptr to r_stl|19704
        } /* cnc30 */
        

        void cnc31() {
        v.cnr_t= (word)(&v.r_stl);				// ptr to r_stl
        //b ||brn|6,cnc33|||merge|19705
         C_GOTO(cnc33);				// merge
//      -title
// cnc32:
        //b |cnc32|mov|3,r_stl|21,=nulls||clear subtitle|19709
        } /* cnc31 */
        

        void cnc32() {
        v.r_stl= (word)(&c.nulls);				// clear subtitle
        //b ||mov|3,cnr_t|20,=r_ttl||ptr to r_ttl|19710
        v.cnr_t= (word)(&v.r_ttl);				// ptr to r_ttl
//      common processing for -title, -stitl
// cnc33:
        //b |cnc33|mov|7,xr|21,=nulls||null in case needed|19714
        C_GOTO(cnc33);
        } /* cnc32 */
        

        void cnc33() {
        xr= (word)(&c.nulls);				// null in case needed
        //b ||mnz|3,cnttl|||set flag for next listr call|19715
        v.cnttl = 0xffffffffffffffff;				// set flag for next listr call
        //b ||mov|8,wb|18,=ccofs||offset to title/subtitle|19716
        wb= CCOFS;				// offset to title/subtitle
        //b ||mov|8,wa|3,scnil||input image length|19717
        wa= v.scnil;				// input image length
        //b ||blo|8,wa|8,wb|6,cnc34|jump if no chars left|19718
        if ((wa-wb) < 0) C_GOTO(cnc34);				// jump if no chars left
        //b ||sub|8,wa|8,wb||no of chars to extract|19719
        wa -= wb;				// no of chars to extract
        //b ||mov|7,xl|3,r_cim||point to image|19720
        xl= v.r_cim;				// point to image
        //b ||jsr|6,sbstr|||get title/subtitle|19721
        C_JSR(sbstr);				// get title/subtitle
//      store title/subtitle
// cnc34:
        //b |cnc34|mov|7,xl|3,cnr_t||point to storage location|19725
        C_GOTO(cnc34);
        } /* cnc33 */
        

        void cnc34() {
        xl= v.cnr_t;				// point to storage location
        //b ||mov|9,(xl)|7,xr||store title/subtitle|19726
        *(xl_it.wp)= xr;				// store title/subtitle
        //b ||beq|7,xl|20,=r_stl|6,cnc09|return if stitl|19727
        if ((xl-(word)(&v.r_stl)) == 0) C_GOTO(cnc09);				// return if stitl
        //b ||bnz|3,precl|6,cnc09||return if extended listing|19728
        if (v.precl) C_GOTO(cnc09);				// return if extended listing
        //b ||bze|3,prich|6,cnc09||return if regular printer|19729
        if ( !( v.prich) ) C_GOTO(cnc09);				// return if regular printer
        //b ||mov|7,xl|13,sclen(xr)||get length of title|19730
        xl= *((word *)(CFP_B*SCLEN + xr));				// get length of title
        //b ||mov|8,wa|7,xl||copy it|19731
        wa= xl;				// copy it
        //b ||bze|7,xl|6,cnc35||jump if null|19732
        if ( !( xl) ) C_GOTO(cnc35);				// jump if null
        //b ||add|7,xl|18,=num10||increment|19733
        xl += NUM10;				// increment
        //b ||bhi|7,xl|3,prlen|6,cnc09|use default lstp0 val if too long|19734
        if ((xl-v.prlen) > 0) C_GOTO(cnc09);				// use default lstp0 val if too long
        //b ||add|8,wa|18,=num04||point just past title|19735
        wa += NUM04;				// point just past title
//      store offset to page nn message for short title
// cnc35:
        //b |cnc35|mov|3,lstpo|8,wa||store offset|19739
        C_GOTO(cnc35);
        } /* cnc34 */
        

        void cnc35() {
        v.lstpo= wa;				// store offset
        //b ||brn|6,cnc09|||return|19740
         C_GOTO(cnc09);				// return
//      -trace
//      provided for system debugging.  toggles the system label
//      trace switch at compile time
// cnc36:
        //b |cnc36|jsr|6,systt|||toggle switch|19746
        } /* cnc35 */
        

        void cnc36() {
        C_JSR(systt);				// toggle switch
        //b ||brn|6,cnc08|||merge|19747
         C_GOTO(cnc08);				// merge
//      -include
// cnc41:
        //b |cnc41|mnz|3,scncc|||set flag for scane|19785
        } /* cnc36 */
        

        void cnc41() {
        v.scncc = 0xffffffffffffffff;				// set flag for scane
        //b ||jsr|6,scane|||scan quoted file name|19786
        C_JSR(scane);				// scan quoted file name
        //b ||zer|3,scncc|||clear scane flag|19787
        v.scncc=0;				// clear scane flag
        //b ||bne|7,xl|18,=t_con|6,cnc06|if not constant|19788
        if ((xl-T_CON) != 0) C_GOTO(cnc06);				// if not constant
        //b ||bne|9,(xr)|22,=b_scl|6,cnc06|if not string constant|19789
        if ((*(xr_it.wp)-(word)(b_scl)) != 0) C_GOTO(cnc06);				// if not string constant
        //b ||mov|3,r_ifn|7,xr||save file name|19790
        v.r_ifn= xr;				// save file name
        //b ||mov|7,xl|3,r_inc||examine include file name table|19791
        xl= v.r_inc;				// examine include file name table
        //b ||zer|8,wb|||lookup by value|19792
        wb=0;				// lookup by value
        //b ||ppm||||never fails|19794
        C_JSR_1(tfind,(C_ERR(299)));				// never fails
        //b ||beq|7,xr|21,=inton|6,cnc09|ignore if already in table|19795
        if ((xr-(word)(&c.inton)) == 0) C_GOTO(cnc09);				// ignore if already in table
        //b ||mnz|8,wb|||set for trim|19796
        wb = 0xffffffffffffffff;				// set for trim
        //b ||mov|7,xr|3,r_ifn||file name|19797
        xr= v.r_ifn;				// file name
        //b ||jsr|6,trimr|||remove trailing blanks|19798
        C_JSR(trimr);				// remove trailing blanks
        //b ||mov|7,xl|3,r_inc||include file name table|19799
        xl= v.r_inc;				// include file name table
        //b ||mnz|8,wb|||lookup by name this time|19800
        wb = 0xffffffffffffffff;				// lookup by name this time
        //b ||ppm||||never fails|19802
        C_JSR_1(tfind,(C_ERR(299)));				// never fails
        //b ||mov|13,teval(xl)|21,=inton||make table value integer 1|19803
        *((word *)(CFP_B*TEVAL + xl))= (word)(&c.inton);				// make table value integer 1
        //b ||icv|3,cnind|||increase nesting level|19804
        (v.cnind)++;				// increase nesting level
        //b ||mov|8,wa|3,cnind||load new nest level|19805
        wa= v.cnind;				// load new nest level
        //b ||bgt|8,wa|18,=ccinm|6,cnc42|fail if excessive nesting|19806
        if ((wa-CCINM) > 0) C_GOTO(cnc42);				// fail if excessive nesting
//      record the name and line number of the current input file
        //b ||mov|7,xl|3,r_ifa||array of nested file names|19811
        xl= v.r_ifa;				// array of nested file names
        //b ||add|8,wa|18,=vcvlb||compute offset in words|19812
        wa += VCVLB;				// compute offset in words
        //b ||wtb|8,wa|||convert to bytes|19813
        wa <<= LOG_CFP_B;				// convert to bytes
        //b ||add|7,xl|8,wa||point to element|19814
        xl += wa;				// point to element
        //b ||mov|9,(xl)|3,r_sfc||record current file name|19815
        *(xl_it.wp)= v.r_sfc;				// record current file name
        //b ||mov|7,xl|8,wa||preserve nesting byte offset|19816
        xl= wa;				// preserve nesting byte offset
        //b ||mti|3,rdnln|||fetch source line number as integer|19817
        ia = (word)(v.rdnln);				// fetch source line number as integer
        //b ||jsr|6,icbld|||convert to icblk|19818
        C_JSR(icbld);				// convert to icblk
        //b ||add|7,xl|3,r_ifl||entry in nested line number array|19819
        xl += v.r_ifl;				// entry in nested line number array
        //b ||mov|9,(xl)|7,xr||record in array|19820
        *(xl_it.wp)= xr;				// record in array
//      here to switch to include file named in r_ifn
        //b ||mov|8,wa|3,cswin||max read length|19825
        wa= v.cswin;				// max read length
        //b ||mov|7,xl|3,r_ifn||include file name|19826
        xl= v.r_ifn;				// include file name
        //b ||jsr|6,alocs|||get buffer for complete file name|19827
        C_JSR(alocs);				// get buffer for complete file name
        //b ||ppm|6,cnc43|||could not open|19829
        C_JSR_1(sysif,C_GOTO(cnc43));				// could not open
//      make note of the complete file name for error messages
        //b ||zer|8,wb|||do not trim trailing blanks|19834
        wb=0;				// do not trim trailing blanks
        //b ||jsr|6,trimr|||adjust scblk for actual length|19835
        C_JSR(trimr);				// adjust scblk for actual length
        //b ||mov|3,r_sfc|7,xr||save ptr to file name|19836
        v.r_sfc= xr;				// save ptr to file name
        //b ||mti|3,cmpsn|||current statement as integer|19837
        ia = (word)(v.cmpsn);				// current statement as integer
        //b ||jsr|6,icbld|||build icblk for stmt number|19838
        C_JSR(icbld);				// build icblk for stmt number
        //b ||mov|7,xl|3,r_sfn||file name table|19839
        xl= v.r_sfn;				// file name table
        //b ||mnz|8,wb|||lookup statement number by name|19840
        wb = 0xffffffffffffffff;				// lookup statement number by name
        //b ||ppm||||always possible to allocate block|19842
        C_JSR_1(tfind,(C_ERR(299)));				// always possible to allocate block
        //b ||mov|13,teval(xl)|3,r_sfc||record file name as entry value|19843
        *((word *)(CFP_B*TEVAL + xl))= v.r_sfc;				// record file name as entry value
        //b ||zer|3,rdnln|||restart line counter for new file|19847
        v.rdnln=0;				// restart line counter for new file
        //b ||beq|3,stage|18,=stgic|6,cnc09|if initial compile|19848
        if ((v.stage-STGIC) == 0) C_GOTO(cnc09);				// if initial compile
        //b ||bne|3,cnind|18,=num01|6,cnc09|if not first execute-time nesting|19849
        if ((v.cnind-NUM01) != 0) C_GOTO(cnc09);				// if not first execute-time nesting
//      here for -include during execute-time compile
        //b ||mov|3,r_ici|3,r_cim||remember code argument string|19853
        v.r_ici= v.r_cim;				// remember code argument string
        //b ||mov|3,cnspt|3,scnpt||save position in string|19854
        v.cnspt= v.scnpt;				// save position in string
        //b ||mov|3,cnsil|3,scnil||and length of string|19855
        v.cnsil= v.scnil;				// and length of string
        //b ||brn|6,cnc09|||all done, merge|19856
         C_GOTO(cnc09);				// all done, merge
//      here for excessive include file nesting
// cnc42:
        //b |cnc42|erb|1,284|26,excessively nested include files|||19860
        } /* cnc41 */
        

        void cnc42() {
        C_ERB(284)
//      here if include file could not be opened
// cnc43:
        //b |cnc43|mov|3,dnamp|7,xr||release allocated scblk|19864
        } /* cnc42 */
        

        void cnc43() {
        v.dnamp= xr;				// release allocated scblk
        //b ||erb|1,285|26,include file cannot be opened|||19865
        C_ERB(285)
//      -line n filename
// cnc44:
        //b |cnc44|jsr|6,scane|||scan integer after -line|19872
        } /* cnc43 */
        

        void cnc44() {
        C_JSR(scane);				// scan integer after -line
        //b ||bne|7,xl|18,=t_con|6,cnc06|jump if no line number|19873
        if ((xl-T_CON) != 0) C_GOTO(cnc06);				// jump if no line number
        //b ||bne|9,(xr)|22,=b_icl|6,cnc06|jump if not integer|19874
        if ((*(xr_it.wp)-(word)(b_icl)) != 0) C_GOTO(cnc06);				// jump if not integer
        //b ||ldi|13,icval(xr)|||fetch integer line number|19875
        ia = *((word *)(CFP_B*ICVAL + xr));				// fetch integer line number
        //b ||ile|6,cnc06|||error if negative or zero|19876
        if (ia <= 0)  C_GOTO(cnc06);				// error if negative or zero
        //b ||beq|3,stage|18,=stgic|6,cnc45|skip if initial compile|19877
        if ((v.stage-STGIC) == 0) C_GOTO(cnc45);				// skip if initial compile
        //b ||mfi|3,cmpln|||set directly for other compiles|19878
        v.cmpln = ia;				// set directly for other compiles
        //b ||brn|6,cnc46|||no need to set rdnln|19879
         C_GOTO(cnc46);				// no need to set rdnln
// cnc45:
        //b |cnc45|sbi|4,intv1|||adjust number by one|19880
        } /* cnc44 */
        

        void cnc45() {
        ia-=c.intv1;				// adjust number by one
        //b ||mfi|3,rdnln|||save line number|19881
        v.rdnln = ia;				// save line number
// cnc46:
        //b |cnc46|mnz|3,scncc|||set flag for scane|19883
        C_GOTO(cnc46);
        } /* cnc45 */
        

        void cnc46() {
        v.scncc = 0xffffffffffffffff;				// set flag for scane
        //b ||jsr|6,scane|||scan quoted file name|19884
        C_JSR(scane);				// scan quoted file name
        //b ||zer|3,scncc|||clear scane flag|19885
        v.scncc=0;				// clear scane flag
        //b ||beq|7,xl|18,=t_smc|6,cnc47|done if no file name|19886
        if ((xl-T_SMC) == 0) C_GOTO(cnc47);				// done if no file name
        //b ||bne|7,xl|18,=t_con|6,cnc06|error if not constant|19887
        if ((xl-T_CON) != 0) C_GOTO(cnc06);				// error if not constant
        //b ||bne|9,(xr)|22,=b_scl|6,cnc06|if not string constant|19888
        if ((*(xr_it.wp)-(word)(b_scl)) != 0) C_GOTO(cnc06);				// if not string constant
        //b ||jsr|6,newfn|||record new file name|19889
        C_JSR(newfn);				// record new file name
        //b ||brn|6,cnc09|||merge|19890
         C_GOTO(cnc09);				// merge
//      here if file name not present
// cnc47:
        //b |cnc47|dcv|3,scnpt|||set to rescan the terminator|19894
        } /* cnc46 */
        

        void cnc47() {
        (v.scnpt)--;				// set to rescan the terminator
        //b ||brn|6,cnc09|||merge|19895
         C_GOTO(cnc09);				// merge
        //b ||ejc|||||19901
        
//      dffnc -- define function
//      dffnc is called whenever a new function is assigned to
//      a variable. it deals with external function use counts.
//      (xr)                  pointer to vrblk
//      (xl)                  pointer to new function block
//      jsr  dffnc            call to define function
//      (wa,wb)               destroyed
// dffnc:
        //b |dffnc|prc|25,e|1,0||entry point|19983
        } /* cnc47 */
        

        void dffnc() {
        //b ||bne|9,(xl)|22,=b_efc|6,dffn1|skip if new function not external|19986
        if ((*(xl_it.wp)-(word)(b_efc)) != 0) C_GOTO(dffn1);				// skip if new function not external
        //b ||icv|13,efuse(xl)|||else increment its use count|19987
        (*((word *)(CFP_B*EFUSE + xl)))++;				// else increment its use count
//      here after dealing with new function use count
// dffn1:
        //b |dffn1|mov|8,wa|7,xr||save vrblk pointer|19991
        C_GOTO(dffn1);
        } /* dffnc */
        

        void dffn1() {
        wa= xr;				// save vrblk pointer
        //b ||mov|7,xr|13,vrfnc(xr)||load old function pointer|19992
        xr= *((word *)(CFP_B*VRFNC + xr));				// load old function pointer
        //b ||bne|9,(xr)|22,=b_efc|6,dffn2|jump if old function not external|19993
        if ((*(xr_it.wp)-(word)(b_efc)) != 0) C_GOTO(dffn2);				// jump if old function not external
        //b ||mov|8,wb|13,efuse(xr)||else get use count|19994
        wb= *((word *)(CFP_B*EFUSE + xr));				// else get use count
        //b ||dcv|8,wb|||decrement|19995
        (wb)--;				// decrement
        //b ||mov|13,efuse(xr)|8,wb||store decremented value|19996
        *((word *)(CFP_B*EFUSE + xr))= wb;				// store decremented value
        //b ||bnz|8,wb|6,dffn2||jump if use count still non-zero|19997
        if (wb) C_GOTO(dffn2);				// jump if use count still non-zero
        //b ||jsr|6,sysul|||else call system unload function|19998
        C_JSR(sysul);				// else call system unload function
//      here after dealing with old function use count
// dffn2:
        //b |dffn2|mov|7,xr|8,wa||restore vrblk pointer|20002
        C_GOTO(dffn2);
        } /* dffn1 */
        

        void dffn2() {
        xr= wa;				// restore vrblk pointer
        //b ||mov|8,wa|7,xl||copy function block ptr|20004
        wa= xl;				// copy function block ptr
        //b ||blt|7,xr|20,=r_yyy|6,dffn3|skip checks if opsyn op definition|20005
        if ((xr-(word)(&v.r_yyy)) < 0) C_GOTO(dffn3);				// skip checks if opsyn op definition
        //b ||bnz|13,vrlen(xr)|6,dffn3||jump if not system variable|20006
        if (*((word *)(CFP_B*VRLEN + xr))) C_GOTO(dffn3);				// jump if not system variable
//      for system variable, check for illegal redefinition
        //b ||mov|7,xl|13,vrsvp(xr)||point to svblk|20010
        xl= *((word *)(CFP_B*VRSVP + xr));				// point to svblk
        //b ||mov|8,wb|13,svbit(xl)||load bit indicators|20011
        wb= *((word *)(CFP_B*SVBIT + xl));				// load bit indicators
        //b ||anb|8,wb|4,btfnc||is it a system function|20012
        wb &= c.btfnc;				// is it a system function
        //b ||zrb|8,wb|6,dffn3||redef ok if not|20013
        if (!(wb)) C_GOTO(dffn3);				// redef ok if not
        //b ||erb|1,248|26,attempted redefinition of system function|||20014
        C_ERB(248)
//      here if redefinition is permitted
// dffn3:
        //b |dffn3|mov|13,vrfnc(xr)|8,wa||store new function pointer|20018
        } /* dffn2 */
        

        void dffn3() {
        *((word *)(CFP_B*VRFNC + xr))= wa;				// store new function pointer
        //b ||mov|7,xl|8,wa||restore function block pointer|20019
        xl= wa;				// restore function block pointer
        //b ||exi||||return to dffnc caller|20020
        C_EXIT(0);				// return to dffnc caller
        //b ||ejc|||||20022
        
//      dtach -- detach i/o associated names
//      detaches trblks from i/o associated variables, removes
//      entry from iochn chain attached to filearg1 vrblk and may
//      remove vrblk access and store traps.
//      input, output, terminal are handled specially.
//      (xl)                  i/o assoc. vbl name base ptr
//      (wa)                  offset to name
//      jsr  dtach            call for detach operation
//      (xl,xr,wa,wb,wc)      destroyed
// dtach:
        //b |dtach|prc|25,e|1,0||entry point|20036
        } /* dffn3 */
        

        void dtach() {
        //b ||mov|3,dtcnb|7,xl||store name base (gbcol not called)|20037
        v.dtcnb= xl;				// store name base (gbcol not called)
        //b ||add|7,xl|8,wa||point to name location|20038
        xl += wa;				// point to name location
        //b ||mov|3,dtcnm|7,xl||store it|20039
        v.dtcnm= xl;				// store it
//      loop to search for i/o trblk
// dtch1:
        //b |dtch1|mov|7,xr|7,xl||copy name pointer|20043
        C_GOTO(dtch1);
        } /* dtach */
        

        void dtch1() {
        xr= xl;				// copy name pointer
//      continue after block deletion
// dtch2:
        //b |dtch2|mov|7,xl|9,(xl)||point to next value|20047
        C_GOTO(dtch2);
        } /* dtch1 */
        

        void dtch2() {
        xl= *(xl_it.wp);				// point to next value
        //b ||bne|9,(xl)|22,=b_trt|6,dtch6|jump at chain end|20048
        if ((*(xl_it.wp)-(word)(b_trt)) != 0) C_GOTO(dtch6);				// jump at chain end
        //b ||mov|8,wa|13,trtyp(xl)||get trap block type|20049
        wa= *((word *)(CFP_B*TRTYP + xl));				// get trap block type
        //b ||beq|8,wa|18,=trtin|6,dtch3|jump if input|20050
        if ((wa-TRTIN) == 0) C_GOTO(dtch3);				// jump if input
        //b ||beq|8,wa|18,=trtou|6,dtch3|jump if output|20051
        if ((wa-TRTOU) == 0) C_GOTO(dtch3);				// jump if output
        //b ||add|7,xl|19,*trnxt||point to next link|20052
        xl += CFP_B*TRNXT;				// point to next link
        //b ||brn|6,dtch1|||loop|20053
         C_GOTO(dtch1);				// loop
//      delete an old association
// dtch3:
        //b |dtch3|mov|9,(xr)|13,trval(xl)||delete trblk|20057
        } /* dtch2 */
        

        void dtch3() {
        *(xr_it.wp)= *((word *)(CFP_B*TRVAL + xl));				// delete trblk
        //b ||mov|8,wa|7,xl||dump xl ...|20058
        wa= xl;				// dump xl ...
        //b ||mov|8,wb|7,xr||... and xr|20059
        wb= xr;				// ... and xr
        //b ||mov|7,xl|13,trtrf(xl)||point to trtrf trap block|20060
        xl= *((word *)(CFP_B*TRTRF + xl));				// point to trtrf trap block
        //b ||bze|7,xl|6,dtch5||jump if no iochn|20061
        if ( !( xl) ) C_GOTO(dtch5);				// jump if no iochn
        //b ||bne|9,(xl)|22,=b_trt|6,dtch5|jump if input, output, terminal|20062
        if ((*(xl_it.wp)-(word)(b_trt)) != 0) C_GOTO(dtch5);				// jump if input, output, terminal
//      loop to search iochn chain for name ptr
// dtch4:
        //b |dtch4|mov|7,xr|7,xl||remember link ptr|20066
        C_GOTO(dtch4);
        } /* dtch3 */
        

        void dtch4() {
        xr= xl;				// remember link ptr
        //b ||mov|7,xl|13,trtrf(xl)||point to next link|20067
        xl= *((word *)(CFP_B*TRTRF + xl));				// point to next link
        //b ||bze|7,xl|6,dtch5||jump if end of chain|20068
        if ( !( xl) ) C_GOTO(dtch5);				// jump if end of chain
        //b ||mov|8,wc|13,ionmb(xl)||get name base|20069
        wc= *((word *)(CFP_B*IONMB + xl));				// get name base
        //b ||add|8,wc|13,ionmo(xl)||add offset|20070
        wc += *((word *)(CFP_B*IONMO + xl));				// add offset
        //b ||bne|8,wc|3,dtcnm|6,dtch4|loop if no match|20071
        if ((wc-v.dtcnm) != 0) C_GOTO(dtch4);				// loop if no match
        //b ||mov|13,trtrf(xr)|13,trtrf(xl)||remove name from chain|20072
        *((word *)(CFP_B*TRTRF + xr))= *((word *)(CFP_B*TRTRF + xl));				// remove name from chain
        //b ||ejc|||||20073
        
//      dtach (continued)
//      prepare to resume i/o trblk scan
// dtch5:
        //b |dtch5|mov|7,xl|8,wa||recover xl ...|20079
        C_GOTO(dtch5);
        } /* dtch4 */
        

        void dtch5() {
        xl= wa;				// recover xl ...
        //b ||mov|7,xr|8,wb||... and xr|20080
        xr= wb;				// ... and xr
        //b ||add|7,xl|19,*trval||point to value field|20081
        xl += CFP_B*TRVAL;				// point to value field
        //b ||brn|6,dtch2|||continue|20082
         C_GOTO(dtch2);				// continue
//      exit point
// dtch6:
        //b |dtch6|mov|7,xr|3,dtcnb||possible vrblk ptr|20086
        } /* dtch5 */
        

        void dtch6() {
        xr= v.dtcnb;				// possible vrblk ptr
        //b ||jsr|6,setvr|||reset vrblk if necessary|20087
        C_JSR(setvr);				// reset vrblk if necessary
        //b ||exi||||return|20088
        C_EXIT(0);				// return
        //b ||ejc|||||20090
        
//      dtype -- get datatype name
//      (xr)                  object whose datatype is required
//      jsr  dtype            call to get datatype
//      (xr)                  result datatype
// dtype:
        //b |dtype|prc|25,e|1,0||entry point|20098
        } /* dtch6 */
        

        void dtype() {
        //b ||beq|9,(xr)|22,=b_pdt|6,dtyp1|jump if prog.defined|20099
        if ((*(xr_it.wp)-(word)(b_pdt)) == 0) C_GOTO(dtyp1);				// jump if prog.defined
        //b ||mov|7,xr|9,(xr)||load type word|20100
        xr= *(xr_it.wp);				// load type word
        //b ||lei|7,xr|||get entry point id (block code)|20101
        xr = find_elab(xr);    /* get entry code */				// get entry point id (block code)
        //b ||wtb|7,xr|||convert to byte offset|20102
        xr <<= LOG_CFP_B;				// convert to byte offset
        //b ||mov|7,xr|14,scnmt(xr)||load table entry|20103
        xr= *((word *)( ((word)&c.scnmt) + xr));				// load table entry
        //b ||exi||||exit to dtype caller|20104
        C_EXIT(0);				// exit to dtype caller
//      here if program defined
// dtyp1:
        //b |dtyp1|mov|7,xr|13,pddfp(xr)||point to dfblk|20108
        } /* dtype */
        

        void dtyp1() {
        xr= *((word *)(CFP_B*PDDFP + xr));				// point to dfblk
        //b ||mov|7,xr|13,dfnam(xr)||get datatype name from dfblk|20109
        xr= *((word *)(CFP_B*DFNAM + xr));				// get datatype name from dfblk
        //b ||exi||||return to dtype caller|20110
        C_EXIT(0);				// return to dtype caller
        //b ||ejc|||||20112
        
//      dumpr -- print dump of storage
//      (xr)                  dump argument (see below)
//      jsr  dumpr            call to print dump
//      (xr,xl)               destroyed
//      (wa,wb,wc,ra)         destroyed
//      the dump argument has the following significance
//      dmarg = 0             no dump printed
//      dmarg = 1             partial dump (nat vars, keywords)
//      dmarg = 2             full dump (arrays, tables, etc.)
//      dmarg = 3             full dump + null variables
//      dmarg ge 4            core dump
//      since dumpr scrambles store, it is not permissible to
//      collect in mid-dump. hence a collect is done initially
//      and then if store runs out an error message is produced.
// dumpr:
        //b |dumpr|prc|25,e|1,0||entry point|20133
        } /* dtyp1 */
        

        void dumpr() {
        //b ||bze|7,xr|6,dmp28||skip dump if argument is zero|20134
        if ( !( xr) ) C_GOTO(dmp28);				// skip dump if argument is zero
        //b ||bgt|7,xr|18,=num03|6,dmp29|jump if core dump required|20135
        if ((xr-NUM03) > 0) C_GOTO(dmp29);				// jump if core dump required
        //b ||zer|7,xl|||clear xl|20136
        xl=0;				// clear xl
        //b ||zer|8,wb|||zero move offset|20137
        wb=0;				// zero move offset
        //b ||mov|3,dmarg|7,xr||save dump argument|20138
        v.dmarg= xr;				// save dump argument
        //b ||zer|3,dnams|||collect sediment too|20140
        v.dnams=0;				// collect sediment too
        //b ||jsr|6,gbcol|||collect garbage|20142
        C_JSR(gbcol);				// collect garbage
        //b ||jsr|6,prtpg|||eject printer|20143
        C_JSR(prtpg);				// eject printer
        //b ||mov|7,xr|21,=dmhdv||point to heading for variables|20144
        xr= (word)(&c.dmhdv);				// point to heading for variables
        //b ||jsr|6,prtst|||print it|20145
        C_JSR(prtst);				// print it
        //b ||jsr|6,prtnl|||terminate print line|20146
        C_JSR(prtnl);				// terminate print line
        //b ||jsr|6,prtnl|||and print a blank line|20147
        C_JSR(prtnl);				// and print a blank line
//      first all natural variable blocks (vrblk) whose values
//      are non-null are linked in lexical order using dmvch as
//      the chain head and chaining through the vrget fields.
//      note that this scrambles store if the process is
//      interrupted before completion e.g. by exceeding time  or
//      print limits. since the subsequent core dumps and
//      failures if execution is resumed are very confusing, the
//      execution time error routine checks for this event and
//      attempts an unscramble. similar precautions should be
//      observed if translate time dumping is implemented.
        //b ||zer|3,dmvch|||set null chain to start|20160
        v.dmvch=0;				// set null chain to start
        //b ||mov|8,wa|3,hshtb||point to hash table|20161
        wa= v.hshtb;				// point to hash table
//      loop through headers in hash table
// dmp00:
        //b |dmp00|mov|7,xr|8,wa||copy hash bucket pointer|20165
        C_GOTO(dmp00);
        } /* dumpr */
        

        void dmp00() {
        xr= wa;				// copy hash bucket pointer
        //b ||ica|8,wa|||bump pointer|20166
        wa += CFP_B;				// bump pointer
        //b ||sub|7,xr|19,*vrnxt||set offset to merge|20167
        xr -= CFP_B*VRNXT;				// set offset to merge
//      loop through vrblks on one chain
// dmp01:
        //b |dmp01|mov|7,xr|13,vrnxt(xr)||point to next vrblk on chain|20171
        C_GOTO(dmp01);
        } /* dmp00 */
        

        void dmp01() {
        xr= *((word *)(CFP_B*VRNXT + xr));				// point to next vrblk on chain
        //b ||bze|7,xr|6,dmp09||jump if end of this hash chain|20172
        if ( !( xr) ) C_GOTO(dmp09);				// jump if end of this hash chain
        //b ||mov|7,xl|7,xr||else copy vrblk pointer|20173
        xl= xr;				// else copy vrblk pointer
        //b ||ejc|||||20174
        
//      dumpr (continued)
//      loop to find value and skip if null
// dmp02:
        //b |dmp02|mov|7,xl|13,vrval(xl)||load value|20180
        C_GOTO(dmp02);
        } /* dmp01 */
        

        void dmp02() {
        xl= *((word *)(CFP_B*VRVAL + xl));				// load value
        //b ||beq|3,dmarg|18,=num03|6,dmp2a|skip null value check if dump(3)|20181
        if ((v.dmarg-NUM03) == 0) C_GOTO(dmp2a);				// skip null value check if dump(3)
        //b ||beq|7,xl|21,=nulls|6,dmp01|loop for next vrblk if null value|20182
        if ((xl-(word)(&c.nulls)) == 0) C_GOTO(dmp01);				// loop for next vrblk if null value
// dmp2a:
        //b |dmp2a|beq|9,(xl)|22,=b_trt|6,dmp02|loop back if value is trapped|20183
        C_GOTO(dmp2a);
        } /* dmp02 */
        

        void dmp2a() {
        if ((*(xl_it.wp)-(word)(b_trt)) == 0) C_GOTO(dmp02);				// loop back if value is trapped
//      non-null value, prepare to search chain
        //b ||mov|8,wc|7,xr||save vrblk pointer|20187
        wc= xr;				// save vrblk pointer
        //b ||add|7,xr|19,*vrsof||adjust ptr to be like scblk ptr|20188
        xr += CFP_B*VRSOF;				// adjust ptr to be like scblk ptr
        //b ||bnz|13,sclen(xr)|6,dmp03||jump if non-system variable|20189
        if (*((word *)(CFP_B*SCLEN + xr))) C_GOTO(dmp03);				// jump if non-system variable
        //b ||mov|7,xr|13,vrsvo(xr)||else load ptr to name in svblk|20190
        xr= *((word *)(CFP_B*VRSVO + xr));				// else load ptr to name in svblk
//      here with name pointer for new block in xr
// dmp03:
        //b |dmp03|mov|8,wb|7,xr||save pointer to chars|20194
        C_GOTO(dmp03);
        } /* dmp2a */
        

        void dmp03() {
        wb= xr;				// save pointer to chars
        //b ||mov|3,dmpsv|8,wa||save hash bucket pointer|20195
        v.dmpsv= wa;				// save hash bucket pointer
        //b ||mov|8,wa|20,=dmvch||point to chain head|20196
        wa= (word)(&v.dmvch);				// point to chain head
//      loop to search chain for correct insertion point
// dmp04:
        //b |dmp04|mov|3,dmpch|8,wa||save chain pointer|20200
        C_GOTO(dmp04);
        } /* dmp03 */
        

        void dmp04() {
        v.dmpch= wa;				// save chain pointer
        //b ||mov|7,xl|8,wa||copy it|20201
        xl= wa;				// copy it
        //b ||mov|7,xr|9,(xl)||load pointer to next entry|20202
        xr= *(xl_it.wp);				// load pointer to next entry
        //b ||bze|7,xr|6,dmp08||jump if end of chain to insert|20203
        if ( !( xr) ) C_GOTO(dmp08);				// jump if end of chain to insert
        //b ||add|7,xr|19,*vrsof||else get name ptr for chained vrblk|20204
        xr += CFP_B*VRSOF;				// else get name ptr for chained vrblk
        //b ||bnz|13,sclen(xr)|6,dmp05||jump if not system variable|20205
        if (*((word *)(CFP_B*SCLEN + xr))) C_GOTO(dmp05);				// jump if not system variable
        //b ||mov|7,xr|13,vrsvo(xr)||else point to name in svblk|20206
        xr= *((word *)(CFP_B*VRSVO + xr));				// else point to name in svblk
//      here prepare to compare the names
//      (wa)                  scratch
//      (wb)                  pointer to string of entering vrblk
//      (wc)                  pointer to entering vrblk
//      (xr)                  pointer to string of current block
//      (xl)                  scratch
// dmp05:
        //b |dmp05|mov|7,xl|8,wb||point to entering vrblk string|20216
        C_GOTO(dmp05);
        } /* dmp04 */
        

        void dmp05() {
        xl= wb;				// point to entering vrblk string
        //b ||mov|8,wa|13,sclen(xl)||load its length|20217
        wa= *((word *)(CFP_B*SCLEN + xl));				// load its length
        //b ||plc|7,xl|||point to chars of entering string|20218
        xl += CFP_F;				// point to chars of entering string
        //b ||bhi|8,wa|13,sclen(xr)|6,dmp06|jump if entering length high|20241
        if ((wa-*((word *)(CFP_B*SCLEN + xr))) > 0) C_GOTO(dmp06);				// jump if entering length high
        //b ||plc|7,xr|||else point to chars of old string|20242
        xr += CFP_F;				// else point to chars of old string
        //b ||cmc|6,dmp08|6,dmp07||compare, insert if new is llt old|20243
        C_CMC(xl_it,xr_it,wa_it,dmp08,dmp07);				// compare, insert if new is llt old
        //b ||brn|6,dmp08|||or if leq (we had shorter length)|20244
         C_GOTO(dmp08);				// or if leq (we had shorter length)
//      here when new length is longer than old length
// dmp06:
        //b |dmp06|mov|8,wa|13,sclen(xr)||load shorter length|20248
        } /* dmp05 */
        

        void dmp06() {
        wa= *((word *)(CFP_B*SCLEN + xr));				// load shorter length
        //b ||plc|7,xr|||point to chars of old string|20249
        xr += CFP_F;				// point to chars of old string
        //b ||cmc|6,dmp08|6,dmp07||compare, insert if new one low|20250
        C_CMC(xl_it,xr_it,wa_it,dmp08,dmp07);				// compare, insert if new one low
        //b ||ejc|||||20251
        
//      dumpr (continued)
//      here we move out on the chain
// dmp07:
        //b |dmp07|mov|7,xl|3,dmpch||copy chain pointer|20257
        C_GOTO(dmp07);
        } /* dmp06 */
        

        void dmp07() {
        xl= v.dmpch;				// copy chain pointer
        //b ||mov|8,wa|9,(xl)||move to next entry on chain|20259
        wa= *(xl_it.wp);				// move to next entry on chain
        //b ||brn|6,dmp04|||loop back|20260
         C_GOTO(dmp04);				// loop back
//      here after locating the proper insertion point
// dmp08:
        //b |dmp08|mov|7,xl|3,dmpch||copy chain pointer|20264
        } /* dmp07 */
        

        void dmp08() {
        xl= v.dmpch;				// copy chain pointer
        //b ||mov|8,wa|3,dmpsv||restore hash bucket pointer|20265
        wa= v.dmpsv;				// restore hash bucket pointer
        //b ||mov|7,xr|8,wc||restore vrblk pointer|20266
        xr= wc;				// restore vrblk pointer
        //b ||mov|13,vrget(xr)|9,(xl)||link vrblk to rest of chain|20267
        *((word *)(CFP_B*VRGET + xr))= *(xl_it.wp);				// link vrblk to rest of chain
        //b ||mov|9,(xl)|7,xr||link vrblk into current chain loc|20268
        *(xl_it.wp)= xr;				// link vrblk into current chain loc
        //b ||brn|6,dmp01|||loop back for next vrblk|20269
         C_GOTO(dmp01);				// loop back for next vrblk
//      here after processing all vrblks on one chain
// dmp09:
        //b |dmp09|bne|8,wa|3,hshte|6,dmp00|loop back if more buckets to go|20273
        } /* dmp08 */
        

        void dmp09() {
        if ((wa-v.hshte) != 0) C_GOTO(dmp00);				// loop back if more buckets to go
//      loop to generate dump of natural variable values
// dmp10:
        //b |dmp10|mov|7,xr|3,dmvch||load pointer to next entry on chain|20277
        C_GOTO(dmp10);
        } /* dmp09 */
        

        void dmp10() {
        xr= v.dmvch;				// load pointer to next entry on chain
        //b ||bze|7,xr|6,dmp11||jump if end of chain|20278
        if ( !( xr) ) C_GOTO(dmp11);				// jump if end of chain
        //b ||mov|3,dmvch|9,(xr)||else update chain ptr to next entry|20279
        v.dmvch= *(xr_it.wp);				// else update chain ptr to next entry
        //b ||jsr|6,setvr|||restore vrget field|20280
        C_JSR(setvr);				// restore vrget field
        //b ||mov|7,xl|7,xr||copy vrblk pointer (name base)|20281
        xl= xr;				// copy vrblk pointer (name base)
        //b ||mov|8,wa|19,*vrval||set offset for vrblk name|20282
        wa= CFP_B*VRVAL;				// set offset for vrblk name
        //b ||jsr|6,prtnv|||print name = value|20283
        C_JSR(prtnv);				// print name = value
        //b ||brn|6,dmp10|||loop back till all printed|20284
         C_GOTO(dmp10);				// loop back till all printed
//      prepare to print keywords
// dmp11:
        //b |dmp11|jsr|6,prtnl|||print blank line|20288
        } /* dmp10 */
        

        void dmp11() {
        C_JSR(prtnl);				// print blank line
        //b ||jsr|6,prtnl|||and another|20289
        C_JSR(prtnl);				// and another
        //b ||mov|7,xr|21,=dmhdk||point to keyword heading|20290
        xr= (word)(&c.dmhdk);				// point to keyword heading
        //b ||jsr|6,prtst|||print heading|20291
        C_JSR(prtst);				// print heading
        //b ||jsr|6,prtnl|||end line|20292
        C_JSR(prtnl);				// end line
        //b ||jsr|6,prtnl|||print one blank line|20293
        C_JSR(prtnl);				// print one blank line
        //b ||mov|7,xl|21,=vdmkw||point to list of keyword svblk ptrs|20294
        xl= (word)(&c.vdmkw);				// point to list of keyword svblk ptrs
        //b ||ejc|||||20295
        
//      dumpr (continued)
//      loop to dump keyword values
// dmp12:
        //b |dmp12|mov|7,xr|10,(xl)+||load next svblk ptr from table|20301
        C_GOTO(dmp12);
        } /* dmp11 */
        

        void dmp12() {
        xr= *(xl_it.wp++);				// load next svblk ptr from table
        //b ||bze|7,xr|6,dmp13||jump if end of list|20302
        if ( !( xr) ) C_GOTO(dmp13);				// jump if end of list
        //b ||beq|7,xr|18,=num01|6,dmp12|&compare ignored if not implemented|20304
        if ((xr-NUM01) == 0) C_GOTO(dmp12);				// &compare ignored if not implemented
        //b ||mov|8,wa|18,=ch_am||load ampersand|20306
        wa= CH_AM;				// load ampersand
        //b ||jsr|6,prtch|||print ampersand|20307
        C_JSR(prtch);				// print ampersand
        //b ||jsr|6,prtst|||print keyword name|20308
        C_JSR(prtst);				// print keyword name
        //b ||mov|8,wa|13,svlen(xr)||load name length from svblk|20309
        wa= *((word *)(CFP_B*SVLEN + xr));				// load name length from svblk
        //b ||ctb|8,wa|2,svchs||get length of name|20310
        wa += (CFP_B-1)+CFP_B*SVCHS;				// get length of name
        wa &= 0xfffffffffffffff8;
        //b ||add|7,xr|8,wa||point to svknm field|20311
        xr += wa;				// point to svknm field
        //b ||mov|3,dmpkn|9,(xr)||store in dummy kvblk|20312
        v.dmpkn= *(xr_it.wp);				// store in dummy kvblk
        //b ||mov|7,xr|21,=tmbeb||point to blank-equal-blank|20313
        xr= (word)(&c.tmbeb);				// point to blank-equal-blank
        //b ||jsr|6,prtst|||print it|20314
        C_JSR(prtst);				// print it
        //b ||mov|3,dmpsv|7,xl||save table pointer|20315
        v.dmpsv= xl;				// save table pointer
        //b ||mov|7,xl|20,=dmpkb||point to dummy kvblk|20316
        xl= (word)(&v.dmpkb);				// point to dummy kvblk
        //b ||mov|9,(xl)|22,=b_kvt||build type word|20317
        *(xl_it.wp)= (word)(b_kvt);				// build type word
        //b ||mov|13,kvvar(xl)|21,=trbkv||build ptr to dummy trace block|20318
        *((word *)(CFP_B*KVVAR + xl))= (word)(&c.trbkv);				// build ptr to dummy trace block
        //b ||mov|8,wa|19,*kvvar||set zero offset|20319
        wa= CFP_B*KVVAR;				// set zero offset
        //b ||ppm||||failure is impossible|20321
        C_JSR_1(acess,(C_ERR(299)));				// failure is impossible
        //b ||jsr|6,prtvl|||print keyword value|20322
        C_JSR(prtvl);				// print keyword value
        //b ||jsr|6,prtnl|||terminate print line|20323
        C_JSR(prtnl);				// terminate print line
        //b ||mov|7,xl|3,dmpsv||restore table pointer|20324
        xl= v.dmpsv;				// restore table pointer
        //b ||brn|6,dmp12|||loop back till all printed|20325
         C_GOTO(dmp12);				// loop back till all printed
//      here after completing partial dump
// dmp13:
        //b |dmp13|beq|3,dmarg|18,=num01|6,dmp27|exit if partial dump complete|20329
        } /* dmp12 */
        

        void dmp13() {
        if ((v.dmarg-NUM01) == 0) C_GOTO(dmp27);				// exit if partial dump complete
        //b ||mov|7,xr|3,dnamb||else point to first dynamic block|20330
        xr= v.dnamb;				// else point to first dynamic block
//      loop through blocks in dynamic storage
// dmp14:
        //b |dmp14|beq|7,xr|3,dnamp|6,dmp27|jump if end of used region|20334
        C_GOTO(dmp14);
        } /* dmp13 */
        

        void dmp14() {
        if ((xr-v.dnamp) == 0) C_GOTO(dmp27);				// jump if end of used region
        //b ||mov|8,wa|9,(xr)||else load first word of block|20335
        wa= *(xr_it.wp);				// else load first word of block
        //b ||beq|8,wa|22,=b_vct|6,dmp16|jump if vector|20336
        if ((wa-(word)(b_vct)) == 0) C_GOTO(dmp16);				// jump if vector
        //b ||beq|8,wa|22,=b_art|6,dmp17|jump if array|20337
        if ((wa-(word)(b_art)) == 0) C_GOTO(dmp17);				// jump if array
        //b ||beq|8,wa|22,=b_pdt|6,dmp18|jump if program defined|20338
        if ((wa-(word)(b_pdt)) == 0) C_GOTO(dmp18);				// jump if program defined
        //b ||beq|8,wa|22,=b_tbt|6,dmp19|jump if table|20339
        if ((wa-(word)(b_tbt)) == 0) C_GOTO(dmp19);				// jump if table
//      merge here to move to next block
// dmp15:
        //b |dmp15|jsr|6,blkln|||get length of block|20347
        C_GOTO(dmp15);
        } /* dmp14 */
        

        void dmp15() {
        C_JSR(blkln);				// get length of block
        //b ||add|7,xr|8,wa||point past this block|20348
        xr += wa;				// point past this block
        //b ||brn|6,dmp14|||loop back for next block|20349
         C_GOTO(dmp14);				// loop back for next block
        //b ||ejc|||||20350
        
//      dumpr (continued)
//      here for vector
// dmp16:
        //b |dmp16|mov|8,wb|19,*vcvls||set offset to first value|20356
        } /* dmp15 */
        

        void dmp16() {
        wb= CFP_B*VCVLS;				// set offset to first value
        //b ||brn|6,dmp19|||jump to merge|20357
         C_GOTO(dmp19);				// jump to merge
//      here for array
// dmp17:
        //b |dmp17|mov|8,wb|13,arofs(xr)||set offset to arpro field|20361
        } /* dmp16 */
        

        void dmp17() {
        wb= *((word *)(CFP_B*AROFS + xr));				// set offset to arpro field
        //b ||ica|8,wb|||bump to get offset to values|20362
        wb += CFP_B;				// bump to get offset to values
        //b ||brn|6,dmp19|||jump to merge|20363
         C_GOTO(dmp19);				// jump to merge
//      here for program defined
// dmp18:
        //b |dmp18|mov|8,wb|19,*pdfld||point to values, merge|20367
        } /* dmp17 */
        

        void dmp18() {
        wb= CFP_B*PDFLD;				// point to values, merge
//      here for table (others merge)
// dmp19:
        //b |dmp19|bze|13,idval(xr)|6,dmp15||ignore block if zero id value|20371
        C_GOTO(dmp19);
        } /* dmp18 */
        

        void dmp19() {
        if ( !( *((word *)(CFP_B*IDVAL + xr))) ) C_GOTO(dmp15);				// ignore block if zero id value
        //b ||jsr|6,blkln|||else get block length|20372
        C_JSR(blkln);				// else get block length
        //b ||mov|7,xl|7,xr||copy block pointer|20373
        xl= xr;				// copy block pointer
        //b ||mov|3,dmpsv|8,wa||save length|20374
        v.dmpsv= wa;				// save length
        //b ||mov|8,wa|8,wb||copy offset to first value|20375
        wa= wb;				// copy offset to first value
        //b ||jsr|6,prtnl|||print blank line|20376
        C_JSR(prtnl);				// print blank line
        //b ||mov|3,dmpsa|8,wa||preserve offset|20377
        v.dmpsa= wa;				// preserve offset
        //b ||jsr|6,prtvl|||print block value (for title)|20378
        C_JSR(prtvl);				// print block value (for title)
        //b ||mov|8,wa|3,dmpsa||recover offset|20379
        wa= v.dmpsa;				// recover offset
        //b ||jsr|6,prtnl|||end print line|20380
        C_JSR(prtnl);				// end print line
        //b ||beq|9,(xr)|22,=b_tbt|6,dmp22|jump if table|20381
        if ((*(xr_it.wp)-(word)(b_tbt)) == 0) C_GOTO(dmp22);				// jump if table
        //b ||dca|8,wa|||point before first word|20382
        wa -= CFP_B;				// point before first word
//      loop to print contents of array, vector, or program def
// dmp20:
        //b |dmp20|mov|7,xr|7,xl||copy block pointer|20386
        C_GOTO(dmp20);
        } /* dmp19 */
        

        void dmp20() {
        xr= xl;				// copy block pointer
        //b ||ica|8,wa|||bump offset|20387
        wa += CFP_B;				// bump offset
        //b ||add|7,xr|8,wa||point to next value|20388
        xr += wa;				// point to next value
        //b ||beq|8,wa|3,dmpsv|6,dmp14|exit if end (xr past block)|20389
        if ((wa-v.dmpsv) == 0) C_GOTO(dmp14);				// exit if end (xr past block)
        //b ||sub|7,xr|19,*vrval||subtract offset to merge into loop|20390
        xr -= CFP_B*VRVAL;				// subtract offset to merge into loop
//      loop to find value and ignore nulls
// dmp21:
        //b |dmp21|mov|7,xr|13,vrval(xr)||load next value|20394
        C_GOTO(dmp21);
        } /* dmp20 */
        

        void dmp21() {
        xr= *((word *)(CFP_B*VRVAL + xr));				// load next value
        //b ||beq|3,dmarg|18,=num03|6,dmp2b|skip null value check if dump(3)|20395
        if ((v.dmarg-NUM03) == 0) C_GOTO(dmp2b);				// skip null value check if dump(3)
        //b ||beq|7,xr|21,=nulls|6,dmp20|loop back if null value|20396
        if ((xr-(word)(&c.nulls)) == 0) C_GOTO(dmp20);				// loop back if null value
// dmp2b:
        //b |dmp2b|beq|9,(xr)|22,=b_trt|6,dmp21|loop back if trapped|20397
        C_GOTO(dmp2b);
        } /* dmp21 */
        

        void dmp2b() {
        if ((*(xr_it.wp)-(word)(b_trt)) == 0) C_GOTO(dmp21);				// loop back if trapped
        //b ||jsr|6,prtnv|||else print name = value|20398
        C_JSR(prtnv);				// else print name = value
        //b ||brn|6,dmp20|||loop back for next field|20399
         C_GOTO(dmp20);				// loop back for next field
        //b ||ejc|||||20400
        
//      dumpr (continued)
//      here to dump a table
// dmp22:
        //b |dmp22|mov|8,wc|19,*tbbuk||set offset to first bucket|20406
        } /* dmp2b */
        

        void dmp22() {
        wc= CFP_B*TBBUK;				// set offset to first bucket
        //b ||mov|8,wa|19,*teval||set name offset for all teblks|20407
        wa= CFP_B*TEVAL;				// set name offset for all teblks
//      loop through table buckets
// dmp23:
        //b |dmp23|mov|11,-(xs)|7,xl||save tbblk pointer|20411
        C_GOTO(dmp23);
        } /* dmp22 */
        

        void dmp23() {
        C_PUSH(xl);				// save tbblk pointer
        //b ||add|7,xl|8,wc||point to next bucket header|20412
        xl += wc;				// point to next bucket header
        //b ||ica|8,wc|||bump bucket offset|20413
        wc += CFP_B;				// bump bucket offset
        //b ||sub|7,xl|19,*tenxt||subtract offset to merge into loop|20414
        xl -= CFP_B*TENXT;				// subtract offset to merge into loop
//      loop to process teblks on one chain
// dmp24:
        //b |dmp24|mov|7,xl|13,tenxt(xl)||point to next teblk|20418
        C_GOTO(dmp24);
        } /* dmp23 */
        

        void dmp24() {
        xl= *((word *)(CFP_B*TENXT + xl));				// point to next teblk
        //b ||beq|7,xl|9,(xs)|6,dmp26|jump if end of chain|20419
        if ((xl-*(xs_it.wp)) == 0) C_GOTO(dmp26);				// jump if end of chain
        //b ||mov|7,xr|7,xl||else copy teblk pointer|20420
        xr= xl;				// else copy teblk pointer
//      loop to find value and ignore if null
// dmp25:
        //b |dmp25|mov|7,xr|13,teval(xr)||load next value|20424
        C_GOTO(dmp25);
        } /* dmp24 */
        

        void dmp25() {
        xr= *((word *)(CFP_B*TEVAL + xr));				// load next value
        //b ||beq|7,xr|21,=nulls|6,dmp24|ignore if null value|20425
        if ((xr-(word)(&c.nulls)) == 0) C_GOTO(dmp24);				// ignore if null value
        //b ||beq|9,(xr)|22,=b_trt|6,dmp25|loop back if trapped|20426
        if ((*(xr_it.wp)-(word)(b_trt)) == 0) C_GOTO(dmp25);				// loop back if trapped
        //b ||mov|3,dmpsv|8,wc||else save offset pointer|20427
        v.dmpsv= wc;				// else save offset pointer
        //b ||jsr|6,prtnv|||print name = value|20428
        C_JSR(prtnv);				// print name = value
        //b ||mov|8,wc|3,dmpsv||reload offset|20429
        wc= v.dmpsv;				// reload offset
        //b ||brn|6,dmp24|||loop back for next teblk|20430
         C_GOTO(dmp24);				// loop back for next teblk
//      here to move to next hash chain
// dmp26:
        //b |dmp26|mov|7,xl|10,(xs)+||restore tbblk pointer|20434
        } /* dmp25 */
        

        void dmp26() {
        xl= C_POP();				// restore tbblk pointer
        //b ||bne|8,wc|13,tblen(xl)|6,dmp23|loop back if more buckets to go|20435
        if ((wc-*((word *)(CFP_B*TBLEN + xl))) != 0) C_GOTO(dmp23);				// loop back if more buckets to go
        //b ||mov|7,xr|7,xl||else copy table pointer|20436
        xr= xl;				// else copy table pointer
        //b ||add|7,xr|8,wc||point to following block|20437
        xr += wc;				// point to following block
        //b ||brn|6,dmp14|||loop back to process next block|20438
         C_GOTO(dmp14);				// loop back to process next block
//      here after completing dump
// dmp27:
        //b |dmp27|jsr|6,prtpg|||eject printer|20442
        } /* dmp26 */
        

        void dmp27() {
        C_JSR(prtpg);				// eject printer
//      merge here if no dump given (dmarg=0)
// dmp28:
        //b |dmp28|exi||||return to dump caller|20446
        C_GOTO(dmp28);
        } /* dmp27 */
        

        void dmp28() {
        C_EXIT(0);				// return to dump caller
//      call system core dump routine
// dmp29:
        //b |dmp29|jsr|6,sysdm|||call it|20450
        } /* dmp28 */
        

        void dmp29() {
        C_JSR(sysdm);				// call it
        //b ||brn|6,dmp28|||return|20451
         C_GOTO(dmp28);				// return
        //b ||ejc|||||20488
        
//      ermsg -- print error code and error message
//      kvert                 error code
//      jsr  ermsg            call to print message
//      (xr,xl,wa,wb,wc,ia)   destroyed
// ermsg:
        //b |ermsg|prc|25,e|1,0||entry point|20496
        } /* dmp29 */
        

        void ermsg() {
        //b ||mov|8,wa|3,kvert||load error code|20497
        wa= v.kvert;				// load error code
        //b ||mov|7,xr|21,=ermms||point to error message /error/|20498
        xr= (word)(&c.ermms);				// point to error message /error/
        //b ||jsr|6,prtst|||print it|20499
        C_JSR(prtst);				// print it
        //b ||jsr|6,ertex|||get error message text|20500
        C_JSR(ertex);				// get error message text
        //b ||add|8,wa|18,=thsnd||bump error code for print|20501
        wa += THSND;				// bump error code for print
        //b ||mti|8,wa|||fail code in int acc|20502
        ia = (word)(wa);				// fail code in int acc
        //b ||mov|8,wb|3,profs||save current buffer position|20503
        wb= v.profs;				// save current buffer position
        //b ||jsr|6,prtin|||print code (now have error1xxx)|20504
        C_JSR(prtin);				// print code (now have error1xxx)
        //b ||mov|7,xl|3,prbuf||point to print buffer|20505
        xl= v.prbuf;				// point to print buffer
        //b ||psc|7,xl|8,wb||point to the 1|20506
        xl_it.chp += CFP_F + wb;				// point to the 1
        //b ||mov|8,wa|18,=ch_bl||load a blank|20507
        wa= CH_BL;				// load a blank
        //b ||sch|8,wa|9,(xl)||store blank over 1 (error xxx)|20508
        *(xl_it.chp) = wa;				// store blank over 1 (error xxx)
        //b ||csc|7,xl|||complete store characters|20509
        //b ||zer|7,xl|||clear garbage pointer in xl|20510
        xl=0;				// clear garbage pointer in xl
        //b ||mov|8,wa|7,xr||keep error text|20511
        wa= xr;				// keep error text
        //b ||mov|7,xr|21,=ermns||point to / -- /|20512
        xr= (word)(&c.ermns);				// point to / -- /
        //b ||jsr|6,prtst|||print it|20513
        C_JSR(prtst);				// print it
        //b ||mov|7,xr|8,wa||get error text again|20514
        xr= wa;				// get error text again
        //b ||jsr|6,prtst|||print error message text|20515
        C_JSR(prtst);				// print error message text
        //b ||jsr|6,prtis|||print line|20516
        C_JSR(prtis);				// print line
        //b ||jsr|6,prtis|||print blank line|20517
        C_JSR(prtis);				// print blank line
        //b ||exi||||return to ermsg caller|20518
        C_EXIT(0);				// return to ermsg caller
        //b ||ejc|||||20520
        
//      ertex -- get error message text
//      (wa)                  error code
//      jsr  ertex            call to get error text
//      (xr)                  ptr to error text in dynamic
//      (r_etx)               copy of ptr to error text
//      (xl,wc,ia)            destroyed
// ertex:
        //b |ertex|prc|25,e|1,0||entry point|20530
        } /* ermsg */
        

        void ertex() {
        //b ||mov|3,ertwa|8,wa||save wa|20531
        v.ertwa= wa;				// save wa
        //b ||mov|3,ertwb|8,wb||save wb|20532
        v.ertwb= wb;				// save wb
        //b ||jsr|6,sysem|||get failure message text|20533
        C_JSR(sysem);				// get failure message text
        //b ||mov|7,xl|7,xr||copy pointer to it|20534
        xl= xr;				// copy pointer to it
        //b ||mov|8,wa|13,sclen(xr)||get length of string|20535
        wa= *((word *)(CFP_B*SCLEN + xr));				// get length of string
        //b ||bze|8,wa|6,ert02||jump if null|20536
        if ( !( wa) ) C_GOTO(ert02);				// jump if null
        //b ||zer|8,wb|||offset of zero|20537
        wb=0;				// offset of zero
        //b ||jsr|6,sbstr|||copy into dynamic store|20538
        C_JSR(sbstr);				// copy into dynamic store
        //b ||mov|3,r_etx|7,xr||store for relocation|20539
        v.r_etx= xr;				// store for relocation
//      return
// ert01:
        //b |ert01|mov|8,wb|3,ertwb||restore wb|20543
        C_GOTO(ert01);
        } /* ertex */
        

        void ert01() {
        wb= v.ertwb;				// restore wb
        //b ||mov|8,wa|3,ertwa||restore wa|20544
        wa= v.ertwa;				// restore wa
        //b ||exi||||return to caller|20545
        C_EXIT(0);				// return to caller
//      return errtext contents instead of null
// ert02:
        //b |ert02|mov|7,xr|3,r_etx||get errtext|20549
        } /* ert01 */
        

        void ert02() {
        xr= v.r_etx;				// get errtext
        //b ||brn|6,ert01|||return|20550
         C_GOTO(ert01);				// return
        //b ||ejc|||||20552
        
//      evali -- evaluate integer argument
//      evali is used by pattern primitives len,tab,rtab,pos,rpos
//      when their argument is an expression value.
//      (xr)                  node pointer
//      (wb)                  cursor
//      jsr  evali            call to evaluate integer
//      ppm  loc              transfer loc for non-integer arg
//      ppm  loc              transfer loc for out of range arg
//      ppm  loc              transfer loc for evaluation failure
//      ppm  loc              transfer loc for successful eval
//      (the normal return is never taken)
//      (xr)                  ptr to node with integer argument
//      (wc,xl,ra)            destroyed
//      on return, the node pointed to has the integer argument
//      in parm1 and the proper successor pointer in pthen.
//      this allows merging with the normal (integer arg) case.
// evali:
        //b |evali|prc|25,r|1,4||entry point (recursive)|20574
        } /* ert02 */
        

        void evali() {
        //b ||ppm|6,evli1|||jump on failure|20576
        C_JSR_1(evalp,C_GOTO(evli1));				// jump on failure
        //b ||mov|11,-(xs)|7,xl||stack result for gtsmi|20577
        C_PUSH(xl);				// stack result for gtsmi
        //b ||mov|7,xl|13,pthen(xr)||load successor pointer|20578
        xl= *((word *)(CFP_B*PTHEN + xr));				// load successor pointer
        //b ||mov|3,evlio|7,xr||save original node pointer|20579
        v.evlio= xr;				// save original node pointer
        //b ||mov|3,evlif|8,wc||zero if simple argument|20580
        v.evlif= wc;				// zero if simple argument
        //b ||ppm|6,evli3|||jump if out of range|20583
        extern void _l0565();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0565);
        } /* evali */
        

        void _l0565() {
        C_JMS_HANDLE_2(gtsmi,C_GOTO(evli2),C_GOTO(evli3));				// jump if out of range
        //b ||mov|3,evliv|7,xr||store result in special dummy node|20584
        v.evliv= xr;				// store result in special dummy node
        //b ||mov|7,xr|20,=evlin||point to dummy node with result|20585
        xr= (word)(&v.evlin);				// point to dummy node with result
        //b ||mov|9,(xr)|22,=p_len||dummy pattern block pcode|20586
        *(xr_it.wp)= (word)(p_len);				// dummy pattern block pcode
        //b ||mov|13,pthen(xr)|7,xl||store successor pointer|20587
        *((word *)(CFP_B*PTHEN + xr))= xl;				// store successor pointer
        //b ||exi|1,4|||take successful exit|20588
        C_EXIT(4);				// take successful exit
//      here if evaluation fails
// evli1:
        //b |evli1|exi|1,3|||take failure return|20592
        } /* _l0565 */
        

        void evli1() {
        C_EXIT(3);				// take failure return
//      here if argument is not integer
// evli2:
        //b |evli2|exi|1,1|||take non-integer error exit|20596
        } /* evli1 */
        

        void evli2() {
        C_EXIT(1);				// take non-integer error exit
//      here if argument is out of range
// evli3:
        //b |evli3|exi|1,2|||take out-of-range error exit|20600
        } /* evli2 */
        

        void evli3() {
        C_EXIT(2);				// take out-of-range error exit
        //b ||ejc|||||20602
        
//      evalp -- evaluate expression during pattern match
//      evalp is used to evaluate an expression (by value) during
//      a pattern match. the effect is like evalx, but pattern
//      variables are stacked and restored if necessary.
//      evalp also differs from evalx in that if the result is
//      an expression it is reevaluated. this occurs repeatedly.
//      to support optimization of pos and rpos, evalp uses wc
//      to signal the caller for the case of a simple vrblk
//      that is not an expression and is not trapped.  because
//      this case cannot have any side effects, optimization is
//      possible.
//      (xr)                  node pointer
//      (wb)                  pattern match cursor
//      jsr  evalp            call to evaluate expression
//      ppm  loc              transfer loc if evaluation fails
//      (xl)                  result
//      (wa)                  first word of result block
//      (wc)                  zero if simple vrblk, else non-zero
//      (xr,wb)               destroyed (failure case only)
//      (ra)                  destroyed
//      the expression pointer is stored in parm1 of the node
//      control returns to failp on failure of evaluation
// evalp:
        //b |evalp|prc|25,r|1,1||entry point (recursive)|20633
        } /* evli3 */
        

        void evalp() {
        //b ||mov|7,xl|13,parm1(xr)||load expression pointer|20634
        xl= *((word *)(CFP_B*PARM1 + xr));				// load expression pointer
        //b ||beq|9,(xl)|22,=b_exl|6,evlp1|jump if exblk case|20635
        if ((*(xl_it.wp)-(word)(b_exl)) == 0) C_GOTO(evlp1);				// jump if exblk case
//      here for case of seblk
//      we can give a fast return if the value of the vrblk is
//      not an expression and is not trapped.
        //b ||mov|7,xl|13,sevar(xl)||load vrblk pointer|20642
        xl= *((word *)(CFP_B*SEVAR + xl));				// load vrblk pointer
        //b ||mov|7,xl|13,vrval(xl)||load value of vrblk|20643
        xl= *((word *)(CFP_B*VRVAL + xl));				// load value of vrblk
        //b ||mov|8,wa|9,(xl)||load first word of value|20644
        wa= *(xl_it.wp);				// load first word of value
        //b ||bhi|8,wa|22,=b_t__|6,evlp3|jump if not seblk, trblk or exblk|20645
        if ((wa-(word)(b_t__)) > 0) C_GOTO(evlp3);				// jump if not seblk, trblk or exblk
//      here for exblk or seblk with expr value or trapped value
// evlp1:
        //b |evlp1|chk||||check for stack space|20649
        C_GOTO(evlp1);
        } /* evalp */
        

        void evlp1() {
        if(xs<v.lowspmin) { C_GOTO(sec06); } /* stack overflow check */				// check for stack space
        //b ||mov|11,-(xs)|7,xr||stack node pointer|20650
        C_PUSH(xr);				// stack node pointer
        //b ||mov|11,-(xs)|8,wb||stack cursor|20651
        C_PUSH(wb);				// stack cursor
        //b ||mov|11,-(xs)|3,r_pms||stack subject string pointer|20652
        C_PUSH(v.r_pms);				// stack subject string pointer
        //b ||mov|11,-(xs)|3,pmssl||stack subject string length|20653
        C_PUSH(v.pmssl);				// stack subject string length
        //b ||mov|11,-(xs)|3,pmdfl||stack dot flag|20654
        C_PUSH(v.pmdfl);				// stack dot flag
        //b ||mov|11,-(xs)|3,pmhbs||stack history stack base pointer|20655
        C_PUSH(v.pmhbs);				// stack history stack base pointer
        //b ||mov|7,xr|13,parm1(xr)||load expression pointer|20656
        xr= *((word *)(CFP_B*PARM1 + xr));				// load expression pointer
        //b ||ejc|||||20657
        
//      evalp (continued)
//      loop back here to reevaluate expression result
// evlp2:
        //b |evlp2|zer|8,wb|||set flag for by value|20663
        C_GOTO(evlp2);
        } /* evlp1 */
        

        void evlp2() {
        wb=0;				// set flag for by value
        //b ||ppm|6,evlp4|||jump on failure|20665
        C_JSR_1(evalx,C_GOTO(evlp4));				// jump on failure
        //b ||mov|8,wa|9,(xr)||else load first word of value|20666
        wa= *(xr_it.wp);				// else load first word of value
        //b ||blo|8,wa|22,=b_e__|6,evlp2|loop back to reevaluate expression|20667
        if ((wa-(word)(b_e__)) < 0) C_GOTO(evlp2);				// loop back to reevaluate expression
//      here to restore pattern values after successful eval
        //b ||mov|7,xl|7,xr||copy result pointer|20671
        xl= xr;				// copy result pointer
        //b ||mov|3,pmhbs|10,(xs)+||restore history stack base pointer|20672
        v.pmhbs= C_POP();				// restore history stack base pointer
        //b ||mov|3,pmdfl|10,(xs)+||restore dot flag|20673
        v.pmdfl= C_POP();				// restore dot flag
        //b ||mov|3,pmssl|10,(xs)+||restore subject string length|20674
        v.pmssl= C_POP();				// restore subject string length
        //b ||mov|3,r_pms|10,(xs)+||restore subject string pointer|20675
        v.r_pms= C_POP();				// restore subject string pointer
        //b ||mov|8,wb|10,(xs)+||restore cursor|20676
        wb= C_POP();				// restore cursor
        //b ||mov|7,xr|10,(xs)+||restore node pointer|20677
        xr= C_POP();				// restore node pointer
        //b ||mov|8,wc|7,xr||non-zero for simple vrblk|20678
        wc= xr;				// non-zero for simple vrblk
        //b ||exi||||return to evalp caller|20679
        C_EXIT(0);				// return to evalp caller
//      here to return after simple vrblk case
// evlp3:
        //b |evlp3|zer|8,wc|||simple vrblk, no side effects|20683
        } /* evlp2 */
        

        void evlp3() {
        wc=0;				// simple vrblk, no side effects
        //b ||exi||||return to evalp caller|20684
        C_EXIT(0);				// return to evalp caller
//      here for failure during evaluation
// evlp4:
        //b |evlp4|mov|3,pmhbs|10,(xs)+||restore history stack base pointer|20688
        } /* evlp3 */
        

        void evlp4() {
        v.pmhbs= C_POP();				// restore history stack base pointer
        //b ||mov|3,pmdfl|10,(xs)+||restore dot flag|20689
        v.pmdfl= C_POP();				// restore dot flag
        //b ||mov|3,pmssl|10,(xs)+||restore subject string length|20690
        v.pmssl= C_POP();				// restore subject string length
        //b ||mov|3,r_pms|10,(xs)+||restore subject string pointer|20691
        v.r_pms= C_POP();				// restore subject string pointer
        //b ||add|7,xs|19,*num02||remove node ptr, cursor|20692
        xs += CFP_B*NUM02;				// remove node ptr, cursor
        //b ||exi|1,1|||take failure exit|20693
        C_EXIT(1);				// take failure exit
        //b ||ejc|||||20695
        
//      evals -- evaluate string argument
//      evals is used by span, any, notany, break, breakx when
//      they are passed an expression argument.
//      (xr)                  node pointer
//      (wb)                  cursor
//      jsr  evals            call to evaluate string
//      ppm  loc              transfer loc for non-string arg
//      ppm  loc              transfer loc for evaluation failure
//      ppm  loc              transfer loc for successful eval
//      (the normal return is never taken)
//      (xr)                  ptr to node with parms set
//      (xl,wc,ra)            destroyed
//      on return, the node pointed to has a character table
//      pointer in parm1 and a bit mask in parm2. the proper
//      successor is stored in pthen of this node. thus it is
//      ok for merging with the normal (multi-char string) case.
// evals:
        //b |evals|prc|25,r|1,3||entry point (recursive)|20717
        } /* evlp4 */
        

        void evals() {
        //b ||ppm|6,evls1|||jump if evaluation fails|20719
        C_JSR_1(evalp,C_GOTO(evls1));				// jump if evaluation fails
        //b ||mov|11,-(xs)|13,pthen(xr)||save successor pointer|20720
        C_PUSH(*((word *)(CFP_B*PTHEN + xr)));				// save successor pointer
        //b ||mov|11,-(xs)|8,wb||save cursor|20721
        C_PUSH(wb);				// save cursor
        //b ||mov|11,-(xs)|7,xl||stack result ptr for patst|20722
        C_PUSH(xl);				// stack result ptr for patst
        //b ||zer|8,wb|||dummy pcode for one char string|20723
        wb=0;				// dummy pcode for one char string
        //b ||zer|8,wc|||dummy pcode for expression arg|20724
        wc=0;				// dummy pcode for expression arg
        //b ||mov|7,xl|22,=p_brk||appropriate pcode for our use|20725
        xl= (word)(p_brk);				// appropriate pcode for our use
        //b ||ppm|6,evls2|||jump if not string|20727
        extern void _l0574();
        C_JMS(patst,P_PRC_PATST,_l0574);
        } /* evals */
        

        void _l0574() {
        C_JMS_HANDLE_1(patst,C_GOTO(evls2));				// jump if not string
        //b ||mov|8,wb|10,(xs)+||restore cursor|20728
        wb= C_POP();				// restore cursor
        //b ||mov|13,pthen(xr)|10,(xs)+||store successor pointer|20729
        *((word *)(CFP_B*PTHEN + xr))= C_POP();				// store successor pointer
        //b ||exi|1,3|||take success return|20730
        C_EXIT(3);				// take success return
//      here if evaluation fails
// evls1:
        //b |evls1|exi|1,2|||take failure return|20734
        } /* _l0574 */
        

        void evls1() {
        C_EXIT(2);				// take failure return
//      here if argument is not string
// evls2:
        //b |evls2|add|7,xs|19,*num02||pop successor and cursor|20738
        } /* evls1 */
        

        void evls2() {
        xs += CFP_B*NUM02;				// pop successor and cursor
        //b ||exi|1,1|||take non-string error exit|20739
        C_EXIT(1);				// take non-string error exit
        //b ||ejc|||||20741
        
//      evalx -- evaluate expression
//      evalx is called to evaluate an expression
//      (xr)                  pointer to exblk or seblk
//      (wb)                  0 if by value, 1 if by name
//      jsr  evalx            call to evaluate expression
//      ppm  loc              transfer loc if evaluation fails
//      (xr)                  result if called by value
//      (xl,wa)               result name base,offset if by name
//      (xr)                  destroyed (name case only)
//      (xl,wa)               destroyed (value case only)
//      (wb,wc,ra)            destroyed
// evalx:
        //b |evalx|prc|25,r|1,1||entry point, recursive|20757
        } /* evls2 */
        

        void evalx() {
        //b ||beq|9,(xr)|22,=b_exl|6,evlx2|jump if exblk case|20758
        if ((*(xr_it.wp)-(word)(b_exl)) == 0) C_GOTO(evlx2);				// jump if exblk case
//      here for seblk
        //b ||mov|7,xl|13,sevar(xr)||load vrblk pointer (name base)|20762
        xl= *((word *)(CFP_B*SEVAR + xr));				// load vrblk pointer (name base)
        //b ||mov|8,wa|19,*vrval||set name offset|20763
        wa= CFP_B*VRVAL;				// set name offset
        //b ||bnz|8,wb|6,evlx1||jump if called by name|20764
        if (wb) C_GOTO(evlx1);				// jump if called by name
        //b ||ppm|6,evlx9|||jump if failure on access|20766
        C_JSR_1(acess,C_GOTO(evlx9));				// jump if failure on access
//      merge here to exit for seblk case
// evlx1:
        //b |evlx1|exi||||return to evalx caller|20770
        C_GOTO(evlx1);
        } /* evalx */
        

        void evlx1() {
        C_EXIT(0);				// return to evalx caller
        //b ||ejc|||||20771
        
//      evalx (continued)
//      here for full expression (exblk) case
//      if an error occurs in the expression code at execution
//      time, control is passed via error section to exfal
//      without returning to this routine.
//      the following entries are made on the stack before
//      giving control to the expression code
//                            evalx return point
//                            saved value of r_cod
//                            code pointer (-r_cod)
//                            saved value of flptr
//                            0 if by value, 1 if by name
//      flptr --------------- *exflc, fail offset in exblk
// evlx2:
        //b |evlx2|scp|8,wc|||get code pointer|20790
        } /* evlx1 */
        

        void evlx2() {
        wc= reg_cp;				// get code pointer
        //b ||mov|8,wa|3,r_cod||load code block pointer|20791
        wa= v.r_cod;				// load code block pointer
        //b ||sub|8,wc|8,wa||get code pointer as offset|20792
        wc -= wa;				// get code pointer as offset
        //b ||mov|11,-(xs)|8,wa||stack old code block pointer|20793
        C_PUSH(wa);				// stack old code block pointer
        //b ||mov|11,-(xs)|8,wc||stack relative code offset|20794
        C_PUSH(wc);				// stack relative code offset
        //b ||mov|11,-(xs)|3,flptr||stack old failure pointer|20795
        C_PUSH(v.flptr);				// stack old failure pointer
        //b ||mov|11,-(xs)|8,wb||stack name/value indicator|20796
        C_PUSH(wb);				// stack name/value indicator
        //b ||mov|11,-(xs)|19,*exflc||stack new fail offset|20797
        C_PUSH(CFP_B*EXFLC);				// stack new fail offset
        //b ||mov|3,gtcef|3,flptr||keep in case of error|20798
        v.gtcef= v.flptr;				// keep in case of error
        //b ||mov|3,r_gtc|3,r_cod||keep code block pointer similarly|20799
        v.r_gtc= v.r_cod;				// keep code block pointer similarly
        //b ||mov|3,flptr|7,xs||set new failure pointer|20800
        v.flptr= xs;				// set new failure pointer
        //b ||mov|3,r_cod|7,xr||set new code block pointer|20801
        v.r_cod= xr;				// set new code block pointer
        //b ||mov|13,exstm(xr)|3,kvstn||remember stmnt number|20802
        *((word *)(CFP_B*EXSTM + xr))= v.kvstn;				// remember stmnt number
        //b ||add|7,xr|19,*excod||point to first code word|20803
        xr += CFP_B*EXCOD;				// point to first code word
        //b ||lcp|7,xr|||set code pointer|20804
        reg_cp = xr;				// set code pointer
        //b ||bne|3,stage|18,=stgxt|6,evlx0|jump if not execution time|20805
        if ((v.stage-STGXT) != 0) C_GOTO(evlx0);				// jump if not execution time
        //b ||mov|3,stage|18,=stgee||evaluating expression|20806
        v.stage= STGEE;				// evaluating expression
//      here to execute first code word of expression
// evlx0:
        //b |evlx0|zer|7,xl|||clear garbage xl|20810
        C_GOTO(evlx0);
        } /* evlx2 */
        

        void evlx0() {
        xl=0;				// clear garbage xl
        //b ||lcw|7,xr|||load first code word|20811
        xr  = *((word *)reg_cp);				// load first code word
          reg_cp += CFP_B;
        //b ||bri|9,(xr)|||execute it|20812
        w0 = xr_it.wp[0];				// execute it
        C_GOTO(w0_it.callp);
        //b ||ejc|||||20813
        
//      evalx (continued)
//      come here if successful return by value (see o_rvl)
// evlx3:
        //b |evlx3|mov|7,xr|10,(xs)+||load value|20819
        } /* evlx0 */
        

        void evlx3() {
        xr= C_POP();				// load value
        //b ||bze|13,num01(xs)|6,evlx5||jump if called by value|20820
        if ( !( *((word *)(CFP_B*NUM01 + xs))) ) C_GOTO(evlx5);				// jump if called by value
        //b ||erb|1,249|26,expression evaluated by name returned value|||20821
        C_ERB(249)
//      here for expression returning by name (see o_rnm)
// evlx4:
        //b |evlx4|mov|8,wa|10,(xs)+||load name offset|20825
        } /* evlx3 */
        

        void evlx4() {
        wa= C_POP();				// load name offset
        //b ||mov|7,xl|10,(xs)+||load name base|20826
        xl= C_POP();				// load name base
        //b ||bnz|13,num01(xs)|6,evlx5||jump if called by name|20827
        if (*((word *)(CFP_B*NUM01 + xs))) C_GOTO(evlx5);				// jump if called by name
        //b ||ppm|6,evlx6|||jump if failure during access|20829
        C_JSR_1(acess,C_GOTO(evlx6));				// jump if failure during access
//      here after loading correct result into xr or xl,wa
// evlx5:
        //b |evlx5|zer|8,wb|||note successful|20833
        C_GOTO(evlx5);
        } /* evlx4 */
        

        void evlx5() {
        wb=0;				// note successful
        //b ||brn|6,evlx7|||merge|20834
         C_GOTO(evlx7);				// merge
//      here for failure in expression evaluation (see o_fex)
// evlx6:
        //b |evlx6|mnz|8,wb|||note unsuccessful|20838
        } /* evlx5 */
        

        void evlx6() {
        wb = 0xffffffffffffffff;				// note unsuccessful
//      restore environment
// evlx7:
        //b |evlx7|bne|3,stage|18,=stgee|6,evlx8|skip if was not previously xt|20842
        C_GOTO(evlx7);
        } /* evlx6 */
        

        void evlx7() {
        if ((v.stage-STGEE) != 0) C_GOTO(evlx8);				// skip if was not previously xt
        //b ||mov|3,stage|18,=stgxt||execute time|20843
        v.stage= STGXT;				// execute time
//      merge with stage set up
// evlx8:
        //b |evlx8|add|7,xs|19,*num02||pop name/value indicator, *exfal|20847
        C_GOTO(evlx8);
        } /* evlx7 */
        

        void evlx8() {
        xs += CFP_B*NUM02;				// pop name/value indicator, *exfal
        //b ||mov|3,flptr|10,(xs)+||restore old failure pointer|20848
        v.flptr= C_POP();				// restore old failure pointer
        //b ||mov|8,wc|10,(xs)+||load code offset|20849
        wc= C_POP();				// load code offset
        //b ||add|8,wc|9,(xs)||make code pointer absolute|20850
        wc += *(xs_it.wp);				// make code pointer absolute
        //b ||mov|3,r_cod|10,(xs)+||restore old code block pointer|20851
        v.r_cod= C_POP();				// restore old code block pointer
        //b ||lcp|8,wc|||restore old code pointer|20852
        reg_cp = wc;				// restore old code pointer
        //b ||bze|8,wb|6,evlx1||jump for successful return|20853
        if ( !( wb) ) C_GOTO(evlx1);				// jump for successful return
//      merge here for failure in seblk case
// evlx9:
        //b |evlx9|exi|1,1|||take failure exit|20857
        C_GOTO(evlx9);
        } /* evlx8 */
        

        void evlx9() {
        C_EXIT(1);				// take failure exit
        //b ||ejc|||||20859
        
//      exbld -- build exblk
//      exbld is used to build an expression block from the
//      code compiled most recently in the current ccblk.
//      (xl)                  offset in ccblk to start of code
//      (wb)                  integer in range 0 le n le mxlen
//      jsr  exbld            call to build exblk
//      (xr)                  ptr to constructed exblk
//      (wa,wb,xl)            destroyed
// exbld:
        //b |exbld|prc|25,e|1,0||entry point|20872
        } /* evlx9 */
        

        void exbld() {
        //b ||mov|8,wa|7,xl||copy offset to start of code|20873
        wa= xl;				// copy offset to start of code
        //b ||sub|8,wa|19,*excod||calc reduction in offset in exblk|20874
        wa -= CFP_B*EXCOD;				// calc reduction in offset in exblk
        //b ||mov|11,-(xs)|8,wa||stack for later|20875
        C_PUSH(wa);				// stack for later
        //b ||mov|8,wa|3,cwcof||load final offset|20876
        wa= v.cwcof;				// load final offset
        //b ||sub|8,wa|7,xl||compute length of code|20877
        wa -= xl;				// compute length of code
        //b ||add|8,wa|19,*exsi_||add space for standard fields|20878
        wa += CFP_B*EXSI_;				// add space for standard fields
        //b ||jsr|6,alloc|||allocate space for exblk|20879
        C_JSR(alloc);				// allocate space for exblk
        //b ||mov|11,-(xs)|7,xr||save pointer to exblk|20880
        C_PUSH(xr);				// save pointer to exblk
        //b ||mov|13,extyp(xr)|22,=b_exl||store type word|20881
        *((word *)(CFP_B*EXTYP + xr))= (word)(b_exl);				// store type word
        //b ||zer|13,exstm(xr)|||zeroise stmnt number field|20882
        *((word *)(CFP_B*EXSTM + xr))=0;				// zeroise stmnt number field
        //b ||mov|13,exsln(xr)|3,cmpln||set line number field|20884
        *((word *)(CFP_B*EXSLN + xr))= v.cmpln;				// set line number field
        //b ||mov|13,exlen(xr)|8,wa||store length|20886
        *((word *)(CFP_B*EXLEN + xr))= wa;				// store length
        //b ||mov|13,exflc(xr)|21,=ofex_||store failure word|20887
        *((word *)(CFP_B*EXFLC + xr))= (word)(&c.ofex_);				// store failure word
        //b ||add|7,xr|19,*exsi_||set xr for mvw|20888
        xr += CFP_B*EXSI_;				// set xr for mvw
        //b ||mov|3,cwcof|7,xl||reset offset to start of code|20889
        v.cwcof= xl;				// reset offset to start of code
        //b ||add|7,xl|3,r_ccb||point to start of code|20890
        xl += v.r_ccb;				// point to start of code
        //b ||sub|8,wa|19,*exsi_||length of code to move|20891
        wa -= CFP_B*EXSI_;				// length of code to move
        //b ||mov|11,-(xs)|8,wa||stack length of code|20892
        C_PUSH(wa);				// stack length of code
        //b ||mvw||||move code to exblk|20893
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// move code to exblk
        //b ||mov|8,wa|10,(xs)+||get length of code|20894
        wa= C_POP();				// get length of code
        //b ||btw|8,wa|||convert byte count to word count|20895
        wa >>= LOG_CFP_B;				// convert byte count to word count
        //b ||lct|8,wa|8,wa||prepare counter for loop|20896
        wa= wa;				// prepare counter for loop
        //b ||mov|7,xl|9,(xs)||copy exblk ptr, dont unstack|20897
        xl= *(xs_it.wp);				// copy exblk ptr, dont unstack
        //b ||add|7,xl|19,*excod||point to code itself|20898
        xl += CFP_B*EXCOD;				// point to code itself
        //b ||mov|8,wb|13,num01(xs)||get reduction in offset|20899
        wb= *((word *)(CFP_B*NUM01 + xs));				// get reduction in offset
//      this loop searches for negation and selection code so
//      that the offsets computed whilst code was in code block
//      can be transformed to reduced values applicable in an
//      exblk.
// exbl1:
        //b |exbl1|mov|7,xr|10,(xl)+||get next code word|20906
        C_GOTO(exbl1);
        } /* exbld */
        

        void exbl1() {
        xr= *(xl_it.wp++);				// get next code word
        //b ||beq|7,xr|21,=osla_|6,exbl3|jump if selection found|20907
        if ((xr-(word)(&c.osla_)) == 0) C_GOTO(exbl3);				// jump if selection found
        //b ||beq|7,xr|21,=onta_|6,exbl3|jump if negation found|20908
        if ((xr-(word)(&c.onta_)) == 0) C_GOTO(exbl3);				// jump if negation found
        //b ||bct|8,wa|6,exbl1||loop to end of code|20909
        if ((--wa))  C_GOTO(exbl1);				// loop to end of code
//      no selection found or merge to exit on termination
// exbl2:
        //b |exbl2|mov|7,xr|10,(xs)+||pop exblk ptr into xr|20913
        C_GOTO(exbl2);
        } /* exbl1 */
        

        void exbl2() {
        xr= C_POP();				// pop exblk ptr into xr
        //b ||mov|7,xl|10,(xs)+||pop reduction constant|20914
        xl= C_POP();				// pop reduction constant
        //b ||exi||||return to caller|20915
        C_EXIT(0);				// return to caller
        //b ||ejc|||||20916
        
//      exbld (continued)
//      selection or negation found
//      reduce the offsets as needed. offsets occur in words
//      following code words -
//           =onta_, =osla_, =oslb_, =oslc_
// exbl3:
        //b |exbl3|sub|10,(xl)+|8,wb||adjust offset|20925
        } /* exbl2 */
        

        void exbl3() {
        *(xl_it.wp++) -= wb;				// adjust offset
        //b ||bct|8,wa|6,exbl4||decrement count|20926
        if ((--wa))  C_GOTO(exbl4);				// decrement count
// exbl4:
        //b |exbl4|bct|8,wa|6,exbl5||decrement count|20928
        C_GOTO(exbl4);
        } /* exbl3 */
        

        void exbl4() {
        if ((--wa))  C_GOTO(exbl5);				// decrement count
//      continue search for more offsets
// exbl5:
        //b |exbl5|mov|7,xr|10,(xl)+||get next code word|20932
        C_GOTO(exbl5);
        } /* exbl4 */
        

        void exbl5() {
        xr= *(xl_it.wp++);				// get next code word
        //b ||beq|7,xr|21,=osla_|6,exbl3|jump if offset found|20933
        if ((xr-(word)(&c.osla_)) == 0) C_GOTO(exbl3);				// jump if offset found
        //b ||beq|7,xr|21,=oslb_|6,exbl3|jump if offset found|20934
        if ((xr-(word)(&c.oslb_)) == 0) C_GOTO(exbl3);				// jump if offset found
        //b ||beq|7,xr|21,=oslc_|6,exbl3|jump if offset found|20935
        if ((xr-(word)(&c.oslc_)) == 0) C_GOTO(exbl3);				// jump if offset found
        //b ||beq|7,xr|21,=onta_|6,exbl3|jump if offset found|20936
        if ((xr-(word)(&c.onta_)) == 0) C_GOTO(exbl3);				// jump if offset found
        //b ||bct|8,wa|6,exbl5||loop|20937
        if ((--wa))  C_GOTO(exbl5);				// loop
        //b ||brn|6,exbl2|||merge to return|20938
         C_GOTO(exbl2);				// merge to return
        //b ||ejc|||||20940
        
//      expan -- analyze expression
//      the expression analyzer (expan) procedure is used to scan
//      an expression and convert it into a tree representation.
//      see the description of cmblk in the structures section
//      for detailed format of tree blocks.
//      the analyzer uses a simple precedence scheme in which
//      operands and operators are placed on a single stack
//      and condensations are made when low precedence operators
//      are stacked after a higher precedence operator. a global
//      variable (in wb) keeps track of the level as follows.
//      0    scanning outer level of statement or expression
//      1    scanning outer level of normal goto
//      2    scanning outer level of direct goto
//      3    scanning inside array brackets
//      4    scanning inside grouping parentheses
//      5    scanning inside function parentheses
//      this variable is saved on the stack on encountering a
//      grouping and restored at the end of the grouping.
//      another global variable (in wc) counts the number of
//      items at one grouping level and is incremented for each
//      comma encountered. it is stacked with the level indicator
//      the scan is controlled by a three state finite machine.
//      a global variable stored in wa is the current state.
//      wa=0                  nothing scanned at this level
//      wa=1                  operand expected
//      wa=2                  operator expected
//      (wb)                  call type (see below)
//      jsr  expan            call to analyze expression
//      (xr)                  pointer to resulting tree
//      (xl,wa,wb,wc,ra)      destroyed
//      the entry value of wb indicates the call type as follows.
//      0    scanning either the main body of a statement or the
//           text of an expression (from eval call). valid
//           terminators are colon, semicolon. the rescan flag is
//           set to return the terminator on the next scane call.
//      1    scanning a normal goto. the only valid
//           terminator is a right paren.
//      2    scanning a direct goto. the only valid
//           terminator is a right bracket.
        //b ||ejc|||||20993
        
//      expan (continued)
//      entry point
// expan:
        //b |expan|prc|25,e|1,0||entry point|20999
        } /* exbl5 */
        

        void expan() {
        //b ||zer|11,-(xs)|||set top of stack indicator|21000
        *(--xs_it.wp)=0;				// set top of stack indicator
        //b ||zer|8,wa|||set initial state to zero|21001
        wa=0;				// set initial state to zero
        //b ||zer|8,wc|||zero counter value|21002
        wc=0;				// zero counter value
//      loop here for successive entries
// exp01:
        //b |exp01|jsr|6,scane|||scan next element|21006
        C_GOTO(exp01);
        } /* expan */
        

        void exp01() {
        C_JSR(scane);				// scan next element
        //b ||add|7,xl|8,wa||add state to syntax code|21007
        xl += wa;				// add state to syntax code
        //b ||bsw|7,xl|2,t_nes||switch on element type/state|21008
        extern word _l0583 [];				// switch on element type/state
        { w0 = ((word *)_l0583)[xl];  C_GOTO(w0_it.callp);}
        }  /* exp01 */
        

        word  _l0583 [] = {
        //b ||iff|2,t_uo0|6,exp27||unop, s=0|21045
        	(word)((word)(exp27)),				// unop, s=0
        //b ||iff|2,t_uo1|6,exp27||unop, s=1|21045
        	(word)((word)(exp27)),				// unop, s=1
        //b ||iff|2,t_uo2|6,exp04||unop, s=2|21045
        	(word)((word)(exp04)),				// unop, s=2
        //b ||iff|2,t_lp0|6,exp06||left paren, s=0|21045
        	(word)((word)(exp06)),				// left paren, s=0
        //b ||iff|2,t_lp1|6,exp06||left paren, s=1|21045
        	(word)((word)(exp06)),				// left paren, s=1
        //b ||iff|2,t_lp2|6,exp04||left paren, s=2|21045
        	(word)((word)(exp04)),				// left paren, s=2
        //b ||iff|2,t_lb0|6,exp08||left brkt, s=0|21045
        	(word)((word)(exp08)),				// left brkt, s=0
        //b ||iff|2,t_lb1|6,exp08||left brkt, s=1|21045
        	(word)((word)(exp08)),				// left brkt, s=1
        //b ||iff|2,t_lb2|6,exp09||left brkt, s=2|21045
        	(word)((word)(exp09)),				// left brkt, s=2
        //b ||iff|2,t_cm0|6,exp02||comma, s=0|21045
        	(word)((word)(exp02)),				// comma, s=0
        //b ||iff|2,t_cm1|6,exp05||comma, s=1|21045
        	(word)((word)(exp05)),				// comma, s=1
        //b ||iff|2,t_cm2|6,exp11||comma, s=2|21045
        	(word)((word)(exp11)),				// comma, s=2
        //b ||iff|2,t_fn0|6,exp10||function, s=0|21045
        	(word)((word)(exp10)),				// function, s=0
        //b ||iff|2,t_fn1|6,exp10||function, s=1|21045
        	(word)((word)(exp10)),				// function, s=1
        //b ||iff|2,t_fn2|6,exp04||function, s=2|21045
        	(word)((word)(exp04)),				// function, s=2
        //b ||iff|2,t_va0|6,exp03||variable, s=0|21045
        	(word)((word)(exp03)),				// variable, s=0
        //b ||iff|2,t_va1|6,exp03||variable, state one|21045
        	(word)((word)(exp03)),				// variable, state one
        //b ||iff|2,t_va2|6,exp04||variable, s=2|21045
        	(word)((word)(exp04)),				// variable, s=2
        //b ||iff|2,t_co0|6,exp03||constant, s=0|21045
        	(word)((word)(exp03)),				// constant, s=0
        //b ||iff|2,t_co1|6,exp03||constant, s=1|21045
        	(word)((word)(exp03)),				// constant, s=1
        //b ||iff|2,t_co2|6,exp04||constant, s=2|21045
        	(word)((word)(exp04)),				// constant, s=2
        //b ||iff|2,t_bo0|6,exp05||binop, s=0|21045
        	(word)((word)(exp05)),				// binop, s=0
        //b ||iff|2,t_bo1|6,exp05||binop, s=1|21045
        	(word)((word)(exp05)),				// binop, s=1
        //b ||iff|2,t_bo2|6,exp26||binop, s=2|21045
        	(word)((word)(exp26)),				// binop, s=2
        //b ||iff|2,t_rp0|6,exp02||right paren, s=0|21045
        	(word)((word)(exp02)),				// right paren, s=0
        //b ||iff|2,t_rp1|6,exp05||right paren, s=1|21045
        	(word)((word)(exp05)),				// right paren, s=1
        //b ||iff|2,t_rp2|6,exp12||right paren, s=2|21045
        	(word)((word)(exp12)),				// right paren, s=2
        //b ||iff|2,t_rb0|6,exp02||right brkt, s=0|21045
        	(word)((word)(exp02)),				// right brkt, s=0
        //b ||iff|2,t_rb1|6,exp05||right brkt, s=1|21045
        	(word)((word)(exp05)),				// right brkt, s=1
        //b ||iff|2,t_rb2|6,exp18||right brkt, s=2|21045
        	(word)((word)(exp18)),				// right brkt, s=2
        //b ||iff|2,t_cl0|6,exp02||colon, s=0|21045
        	(word)((word)(exp02)),				// colon, s=0
        //b ||iff|2,t_cl1|6,exp05||colon, s=1|21045
        	(word)((word)(exp05)),				// colon, s=1
        //b ||iff|2,t_cl2|6,exp19||colon, s=2|21045
        	(word)((word)(exp19)),				// colon, s=2
        //b ||iff|2,t_sm0|6,exp02||semicolon, s=0|21045
        	(word)((word)(exp02)),				// semicolon, s=0
        //b ||iff|2,t_sm1|6,exp05||semicolon, s=1|21045
        	(word)((word)(exp05)),				// semicolon, s=1
        //b ||iff|2,t_sm2|6,exp19||semicolon, s=2|21045
        	(word)((word)(exp19)),				// semicolon, s=2
        //b ||esw||||end switch on element type/state|21045
             }; /* bsw list for _l0583 */				// end switch on element type/state
        //b ||ejc|||||21046
        
//      expan (continued)
//      here for rbr,rpr,col,smc,cma in state 0
//      set to rescan the terminator encountered and create
//      a null constant (case of omitted null)
// exp02:
        //b |exp02|mnz|3,scnrs|||set to rescan element|21055
        void exp02() {
        v.scnrs = 0xffffffffffffffff;				// set to rescan element
        //b ||mov|7,xr|21,=nulls||point to null, merge|21056
        xr= (word)(&c.nulls);				// point to null, merge
//      here for var or con in states 0,1
//      stack the variable/constant and set state=2
// exp03:
        //b |exp03|mov|11,-(xs)|7,xr||stack pointer to operand|21062
        C_GOTO(exp03);
        } /* exp02 */
        

        void exp03() {
        C_PUSH(xr);				// stack pointer to operand
        //b ||mov|8,wa|18,=num02||set state 2|21063
        wa= NUM02;				// set state 2
        //b ||brn|6,exp01|||jump for next element|21064
         C_GOTO(exp01);				// jump for next element
//      here for var,con,lpr,fnc,uop in state 2
//      we rescan the element and create a concatenation operator
//      this is the case of the blank concatenation operator.
// exp04:
        //b |exp04|mnz|3,scnrs|||set to rescan element|21071
        } /* exp03 */
        

        void exp04() {
        v.scnrs = 0xffffffffffffffff;				// set to rescan element
        //b ||mov|7,xr|21,=opdvc||point to concat operator dv|21072
        xr= (word)(&c.opdvc);				// point to concat operator dv
        //b ||bze|8,wb|6,exp4a||ok if at top level|21073
        if ( !( wb) ) C_GOTO(exp4a);				// ok if at top level
        //b ||mov|7,xr|21,=opdvp||else point to unmistakable concat.|21074
        xr= (word)(&c.opdvp);				// else point to unmistakable concat.
//      merge here when xr set up with proper concatenation dvblk
// exp4a:
        //b |exp4a|bnz|3,scnbl|6,exp26||merge bop if blanks, else error|21078
        C_GOTO(exp4a);
        } /* exp04 */
        

        void exp4a() {
        if (v.scnbl) C_GOTO(exp26);				// merge bop if blanks, else error
//      dcv  scnse            adjust start of element location
        //b ||erb|1,220|26,syntax error: missing operator|||21080
        C_ERB(220)
//      here for cma,rpr,rbr,col,smc,bop(s=1) bop(s=0)
//      this is an erronous contruction
//exp05 dcv  scnse            adjust start of element location
// exp05:
        //b |exp05|erb|1,221|26,syntax error: missing operand|||21088
        } /* exp4a */
        

        void exp05() {
        C_ERB(221)
//      here for lpr (s=0,1)
// exp06:
        //b |exp06|mov|7,xl|18,=num04||set new level indicator|21092
        } /* exp05 */
        

        void exp06() {
        xl= NUM04;				// set new level indicator
        //b ||zer|7,xr|||set zero value for cmopn|21093
        xr=0;				// set zero value for cmopn
        //b ||ejc|||||21094
        
//      expan (continued)
//      merge here to store old level on stack and start new one
// exp07:
        //b |exp07|mov|11,-(xs)|7,xr||stack cmopn value|21100
        C_GOTO(exp07);
        } /* exp06 */
        

        void exp07() {
        C_PUSH(xr);				// stack cmopn value
        //b ||mov|11,-(xs)|8,wc||stack old counter|21101
        C_PUSH(wc);				// stack old counter
        //b ||mov|11,-(xs)|8,wb||stack old level indicator|21102
        C_PUSH(wb);				// stack old level indicator
        //b ||chk||||check for stack overflow|21103
        if(xs<v.lowspmin) { C_GOTO(sec06); } /* stack overflow check */				// check for stack overflow
        //b ||zer|8,wa|||set new state to zero|21104
        wa=0;				// set new state to zero
        //b ||mov|8,wb|7,xl||set new level indicator|21105
        wb= xl;				// set new level indicator
        //b ||mov|8,wc|18,=num01||initialize new counter|21106
        wc= NUM01;				// initialize new counter
        //b ||brn|6,exp01|||jump to scan next element|21107
         C_GOTO(exp01);				// jump to scan next element
//      here for lbr (s=0,1)
//      this is an illegal use of left bracket
// exp08:
        //b |exp08|erb|1,222|26,syntax error: invalid use of left bracket|||21113
        } /* exp07 */
        

        void exp08() {
        C_ERB(222)
//      here for lbr (s=2)
//      set new level and start to scan subscripts
// exp09:
        //b |exp09|mov|7,xr|10,(xs)+||load array ptr for cmopn|21119
        } /* exp08 */
        

        void exp09() {
        xr= C_POP();				// load array ptr for cmopn
        //b ||mov|7,xl|18,=num03||set new level indicator|21120
        xl= NUM03;				// set new level indicator
        //b ||brn|6,exp07|||jump to stack old and start new|21121
         C_GOTO(exp07);				// jump to stack old and start new
//      here for fnc (s=0,1)
//      stack old level and start to scan arguments
// exp10:
        //b |exp10|mov|7,xl|18,=num05||set new lev indic (xr=vrblk=cmopn)|21127
        } /* exp09 */
        

        void exp10() {
        xl= NUM05;				// set new lev indic (xr=vrblk=cmopn)
        //b ||brn|6,exp07|||jump to stack old and start new|21128
         C_GOTO(exp07);				// jump to stack old and start new
//      here for cma (s=2)
//      increment argument count and continue
// exp11:
        //b |exp11|icv|8,wc|||increment counter|21134
        } /* exp10 */
        

        void exp11() {
        (wc)++;				// increment counter
        //b ||jsr|6,expdm|||dump operators at this level|21135
        extern void _l0584();
        C_JMS(expdm,P_PRC_EXPDM,_l0584);
        } /* exp11 */
        

        void _l0584() {
        //b ||zer|11,-(xs)|||set new level for parameter|21136
        *(--xs_it.wp)=0;				// set new level for parameter
        //b ||zer|8,wa|||set new state|21137
        wa=0;				// set new state
        //b ||bgt|8,wb|18,=num02|6,exp01|loop back unless outer level|21138
        if ((wb-NUM02) > 0) C_GOTO(exp01);				// loop back unless outer level
        //b ||erb|1,223|26,syntax error: invalid use of comma|||21139
        C_ERB(223)
        //b ||ejc|||||21140
        
//      expan (continued)
//      here for rpr (s=2)
//      at outer level in a normal goto this is a terminator
//      otherwise it must terminate a function or grouping
// exp12:
        //b |exp12|beq|8,wb|18,=num01|6,exp20|end of normal goto|21149
        } /* _l0584 */
        

        void exp12() {
        if ((wb-NUM01) == 0) C_GOTO(exp20);				// end of normal goto
        //b ||beq|8,wb|18,=num05|6,exp13|end of function arguments|21150
        if ((wb-NUM05) == 0) C_GOTO(exp13);				// end of function arguments
        //b ||beq|8,wb|18,=num04|6,exp14|end of grouping / selection|21151
        if ((wb-NUM04) == 0) C_GOTO(exp14);				// end of grouping / selection
        //b ||erb|1,224|26,syntax error: unbalanced right parenthesis|||21152
        C_ERB(224)
//      here at end of function arguments
// exp13:
        //b |exp13|mov|7,xl|18,=c_fnc||set cmtyp value for function|21156
        } /* exp12 */
        

        void exp13() {
        xl= C_FNC;				// set cmtyp value for function
        //b ||brn|6,exp15|||jump to build cmblk|21157
         C_GOTO(exp15);				// jump to build cmblk
//      here for end of grouping
// exp14:
        //b |exp14|beq|8,wc|18,=num01|6,exp17|jump if end of grouping|21161
        } /* exp13 */
        

        void exp14() {
        if ((wc-NUM01) == 0) C_GOTO(exp17);				// jump if end of grouping
        //b ||mov|7,xl|18,=c_sel||else set cmtyp for selection|21162
        xl= C_SEL;				// else set cmtyp for selection
//      merge here to build cmblk for level just scanned and
//      to pop up to the previous scan level before continuing.
// exp15:
        //b |exp15|jsr|6,expdm|||dump operators at this level|21167
        C_GOTO(exp15);
        } /* exp14 */
        

        void exp15() {
        extern void _l0586();
        C_JMS(expdm,P_PRC_EXPDM,_l0586);
        } /* exp15 */
        

        void _l0586() {
        //b ||mov|8,wa|8,wc||copy count|21168
        wa= wc;				// copy count
        //b ||add|8,wa|18,=cmvls||add for standard fields at start|21169
        wa += CMVLS;				// add for standard fields at start
        //b ||wtb|8,wa|||convert length to bytes|21170
        wa <<= LOG_CFP_B;				// convert length to bytes
        //b ||jsr|6,alloc|||allocate space for cmblk|21171
        C_JSR(alloc);				// allocate space for cmblk
        //b ||mov|9,(xr)|22,=b_cmt||store type code for cmblk|21172
        *(xr_it.wp)= (word)(b_cmt);				// store type code for cmblk
        //b ||mov|13,cmtyp(xr)|7,xl||store cmblk node type indicator|21173
        *((word *)(CFP_B*CMTYP + xr))= xl;				// store cmblk node type indicator
        //b ||mov|13,cmlen(xr)|8,wa||store length|21174
        *((word *)(CFP_B*CMLEN + xr))= wa;				// store length
        //b ||add|7,xr|8,wa||point past end of block|21175
        xr += wa;				// point past end of block
        //b ||lct|8,wc|8,wc||set loop counter|21176
        wc= wc;				// set loop counter
//      loop to move remaining words to cmblk
// exp16:
        //b |exp16|mov|11,-(xr)|10,(xs)+||move one operand ptr from stack|21180
        C_GOTO(exp16);
        } /* _l0586 */
        

        void exp16() {
        *(--xr_it.wp)= C_POP();				// move one operand ptr from stack
        //b ||mov|8,wb|10,(xs)+||pop to old level indicator|21181
        wb= C_POP();				// pop to old level indicator
        //b ||bct|8,wc|6,exp16||loop till all moved|21182
        if ((--wc))  C_GOTO(exp16);				// loop till all moved
        //b ||ejc|||||21183
        
//      expan (continued)
//      complete cmblk and stack pointer to it on stack
        //b ||sub|7,xr|19,*cmvls||point back to start of block|21189
        xr -= CFP_B*CMVLS;				// point back to start of block
        //b ||mov|8,wc|10,(xs)+||restore old counter|21190
        wc= C_POP();				// restore old counter
        //b ||mov|13,cmopn(xr)|9,(xs)||store operand ptr in cmblk|21191
        *((word *)(CFP_B*CMOPN + xr))= *(xs_it.wp);				// store operand ptr in cmblk
        //b ||mov|9,(xs)|7,xr||stack cmblk pointer|21192
        *(xs_it.wp)= xr;				// stack cmblk pointer
        //b ||mov|8,wa|18,=num02||set new state|21193
        wa= NUM02;				// set new state
        //b ||brn|6,exp01|||back for next element|21194
         C_GOTO(exp01);				// back for next element
//      here at end of a parenthesized expression
// exp17:
        //b |exp17|jsr|6,expdm|||dump operators at this level|21198
        } /* exp16 */
        

        void exp17() {
        extern void _l0590();
        C_JMS(expdm,P_PRC_EXPDM,_l0590);
        } /* exp17 */
        

        void _l0590() {
        //b ||mov|7,xr|10,(xs)+||restore xr|21199
        xr= C_POP();				// restore xr
        //b ||mov|8,wb|10,(xs)+||restore outer level|21200
        wb= C_POP();				// restore outer level
        //b ||mov|8,wc|10,(xs)+||restore outer count|21201
        wc= C_POP();				// restore outer count
        //b ||mov|9,(xs)|7,xr||store opnd over unused cmopn val|21202
        *(xs_it.wp)= xr;				// store opnd over unused cmopn val
        //b ||mov|8,wa|18,=num02||set new state|21203
        wa= NUM02;				// set new state
        //b ||brn|6,exp01|||back for next ele8ent|21204
         C_GOTO(exp01);				// back for next ele8ent
//      here for rbr (s=2)
//      at outer level in a direct goto, this is a terminator.
//      otherwise it must terminate a subscript list.
// exp18:
        //b |exp18|mov|7,xl|18,=c_arr||set cmtyp for array reference|21211
        } /* _l0590 */
        

        void exp18() {
        xl= C_ARR;				// set cmtyp for array reference
        //b ||beq|8,wb|18,=num03|6,exp15|jump to build cmblk if end arrayref|21212
        if ((wb-NUM03) == 0) C_GOTO(exp15);				// jump to build cmblk if end arrayref
        //b ||beq|8,wb|18,=num02|6,exp20|jump if end of direct goto|21213
        if ((wb-NUM02) == 0) C_GOTO(exp20);				// jump if end of direct goto
        //b ||erb|1,225|26,syntax error: unbalanced right bracket|||21214
        C_ERB(225)
        //b ||ejc|||||21215
        
//      expan (continued)
//      here for col,smc (s=2)
//      error unless terminating statement body at outer level
// exp19:
        //b |exp19|mnz|3,scnrs|||rescan terminator|21223
        } /* exp18 */
        

        void exp19() {
        v.scnrs = 0xffffffffffffffff;				// rescan terminator
        //b ||mov|7,xl|8,wb||copy level indicator|21224
        xl= wb;				// copy level indicator
        //b ||bsw|7,xl|1,6||switch on level indicator|21225
        extern word _l0591 [];				// switch on level indicator
        { w0 = ((word *)_l0591)[xl];  C_GOTO(w0_it.callp);}
        }  /* exp19 */
        

        word  _l0591 [] = {
        //b ||iff|1,0|6,exp20||normal outer level|21232
        	(word)((word)(exp20)),				// normal outer level
        //b ||iff|1,1|6,exp22||fail if normal goto|21232
        	(word)((word)(exp22)),				// fail if normal goto
        //b ||iff|1,2|6,exp23||fail if direct goto|21232
        	(word)((word)(exp23)),				// fail if direct goto
        //b ||iff|1,3|6,exp24||fail array brackets|21232
        	(word)((word)(exp24)),				// fail array brackets
        //b ||iff|1,4|6,exp21||fail if in grouping|21232
        	(word)((word)(exp21)),				// fail if in grouping
        //b ||iff|1,5|6,exp21||fail function args|21232
        	(word)((word)(exp21)),				// fail function args
        //b ||esw||||end switch on level|21232
             }; /* bsw list for _l0591 */				// end switch on level
//      here at normal end of expression
// exp20:
        //b |exp20|jsr|6,expdm|||dump remaining operators|21236
        void exp20() {
        extern void _l0592();
        C_JMS(expdm,P_PRC_EXPDM,_l0592);
        } /* exp20 */
        

        void _l0592() {
        //b ||mov|7,xr|10,(xs)+||load tree pointer|21237
        xr= C_POP();				// load tree pointer
        //b ||ica|7,xs|||pop off bottom of stack marker|21238
        xs += CFP_B;				// pop off bottom of stack marker
        //b ||exi||||return to expan caller|21239
        C_EXIT(0);				// return to expan caller
//      missing right paren
// exp21:
        //b |exp21|erb|1,226|26,syntax error: missing right paren|||21243
        } /* _l0592 */
        

        void exp21() {
        C_ERB(226)
//      missing right paren in goto field
// exp22:
        //b |exp22|erb|1,227|26,syntax error: right paren missing from goto|||21247
        } /* exp21 */
        

        void exp22() {
        C_ERB(227)
//      missing bracket in goto
// exp23:
        //b |exp23|erb|1,228|26,syntax error: right bracket missing from goto|||21251
        } /* exp22 */
        

        void exp23() {
        C_ERB(228)
//      missing array bracket
// exp24:
        //b |exp24|erb|1,229|26,syntax error: missing right array bracket|||21255
        } /* exp23 */
        

        void exp24() {
        C_ERB(229)
        //b ||ejc|||||21256
        
//      expan (continued)
//      loop here when an operator causes an operator dump
// exp25:
        //b |exp25|mov|3,expsv|7,xr|||21262
        } /* exp24 */
        

        void exp25() {
        v.expsv= xr;
        //b ||jsr|6,expop|||pop one operator|21263
        extern void _l0593();
        C_JMS(expop,P_PRC_EXPOP,_l0593);
        } /* exp25 */
        

        void _l0593() {
        //b ||mov|7,xr|3,expsv||restore op dv pointer and merge|21264
        xr= v.expsv;				// restore op dv pointer and merge
//      here for bop (s=2)
//      remove operators (condense) from stack until no more
//      left at this level or top one has lower precedence.
//      loop here till this condition is met.
// exp26:
        //b |exp26|mov|7,xl|13,num01(xs)||load operator dvptr from stack|21272
        C_GOTO(exp26);
        } /* _l0593 */
        

        void exp26() {
        xl= *((word *)(CFP_B*NUM01 + xs));				// load operator dvptr from stack
        //b ||ble|7,xl|18,=num05|6,exp27|jump if bottom of stack level|21273
        if ((xl-NUM05) <= 0) C_GOTO(exp27);				// jump if bottom of stack level
        //b ||blt|13,dvrpr(xr)|13,dvlpr(xl)|6,exp25|else pop if new prec is lo|21274
        if ((*((word *)(CFP_B*DVRPR + xr))-*((word *)(CFP_B*DVLPR + xl))) < 0) C_GOTO(exp25);				// else pop if new prec is lo
//      here for uop (s=0,1)
//      binary operator merges after precedence check
//      the operator dv is stored on the stack and the scan
//      continues after setting the scan state to one.
// exp27:
        //b |exp27|mov|11,-(xs)|7,xr||stack operator dvptr on stack|21283
        C_GOTO(exp27);
        } /* exp26 */
        

        void exp27() {
        C_PUSH(xr);				// stack operator dvptr on stack
        //b ||chk||||check for stack overflow|21284
        if(xs<v.lowspmin) { C_GOTO(sec06); } /* stack overflow check */				// check for stack overflow
        //b ||mov|8,wa|18,=num01||set new state|21285
        wa= NUM01;				// set new state
        //b ||bne|7,xr|21,=opdvs|6,exp01|back for next element unless =|21286
        if ((xr-(word)(&c.opdvs)) != 0) C_GOTO(exp01);				// back for next element unless =
//      here for special case of binary =. the syntax allows a
//      null right argument for this operator to be left
//      out. accordingly we reset to state zero to get proper
//      action on a terminator (supply a null constant).
        //b ||zer|8,wa|||set state zero|21293
        wa=0;				// set state zero
        //b ||brn|6,exp01|||jump for next element|21294
         C_GOTO(exp01);				// jump for next element
        //b ||ejc|||||21296
        
//      expap -- test for pattern match tree
//      expap is passed an expression tree to determine if it
//      is a pattern match. the following are recogized as
//      matches in the context of this call.
//      1)   an explicit use of binary question mark
//      2)   a concatenation
//      3)   an alternation whose left operand is a concatenation
//      (xr)                  ptr to expan tree
//      jsr  expap            call to test for pattern match
//      ppm  loc              transfer loc if not a pattern match
//      (wa)                  destroyed
//      (xr)                  unchanged (if not match)
//      (xr)                  ptr to binary operator blk if match
// expap:
        //b |expap|prc|25,e|1,1||entry point|21315
        } /* exp27 */
        

        void expap() {
        //b ||mov|11,-(xs)|7,xl||save xl|21316
        C_PUSH(xl);				// save xl
        //b ||bne|9,(xr)|22,=b_cmt|6,expp2|no match if not complex|21317
        if ((*(xr_it.wp)-(word)(b_cmt)) != 0) C_GOTO(expp2);				// no match if not complex
        //b ||mov|8,wa|13,cmtyp(xr)||else load type code|21318
        wa= *((word *)(CFP_B*CMTYP + xr));				// else load type code
        //b ||beq|8,wa|18,=c_cnc|6,expp1|concatenation is a match|21319
        if ((wa-C_CNC) == 0) C_GOTO(expp1);				// concatenation is a match
        //b ||beq|8,wa|18,=c_pmt|6,expp1|binary question mark is a match|21320
        if ((wa-C_PMT) == 0) C_GOTO(expp1);				// binary question mark is a match
        //b ||bne|8,wa|18,=c_alt|6,expp2|else not match unless alternation|21321
        if ((wa-C_ALT) != 0) C_GOTO(expp2);				// else not match unless alternation
//      here for alternation. change (a b) / c to a qm (b / c)
        //b ||mov|7,xl|13,cmlop(xr)||load left operand pointer|21325
        xl= *((word *)(CFP_B*CMLOP + xr));				// load left operand pointer
        //b ||bne|9,(xl)|22,=b_cmt|6,expp2|not match if left opnd not complex|21326
        if ((*(xl_it.wp)-(word)(b_cmt)) != 0) C_GOTO(expp2);				// not match if left opnd not complex
        //b ||bne|13,cmtyp(xl)|18,=c_cnc|6,expp2|not match if left op not conc|21327
        if ((*((word *)(CFP_B*CMTYP + xl))-C_CNC) != 0) C_GOTO(expp2);				// not match if left op not conc
        //b ||mov|13,cmlop(xr)|13,cmrop(xl)||xr points to (b / c)|21328
        *((word *)(CFP_B*CMLOP + xr))= *((word *)(CFP_B*CMROP + xl));				// xr points to (b / c)
        //b ||mov|13,cmrop(xl)|7,xr||set xl opnds to a, (b / c)|21329
        *((word *)(CFP_B*CMROP + xl))= xr;				// set xl opnds to a, (b / c)
        //b ||mov|7,xr|7,xl||point to this altered node|21330
        xr= xl;				// point to this altered node
//      exit here for pattern match
// expp1:
        //b |expp1|mov|7,xl|10,(xs)+||restore entry xl|21334
        C_GOTO(expp1);
        } /* expap */
        

        void expp1() {
        xl= C_POP();				// restore entry xl
        //b ||exi||||give pattern match return|21335
        C_EXIT(0);				// give pattern match return
//      exit here if not pattern match
// expp2:
        //b |expp2|mov|7,xl|10,(xs)+||restore entry xl|21339
        } /* expp1 */
        

        void expp2() {
        xl= C_POP();				// restore entry xl
        //b ||exi|1,1|||give non-match return|21340
        C_EXIT(1);				// give non-match return
        //b ||ejc|||||21342
        
//      expdm -- dump operators at current level (for expan)
//      expdm uses expop to condense all operators at this syntax
//      level. the stack bottom is recognized from the level
//      value which is saved on the top of the stack.
//      jsr  expdm            call to dump operators
//      (xs)                  popped as required
//      (xr,wa)               destroyed
// expdm:
        //b |expdm|prc|25,n|1,0||entry point|21354
        } /* expp2 */
        

        void expdm() {
        //b ||mov|3,r_exs|7,xl||save xl value|21355
        v.r_exs= xl;				// save xl value
//      loop to dump operators
// exdm1:
        //b |exdm1|ble|13,num01(xs)|18,=num05|6,exdm2|jump if stack bottom (saved level|21359
        C_GOTO(exdm1);
        } /* expdm */
        

        void exdm1() {
        if ((*((word *)(CFP_B*NUM01 + xs))-NUM05) <= 0) C_GOTO(exdm2);				// jump if stack bottom (saved level
        //b ||jsr|6,expop|||else pop one operator|21360
        extern void _l0594();
        C_JMS(expop,P_PRC_EXPOP,_l0594);
        } /* exdm1 */
        

        void _l0594() {
        //b ||brn|6,exdm1|||and loop back|21361
         C_GOTO(exdm1);				// and loop back
//      here after popping all operators
// exdm2:
        //b |exdm2|mov|7,xl|3,r_exs||restore xl|21365
        } /* _l0594 */
        

        void exdm2() {
        xl= v.r_exs;				// restore xl
        //b ||zer|3,r_exs|||release save location|21366
        v.r_exs=0;				// release save location
        //b ||exi||||return to expdm caller|21367
        C_NEXIT(P_PRC_EXPDM,0);				// return to expdm caller
        //b ||ejc|||||21369
        
//      expop-- pop operator (for expan)
//      expop is used by the expan routine to condense one
//      operator from the top of the syntax stack. an appropriate
//      cmblk is built for the operator (unary or binary) and a
//      pointer to this cmblk is stacked.
//      expop is also used by scngf (goto field scan) procedure
//      jsr  expop            call to pop operator
//      (xs)                  popped appropriately
//      (xr,xl,wa)            destroyed
// expop:
        //b |expop|prc|25,n|1,0||entry point|21384
        } /* exdm2 */
        

        void expop() {
        //b ||mov|7,xr|13,num01(xs)||load operator dv pointer|21385
        xr= *((word *)(CFP_B*NUM01 + xs));				// load operator dv pointer
        //b ||beq|13,dvlpr(xr)|18,=lluno|6,expo2|jump if unary|21386
        if ((*((word *)(CFP_B*DVLPR + xr))-LLUNO) == 0) C_GOTO(expo2);				// jump if unary
//      here for binary operator
        //b ||mov|8,wa|19,*cmbs_||set size of binary operator cmblk|21390
        wa= CFP_B*CMBS_;				// set size of binary operator cmblk
        //b ||jsr|6,alloc|||allocate space for cmblk|21391
        C_JSR(alloc);				// allocate space for cmblk
        //b ||mov|13,cmrop(xr)|10,(xs)+||pop and store right operand ptr|21392
        *((word *)(CFP_B*CMROP + xr))= C_POP();				// pop and store right operand ptr
        //b ||mov|7,xl|10,(xs)+||pop and load operator dv ptr|21393
        xl= C_POP();				// pop and load operator dv ptr
        //b ||mov|13,cmlop(xr)|9,(xs)||store left operand pointer|21394
        *((word *)(CFP_B*CMLOP + xr))= *(xs_it.wp);				// store left operand pointer
//      common exit point
// expo1:
        //b |expo1|mov|9,(xr)|22,=b_cmt||store type code for cmblk|21398
        C_GOTO(expo1);
        } /* expop */
        

        void expo1() {
        *(xr_it.wp)= (word)(b_cmt);				// store type code for cmblk
        //b ||mov|13,cmtyp(xr)|13,dvtyp(xl)||store cmblk node type code|21399
        *((word *)(CFP_B*CMTYP + xr))= *((word *)(CFP_B*DVTYP + xl));				// store cmblk node type code
        //b ||mov|13,cmopn(xr)|7,xl||store dvptr (=ptr to dac o_xxx)|21400
        *((word *)(CFP_B*CMOPN + xr))= xl;				// store dvptr (=ptr to dac o_xxx)
        //b ||mov|13,cmlen(xr)|8,wa||store cmblk length|21401
        *((word *)(CFP_B*CMLEN + xr))= wa;				// store cmblk length
        //b ||mov|9,(xs)|7,xr||store resulting node ptr on stack|21402
        *(xs_it.wp)= xr;				// store resulting node ptr on stack
        //b ||exi||||return to expop caller|21403
        C_NEXIT(P_PRC_EXPOP,0);				// return to expop caller
//      here for unary operator
// expo2:
        //b |expo2|mov|8,wa|19,*cmus_||set size of unary operator cmblk|21407
        } /* expo1 */
        

        void expo2() {
        wa= CFP_B*CMUS_;				// set size of unary operator cmblk
        //b ||jsr|6,alloc|||allocate space for cmblk|21408
        C_JSR(alloc);				// allocate space for cmblk
        //b ||mov|13,cmrop(xr)|10,(xs)+||pop and store operand pointer|21409
        *((word *)(CFP_B*CMROP + xr))= C_POP();				// pop and store operand pointer
        //b ||mov|7,xl|9,(xs)||load operator dv pointer|21410
        xl= *(xs_it.wp);				// load operator dv pointer
        //b ||brn|6,expo1|||merge back to exit|21411
         C_GOTO(expo1);				// merge back to exit
        //b ||ejc|||||21413
        
//      filnm -- obtain file name from statement number
//      filnm takes a statement number and examines the file name
//      table pointed to by r_sfn to find the name of the file
//      containing the given statement.  table entries are
//      arranged in order of ascending statement number (there
//      is only one hash bucket in this table).  elements are
//      added to the table each time there is a change in
//      file name, recording the then current statement number.
//      to find the file name, the linked list of teblks is
//      scanned for an element containing a subscript (statement
//      number) greater than the argument statement number, or
//      the end of chain.  when this condition is met, the
//      previous teblk contains the desired file name as its
//      value entry.
//      (wc)                  statement number
//      jsr  filnm            call to obtain file name
//      (xl)                  file name (scblk)
//      (ia)                  destroyed
// filnm:
        //b |filnm|prc|25,e|1,0||entry point|21438
        } /* expo2 */
        

        void filnm() {
        //b ||mov|11,-(xs)|8,wb||preserve wb|21439
        C_PUSH(wb);				// preserve wb
        //b ||bze|8,wc|6,filn3||return nulls if stno is zero|21440
        if ( !( wc) ) C_GOTO(filn3);				// return nulls if stno is zero
        //b ||mov|7,xl|3,r_sfn||file name table|21441
        xl= v.r_sfn;				// file name table
        //b ||bze|7,xl|6,filn3||if no table|21442
        if ( !( xl) ) C_GOTO(filn3);				// if no table
        //b ||mov|8,wb|13,tbbuk(xl)||get bucket entry|21443
        wb= *((word *)(CFP_B*TBBUK + xl));				// get bucket entry
        //b ||beq|8,wb|3,r_sfn|6,filn3|jump if no teblks on chain|21444
        if ((wb-v.r_sfn) == 0) C_GOTO(filn3);				// jump if no teblks on chain
        //b ||mov|11,-(xs)|7,xr||preserve xr|21445
        C_PUSH(xr);				// preserve xr
        //b ||mov|7,xr|8,wb||previous block pointer|21446
        xr= wb;				// previous block pointer
        //b ||mov|11,-(xs)|8,wc||preserve stmt number|21447
        C_PUSH(wc);				// preserve stmt number
//      loop through teblks on hash chain
// filn1:
        //b |filn1|mov|7,xl|7,xr||next element to examine|21451
        C_GOTO(filn1);
        } /* filnm */
        

        void filn1() {
        xl= xr;				// next element to examine
        //b ||mov|7,xr|13,tesub(xl)||load subscript value (an icblk)|21452
        xr= *((word *)(CFP_B*TESUB + xl));				// load subscript value (an icblk)
        //b ||ldi|13,icval(xr)|||load the statement number|21453
        ia = *((word *)(CFP_B*ICVAL + xr));				// load the statement number
        //b ||mfi|8,wc|||convert to address constant|21454
        wc = ia;				// convert to address constant
        //b ||blt|9,(xs)|8,wc|6,filn2|compare arg with teblk stmt number|21455
        if ((*(xs_it.wp)-wc) < 0) C_GOTO(filn2);				// compare arg with teblk stmt number
//      here if desired stmt number is ge teblk stmt number
        //b ||mov|8,wb|7,xl||save previous entry pointer|21459
        wb= xl;				// save previous entry pointer
        //b ||mov|7,xr|13,tenxt(xl)||point to next teblk on chain|21460
        xr= *((word *)(CFP_B*TENXT + xl));				// point to next teblk on chain
        //b ||bne|7,xr|3,r_sfn|6,filn1|jump if there is one|21461
        if ((xr-v.r_sfn) != 0) C_GOTO(filn1);				// jump if there is one
//      here if chain exhausted or desired block found.
// filn2:
        //b |filn2|mov|7,xl|8,wb||previous teblk|21465
        C_GOTO(filn2);
        } /* filn1 */
        

        void filn2() {
        xl= wb;				// previous teblk
        //b ||mov|7,xl|13,teval(xl)||get ptr to file name scblk|21466
        xl= *((word *)(CFP_B*TEVAL + xl));				// get ptr to file name scblk
        //b ||mov|8,wc|10,(xs)+||restore stmt number|21467
        wc= C_POP();				// restore stmt number
        //b ||mov|7,xr|10,(xs)+||restore xr|21468
        xr= C_POP();				// restore xr
        //b ||mov|8,wb|10,(xs)+||restore wb|21469
        wb= C_POP();				// restore wb
        //b ||exi|||||21470
        C_EXIT(0);
//      no table or no table entries
// filn3:
        //b |filn3|mov|8,wb|10,(xs)+||restore wb|21474
        } /* filn2 */
        

        void filn3() {
        wb= C_POP();				// restore wb
        //b ||mov|7,xl|21,=nulls||return null string|21475
        xl= (word)(&c.nulls);				// return null string
        //b ||exi|||||21476
        C_EXIT(0);
        //b ||ejc|||||21478
        
//      gbcol -- perform garbage collection
//      gbcol performs a garbage collection on the dynamic region
//      all blocks which are no longer in use are eliminated
//      by moving blocks which are in use down and resetting
//      dnamp, the pointer to the next available location.
//      (wb)                  move offset (see below)
//      jsr  gbcol            call to collect garbage
//      (xr)                  sediment size after collection
//      the following conditions must be met at the time when
//      gbcol is called.
//      1)   all pointers to blocks in the dynamic area must be
//           accessible to the garbage collector. this means
//           that they must occur in one of the following.
//           a)               main stack, with current top
//                            element being indicated by xs
//           b)               in relocatable fields of vrblks.
//           c)               in register xl at the time of call
//           e)               in the special region of working
//                            storage where names begin with r_.
//      2)   all pointers must point to the start of blocks with
//           the sole exception of the contents of the code
//           pointer register which points into the r_cod block.
//      3)   no location which appears to contain a pointer
//           into the dynamic region may occur unless it is in
//           fact a pointer to the start of the block. however
//           pointers outside this area may occur and will
//           not be changed by the garbage collector.
//           it is especially important to make sure that xl
//           does not contain a garbage value from some process
//           carried out before the call to the collector.
//      gbcol has the capability of moving the final compacted
//      result up in memory (with addresses adjusted accordingly)
//      this is used to add space to the static region. the
//      entry value of wb is the number of bytes to move up.
//      the caller must guarantee that there is enough room.
//      furthermore the value in wb if it is non-zero, must be at
//      least 256 so that the mwb instruction conditions are met.
        //b ||ejc|||||21580
        
//      gbcol (continued)
//      the algorithm, which is a modification of the lisp-2
//      garbage collector devised by r.dewar and k.belcher
//      takes three passes as follows.
//      1)   all pointers in memory are scanned and blocks in use
//           determined from this scan. note that this procedure
//           is recursive and uses the main stack for linkage.
//           the marking process is thus similar to that used in
//           a standard lisp collector. however the method of
//           actually marking the blocks is different.
//           the first field of a block normally contains a
//           code entry point pointer. such an entry pointer
//           can be distinguished from the address of any pointer
//           to be processed by the collector. during garbage
//           collection, this word is used to build a back chain
//           of pointers through fields which point to the block.
//           the end of the chain is marked by the occurence
//           of the word which used to be in the first word of
//           the block. this backchain serves both as a mark
//           indicating that the block is in use and as a list of
//           references for the relocation phase.
//      2)   storage is scanned sequentially to discover which
//           blocks are currently in use as indicated by the
//           presence of a backchain. two pointers are maintained
//           one scans through looking at each block. the other
//           is incremented only for blocks found to be in use.
//           in this way, the eventual location of each block can
//           be determined without actually moving any blocks.
//           as each block which is in use is processed, the back
//           chain is used to reset all pointers which point to
//           this block to contain its new address, i.e. the
//           address it will occupy after the blocks are moved.
//           the first word of the block, taken from the end of
//           the chain is restored at this point.
//           during pass 2, the collector builds blocks which
//           describe the regions of storage which are to be
//           moved in the third pass. there is one descriptor for
//           each contiguous set of good blocks. the descriptor
//           is built just behind the block to be moved and
//           contains a pointer to the next block and the number
//           of words to be moved.
//      3)   in the third and final pass, the move descriptor
//           blocks built in pass two are used to actually move
//           the blocks down to the bottom of the dynamic region.
//           the collection is then complete and the next
//           available location pointer is reset.
        //b ||ejc|||||21634
        
//      gbcol (continued)
//      the garbage collector also recognizes the concept of
//      sediment.  sediment is defined as long-lived objects
//      which percipitate to the bottom of dynamic storage.
//      moving these objects during repeated collections is
//      inefficient.  it also contributes to thrashing on
//      systems with virtual memory.  in a typical worst-case
//      situation, there may be several megabytes of live objects
//      in the sediment, and only a few dead objects in need of
//      collection.  without recognising sediment, the standard
//      collector would move those megabytes of objects downward
//      to squeeze out the dead objects.  this type of move
//      would result in excessive thrasing for very little memory
//      gain.
//      scanning of blocks in the sediment cannot be avoided
//      entirely, because these blocks may contain pointers to
//      live objects above the sediment.  however, sediment
//      blocks need not be linked to a back chain as described
//      in pass one above.  since these blocks will not be moved,
//      pointers to them do not need to be adjusted.  eliminating
//      unnecessary back chain links increases locality of
//      reference, improving virtual memory performance.
//      because back chains are used to mark blocks whose con-
//      tents have been processed, a different marking system
//      is needed for blocks in the sediment.  since block type
//      words point to odd-parity entry addresses, merely incre-
//      menting the type word serves to mark the block as pro-
//      cessed.  during pass three, the type words are decre-
//      mented to restore them to their original value.
        //b ||ejc|||||21678
        
//      gbcol (continued)
//      the variable dnams contains the number of bytes of memory
//      currently in the sediment.  setting dnams to zero will
//      eliminate the sediment and force it to be included in a
//      full garbage collection.  gbcol returns a suggested new
//      value for dnams (usually dnamp-dnamb) in xr which the
//      caller can store in dnams if it wishes to maintain the
//      sediment.  that is, data remaining after a garbage
//      collection is considered to be sediment.  if one accepts
//      the common lore that most objects are either very short-
//      or very long-lived, then this naive setting of dnams
//      probably includes some short-lived objects toward the end
//      of the sediment.
//      knowing when to reset dnams to zero to collect the sedi-
//      ment is not precisely known.  we force it to zero prior
//      to producing a dump, when gbcol is invoked by collect()
//      (so that the sediment is invisible to the user), when
//      sysmm is unable to obtain additional memory, and when
//      gbcol is called to relocate the dynamic area up in memory
//      (to make room for enlarging the static area).  if there
//      are no other reset situations, this leads to the inexo-
//      rable growth of the sediment, possible forcing a modest
//      program to begin to use virtual memory that it otherwise
//      would not.
//      as we scan sediment blocks in pass three, we maintain
//      aggregate counts of the amount of dead and live storage,
//      which is used to decide when to reset dnams.  when the
//      ratio of free storage found in the sediment to total
//      sediment size exceeds a threshold, the sediment is marked
//      for collection on the next gbcol call.
        //b ||ejc|||||21716
        
//      gbcol (continued)
// gbcol:
        //b |gbcol|prc|25,e|1,0||entry point|21720
        } /* filn3 */
        

        void gbcol() {
        //b ||bnz|3,dmvch|6,gbc14||fail if in mid-dump|21722
        if (v.dmvch) C_GOTO(gbc14);				// fail if in mid-dump
        //b ||mnz|3,gbcfl|||note gbcol entered|21723
        v.gbcfl = 0xffffffffffffffff;				// note gbcol entered
        //b ||mov|3,gbsva|8,wa||save entry wa|21724
        v.gbsva= wa;				// save entry wa
        //b ||mov|3,gbsvb|8,wb||save entry wb|21725
        v.gbsvb= wb;				// save entry wb
        //b ||mov|3,gbsvc|8,wc||save entry wc|21726
        v.gbsvc= wc;				// save entry wc
        //b ||mov|11,-(xs)|7,xl||save entry xl|21727
        C_PUSH(xl);				// save entry xl
        //b ||scp|8,wa|||get code pointer value|21728
        wa= reg_cp;				// get code pointer value
        //b ||sub|8,wa|3,r_cod||make relative|21729
        wa -= v.r_cod;				// make relative
        //b ||lcp|8,wa|||and restore|21730
        reg_cp = wa;				// and restore
        //b ||bze|8,wb|6,gbc0a||check there is no move offset|21732
        if ( !( wb) ) C_GOTO(gbc0a);				// check there is no move offset
        //b ||zer|3,dnams|||collect sediment if must move it|21733
        v.dnams=0;				// collect sediment if must move it
// gbc0a:
        //b |gbc0a|mov|8,wa|3,dnamb||start of dynamic area|21734
        C_GOTO(gbc0a);
        } /* gbcol */
        

        void gbc0a() {
        wa= v.dnamb;				// start of dynamic area
        //b ||add|8,wa|3,dnams||size of sediment|21735
        wa += v.dnams;				// size of sediment
        //b ||mov|3,gbcsd|8,wa||first location past sediment|21736
        v.gbcsd= wa;				// first location past sediment
//      inform sysgc that collection to commence
        //b ||mnz|7,xr|||non-zero flags start of collection|21749
        xr = 0xffffffffffffffff;				// non-zero flags start of collection
        //b ||mov|8,wa|3,dnamb||start of dynamic area|21750
        wa= v.dnamb;				// start of dynamic area
        //b ||mov|8,wb|3,dnamp||next available location|21751
        wb= v.dnamp;				// next available location
        //b ||mov|8,wc|3,dname||last available location + 1|21752
        wc= v.dname;				// last available location + 1
        //b ||jsr|6,sysgc|||inform of collection|21753
        C_JSR(sysgc);				// inform of collection
//      process stack entries
        //b ||mov|7,xr|7,xs||point to stack front|21758
        xr= xs;				// point to stack front
        //b ||mov|7,xl|3,stbas||point past end of stack|21759
        xl= v.stbas;				// point past end of stack
        //b ||bge|7,xl|7,xr|6,gbc00|ok if d-stack|21760
        if ((xl-xr) >= 0) C_GOTO(gbc00);				// ok if d-stack
        //b ||mov|7,xr|7,xl||reverse if ...|21761
        xr= xl;				// reverse if ...
        //b ||mov|7,xl|7,xs||... u-stack|21762
        xl= xs;				// ... u-stack
//      process the stack
// gbc00:
        //b |gbc00|jsr|6,gbcpf|||process pointers on stack|21766
        C_GOTO(gbc00);
        } /* gbc0a */
        

        void gbc00() {
        C_JSR(gbcpf);				// process pointers on stack
//      process special work locations
        //b ||mov|7,xr|20,=r_aaa||point to start of relocatable locs|21770
        xr= (word)(&v.r_aaa);				// point to start of relocatable locs
        //b ||mov|7,xl|20,=r_yyy||point past end of relocatable locs|21771
        xl= (word)(&v.r_yyy);				// point past end of relocatable locs
        //b ||jsr|6,gbcpf|||process work fields|21772
        C_JSR(gbcpf);				// process work fields
//      prepare to process variable blocks
        //b ||mov|8,wa|3,hshtb||point to first hash slot pointer|21776
        wa= v.hshtb;				// point to first hash slot pointer
//      loop through hash slots
// gbc01:
        //b |gbc01|mov|7,xl|8,wa||point to next slot|21780
        C_GOTO(gbc01);
        } /* gbc00 */
        

        void gbc01() {
        xl= wa;				// point to next slot
        //b ||ica|8,wa|||bump bucket pointer|21781
        wa += CFP_B;				// bump bucket pointer
        //b ||mov|3,gbcnm|8,wa||save bucket pointer|21782
        v.gbcnm= wa;				// save bucket pointer
        //b ||ejc|||||21783
        
//      gbcol (continued)
//      loop through variables on one hash chain
// gbc02:
        //b |gbc02|mov|7,xr|9,(xl)||load ptr to next vrblk|21789
        C_GOTO(gbc02);
        } /* gbc01 */
        

        void gbc02() {
        xr= *(xl_it.wp);				// load ptr to next vrblk
        //b ||bze|7,xr|6,gbc03||jump if end of chain|21790
        if ( !( xr) ) C_GOTO(gbc03);				// jump if end of chain
        //b ||mov|7,xl|7,xr||else copy vrblk pointer|21791
        xl= xr;				// else copy vrblk pointer
        //b ||add|7,xr|19,*vrval||point to first reloc fld|21792
        xr += CFP_B*VRVAL;				// point to first reloc fld
        //b ||add|7,xl|19,*vrnxt||point past last (and to link ptr)|21793
        xl += CFP_B*VRNXT;				// point past last (and to link ptr)
        //b ||jsr|6,gbcpf|||process reloc fields in vrblk|21794
        C_JSR(gbcpf);				// process reloc fields in vrblk
        //b ||brn|6,gbc02|||loop back for next block|21795
         C_GOTO(gbc02);				// loop back for next block
//      here at end of one hash chain
// gbc03:
        //b |gbc03|mov|8,wa|3,gbcnm||restore bucket pointer|21799
        } /* gbc02 */
        

        void gbc03() {
        wa= v.gbcnm;				// restore bucket pointer
        //b ||bne|8,wa|3,hshte|6,gbc01|loop back if more buckets to go|21800
        if ((wa-v.hshte) != 0) C_GOTO(gbc01);				// loop back if more buckets to go
        //b ||ejc|||||21801
        
//      gbcol (continued)
//      now we are ready to start pass two. registers are used
//      as follows in pass two.
//      (xr)                  scans through all blocks
//      (wc)                  pointer to eventual location
//      the move description blocks built in this pass have
//      the following format.
//      word 1                pointer to next move block,
//                            zero if end of chain of blocks
//      word 2                length of blocks to be moved in
//                            bytes. set to the address of the
//                            first byte while actually scanning
//                            the blocks.
//      the first entry on this chain is a special entry
//      consisting of the two words gbcnm and gbcns. after
//      building the chain of move descriptors, gbcnm points to
//      the first real move block, and gbcns is the length of
//      blocks in use at the start of storage which need not
//      be moved since they are in the correct position.
        //b ||mov|7,xr|3,dnamb||point to first block|21830
        xr= v.dnamb;				// point to first block
        //b ||zer|8,wb|||accumulate size of dead blocks|21831
        wb=0;				// accumulate size of dead blocks
// gbc04:
        //b |gbc04|beq|7,xr|3,gbcsd|6,gbc4c|jump if end of sediment|21832
        C_GOTO(gbc04);
        } /* gbc03 */
        

        void gbc04() {
        if ((xr-v.gbcsd) == 0) C_GOTO(gbc4c);				// jump if end of sediment
        //b ||mov|8,wa|9,(xr)||else get first word|21833
        wa= *(xr_it.wp);				// else get first word
        //b ||bod|8,wa|6,gbc4b||jump if entry pointer (unused)|21835
        if (wa & 1)  C_GOTO(gbc4b);				// jump if entry pointer (unused)
        //b ||dcv|8,wa|||restore entry pointer|21836
        (wa)--;				// restore entry pointer
        //b ||mov|9,(xr)|8,wa||restore first word|21842
        *(xr_it.wp)= wa;				// restore first word
        //b ||jsr|6,blkln|||get length of this block|21843
        C_JSR(blkln);				// get length of this block
        //b ||add|7,xr|8,wa||bump actual pointer|21844
        xr += wa;				// bump actual pointer
        //b ||brn|6,gbc04|||continue scan through sediment|21845
         C_GOTO(gbc04);				// continue scan through sediment
//      here for unused sediment block
// gbc4b:
        //b |gbc4b|jsr|6,blkln|||get length of this block|21849
        } /* gbc04 */
        

        void gbc4b() {
        C_JSR(blkln);				// get length of this block
        //b ||add|7,xr|8,wa||bump actual pointer|21850
        xr += wa;				// bump actual pointer
        //b ||add|8,wb|8,wa||count size of unused blocks|21851
        wb += wa;				// count size of unused blocks
        //b ||brn|6,gbc04|||continue scan through sediment|21852
         C_GOTO(gbc04);				// continue scan through sediment
//      here at end of sediment.  remember size of free blocks
//      within the sediment.  this will be used later to decide
//      how to set the sediment size returned to caller.
//      then scan rest of dynamic area above sediment.
//      (wb) = aggregate size of free blocks in sediment
//      (xr) = first location past sediment
// gbc4c:
        //b |gbc4c|mov|3,gbcsf|8,wb||size of sediment free space|21863
        } /* gbc4b */
        

        void gbc4c() {
        v.gbcsf= wb;				// size of sediment free space
        //b ||mov|8,wc|7,xr||set as first eventual location|21867
        wc= xr;				// set as first eventual location
        //b ||add|8,wc|3,gbsvb||add offset for eventual move up|21868
        wc += v.gbsvb;				// add offset for eventual move up
        //b ||zer|3,gbcnm|||clear initial forward pointer|21869
        v.gbcnm=0;				// clear initial forward pointer
        //b ||mov|3,gbclm|20,=gbcnm||initialize ptr to last move block|21870
        v.gbclm= (word)(&v.gbcnm);				// initialize ptr to last move block
        //b ||mov|3,gbcns|7,xr||initialize first address|21871
        v.gbcns= xr;				// initialize first address
//      loop through a series of blocks in use
// gbc05:
        //b |gbc05|beq|7,xr|3,dnamp|6,gbc07|jump if end of used region|21875
        C_GOTO(gbc05);
        } /* gbc4c */
        

        void gbc05() {
        if ((xr-v.dnamp) == 0) C_GOTO(gbc07);				// jump if end of used region
        //b ||mov|8,wa|9,(xr)||else get first word|21876
        wa= *(xr_it.wp);				// else get first word
        //b ||bod|8,wa|6,gbc07||jump if entry pointer (unused)|21878
        if (wa & 1)  C_GOTO(gbc07);				// jump if entry pointer (unused)
//      here for block in use, loop to relocate references
// gbc06:
        //b |gbc06|mov|7,xl|8,wa||copy pointer|21886
        C_GOTO(gbc06);
        } /* gbc05 */
        

        void gbc06() {
        xl= wa;				// copy pointer
        //b ||mov|8,wa|9,(xl)||load forward pointer|21887
        wa= *(xl_it.wp);				// load forward pointer
        //b ||mov|9,(xl)|8,wc||relocate reference|21888
        *(xl_it.wp)= wc;				// relocate reference
        //b ||bev|8,wa|6,gbc06||loop back if not end of chain|21890
        if (!((wa) & 1))  C_GOTO(gbc06);				// loop back if not end of chain
        //b ||ejc|||||21895
        
//      gbcol (continued)
//      at end of chain, restore first word and bump past
        //b ||mov|9,(xr)|8,wa||restore first word|21901
        *(xr_it.wp)= wa;				// restore first word
        //b ||jsr|6,blkln|||get length of this block|21902
        C_JSR(blkln);				// get length of this block
        //b ||add|7,xr|8,wa||bump actual pointer|21903
        xr += wa;				// bump actual pointer
        //b ||add|8,wc|8,wa||bump eventual pointer|21904
        wc += wa;				// bump eventual pointer
        //b ||brn|6,gbc05|||loop back for next block|21905
         C_GOTO(gbc05);				// loop back for next block
//      here at end of a series of blocks in use
// gbc07:
        //b |gbc07|mov|8,wa|7,xr||copy pointer past last block|21909
        } /* gbc06 */
        

        void gbc07() {
        wa= xr;				// copy pointer past last block
        //b ||mov|7,xl|3,gbclm||point to previous move block|21910
        xl= v.gbclm;				// point to previous move block
        //b ||sub|8,wa|13,num01(xl)||subtract starting address|21911
        wa -= *((word *)(CFP_B*NUM01 + xl));				// subtract starting address
        //b ||mov|13,num01(xl)|8,wa||store length of block to be moved|21912
        *((word *)(CFP_B*NUM01 + xl))= wa;				// store length of block to be moved
//      loop through a series of blocks not in use
// gbc08:
        //b |gbc08|beq|7,xr|3,dnamp|6,gbc10|jump if end of used region|21916
        C_GOTO(gbc08);
        } /* gbc07 */
        

        void gbc08() {
        if ((xr-v.dnamp) == 0) C_GOTO(gbc10);				// jump if end of used region
        //b ||mov|8,wa|9,(xr)||else load first word of next block|21917
        wa= *(xr_it.wp);				// else load first word of next block
        //b ||bev|8,wa|6,gbc09||jump if in use|21919
        if (!((wa) & 1))  C_GOTO(gbc09);				// jump if in use
        //b ||jsr|6,blkln|||else get length of next block|21924
        C_JSR(blkln);				// else get length of next block
        //b ||add|7,xr|8,wa||push pointer|21925
        xr += wa;				// push pointer
        //b ||brn|6,gbc08|||and loop back|21926
         C_GOTO(gbc08);				// and loop back
//      here for a block in use after processing a series of
//      blocks which were not in use, build new move block.
// gbc09:
        //b |gbc09|sub|7,xr|19,*num02||point 2 words behind for move block|21931
        } /* gbc08 */
        

        void gbc09() {
        xr -= CFP_B*NUM02;				// point 2 words behind for move block
        //b ||mov|7,xl|3,gbclm||point to previous move block|21932
        xl= v.gbclm;				// point to previous move block
        //b ||mov|9,(xl)|7,xr||set forward ptr in previous block|21933
        *(xl_it.wp)= xr;				// set forward ptr in previous block
        //b ||zer|9,(xr)|||zero forward ptr of new block|21934
        *(xr_it.wp)=0;				// zero forward ptr of new block
        //b ||mov|3,gbclm|7,xr||remember address of this block|21935
        v.gbclm= xr;				// remember address of this block
        //b ||mov|7,xl|7,xr||copy ptr to move block|21936
        xl= xr;				// copy ptr to move block
        //b ||add|7,xr|19,*num02||point back to block in use|21937
        xr += CFP_B*NUM02;				// point back to block in use
        //b ||mov|13,num01(xl)|7,xr||store starting address|21938
        *((word *)(CFP_B*NUM01 + xl))= xr;				// store starting address
        //b ||brn|6,gbc06|||jump to process block in use|21939
         C_GOTO(gbc06);				// jump to process block in use
        //b ||ejc|||||21940
        
//      gbcol (continued)
//      here for pass three -- actually move the blocks down
//      (xl)                  pointer to old location
//      (xr)                  pointer to new location
// gbc10:
        //b |gbc10|mov|7,xr|3,gbcsd||point to storage above sediment|21950
        } /* gbc09 */
        

        void gbc10() {
        xr= v.gbcsd;				// point to storage above sediment
        //b ||add|7,xr|3,gbcns||bump past unmoved blocks at start|21954
        xr += v.gbcns;				// bump past unmoved blocks at start
//      loop through move descriptors
// gbc11:
        //b |gbc11|mov|7,xl|3,gbcnm||point to next move block|21958
        C_GOTO(gbc11);
        } /* gbc10 */
        

        void gbc11() {
        xl= v.gbcnm;				// point to next move block
        //b ||bze|7,xl|6,gbc12||jump if end of chain|21959
        if ( !( xl) ) C_GOTO(gbc12);				// jump if end of chain
        //b ||mov|3,gbcnm|10,(xl)+||move pointer down chain|21960
        v.gbcnm= *(xl_it.wp++);				// move pointer down chain
        //b ||mov|8,wa|10,(xl)+||get length to move|21961
        wa= *(xl_it.wp++);				// get length to move
        //b ||mvw||||perform move|21962
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// perform move
        //b ||brn|6,gbc11|||loop back|21963
         C_GOTO(gbc11);				// loop back
//      now test for move up
// gbc12:
        //b |gbc12|mov|3,dnamp|7,xr||set next available loc ptr|21967
        } /* gbc11 */
        

        void gbc12() {
        v.dnamp= xr;				// set next available loc ptr
        //b ||mov|8,wb|3,gbsvb||reload move offset|21968
        wb= v.gbsvb;				// reload move offset
        //b ||bze|8,wb|6,gbc13||jump if no move required|21969
        if ( !( wb) ) C_GOTO(gbc13);				// jump if no move required
        //b ||mov|7,xl|7,xr||else copy old top of core|21970
        xl= xr;				// else copy old top of core
        //b ||add|7,xr|8,wb||point to new top of core|21971
        xr += wb;				// point to new top of core
        //b ||mov|3,dnamp|7,xr||save new top of core pointer|21972
        v.dnamp= xr;				// save new top of core pointer
        //b ||mov|8,wa|7,xl||copy old top|21973
        wa= xl;				// copy old top
        //b ||sub|8,wa|3,dnamb||minus old bottom = length|21974
        wa -= v.dnamb;				// minus old bottom = length
        //b ||add|3,dnamb|8,wb||bump bottom to get new value|21975
        v.dnamb += wb;				// bump bottom to get new value
        //b ||mwb||||perform move (backwards)|21976
        wa = wa >> LOG_CFP_B; do { *(--xr_it.wp)= *(--xl_it.wp); } while (--wa);				// perform move (backwards)
//      merge here to exit
// gbc13:
        //b |gbc13|zer|7,xr|||clear garbage value in xr|21980
        C_GOTO(gbc13);
        } /* gbc12 */
        

        void gbc13() {
        xr=0;				// clear garbage value in xr
        //b ||mov|3,gbcfl|7,xr||note exit from gbcol|21981
        v.gbcfl= xr;				// note exit from gbcol
        //b ||mov|8,wa|3,dnamb||start of dynamic area|21983
        wa= v.dnamb;				// start of dynamic area
        //b ||mov|8,wb|3,dnamp||next available location|21984
        wb= v.dnamp;				// next available location
        //b ||mov|8,wc|3,dname||last available location + 1|21985
        wc= v.dname;				// last available location + 1
        //b ||jsr|6,sysgc|||inform sysgc of completion|21986
        C_JSR(sysgc);				// inform sysgc of completion
//      decide whether to mark sediment for collection next time.
//      this is done by examining the ratio of previous sediment
//      free space to the new sediment size.
        //b ||sti|3,gbcia|||save ia|21994
        v.gbcia= ia;				// save ia
        //b ||zer|7,xr|||presume no sediment will remain|21995
        xr=0;				// presume no sediment will remain
        //b ||mov|8,wb|3,gbcsf||free space in sediment|21996
        wb= v.gbcsf;				// free space in sediment
        //b ||btw|8,wb|||convert bytes to words|21997
        wb >>= LOG_CFP_B;				// convert bytes to words
        //b ||mti|8,wb|||put sediment free store in ia|21998
        ia = (word)(wb);				// put sediment free store in ia
        //b ||mli|3,gbsed|||multiply by sediment factor|21999
        ia*=v.gbsed;				// multiply by sediment factor
        //b ||iov|6,gb13a|||jump if overflowed|22000
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// jump if overflowed
        //b ||mov|8,wb|3,dnamp||end of dynamic area in use|22001
        wb= v.dnamp;				// end of dynamic area in use
        //b ||sub|8,wb|3,dnamb||minus start is sediment remaining|22002
        wb -= v.dnamb;				// minus start is sediment remaining
        //b ||btw|8,wb|||convert to words|22003
        wb >>= LOG_CFP_B;				// convert to words
        //b ||mov|3,gbcsf|8,wb||store it|22004
        v.gbcsf= wb;				// store it
        //b ||sbi|3,gbcsf|||subtract from scaled up free store|22005
        ia-=v.gbcsf;				// subtract from scaled up free store
        //b ||igt|6,gb13a|||jump if large free store in sedimnt|22006
        if (ia > 0)  C_GOTO(gb13a);				// jump if large free store in sedimnt
        //b ||mov|7,xr|3,dnamp||below threshold, return sediment|22007
        xr= v.dnamp;				// below threshold, return sediment
        //b ||sub|7,xr|3,dnamb||for use by caller|22008
        xr -= v.dnamb;				// for use by caller
// gb13a:
        //b |gb13a|ldi|3,gbcia|||restore ia|22009
        C_GOTO(gb13a);
        } /* gbc13 */
        

        void gb13a() {
        ia = v.gbcia;				// restore ia
        //b ||mov|8,wa|3,gbsva||restore wa|22011
        wa= v.gbsva;				// restore wa
        //b ||mov|8,wb|3,gbsvb||restore wb|22012
        wb= v.gbsvb;				// restore wb
        //b ||scp|8,wc|||get code pointer|22013
        wc= reg_cp;				// get code pointer
        //b ||add|8,wc|3,r_cod||make absolute again|22014
        wc += v.r_cod;				// make absolute again
        //b ||lcp|8,wc|||and replace absolute value|22015
        reg_cp = wc;				// and replace absolute value
        //b ||mov|8,wc|3,gbsvc||restore wc|22016
        wc= v.gbsvc;				// restore wc
        //b ||mov|7,xl|10,(xs)+||restore entry xl|22017
        xl= C_POP();				// restore entry xl
        //b ||icv|3,gbcnt|||increment count of collections|22018
        (v.gbcnt)++;				// increment count of collections
        //b ||exi||||exit to gbcol caller|22019
        C_EXIT(0);				// exit to gbcol caller
//      garbage collection not allowed whilst dumping
// gbc14:
        //b |gbc14|icv|3,errft|||fatal error|22023
        } /* gb13a */
        

        void gbc14() {
        (v.errft)++;				// fatal error
        //b ||erb|1,250|26,insufficient memory to complete dump|||22024
        C_ERB(250)
        //b ||ejc|||||22026
        
//      gbcpf -- process fields for garbage collector
//      this procedure is used by the garbage collector to
//      process fields in pass one. see gbcol for full details.
//      (xr)                  ptr to first location to process
//      (xl)                  ptr past last location to process
//      jsr  gbcpf            call to process fields
//      (xr,wa,wb,wc,ia)      destroyed
//      note that although this procedure uses a recursive
//      approach, it controls its own stack and is not recursive.
// gbcpf:
        //b |gbcpf|prc|25,e|1,0||entry point|22041
        } /* gbc14 */
        

        void gbcpf() {
        //b ||zer|11,-(xs)|||set zero to mark bottom of stack|22042
        *(--xs_it.wp)=0;				// set zero to mark bottom of stack
        //b ||mov|11,-(xs)|7,xl||save end pointer|22043
        C_PUSH(xl);				// save end pointer
//      merge here to go down a level and start a new loop
//      1(xs)                 next lvl field ptr (0 at outer lvl)
//      0(xs)                 ptr past last field to process
//      (xr)                  ptr to first field to process
//      loop to process successive fields
// gpf01:
        //b |gpf01|mov|7,xl|9,(xr)||load field contents|22053
        C_GOTO(gpf01);
        } /* gbcpf */
        

        void gpf01() {
        xl= *(xr_it.wp);				// load field contents
        //b ||mov|8,wc|7,xr||save field pointer|22054
        wc= xr;				// save field pointer
        //b ||blt|7,xl|3,dnamb|6,gpf2a|jump if not ptr into dynamic area|22058
        if ((xl-v.dnamb) < 0) C_GOTO(gpf2a);				// jump if not ptr into dynamic area
        //b ||bge|7,xl|3,dnamp|6,gpf2a|jump if not ptr into dynamic area|22059
        if ((xl-v.dnamp) >= 0) C_GOTO(gpf2a);				// jump if not ptr into dynamic area
//      here we have a ptr to a block in the dynamic area.
//      link this field onto the reference backchain.
        //b ||mov|8,wa|9,(xl)||load ptr to chain (or entry ptr)|22064
        wa= *(xl_it.wp);				// load ptr to chain (or entry ptr)
        //b ||blt|7,xl|3,gbcsd|6,gpf1a|do not chain if within sediment|22066
        if ((xl-v.gbcsd) < 0) C_GOTO(gpf1a);				// do not chain if within sediment
        //b ||mov|9,(xl)|7,xr||set this field as new head of chain|22068
        *(xl_it.wp)= xr;				// set this field as new head of chain
        //b ||mov|9,(xr)|8,wa||set forward pointer|22069
        *(xr_it.wp)= wa;				// set forward pointer
//      now see if this block has been processed before
// gpf1a:
        //b |gpf1a|bod|8,wa|6,gpf03||jump if not already processed|22074
        C_GOTO(gpf1a);
        } /* gpf01 */
        

        void gpf1a() {
        if (wa & 1)  C_GOTO(gpf03);				// jump if not already processed
//      here to restore pointer in xr to field just processed
// gpf02:
        //b |gpf02|mov|7,xr|8,wc||restore field pointer|22082
        C_GOTO(gpf02);
        } /* gpf1a */
        

        void gpf02() {
        xr= wc;				// restore field pointer
//      here to move to next field
// gpf2a:
        //b |gpf2a|ica|7,xr|||bump to next field|22086
        C_GOTO(gpf2a);
        } /* gpf02 */
        

        void gpf2a() {
        xr += CFP_B;				// bump to next field
        //b ||bne|7,xr|9,(xs)|6,gpf01|loop back if more to go|22087
        if ((xr-*(xs_it.wp)) != 0) C_GOTO(gpf01);				// loop back if more to go
        //b ||ejc|||||22088
        
//      gbcpf (continued)
//      here we pop up a level after finishing a block
        //b ||mov|7,xl|10,(xs)+||restore pointer past end|22094
        xl= C_POP();				// restore pointer past end
        //b ||mov|7,xr|10,(xs)+||restore block pointer|22095
        xr= C_POP();				// restore block pointer
        //b ||bnz|7,xr|6,gpf2a||continue loop unless outer levl|22096
        if (xr) C_GOTO(gpf2a);				// continue loop unless outer levl
        //b ||exi||||return to caller if outer level|22097
        C_EXIT(0);				// return to caller if outer level
//      here to process an active block which has not been done
//      since sediment blocks are not marked by putting them on
//      the back chain, they must be explicitly marked in another
//      manner.  if odd parity entry points are present, mark by
//      temporarily converting to even parity.  if odd parity not
//      available, the entry point is adjusted by the value in
//      gbcmk.
// gpf03:
        //b |gpf03|bge|7,xl|3,gbcsd|6,gpf3a|if not within sediment|22110
        } /* gpf2a */
        

        void gpf03() {
        if ((xl-v.gbcsd) >= 0) C_GOTO(gpf3a);				// if not within sediment
        //b ||icv|9,(xl)|||mark by making entry point even|22112
        (*(xl_it.wp))++;				// mark by making entry point even
// gpf3a:
        //b |gpf3a|mov|7,xr|7,xl||copy block pointer|22116
        C_GOTO(gpf3a);
        } /* gpf03 */
        

        void gpf3a() {
        xr= xl;				// copy block pointer
        //b ||mov|7,xl|8,wa||copy first word of block|22120
        xl= wa;				// copy first word of block
        //b ||lei|7,xl|||load entry point id (bl_xx)|22121
        xl = find_elab(xl);    /* get entry code */				// load entry point id (bl_xx)
//      block type switch. note that blocks with no relocatable
//      fields just return to gpf02 here to continue to next fld.
        //b ||bsw|7,xl|2,bl___||switch on block type|22126
        extern word _l0603 [];				// switch on block type
        { w0 = ((word *)_l0603)[xl];  C_GOTO(w0_it.callp);}
        }  /* gpf3a */
        

        word  _l0603 [] = {
        //b ||iff|2,bl_ar|6,gpf06||arblk|22164
        	(word)((word)(gpf06)),				// arblk
        //b ||iff|2,bl_cd|6,gpf19||cdblk|22164
        	(word)((word)(gpf19)),				// cdblk
        //b ||iff|2,bl_ex|6,gpf17||exblk|22164
        	(word)((word)(gpf17)),				// exblk
        //b ||iff|2,bl_ic|6,gpf02||icblk|22164
        	(word)((word)(gpf02)),				// icblk
        //b ||iff|2,bl_nm|6,gpf10||nmblk|22164
        	(word)((word)(gpf10)),				// nmblk
        //b ||iff|2,bl_p0|6,gpf10||p0blk|22164
        	(word)((word)(gpf10)),				// p0blk
        //b ||iff|2,bl_p1|6,gpf12||p1blk|22164
        	(word)((word)(gpf12)),				// p1blk
        //b ||iff|2,bl_p2|6,gpf12||p2blk|22164
        	(word)((word)(gpf12)),				// p2blk
        //b ||iff|2,bl_rc|6,gpf02||rcblk|22164
        	(word)((word)(gpf02)),				// rcblk
        //b ||iff|2,bl_sc|6,gpf02||scblk|22164
        	(word)((word)(gpf02)),				// scblk
        //b ||iff|2,bl_se|6,gpf02||seblk|22164
        	(word)((word)(gpf02)),				// seblk
        //b ||iff|2,bl_tb|6,gpf08||tbblk|22164
        	(word)((word)(gpf08)),				// tbblk
        //b ||iff|2,bl_vc|6,gpf08||vcblk|22164
        	(word)((word)(gpf08)),				// vcblk
        //b ||iff|2,bl_xn|6,gpf02||xnblk|22164
        	(word)((word)(gpf02)),				// xnblk
        //b ||iff|2,bl_xr|6,gpf09||xrblk|22164
        	(word)((word)(gpf09)),				// xrblk
        //b ||iff|2,bl_bc|6,gpf02||bcblk - dummy to fill out iffs|22164
        	(word)((word)(gpf02)),				// bcblk - dummy to fill out iffs
        //b ||iff|2,bl_pd|6,gpf13||pdblk|22164
        	(word)((word)(gpf13)),				// pdblk
        //b ||iff|2,bl_tr|6,gpf16||trblk|22164
        	(word)((word)(gpf16)),				// trblk
        //b ||iff|2,bl_bf|6,gpf02||bfblk|22164
        	(word)((word)(gpf02)),				// bfblk
        //b ||iff|2,bl_cc|6,gpf07||ccblk|22164
        	(word)((word)(gpf07)),				// ccblk
        //b ||iff|2,bl_cm|6,gpf04||cmblk|22164
        	(word)((word)(gpf04)),				// cmblk
        //b ||iff|2,bl_ct|6,gpf02||ctblk|22164
        	(word)((word)(gpf02)),				// ctblk
        //b ||iff|2,bl_df|6,gpf02||dfblk|22164
        	(word)((word)(gpf02)),				// dfblk
        //b ||iff|2,bl_ef|6,gpf02||efblk|22164
        	(word)((word)(gpf02)),				// efblk
        //b ||iff|2,bl_ev|6,gpf10||evblk|22164
        	(word)((word)(gpf10)),				// evblk
        //b ||iff|2,bl_ff|6,gpf11||ffblk|22164
        	(word)((word)(gpf11)),				// ffblk
        //b ||iff|2,bl_kv|6,gpf02||kvblk|22164
        	(word)((word)(gpf02)),				// kvblk
        //b ||iff|2,bl_pf|6,gpf14||pfblk|22164
        	(word)((word)(gpf14)),				// pfblk
        //b ||iff|2,bl_te|6,gpf15||teblk|22164
        	(word)((word)(gpf15)),				// teblk
        //b ||esw||||end of jump table|22164
             }; /* bsw list for _l0603 */				// end of jump table
        //b ||ejc|||||22165
        
//      gbcpf (continued)
//      cmblk
// gpf04:
        //b |gpf04|mov|8,wa|13,cmlen(xr)||load length|22171
        void gpf04() {
        wa= *((word *)(CFP_B*CMLEN + xr));				// load length
        //b ||mov|8,wb|19,*cmtyp||set offset|22172
        wb= CFP_B*CMTYP;				// set offset
//      here to push down to new level
//      (wc)                  field ptr at previous level
//      (xr)                  ptr to new block
//      (wa)                  length (reloc flds + flds at start)
//      (wb)                  offset to first reloc field
// gpf05:
        //b |gpf05|add|8,wa|7,xr||point past last reloc field|22181
        C_GOTO(gpf05);
        } /* gpf04 */
        

        void gpf05() {
        wa += xr;				// point past last reloc field
        //b ||add|7,xr|8,wb||point to first reloc field|22182
        xr += wb;				// point to first reloc field
        //b ||mov|11,-(xs)|8,wc||stack old field pointer|22183
        C_PUSH(wc);				// stack old field pointer
        //b ||mov|11,-(xs)|8,wa||stack new limit pointer|22184
        C_PUSH(wa);				// stack new limit pointer
        //b ||chk||||check for stack overflow|22185
        if(xs<v.lowspmin) { C_GOTO(sec06); } /* stack overflow check */				// check for stack overflow
        //b ||brn|6,gpf01|||if ok, back to process|22186
         C_GOTO(gpf01);				// if ok, back to process
//      arblk
// gpf06:
        //b |gpf06|mov|8,wa|13,arlen(xr)||load length|22190
        } /* gpf05 */
        

        void gpf06() {
        wa= *((word *)(CFP_B*ARLEN + xr));				// load length
        //b ||mov|8,wb|13,arofs(xr)||set offset to 1st reloc fld (arpro)|22191
        wb= *((word *)(CFP_B*AROFS + xr));				// set offset to 1st reloc fld (arpro)
        //b ||brn|6,gpf05|||all set|22192
         C_GOTO(gpf05);				// all set
//      ccblk
// gpf07:
        //b |gpf07|mov|8,wa|13,ccuse(xr)||set length in use|22196
        } /* gpf06 */
        

        void gpf07() {
        wa= *((word *)(CFP_B*CCUSE + xr));				// set length in use
        //b ||mov|8,wb|19,*ccuse||1st word (make sure at least one)|22197
        wb= CFP_B*CCUSE;				// 1st word (make sure at least one)
        //b ||brn|6,gpf05|||all set|22198
         C_GOTO(gpf05);				// all set
        //b ||ejc|||||22199
        
//      gbcpf (continued)
//      cdblk
// gpf19:
        //b |gpf19|mov|8,wa|13,cdlen(xr)||load length|22206
        } /* gpf07 */
        

        void gpf19() {
        wa= *((word *)(CFP_B*CDLEN + xr));				// load length
        //b ||mov|8,wb|19,*cdfal||set offset|22207
        wb= CFP_B*CDFAL;				// set offset
        //b ||brn|6,gpf05|||jump back|22208
         C_GOTO(gpf05);				// jump back
//      tbblk, vcblk
// gpf08:
        //b |gpf08|mov|8,wa|13,offs2(xr)||load length|22215
        } /* gpf19 */
        

        void gpf08() {
        wa= *((word *)(CFP_B*OFFS2 + xr));				// load length
        //b ||mov|8,wb|19,*offs3||set offset|22216
        wb= CFP_B*OFFS3;				// set offset
        //b ||brn|6,gpf05|||jump back|22217
         C_GOTO(gpf05);				// jump back
//      xrblk
// gpf09:
        //b |gpf09|mov|8,wa|13,xrlen(xr)||load length|22221
        } /* gpf08 */
        

        void gpf09() {
        wa= *((word *)(CFP_B*XRLEN + xr));				// load length
        //b ||mov|8,wb|19,*xrptr||set offset|22222
        wb= CFP_B*XRPTR;				// set offset
        //b ||brn|6,gpf05|||jump back|22223
         C_GOTO(gpf05);				// jump back
//      evblk, nmblk, p0blk
// gpf10:
        //b |gpf10|mov|8,wa|19,*offs2||point past second field|22227
        } /* gpf09 */
        

        void gpf10() {
        wa= CFP_B*OFFS2;				// point past second field
        //b ||mov|8,wb|19,*offs1||offset is one (only reloc fld is 2)|22228
        wb= CFP_B*OFFS1;				// offset is one (only reloc fld is 2)
        //b ||brn|6,gpf05|||all set|22229
         C_GOTO(gpf05);				// all set
//      ffblk
// gpf11:
        //b |gpf11|mov|8,wa|19,*ffofs||set length|22233
        } /* gpf10 */
        

        void gpf11() {
        wa= CFP_B*FFOFS;				// set length
        //b ||mov|8,wb|19,*ffnxt||set offset|22234
        wb= CFP_B*FFNXT;				// set offset
        //b ||brn|6,gpf05|||all set|22235
         C_GOTO(gpf05);				// all set
//      p1blk, p2blk
// gpf12:
        //b |gpf12|mov|8,wa|19,*parm2||length (parm2 is non-relocatable)|22239
        } /* gpf11 */
        

        void gpf12() {
        wa= CFP_B*PARM2;				// length (parm2 is non-relocatable)
        //b ||mov|8,wb|19,*pthen||set offset|22240
        wb= CFP_B*PTHEN;				// set offset
        //b ||brn|6,gpf05|||all set|22241
         C_GOTO(gpf05);				// all set
        //b ||ejc|||||22242
        
//      gbcpf (continued)
//      pdblk
// gpf13:
        //b |gpf13|mov|7,xl|13,pddfp(xr)||load ptr to dfblk|22248
        } /* gpf12 */
        

        void gpf13() {
        xl= *((word *)(CFP_B*PDDFP + xr));				// load ptr to dfblk
        //b ||mov|8,wa|13,dfpdl(xl)||get pdblk length|22249
        wa= *((word *)(CFP_B*DFPDL + xl));				// get pdblk length
        //b ||mov|8,wb|19,*pdfld||set offset|22250
        wb= CFP_B*PDFLD;				// set offset
        //b ||brn|6,gpf05|||all set|22251
         C_GOTO(gpf05);				// all set
//      pfblk
// gpf14:
        //b |gpf14|mov|8,wa|19,*pfarg||length past last reloc|22255
        } /* gpf13 */
        

        void gpf14() {
        wa= CFP_B*PFARG;				// length past last reloc
        //b ||mov|8,wb|19,*pfcod||offset to first reloc|22256
        wb= CFP_B*PFCOD;				// offset to first reloc
        //b ||brn|6,gpf05|||all set|22257
         C_GOTO(gpf05);				// all set
//      teblk
// gpf15:
        //b |gpf15|mov|8,wa|19,*tesi_||set length|22261
        } /* gpf14 */
        

        void gpf15() {
        wa= CFP_B*TESI_;				// set length
        //b ||mov|8,wb|19,*tesub||and offset|22262
        wb= CFP_B*TESUB;				// and offset
        //b ||brn|6,gpf05|||all set|22263
         C_GOTO(gpf05);				// all set
//      trblk
// gpf16:
        //b |gpf16|mov|8,wa|19,*trsi_||set length|22267
        } /* gpf15 */
        

        void gpf16() {
        wa= CFP_B*TRSI_;				// set length
        //b ||mov|8,wb|19,*trval||and offset|22268
        wb= CFP_B*TRVAL;				// and offset
        //b ||brn|6,gpf05|||all set|22269
         C_GOTO(gpf05);				// all set
//      exblk
// gpf17:
        //b |gpf17|mov|8,wa|13,exlen(xr)||load length|22273
        } /* gpf16 */
        

        void gpf17() {
        wa= *((word *)(CFP_B*EXLEN + xr));				// load length
        //b ||mov|8,wb|19,*exflc||set offset|22274
        wb= CFP_B*EXFLC;				// set offset
        //b ||brn|6,gpf05|||jump back|22275
         C_GOTO(gpf05);				// jump back
        //b ||ejc|||||22286
        
//      gtarr -- get array
//      gtarr is passed an object and returns an array if possibl
//      (xr)                  value to be converted
//      (wa)                  0 to place table addresses in array
//                            non-zero for keys/values in array
//      jsr  gtarr            call to get array
//      ppm  loc              transfer loc for all null table
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  resulting array
//      (xl,wa,wb,wc)         destroyed
// gtarr:
        //b |gtarr|prc|25,e|1,2||entry point|22302
        } /* gpf17 */
        

        void gtarr() {
        //b ||mov|3,gtawa|8,wa||save wa indicator|22303
        v.gtawa= wa;				// save wa indicator
        //b ||mov|8,wa|9,(xr)||load type word|22304
        wa= *(xr_it.wp);				// load type word
        //b ||beq|8,wa|22,=b_art|6,gtar8|exit if already an array|22305
        if ((wa-(word)(b_art)) == 0) C_GOTO(gtar8);				// exit if already an array
        //b ||beq|8,wa|22,=b_vct|6,gtar8|exit if already an array|22306
        if ((wa-(word)(b_vct)) == 0) C_GOTO(gtar8);				// exit if already an array
        //b ||bne|8,wa|22,=b_tbt|6,gta9a|else fail if not a table (sgd02)|22307
        if ((wa-(word)(b_tbt)) != 0) C_GOTO(gta9a);				// else fail if not a table (sgd02)
//      here we convert a table to an array
        //b ||mov|11,-(xs)|7,xr||replace tbblk pointer on stack|22311
        C_PUSH(xr);				// replace tbblk pointer on stack
        //b ||zer|7,xr|||signal first pass|22312
        xr=0;				// signal first pass
        //b ||zer|8,wb|||zero non-null element count|22313
        wb=0;				// zero non-null element count
//      the following code is executed twice. on the first pass,
//      signalled by xr=0, the number of non-null elements in
//      the table is counted in wb. in the second pass, where
//      xr is a pointer into the arblk, the name and value are
//      entered into the current arblk location provided gtawa
//      is non-zero.  if gtawa is zero, the address of the teblk
//      is entered into the arblk twice (c3.762).
// gtar1:
        //b |gtar1|mov|7,xl|9,(xs)||point to table|22323
        C_GOTO(gtar1);
        } /* gtarr */
        

        void gtar1() {
        xl= *(xs_it.wp);				// point to table
        //b ||add|7,xl|13,tblen(xl)||point past last bucket|22324
        xl += *((word *)(CFP_B*TBLEN + xl));				// point past last bucket
        //b ||sub|7,xl|19,*tbbuk||set first bucket offset|22325
        xl -= CFP_B*TBBUK;				// set first bucket offset
        //b ||mov|8,wa|7,xl||copy adjusted pointer|22326
        wa= xl;				// copy adjusted pointer
//      loop through buckets in table block
//      next three lines of code rely on tenxt having a value
//      1 less than tbbuk.
// gtar2:
        //b |gtar2|mov|7,xl|8,wa||copy bucket pointer|22332
        C_GOTO(gtar2);
        } /* gtar1 */
        

        void gtar2() {
        xl= wa;				// copy bucket pointer
        //b ||dca|8,wa|||decrement bucket pointer|22333
        wa -= CFP_B;				// decrement bucket pointer
//      loop through teblks on one bucket chain
// gtar3:
        //b |gtar3|mov|7,xl|13,tenxt(xl)||point to next teblk|22337
        C_GOTO(gtar3);
        } /* gtar2 */
        

        void gtar3() {
        xl= *((word *)(CFP_B*TENXT + xl));				// point to next teblk
        //b ||beq|7,xl|9,(xs)|6,gtar6|jump if chain end (tbblk ptr)|22338
        if ((xl-*(xs_it.wp)) == 0) C_GOTO(gtar6);				// jump if chain end (tbblk ptr)
        //b ||mov|3,cnvtp|7,xl||else save teblk pointer|22339
        v.cnvtp= xl;				// else save teblk pointer
//      loop to find value down trblk chain
// gtar4:
        //b |gtar4|mov|7,xl|13,teval(xl)||load value|22343
        C_GOTO(gtar4);
        } /* gtar3 */
        

        void gtar4() {
        xl= *((word *)(CFP_B*TEVAL + xl));				// load value
        //b ||beq|9,(xl)|22,=b_trt|6,gtar4|loop till value found|22344
        if ((*(xl_it.wp)-(word)(b_trt)) == 0) C_GOTO(gtar4);				// loop till value found
        //b ||mov|8,wc|7,xl||copy value|22345
        wc= xl;				// copy value
        //b ||mov|7,xl|3,cnvtp||restore teblk pointer|22346
        xl= v.cnvtp;				// restore teblk pointer
        //b ||ejc|||||22347
        
//      gtarr (continued)
//      now check for null and test cases
        //b ||beq|8,wc|21,=nulls|6,gtar3|loop back to ignore null value|22353
        if ((wc-(word)(&c.nulls)) == 0) C_GOTO(gtar3);				// loop back to ignore null value
        //b ||bnz|7,xr|6,gtar5||jump if second pass|22354
        if (xr) C_GOTO(gtar5);				// jump if second pass
        //b ||icv|8,wb|||for the first pass, bump count|22355
        (wb)++;				// for the first pass, bump count
        //b ||brn|6,gtar3|||and loop back for next teblk|22356
         C_GOTO(gtar3);				// and loop back for next teblk
//      here in second pass
// gtar5:
        //b |gtar5|bze|3,gtawa|6,gta5a||jump if address wanted|22360
        } /* gtar4 */
        

        void gtar5() {
        if ( !( v.gtawa) ) C_GOTO(gta5a);				// jump if address wanted
        //b ||mov|10,(xr)+|13,tesub(xl)||store subscript name|22361
        *(xr_it.wp++)= *((word *)(CFP_B*TESUB + xl));				// store subscript name
        //b ||mov|10,(xr)+|8,wc||store value in arblk|22362
        *(xr_it.wp++)= wc;				// store value in arblk
        //b ||brn|6,gtar3|||loop back for next teblk|22363
         C_GOTO(gtar3);				// loop back for next teblk
//      here to record teblk address in arblk.  this allows
//      a sort routine to sort by ascending address.
// gta5a:
        //b |gta5a|mov|10,(xr)+|7,xl||store teblk address in name|22368
        } /* gtar5 */
        

        void gta5a() {
        *(xr_it.wp++)= xl;				// store teblk address in name
        //b ||mov|10,(xr)+|7,xl||and value slots|22369
        *(xr_it.wp++)= xl;				// and value slots
        //b ||brn|6,gtar3|||loop back for next teblk|22370
         C_GOTO(gtar3);				// loop back for next teblk
//      here after scanning teblks on one chain
// gtar6:
        //b |gtar6|bne|8,wa|9,(xs)|6,gtar2|loop back if more buckets to go|22374
        } /* gta5a */
        

        void gtar6() {
        if ((wa-*(xs_it.wp)) != 0) C_GOTO(gtar2);				// loop back if more buckets to go
        //b ||bnz|7,xr|6,gtar7||else jump if second pass|22375
        if (xr) C_GOTO(gtar7);				// else jump if second pass
//      here after counting non-null elements
        //b ||bze|8,wb|6,gtar9||fail if no non-null elements|22379
        if ( !( wb) ) C_GOTO(gtar9);				// fail if no non-null elements
        //b ||mov|8,wa|8,wb||else copy count|22380
        wa= wb;				// else copy count
        //b ||add|8,wa|8,wb||double (two words/element)|22381
        wa += wb;				// double (two words/element)
        //b ||add|8,wa|18,=arvl2||add space for standard fields|22382
        wa += ARVL2;				// add space for standard fields
        //b ||wtb|8,wa|||convert length to bytes|22383
        wa <<= LOG_CFP_B;				// convert length to bytes
        //b ||bgt|8,wa|3,mxlen|6,gta9b|error if too long for array|22384
        if ((wa-v.mxlen) > 0) C_GOTO(gta9b);				// error if too long for array
        //b ||jsr|6,alloc|||else allocate space for arblk|22385
        C_JSR(alloc);				// else allocate space for arblk
        //b ||mov|9,(xr)|22,=b_art||store type word|22386
        *(xr_it.wp)= (word)(b_art);				// store type word
        //b ||zer|13,idval(xr)|||zero id for the moment|22387
        *((word *)(CFP_B*IDVAL + xr))=0;				// zero id for the moment
        //b ||mov|13,arlen(xr)|8,wa||store length|22388
        *((word *)(CFP_B*ARLEN + xr))= wa;				// store length
        //b ||mov|13,arndm(xr)|18,=num02||set dimensions = 2|22389
        *((word *)(CFP_B*ARNDM + xr))= NUM02;				// set dimensions = 2
        //b ||ldi|4,intv1|||get integer one|22390
        ia = c.intv1;				// get integer one
        //b ||sti|13,arlbd(xr)|||store as lbd 1|22391
        *((word *)(CFP_B*ARLBD + xr))= ia;				// store as lbd 1
        //b ||sti|13,arlb2(xr)|||store as lbd 2|22392
        *((word *)(CFP_B*ARLB2 + xr))= ia;				// store as lbd 2
        //b ||ldi|4,intv2|||load integer two|22393
        ia = c.intv2;				// load integer two
        //b ||sti|13,ardm2(xr)|||store as dim 2|22394
        *((word *)(CFP_B*ARDM2 + xr))= ia;				// store as dim 2
        //b ||mti|8,wb|||get element count as integer|22395
        ia = (word)(wb);				// get element count as integer
        //b ||sti|13,ardim(xr)|||store as dim 1|22396
        *((word *)(CFP_B*ARDIM + xr))= ia;				// store as dim 1
        //b ||zer|13,arpr2(xr)|||zero prototype field for now|22397
        *((word *)(CFP_B*ARPR2 + xr))=0;				// zero prototype field for now
        //b ||mov|13,arofs(xr)|19,*arpr2||set offset field (signal pass 2)|22398
        *((word *)(CFP_B*AROFS + xr))= CFP_B*ARPR2;				// set offset field (signal pass 2)
        //b ||mov|8,wb|7,xr||save arblk pointer|22399
        wb= xr;				// save arblk pointer
        //b ||add|7,xr|19,*arvl2||point to first element location|22400
        xr += CFP_B*ARVL2;				// point to first element location
        //b ||brn|6,gtar1|||jump back to fill in elements|22401
         C_GOTO(gtar1);				// jump back to fill in elements
        //b ||ejc|||||22402
        
//      gtarr (continued)
//      here after filling in element values
// gtar7:
        //b |gtar7|mov|7,xr|8,wb||restore arblk pointer|22408
        } /* gtar6 */
        

        void gtar7() {
        xr= wb;				// restore arblk pointer
        //b ||mov|9,(xs)|8,wb||store as result|22409
        *(xs_it.wp)= wb;				// store as result
//      now we need the array prototype which is of the form nn,2
//      this is obtained by building the string for nn02 and
//      changing the zero to a comma before storing it.
        //b ||ldi|13,ardim(xr)|||get number of elements (nn)|22415
        ia = *((word *)(CFP_B*ARDIM + xr));				// get number of elements (nn)
        //b ||mli|4,intvh|||multiply by 100|22416
        ia*=c.intvh;				// multiply by 100
        //b ||adi|4,intv2|||add 2 (nn02)|22417
        ia+=c.intv2;				// add 2 (nn02)
        //b ||jsr|6,icbld|||build integer|22418
        C_JSR(icbld);				// build integer
        //b ||mov|11,-(xs)|7,xr||store ptr for gtstg|22419
        C_PUSH(xr);				// store ptr for gtstg
        //b ||ppm||||convert fail is impossible|22421
        extern void _l0608();
        C_JMS(gtstg,P_PRC_GTSTG,_l0608);
        } /* gtar7 */
        

        void _l0608() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(299)));				// convert fail is impossible
        //b ||mov|7,xl|7,xr||copy string pointer|22422
        xl= xr;				// copy string pointer
        //b ||mov|7,xr|10,(xs)+||reload arblk pointer|22423
        xr= C_POP();				// reload arblk pointer
        //b ||mov|13,arpr2(xr)|7,xl||store prototype ptr (nn02)|22424
        *((word *)(CFP_B*ARPR2 + xr))= xl;				// store prototype ptr (nn02)
        //b ||sub|8,wa|18,=num02||adjust length to point to zero|22425
        wa -= NUM02;				// adjust length to point to zero
        //b ||psc|7,xl|8,wa||point to zero|22426
        xl_it.chp += CFP_F + wa;				// point to zero
        //b ||mov|8,wb|18,=ch_cm||load a comma|22427
        wb= CH_CM;				// load a comma
        //b ||sch|8,wb|9,(xl)||store a comma over the zero|22428
        *(xl_it.chp) = wb;				// store a comma over the zero
//      normal return
// gtar8:
        //b ||csc|7,xl|||complete store characters|22429
        //b |gtar8|exi||||return to caller|22433
        C_GOTO(gtar8);
        } /* _l0608 */
        

        void gtar8() {
        C_EXIT(0);				// return to caller
//      null table non-conversion return
// gtar9:
        //b |gtar9|mov|7,xr|10,(xs)+||restore stack for conv err (sgd02)|22437
        } /* gtar8 */
        

        void gtar9() {
        xr= C_POP();				// restore stack for conv err (sgd02)
        //b ||exi|1,1|||return|22438
        C_EXIT(1);				// return
//      impossible conversion return
// gta9a:
        //b |gta9a|exi|1,2|||return|22442
        } /* gtar9 */
        

        void gta9a() {
        C_EXIT(2);				// return
//      array size too large
// gta9b:
        //b |gta9b|erb|1,260|26,conversion array size exceeds maximum permitted|||22446
        } /* gta9a */
        

        void gta9b() {
        C_ERB(260)
        //b ||ejc|||||22448
        
//      gtcod -- convert to code
//      (xr)                  object to be converted
//      jsr  gtcod            call to convert to code
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  pointer to resulting cdblk
//      (xl,wa,wb,wc,ra)      destroyed
//      if a spitbol error occurs during compilation or pre-
//      evaluation, control is passed via error section to exfal
//      without returning to this routine.
// gtcod:
        //b |gtcod|prc|25,e|1,1||entry point|22462
        } /* gta9b */
        

        void gtcod() {
        //b ||beq|9,(xr)|22,=b_cds|6,gtcd1|jump if already code|22463
        if ((*(xr_it.wp)-(word)(b_cds)) == 0) C_GOTO(gtcd1);				// jump if already code
        //b ||beq|9,(xr)|22,=b_cdc|6,gtcd1|jump if already code|22464
        if ((*(xr_it.wp)-(word)(b_cdc)) == 0) C_GOTO(gtcd1);				// jump if already code
//      here we must generate a cdblk by compilation
        //b ||mov|11,-(xs)|7,xr||stack argument for gtstg|22468
        C_PUSH(xr);				// stack argument for gtstg
        //b ||ppm|6,gtcd2|||jump if non-convertible|22470
        extern void _l0609();
        C_JMS(gtstg,P_PRC_GTSTG,_l0609);
        } /* gtcod */
        

        void _l0609() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(gtcd2));				// jump if non-convertible
        //b ||mov|3,gtcef|3,flptr||save fail ptr in case of error|22471
        v.gtcef= v.flptr;				// save fail ptr in case of error
        //b ||mov|3,r_gtc|3,r_cod||also save code ptr|22472
        v.r_gtc= v.r_cod;				// also save code ptr
        //b ||mov|3,r_cim|7,xr||else set image pointer|22473
        v.r_cim= xr;				// else set image pointer
        //b ||mov|3,scnil|8,wa||set image length|22474
        v.scnil= wa;				// set image length
        //b ||zer|3,scnpt|||set scan pointer|22475
        v.scnpt=0;				// set scan pointer
        //b ||mov|3,stage|18,=stgxc||set stage for execute compile|22476
        v.stage= STGXC;				// set stage for execute compile
        //b ||mov|3,lstsn|3,cmpsn||in case listr called|22477
        v.lstsn= v.cmpsn;				// in case listr called
        //b ||icv|3,cmpln|||bump line number|22479
        (v.cmpln)++;				// bump line number
        //b ||jsr|6,cmpil|||compile string|22481
        C_JSR(cmpil);				// compile string
        //b ||mov|3,stage|18,=stgxt||reset stage for execute time|22482
        v.stage= STGXT;				// reset stage for execute time
        //b ||zer|3,r_cim|||clear image|22483
        v.r_cim=0;				// clear image
//      merge here if no convert required
// gtcd1:
        //b |gtcd1|exi||||give normal gtcod return|22487
        C_GOTO(gtcd1);
        } /* _l0609 */
        

        void gtcd1() {
        C_EXIT(0);				// give normal gtcod return
//      here if unconvertible
// gtcd2:
        //b |gtcd2|exi|1,1|||give error return|22491
        } /* gtcd1 */
        

        void gtcd2() {
        C_EXIT(1);				// give error return
        //b ||ejc|||||22493
        
//      gtexp -- convert to expression
//      (wb)                  0 if by value, 1 if by name
//      (xr)                  input value to be converted
//      jsr  gtexp            call to convert to expression
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  pointer to result exblk or seblk
//      (xl,wa,wb,wc,ra)      destroyed
//      if a spitbol error occurs during compilation or pre-
//      evaluation, control is passed via error section to exfal
//      without returning to this routine.
// gtexp:
        //b |gtexp|prc|25,e|1,1||entry point|22510
        } /* gtcd2 */
        

        void gtexp() {
        //b ||blo|9,(xr)|22,=b_e__|6,gtex1|jump if already an expression|22511
        if ((*(xr_it.wp)-(word)(b_e__)) < 0) C_GOTO(gtex1);				// jump if already an expression
        //b ||mov|11,-(xs)|7,xr||store argument for gtstg|22512
        C_PUSH(xr);				// store argument for gtstg
        //b ||ppm|6,gtex2|||jump if unconvertible|22514
        extern void _l0610();
        C_JMS(gtstg,P_PRC_GTSTG,_l0610);
        } /* gtexp */
        

        void _l0610() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(gtex2));				// jump if unconvertible
//      check the last character of the string for colon or
//      semicolon.  these characters can legitimately end an
//      expression in open code, so expan will not detect them
//      as errors, but they are invalid as terminators for a
//      string that is being converted to expression form.
        //b ||mov|7,xl|7,xr||copy input string pointer|22522
        xl= xr;				// copy input string pointer
        //b ||plc|7,xl|8,wa||point one past the string end|22523
        xl_it.chp += CFP_F + wa;				// point one past the string end
        //b ||lch|7,xl|11,-(xl)||fetch the last character|22524
        xl = *(--xl_it.chp);				// fetch the last character
        //b ||beq|7,xl|18,=ch_cl|6,gtex2|error if it is a semicolon|22525
        if ((xl-CH_CL) == 0) C_GOTO(gtex2);				// error if it is a semicolon
        //b ||beq|7,xl|18,=ch_sm|6,gtex2|or if it is a colon|22526
        if ((xl-CH_SM) == 0) C_GOTO(gtex2);				// or if it is a colon
//      here we convert a string by compilation
        //b ||mov|3,r_cim|7,xr||set input image pointer|22530
        v.r_cim= xr;				// set input image pointer
        //b ||zer|3,scnpt|||set scan pointer|22531
        v.scnpt=0;				// set scan pointer
        //b ||mov|3,scnil|8,wa||set input image length|22532
        v.scnil= wa;				// set input image length
        //b ||mov|11,-(xs)|8,wb||save value/name flag|22534
        C_PUSH(wb);				// save value/name flag
        //b ||zer|8,wb|||set code for normal scan|22536
        wb=0;				// set code for normal scan
        //b ||mov|3,gtcef|3,flptr||save fail ptr in case of error|22537
        v.gtcef= v.flptr;				// save fail ptr in case of error
        //b ||mov|3,r_gtc|3,r_cod||also save code ptr|22538
        v.r_gtc= v.r_cod;				// also save code ptr
        //b ||mov|3,stage|18,=stgev||adjust stage for compile|22539
        v.stage= STGEV;				// adjust stage for compile
        //b ||mov|3,scntp|18,=t_uok||indicate unary operator acceptable|22540
        v.scntp= T_UOK;				// indicate unary operator acceptable
        //b ||jsr|6,expan|||build tree for expression|22541
        C_JSR(expan);				// build tree for expression
        //b ||zer|3,scnrs|||reset rescan flag|22542
        v.scnrs=0;				// reset rescan flag
        //b ||mov|8,wa|10,(xs)+||restore value/name flag|22544
        wa= C_POP();				// restore value/name flag
        //b ||bne|3,scnpt|3,scnil|6,gtex2|error if not end of image|22546
        if ((v.scnpt-v.scnil) != 0) C_GOTO(gtex2);				// error if not end of image
        //b ||zer|8,wb|||set ok value for cdgex call|22547
        wb=0;				// set ok value for cdgex call
        //b ||mov|7,xl|7,xr||copy tree pointer|22548
        xl= xr;				// copy tree pointer
        //b ||jsr|6,cdgex|||build expression block|22549
        C_JSR(cdgex);				// build expression block
        //b ||zer|3,r_cim|||clear pointer|22550
        v.r_cim=0;				// clear pointer
        //b ||mov|3,stage|18,=stgxt||restore stage for execute time|22551
        v.stage= STGXT;				// restore stage for execute time
//      merge here if no conversion required
// gtex1:
        //b |gtex1|exi||||return to gtexp caller|22555
        C_GOTO(gtex1);
        } /* _l0610 */
        

        void gtex1() {
        C_EXIT(0);				// return to gtexp caller
//      here if unconvertible
// gtex2:
        //b |gtex2|exi|1,1|||take error exit|22559
        } /* gtex1 */
        

        void gtex2() {
        C_EXIT(1);				// take error exit
        //b ||ejc|||||22561
        
//      gtint -- get integer value
//      gtint is passed an object and returns an integer after
//      performing any necessary conversions.
//      (xr)                  value to be converted
//      jsr  gtint            call to convert to integer
//      ppm  loc              transfer loc for convert impossible
//      (xr)                  resulting integer
//      (wc,ra)               destroyed
//      (wa,wb)               destroyed (only on conversion err)
//      (xr)                  unchanged (on convert error)
// gtint:
        //b |gtint|prc|25,e|1,1||entry point|22576
        } /* gtex2 */
        

        void gtint() {
        //b ||beq|9,(xr)|22,=b_icl|6,gtin2|jump if already an integer|22577
        if ((*(xr_it.wp)-(word)(b_icl)) == 0) C_GOTO(gtin2);				// jump if already an integer
        //b ||mov|3,gtina|8,wa||else save wa|22578
        v.gtina= wa;				// else save wa
        //b ||mov|3,gtinb|8,wb||save wb|22579
        v.gtinb= wb;				// save wb
        //b ||ppm|6,gtin3|||jump if unconvertible|22581
        C_JSR_1(gtnum,C_GOTO(gtin3));				// jump if unconvertible
        //b ||beq|8,wa|22,=b_icl|6,gtin1|jump if integer|22584
        if ((wa-(word)(b_icl)) == 0) C_GOTO(gtin1);				// jump if integer
//      here we convert a real to integer
        //b ||ldr|13,rcval(xr)|||load real value|22588
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load real value
        //b ||rti|6,gtin3|||convert to integer (err if ovflow)|22589
        ia =  ( ra_it.d);				// convert to integer (err if ovflow)
        //b ||jsr|6,icbld|||if ok build icblk|22590
        C_JSR(icbld);				// if ok build icblk
//      here after successful conversion to integer
// gtin1:
        //b |gtin1|mov|8,wa|3,gtina||restore wa|22595
        C_GOTO(gtin1);
        } /* gtint */
        

        void gtin1() {
        wa= v.gtina;				// restore wa
        //b ||mov|8,wb|3,gtinb||restore wb|22596
        wb= v.gtinb;				// restore wb
//      common exit point
// gtin2:
        //b |gtin2|exi||||return to gtint caller|22600
        C_GOTO(gtin2);
        } /* gtin1 */
        

        void gtin2() {
        C_EXIT(0);				// return to gtint caller
//      here on conversion error
// gtin3:
        //b |gtin3|exi|1,1|||take convert error exit|22604
        } /* gtin2 */
        

        void gtin3() {
        C_EXIT(1);				// take convert error exit
        //b ||ejc|||||22606
        
//      gtnum -- get numeric value
//      gtnum is given an object and returns either an integer
//      or a real, performing any necessary conversions.
//      (xr)                  object to be converted
//      jsr  gtnum            call to convert to numeric
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  pointer to result (int or real)
//      (wa)                  first word of result block
//      (wb,wc,ra)            destroyed
//      (xr)                  unchanged (on convert error)
// gtnum:
        //b |gtnum|prc|25,e|1,1||entry point|22621
        } /* gtin3 */
        

        void gtnum() {
        //b ||mov|8,wa|9,(xr)||load first word of block|22622
        wa= *(xr_it.wp);				// load first word of block
        //b ||beq|8,wa|22,=b_icl|6,gtn34|jump if integer (no conversion)|22623
        if ((wa-(word)(b_icl)) == 0) C_GOTO(gtn34);				// jump if integer (no conversion)
        //b ||beq|8,wa|22,=b_rcl|6,gtn34|jump if real (no conversion)|22626
        if ((wa-(word)(b_rcl)) == 0) C_GOTO(gtn34);				// jump if real (no conversion)
//      at this point the only possibility is to convert a string
//      to an integer or real as appropriate.
        //b ||mov|11,-(xs)|7,xr||stack argument in case convert err|22632
        C_PUSH(xr);				// stack argument in case convert err
        //b ||mov|11,-(xs)|7,xr||stack argument for gtstg|22633
        C_PUSH(xr);				// stack argument for gtstg
        //b ||ppm|6,gtn36|||jump if unconvertible|22639
        extern void _l0612();
        C_JMS(gtstg,P_PRC_GTSTG,_l0612);
        } /* gtnum */
        

        void _l0612() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(gtn36));				// jump if unconvertible
//      initialize numeric conversion
        //b ||ldi|4,intv0|||initialize integer result to zero|22643
        ia = c.intv0;				// initialize integer result to zero
        //b ||bze|8,wa|6,gtn32||jump to exit with zero if null|22644
        if ( !( wa) ) C_GOTO(gtn32);				// jump to exit with zero if null
        //b ||lct|8,wa|8,wa||set bct counter for following loops|22645
        wa= wa;				// set bct counter for following loops
        //b ||zer|3,gtnnf|||tentatively indicate result +|22646
        v.gtnnf=0;				// tentatively indicate result +
        //b ||sti|3,gtnex|||initialise exponent to zero|22649
        v.gtnex= ia;				// initialise exponent to zero
        //b ||zer|3,gtnsc|||zero scale in case real|22650
        v.gtnsc=0;				// zero scale in case real
        //b ||zer|3,gtndf|||reset flag for dec point found|22651
        v.gtndf=0;				// reset flag for dec point found
        //b ||zer|3,gtnrd|||reset flag for digits found|22652
        v.gtnrd=0;				// reset flag for digits found
        //b ||ldr|4,reav0|||zero real accum in case real|22653
        {ra_it.d = c.reav0;fl=(!isgoodnum(ra_it.d));}				// zero real accum in case real
        //b ||plc|7,xr|||point to argument characters|22655
        xr += CFP_F;				// point to argument characters
//      merge back here after ignoring leading blank
// gtn01:
        //b |gtn01|lch|8,wb|10,(xr)+||load first character|22659
        C_GOTO(gtn01);
        } /* _l0612 */
        

        void gtn01() {
        wb = *(xr_it.chp++);				// load first character
        //b ||blt|8,wb|18,=ch_d0|6,gtn02|jump if not digit|22660
        if ((wb-CH_D0) < 0) C_GOTO(gtn02);				// jump if not digit
        //b ||ble|8,wb|18,=ch_d9|6,gtn06|jump if first char is a digit|22661
        if ((wb-CH_D9) <= 0) C_GOTO(gtn06);				// jump if first char is a digit
        //b ||ejc|||||22662
        
//      gtnum (continued)
//      here if first digit is non-digit
// gtn02:
        //b |gtn02|bne|8,wb|18,=ch_bl|6,gtn03|jump if non-blank|22668
        C_GOTO(gtn02);
        } /* gtn01 */
        

        void gtn02() {
        if ((wb-CH_BL) != 0) C_GOTO(gtn03);				// jump if non-blank
// gtna2:
        //b |gtna2|bct|8,wa|6,gtn01||else decr count and loop back|22669
        C_GOTO(gtna2);
        } /* gtn02 */
        

        void gtna2() {
        if ((--wa))  C_GOTO(gtn01);				// else decr count and loop back
        //b ||brn|6,gtn07|||jump to return zero if all blanks|22670
         C_GOTO(gtn07);				// jump to return zero if all blanks
//      here for first character non-blank, non-digit
// gtn03:
        //b |gtn03|beq|8,wb|18,=ch_pl|6,gtn04|jump if plus sign|22674
        } /* gtna2 */
        

        void gtn03() {
        if ((wb-CH_PL) == 0) C_GOTO(gtn04);				// jump if plus sign
        //b ||beq|8,wb|18,=ch_ht|6,gtna2|horizontal tab equiv to blank|22676
        if ((wb-CH_HT) == 0) C_GOTO(gtna2);				// horizontal tab equiv to blank
        //b ||bne|8,wb|18,=ch_mn|6,gtn12|jump if not minus (may be real)|22684
        if ((wb-CH_MN) != 0) C_GOTO(gtn12);				// jump if not minus (may be real)
        //b ||mnz|3,gtnnf|||if minus sign, set negative flag|22686
        v.gtnnf = 0xffffffffffffffff;				// if minus sign, set negative flag
//      merge here after processing sign
// gtn04:
        //b |gtn04|bct|8,wa|6,gtn05||jump if chars left|22690
        C_GOTO(gtn04);
        } /* gtn03 */
        

        void gtn04() {
        if ((--wa))  C_GOTO(gtn05);				// jump if chars left
        //b ||brn|6,gtn36|||else error|22691
         C_GOTO(gtn36);				// else error
//      loop to fetch characters of an integer
// gtn05:
        //b |gtn05|lch|8,wb|10,(xr)+||load next character|22695
        } /* gtn04 */
        

        void gtn05() {
        wb = *(xr_it.chp++);				// load next character
        //b ||blt|8,wb|18,=ch_d0|6,gtn08|jump if not a digit|22696
        if ((wb-CH_D0) < 0) C_GOTO(gtn08);				// jump if not a digit
        //b ||bgt|8,wb|18,=ch_d9|6,gtn08|jump if not a digit|22697
        if ((wb-CH_D9) > 0) C_GOTO(gtn08);				// jump if not a digit
//      merge here for first digit
// gtn06:
        //b |gtn06|sti|3,gtnsi|||save current value|22701
        C_GOTO(gtn06);
        } /* gtn05 */
        

        void gtn06() {
        v.gtnsi= ia;				// save current value
        //b ||cvm|6,gtn35|||current*10-(new dig) jump if ovflow|22705
        w0 = ia;				// current*10-(new dig) jump if ovflow
        w0 *= 10;
        if ((ia&0x8000000000000000) != (w0 & 0x8000000000000000)) C_GOTO(gtn35);
        wb = wb - CH_D0; w0 = w0 - wb; ia =w0; /* time 10 ascii */
        //b ||mnz|3,gtnrd|||set digit read flag|22706
        v.gtnrd = 0xffffffffffffffff;				// set digit read flag
        //b ||bct|8,wa|6,gtn05||else loop back if more chars|22708
        if ((--wa))  C_GOTO(gtn05);				// else loop back if more chars
//      here to exit with converted integer value
// gtn07:
        //b |gtn07|bnz|3,gtnnf|6,gtn32||jump if negative (all set)|22712
        C_GOTO(gtn07);
        } /* gtn06 */
        

        void gtn07() {
        if (v.gtnnf) C_GOTO(gtn32);				// jump if negative (all set)
        //b ||ngi||||else negate|22713
        ia= -ia;				// else negate
        //b ||ino|6,gtn32|||jump if no overflow|22714
         C_GOTO(gtn32);				// jump if no overflow
        /*g.ino g.iov is a noop, but could be done like g.aov*/
        //b ||brn|6,gtn36|||else signal error|22715
         C_GOTO(gtn36);				// else signal error
        //b ||ejc|||||22716
        
//      gtnum (continued)
//      here for a non-digit character while attempting to
//      convert an integer, check for trailing blanks or real.
// gtn08:
        //b |gtn08|beq|8,wb|18,=ch_bl|6,gtna9|jump if a blank|22723
        } /* gtn07 */
        

        void gtn08() {
        if ((wb-CH_BL) == 0) C_GOTO(gtna9);				// jump if a blank
        //b ||beq|8,wb|18,=ch_ht|6,gtna9|jump if horizontal tab|22725
        if ((wb-CH_HT) == 0) C_GOTO(gtna9);				// jump if horizontal tab
        //b ||itr||||else convert integer to real|22733
        ra =  (double) (ia);				// else convert integer to real
        //b ||ngr||||negate to get positive value|22734
        {ra_it.d = - ra_it.d;fl=(!isgoodnum(ra_it.d));}				// negate to get positive value
        //b ||brn|6,gtn12|||jump to try for real|22735
         C_GOTO(gtn12);				// jump to try for real
//      here we scan out blanks to end of string
// gtn09:
        //b |gtn09|lch|8,wb|10,(xr)+||get next char|22740
        } /* gtn08 */
        

        void gtn09() {
        wb = *(xr_it.chp++);				// get next char
        //b ||beq|8,wb|18,=ch_ht|6,gtna9|jump if horizontal tab|22742
        if ((wb-CH_HT) == 0) C_GOTO(gtna9);				// jump if horizontal tab
        //b ||bne|8,wb|18,=ch_bl|6,gtn36|error if non-blank|22747
        if ((wb-CH_BL) != 0) C_GOTO(gtn36);				// error if non-blank
// gtna9:
        //b |gtna9|bct|8,wa|6,gtn09||loop back if more chars to check|22748
        C_GOTO(gtna9);
        } /* gtn09 */
        

        void gtna9() {
        if ((--wa))  C_GOTO(gtn09);				// loop back if more chars to check
        //b ||brn|6,gtn07|||return integer if all blanks|22749
         C_GOTO(gtn07);				// return integer if all blanks
//      loop to collect mantissa of real
// gtn10:
        //b |gtn10|lch|8,wb|10,(xr)+||load next character|22755
        } /* gtna9 */
        

        void gtn10() {
        wb = *(xr_it.chp++);				// load next character
        //b ||blt|8,wb|18,=ch_d0|6,gtn12|jump if non-numeric|22756
        if ((wb-CH_D0) < 0) C_GOTO(gtn12);				// jump if non-numeric
        //b ||bgt|8,wb|18,=ch_d9|6,gtn12|jump if non-numeric|22757
        if ((wb-CH_D9) > 0) C_GOTO(gtn12);				// jump if non-numeric
//      merge here to collect first real digit
// gtn11:
        //b |gtn11|sub|8,wb|18,=ch_d0||convert digit to number|22761
        C_GOTO(gtn11);
        } /* gtn10 */
        

        void gtn11() {
        wb -= CH_D0;				// convert digit to number
        //b ||mlr|4,reavt|||multiply real by 10.0|22762
        {w0 = c.reavt;ra_it.d *=  w0_it.d;fl=(!isgoodnum(ra_it.d));}				// multiply real by 10.0
        //b ||rov|6,gtn36|||convert error if overflow|22763
        if (fl) C_GOTO(gtn36);				// convert error if overflow
        //b ||str|3,gtnsr|||save result|22764
        v.gtnsr = (ra_it.d);				// save result
        //b ||mti|8,wb|||get new digit as integer|22765
        ia = (word)(wb);				// get new digit as integer
        //b ||itr||||convert new digit to real|22766
        ra =  (double) (ia);				// convert new digit to real
        //b ||adr|3,gtnsr|||add to get new total|22767
        {w0 = v.gtnsr;ra_it.d += w0_it.d;fl=(!isgoodnum(ra_it.d));}				// add to get new total
        //b ||add|3,gtnsc|3,gtndf||increment scale if after dec point|22768
        v.gtnsc += v.gtndf;				// increment scale if after dec point
        //b ||mnz|3,gtnrd|||set digit found flag|22769
        v.gtnrd = 0xffffffffffffffff;				// set digit found flag
        //b ||bct|8,wa|6,gtn10||loop back if more chars|22770
        if ((--wa))  C_GOTO(gtn10);				// loop back if more chars
        //b ||brn|6,gtn22|||else jump to scale|22771
         C_GOTO(gtn22);				// else jump to scale
        //b ||ejc|||||22772
        
//      gtnum (continued)
//      here if non-digit found while collecting a real
// gtn12:
        //b |gtn12|bne|8,wb|18,=ch_dt|6,gtn13|jump if not dec point|22778
        } /* gtn11 */
        

        void gtn12() {
        if ((wb-CH_DT) != 0) C_GOTO(gtn13);				// jump if not dec point
        //b ||bnz|3,gtndf|6,gtn36||if dec point, error if one already|22779
        if (v.gtndf) C_GOTO(gtn36);				// if dec point, error if one already
        //b ||mov|3,gtndf|18,=num01||else set flag for dec point|22780
        v.gtndf= NUM01;				// else set flag for dec point
        //b ||bct|8,wa|6,gtn10||loop back if more chars|22781
        if ((--wa))  C_GOTO(gtn10);				// loop back if more chars
        //b ||brn|6,gtn22|||else jump to scale|22782
         C_GOTO(gtn22);				// else jump to scale
//      here if not decimal point
// gtn13:
        //b |gtn13|beq|8,wb|18,=ch_le|6,gtn15|jump if e for exponent|22786
        } /* gtn12 */
        

        void gtn13() {
        if ((wb-CH_LE) == 0) C_GOTO(gtn15);				// jump if e for exponent
        //b ||beq|8,wb|18,=ch_ld|6,gtn15|jump if d for exponent|22787
        if ((wb-CH_LD) == 0) C_GOTO(gtn15);				// jump if d for exponent
//      here check for trailing blanks
// gtn14:
        //b |gtn14|beq|8,wb|18,=ch_bl|6,gtnb4|jump if blank|22795
        C_GOTO(gtn14);
        } /* gtn13 */
        

        void gtn14() {
        if ((wb-CH_BL) == 0) C_GOTO(gtnb4);				// jump if blank
        //b ||beq|8,wb|18,=ch_ht|6,gtnb4|jump if horizontal tab|22797
        if ((wb-CH_HT) == 0) C_GOTO(gtnb4);				// jump if horizontal tab
        //b ||brn|6,gtn36|||error if non-blank|22802
         C_GOTO(gtn36);				// error if non-blank
// gtnb4:
        //b |gtnb4|lch|8,wb|10,(xr)+||get next character|22804
        } /* gtn14 */
        

        void gtnb4() {
        wb = *(xr_it.chp++);				// get next character
        //b ||bct|8,wa|6,gtn14||loop back to check if more|22805
        if ((--wa))  C_GOTO(gtn14);				// loop back to check if more
        //b ||brn|6,gtn22|||else jump to scale|22806
         C_GOTO(gtn22);				// else jump to scale
//      here to read and process an exponent
// gtn15:
        //b |gtn15|zer|3,gtnes|||set exponent sign positive|22810
        } /* gtnb4 */
        

        void gtn15() {
        v.gtnes=0;				// set exponent sign positive
        //b ||ldi|4,intv0|||initialize exponent to zero|22811
        ia = c.intv0;				// initialize exponent to zero
        //b ||mnz|3,gtndf|||reset no dec point indication|22812
        v.gtndf = 0xffffffffffffffff;				// reset no dec point indication
        //b ||bct|8,wa|6,gtn16||jump skipping past e or d|22813
        if ((--wa))  C_GOTO(gtn16);				// jump skipping past e or d
        //b ||brn|6,gtn36|||error if null exponent|22814
         C_GOTO(gtn36);				// error if null exponent
//      check for exponent sign
// gtn16:
        //b |gtn16|lch|8,wb|10,(xr)+||load first exponent character|22818
        } /* gtn15 */
        

        void gtn16() {
        wb = *(xr_it.chp++);				// load first exponent character
        //b ||beq|8,wb|18,=ch_pl|6,gtn17|jump if plus sign|22819
        if ((wb-CH_PL) == 0) C_GOTO(gtn17);				// jump if plus sign
        //b ||bne|8,wb|18,=ch_mn|6,gtn19|else jump if not minus sign|22820
        if ((wb-CH_MN) != 0) C_GOTO(gtn19);				// else jump if not minus sign
        //b ||mnz|3,gtnes|||set sign negative if minus sign|22821
        v.gtnes = 0xffffffffffffffff;				// set sign negative if minus sign
//      merge here after processing exponent sign
// gtn17:
        //b |gtn17|bct|8,wa|6,gtn18||jump if chars left|22825
        C_GOTO(gtn17);
        } /* gtn16 */
        

        void gtn17() {
        if ((--wa))  C_GOTO(gtn18);				// jump if chars left
        //b ||brn|6,gtn36|||else error|22826
         C_GOTO(gtn36);				// else error
//      loop to convert exponent digits
// gtn18:
        //b |gtn18|lch|8,wb|10,(xr)+||load next character|22830
        } /* gtn17 */
        

        void gtn18() {
        wb = *(xr_it.chp++);				// load next character
        //b ||ejc|||||22831
        
//      gtnum (continued)
//      merge here for first exponent digit
// gtn19:
        //b |gtn19|blt|8,wb|18,=ch_d0|6,gtn20|jump if not digit|22837
        C_GOTO(gtn19);
        } /* gtn18 */
        

        void gtn19() {
        if ((wb-CH_D0) < 0) C_GOTO(gtn20);				// jump if not digit
        //b ||bgt|8,wb|18,=ch_d9|6,gtn20|jump if not digit|22838
        if ((wb-CH_D9) > 0) C_GOTO(gtn20);				// jump if not digit
        //b ||cvm|6,gtn36|||else current*10, subtract new digit|22839
        w0 = ia;				// else current*10, subtract new digit
        w0 *= 10;
        if ((ia&0x8000000000000000) != (w0 & 0x8000000000000000)) C_GOTO(gtn36);
        wb = wb - CH_D0; w0 = w0 - wb; ia =w0; /* time 10 ascii */
        //b ||bct|8,wa|6,gtn18||loop back if more chars|22840
        if ((--wa))  C_GOTO(gtn18);				// loop back if more chars
        //b ||brn|6,gtn21|||jump if exponent field is exhausted|22841
         C_GOTO(gtn21);				// jump if exponent field is exhausted
//      here to check for trailing blanks after exponent
// gtn20:
        //b |gtn20|beq|8,wb|18,=ch_bl|6,gtnc0|jump if blank|22845
        } /* gtn19 */
        

        void gtn20() {
        if ((wb-CH_BL) == 0) C_GOTO(gtnc0);				// jump if blank
        //b ||beq|8,wb|18,=ch_ht|6,gtnc0|jump if horizontal tab|22847
        if ((wb-CH_HT) == 0) C_GOTO(gtnc0);				// jump if horizontal tab
        //b ||brn|6,gtn36|||error if non-blank|22852
         C_GOTO(gtn36);				// error if non-blank
// gtnc0:
        //b |gtnc0|lch|8,wb|10,(xr)+||get next character|22854
        } /* gtn20 */
        

        void gtnc0() {
        wb = *(xr_it.chp++);				// get next character
        //b ||bct|8,wa|6,gtn20||loop back till all blanks scanned|22855
        if ((--wa))  C_GOTO(gtn20);				// loop back till all blanks scanned
//      merge here after collecting exponent
// gtn21:
        //b |gtn21|sti|3,gtnex|||save collected exponent|22859
        C_GOTO(gtn21);
        } /* gtnc0 */
        

        void gtn21() {
        v.gtnex= ia;				// save collected exponent
        //b ||bnz|3,gtnes|6,gtn22||jump if it was negative|22860
        if (v.gtnes) C_GOTO(gtn22);				// jump if it was negative
        //b ||ngi||||else complement|22861
        ia= -ia;				// else complement
        //b ||iov|6,gtn36|||error if overflow|22862
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// error if overflow
        //b ||sti|3,gtnex|||and store positive exponent|22863
        v.gtnex= ia;				// and store positive exponent
//      merge here with exponent (0 if none given)
// gtn22:
        //b |gtn22|bze|3,gtnrd|6,gtn36||error if not digits collected|22867
        C_GOTO(gtn22);
        } /* gtn21 */
        

        void gtn22() {
        if ( !( v.gtnrd) ) C_GOTO(gtn36);				// error if not digits collected
        //b ||bze|3,gtndf|6,gtn36||error if no exponent or dec point|22868
        if ( !( v.gtndf) ) C_GOTO(gtn36);				// error if no exponent or dec point
        //b ||mti|3,gtnsc|||else load scale as integer|22869
        ia = (word)(v.gtnsc);				// else load scale as integer
        //b ||sbi|3,gtnex|||subtract exponent|22870
        ia-=v.gtnex;				// subtract exponent
        //b ||iov|6,gtn36|||error if overflow|22871
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// error if overflow
        //b ||ilt|6,gtn26|||jump if we must scale up|22872
        if (ia < 0)  C_GOTO(gtn26);				// jump if we must scale up
//      here we have a negative exponent, so scale down
        //b ||mfi|8,wa|6,gtn36||load scale factor, err if ovflow|22876
        if (ia<0) C_GOTO( gtn36);				// load scale factor, err if ovflow
        wa = ia;
//      loop to scale down in steps of 10**10
// gtn23:
        //b |gtn23|ble|8,wa|18,=num10|6,gtn24|jump if 10 or less to go|22880
        C_GOTO(gtn23);
        } /* gtn22 */
        

        void gtn23() {
        if ((wa-NUM10) <= 0) C_GOTO(gtn24);				// jump if 10 or less to go
        //b ||dvr|4,reatt|||else divide by 10**10|22881
        {w0 = c.reatt; if (w0_it.d != 0.0) {ra_it.d /= w0_it.d;fl= (!isgoodnum(ra_it.d));} else {fl=1;}}				// else divide by 10**10
        //b ||sub|8,wa|18,=num10||decrement scale|22882
        wa -= NUM10;				// decrement scale
        //b ||brn|6,gtn23|||and loop back|22883
         C_GOTO(gtn23);				// and loop back
        //b ||ejc|||||22884
        
//      gtnum (continued)
//      here scale rest of way from powers of ten table
// gtn24:
        //b |gtn24|bze|8,wa|6,gtn30||jump if scaled|22890
        } /* gtn23 */
        

        void gtn24() {
        if ( !( wa) ) C_GOTO(gtn30);				// jump if scaled
        //b ||lct|8,wb|18,=cfp_r||else get indexing factor|22891
        wb= CFP_R;				// else get indexing factor
        //b ||mov|7,xr|21,=reav1||point to powers of ten table|22892
        xr= (word)(&c.reav1);				// point to powers of ten table
        //b ||wtb|8,wa|||convert remaining scale to byte ofs|22893
        wa <<= LOG_CFP_B;				// convert remaining scale to byte ofs
//      loop to point to powers of ten table entry
// gtn25:
        //b |gtn25|add|7,xr|8,wa||bump pointer|22897
        C_GOTO(gtn25);
        } /* gtn24 */
        

        void gtn25() {
        xr += wa;				// bump pointer
        //b ||bct|8,wb|6,gtn25||once for each value word|22898
        if ((--wb))  C_GOTO(gtn25);				// once for each value word
        //b ||dvr|9,(xr)|||scale down as required|22899
        {w0 = *(xr_it.wp); if (w0_it.d != 0.0) {ra_it.d /= w0_it.d;fl= (!isgoodnum(ra_it.d));} else {fl=1;}}				// scale down as required
        //b ||brn|6,gtn30|||and jump|22900
         C_GOTO(gtn30);				// and jump
//      come here to scale result up (positive exponent)
// gtn26:
        //b |gtn26|ngi||||get absolute value of exponent|22904
        } /* gtn25 */
        

        void gtn26() {
        ia= -ia;				// get absolute value of exponent
        //b ||iov|6,gtn36|||error if overflow|22905
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// error if overflow
        //b ||mfi|8,wa|6,gtn36||acquire scale, error if ovflow|22906
        if (ia<0) C_GOTO( gtn36);				// acquire scale, error if ovflow
        wa = ia;
//      loop to scale up in steps of 10**10
// gtn27:
        //b |gtn27|ble|8,wa|18,=num10|6,gtn28|jump if 10 or less to go|22910
        C_GOTO(gtn27);
        } /* gtn26 */
        

        void gtn27() {
        if ((wa-NUM10) <= 0) C_GOTO(gtn28);				// jump if 10 or less to go
        //b ||mlr|4,reatt|||else multiply by 10**10|22911
        {w0 = c.reatt;ra_it.d *=  w0_it.d;fl=(!isgoodnum(ra_it.d));}				// else multiply by 10**10
        //b ||rov|6,gtn36|||error if overflow|22912
        if (fl) C_GOTO(gtn36);				// error if overflow
        //b ||sub|8,wa|18,=num10||else decrement scale|22913
        wa -= NUM10;				// else decrement scale
        //b ||brn|6,gtn27|||and loop back|22914
         C_GOTO(gtn27);				// and loop back
//      here to scale up rest of way with table
// gtn28:
        //b |gtn28|bze|8,wa|6,gtn30||jump if scaled|22918
        } /* gtn27 */
        

        void gtn28() {
        if ( !( wa) ) C_GOTO(gtn30);				// jump if scaled
        //b ||lct|8,wb|18,=cfp_r||else get indexing factor|22919
        wb= CFP_R;				// else get indexing factor
        //b ||mov|7,xr|21,=reav1||point to powers of ten table|22920
        xr= (word)(&c.reav1);				// point to powers of ten table
        //b ||wtb|8,wa|||convert remaining scale to byte ofs|22921
        wa <<= LOG_CFP_B;				// convert remaining scale to byte ofs
//      loop to point to proper entry in powers of ten table
// gtn29:
        //b |gtn29|add|7,xr|8,wa||bump pointer|22925
        C_GOTO(gtn29);
        } /* gtn28 */
        

        void gtn29() {
        xr += wa;				// bump pointer
        //b ||bct|8,wb|6,gtn29||once for each word in value|22926
        if ((--wb))  C_GOTO(gtn29);				// once for each word in value
        //b ||mlr|9,(xr)|||scale up|22927
        {w0 = *(xr_it.wp);ra_it.d *=  w0_it.d;fl=(!isgoodnum(ra_it.d));}				// scale up
        //b ||rov|6,gtn36|||error if overflow|22928
        if (fl) C_GOTO(gtn36);				// error if overflow
        //b ||ejc|||||22929
        
//      gtnum (continued)
//      here with real value scaled and ready except for sign
// gtn30:
        //b |gtn30|bze|3,gtnnf|6,gtn31||jump if positive|22935
        C_GOTO(gtn30);
        } /* gtn29 */
        

        void gtn30() {
        if ( !( v.gtnnf) ) C_GOTO(gtn31);				// jump if positive
        //b ||ngr||||else negate|22936
        {ra_it.d = - ra_it.d;fl=(!isgoodnum(ra_it.d));}				// else negate
//      here with properly signed real value in (ra)
// gtn31:
        //b |gtn31|jsr|6,rcbld|||build real block|22940
        C_GOTO(gtn31);
        } /* gtn30 */
        

        void gtn31() {
        C_JSR(rcbld);				// build real block
        //b ||brn|6,gtn33|||merge to exit|22941
         C_GOTO(gtn33);				// merge to exit
//      here with properly signed integer value in (ia)
// gtn32:
        //b |gtn32|jsr|6,icbld|||build icblk|22946
        } /* gtn31 */
        

        void gtn32() {
        C_JSR(icbld);				// build icblk
//      real merges here
// gtn33:
        //b |gtn33|mov|8,wa|9,(xr)||load first word of result block|22950
        C_GOTO(gtn33);
        } /* gtn32 */
        

        void gtn33() {
        wa= *(xr_it.wp);				// load first word of result block
        //b ||ica|7,xs|||pop argument off stack|22951
        xs += CFP_B;				// pop argument off stack
//      common exit point
// gtn34:
        //b |gtn34|exi||||return to gtnum caller|22955
        C_GOTO(gtn34);
        } /* gtn33 */
        

        void gtn34() {
        C_EXIT(0);				// return to gtnum caller
//      come here if overflow occurs during collection of integer
//      have to restore wb which cvm may have destroyed.
// gtn35:
        //b |gtn35|lch|8,wb|11,-(xr)||reload current character|22962
        } /* gtn34 */
        

        void gtn35() {
        wb = *(--xr_it.chp);				// reload current character
        //b ||lch|8,wb|10,(xr)+||bump character pointer|22963
        wb = *(xr_it.chp++);				// bump character pointer
        //b ||ldi|3,gtnsi|||reload integer so far|22964
        ia = v.gtnsi;				// reload integer so far
        //b ||itr||||convert to real|22965
        ra =  (double) (ia);				// convert to real
        //b ||ngr||||make value positive|22966
        {ra_it.d = - ra_it.d;fl=(!isgoodnum(ra_it.d));}				// make value positive
        //b ||brn|6,gtn11|||merge with real circuit|22967
         C_GOTO(gtn11);				// merge with real circuit
//      here for unconvertible to string or conversion error
// gtn36:
        //b |gtn36|mov|7,xr|10,(xs)+||reload original argument|22972
        } /* gtn35 */
        

        void gtn36() {
        xr= C_POP();				// reload original argument
        //b ||exi|1,1|||take convert-error exit|22973
        C_EXIT(1);				// take convert-error exit
        //b ||ejc|||||22975
        
//      gtnvr -- convert to natural variable
//      gtnvr locates a variable block (vrblk) given either an
//      appropriate name (nmblk) or a non-null string (scblk).
//      (xr)                  argument
//      jsr  gtnvr            call to convert to natural variable
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  pointer to vrblk
//      (wa,wb)               destroyed (conversion error only)
//      (wc)                  destroyed
// gtnvr:
        //b |gtnvr|prc|25,e|1,1||entry point|22989
        } /* gtn36 */
        

        void gtnvr() {
        //b ||bne|9,(xr)|22,=b_nml|6,gnv02|jump if not name|22991
        if ((*(xr_it.wp)-(word)(b_nml)) != 0) C_GOTO(gnv02);				// jump if not name
        //b ||mov|7,xr|13,nmbas(xr)||else load name base if name|22992
        xr= *((word *)(CFP_B*NMBAS + xr));				// else load name base if name
        //b ||blo|7,xr|3,state|6,gnv07|skip if vrblk (in static region)|22993
        if ((xr-v.state) < 0) C_GOTO(gnv07);				// skip if vrblk (in static region)
//      common error exit
// gnv01:
        //b |gnv01|exi|1,1|||take convert-error exit|22997
        C_GOTO(gnv01);
        } /* gtnvr */
        

        void gnv01() {
        C_EXIT(1);				// take convert-error exit
//      here if not name
// gnv02:
        //b |gnv02|mov|3,gnvsa|8,wa||save wa|23001
        } /* gnv01 */
        

        void gnv02() {
        v.gnvsa= wa;				// save wa
        //b ||mov|3,gnvsb|8,wb||save wb|23002
        v.gnvsb= wb;				// save wb
        //b ||mov|11,-(xs)|7,xr||stack argument for gtstg|23003
        C_PUSH(xr);				// stack argument for gtstg
        //b ||ppm|6,gnv01|||jump if conversion error|23005
        extern void _l0623();
        C_JMS(gtstg,P_PRC_GTSTG,_l0623);
        } /* gnv02 */
        

        void _l0623() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(gnv01));				// jump if conversion error
        //b ||bze|8,wa|6,gnv01||null string is an error|23006
        if ( !( wa) ) C_GOTO(gnv01);				// null string is an error
        //b ||mov|11,-(xs)|7,xl||save xl|23010
        C_PUSH(xl);				// save xl
        //b ||mov|11,-(xs)|7,xr||stack string ptr for later|23011
        C_PUSH(xr);				// stack string ptr for later
        //b ||mov|8,wb|7,xr||copy string pointer|23012
        wb= xr;				// copy string pointer
        //b ||add|8,wb|19,*schar||point to characters of string|23013
        wb += CFP_B*SCHAR;				// point to characters of string
        //b ||mov|3,gnvst|8,wb||save pointer to characters|23014
        v.gnvst= wb;				// save pointer to characters
        //b ||mov|8,wb|8,wa||copy length|23015
        wb= wa;				// copy length
        //b ||ctw|8,wb|1,0||get number of words in name|23016
        wb = (wb+(CFP_C-1)+CFP_C* 0) >> LOG_CFP_C;				// get number of words in name
        //b ||mov|3,gnvnw|8,wb||save for later|23017
        v.gnvnw= wb;				// save for later
        //b ||jsr|6,hashs|||compute hash index for string|23018
        C_JSR(hashs);				// compute hash index for string
        //b ||rmi|3,hshnb|||compute hash offset by taking mod|23019
        ia=ia % v.hshnb;				// compute hash offset by taking mod
        //b ||mfi|8,wc|||get as offset|23020
        wc = ia;				// get as offset
        //b ||wtb|8,wc|||convert offset to bytes|23021
        wc <<= LOG_CFP_B;				// convert offset to bytes
        //b ||add|8,wc|3,hshtb||point to proper hash chain|23022
        wc += v.hshtb;				// point to proper hash chain
        //b ||sub|8,wc|19,*vrnxt||subtract offset to merge into loop|23023
        wc -= CFP_B*VRNXT;				// subtract offset to merge into loop
        //b ||ejc|||||23024
        
//      gtnvr (continued)
//      loop to search hash chain
// gnv03:
        //b |gnv03|mov|7,xl|8,wc||copy hash chain pointer|23030
        C_GOTO(gnv03);
        } /* _l0623 */
        

        void gnv03() {
        xl= wc;				// copy hash chain pointer
        //b ||mov|7,xl|13,vrnxt(xl)||point to next vrblk on chain|23031
        xl= *((word *)(CFP_B*VRNXT + xl));				// point to next vrblk on chain
        //b ||bze|7,xl|6,gnv08||jump if end of chain|23032
        if ( !( xl) ) C_GOTO(gnv08);				// jump if end of chain
        //b ||mov|8,wc|7,xl||save pointer to this vrblk|23033
        wc= xl;				// save pointer to this vrblk
        //b ||bnz|13,vrlen(xl)|6,gnv04||jump if not system variable|23034
        if (*((word *)(CFP_B*VRLEN + xl))) C_GOTO(gnv04);				// jump if not system variable
        //b ||mov|7,xl|13,vrsvp(xl)||else point to svblk|23035
        xl= *((word *)(CFP_B*VRSVP + xl));				// else point to svblk
        //b ||sub|7,xl|19,*vrsof||adjust offset for merge|23036
        xl -= CFP_B*VRSOF;				// adjust offset for merge
//      merge here with string ptr (like vrblk) in xl
// gnv04:
        //b |gnv04|bne|8,wa|13,vrlen(xl)|6,gnv03|back for next vrblk if lengths ne|23040
        C_GOTO(gnv04);
        } /* gnv03 */
        

        void gnv04() {
        if ((wa-*((word *)(CFP_B*VRLEN + xl))) != 0) C_GOTO(gnv03);				// back for next vrblk if lengths ne
        //b ||add|7,xl|19,*vrchs||else point to chars of chain entry|23041
        xl += CFP_B*VRCHS;				// else point to chars of chain entry
        //b ||lct|8,wb|3,gnvnw||get word counter to control loop|23042
        wb= v.gnvnw;				// get word counter to control loop
        //b ||mov|7,xr|3,gnvst||point to chars of new name|23043
        xr= v.gnvst;				// point to chars of new name
//      loop to compare characters of the two names
// gnv05:
        //b |gnv05|cne|9,(xr)|9,(xl)|6,gnv03|jump if no match for next vrblk|23047
        C_GOTO(gnv05);
        } /* gnv04 */
        

        void gnv05() {
        if ((*(xr_it.wp) - *(xl_it.wp))!= 0) C_GOTO(gnv03);				// jump if no match for next vrblk
        //b ||ica|7,xr|||bump new name pointer|23048
        xr += CFP_B;				// bump new name pointer
        //b ||ica|7,xl|||bump vrblk in chain name pointer|23049
        xl += CFP_B;				// bump vrblk in chain name pointer
        //b ||bct|8,wb|6,gnv05||else loop till all compared|23050
        if ((--wb))  C_GOTO(gnv05);				// else loop till all compared
        //b ||mov|7,xr|8,wc||we have found a match, get vrblk|23051
        xr= wc;				// we have found a match, get vrblk
//      exit point after finding vrblk or building new one
// gnv06:
        //b |gnv06|mov|8,wa|3,gnvsa||restore wa|23055
        C_GOTO(gnv06);
        } /* gnv05 */
        

        void gnv06() {
        wa= v.gnvsa;				// restore wa
        //b ||mov|8,wb|3,gnvsb||restore wb|23056
        wb= v.gnvsb;				// restore wb
        //b ||ica|7,xs|||pop string pointer|23057
        xs += CFP_B;				// pop string pointer
        //b ||mov|7,xl|10,(xs)+||restore xl|23058
        xl= C_POP();				// restore xl
//      common exit point
// gnv07:
        //b |gnv07|exi||||return to gtnvr caller|23062
        C_GOTO(gnv07);
        } /* gnv06 */
        

        void gnv07() {
        C_EXIT(0);				// return to gtnvr caller
//      not found, prepare to search system variable table
// gnv08:
        //b |gnv08|zer|7,xr|||clear garbage xr pointer|23066
        } /* gnv07 */
        

        void gnv08() {
        xr=0;				// clear garbage xr pointer
        //b ||mov|3,gnvhe|8,wc||save ptr to end of hash chain|23067
        v.gnvhe= wc;				// save ptr to end of hash chain
        //b ||bgt|8,wa|18,=num09|6,gnv14|cannot be system var if length gt 9|23068
        if ((wa-NUM09) > 0) C_GOTO(gnv14);				// cannot be system var if length gt 9
        //b ||mov|7,xl|8,wa||else copy length|23069
        xl= wa;				// else copy length
        //b ||wtb|7,xl|||convert to byte offset|23070
        xl <<= LOG_CFP_B;				// convert to byte offset
        //b ||mov|7,xl|14,vsrch(xl)||point to first svblk of this length|23071
        xl= *((word *)( ((word)&c.vsrch) + xl));				// point to first svblk of this length
        //b ||ejc|||||23072
        
//      gtnvr (continued)
//      loop to search entries in standard variable table
// gnv09:
        //b |gnv09|mov|3,gnvsp|7,xl||save table pointer|23078
        C_GOTO(gnv09);
        } /* gnv08 */
        

        void gnv09() {
        v.gnvsp= xl;				// save table pointer
        //b ||mov|8,wc|10,(xl)+||load svbit bit string|23079
        wc= *(xl_it.wp++);				// load svbit bit string
        //b ||mov|8,wb|10,(xl)+||load length from table entry|23080
        wb= *(xl_it.wp++);				// load length from table entry
        //b ||bne|8,wa|8,wb|6,gnv14|jump if end of right length entries|23081
        if ((wa-wb) != 0) C_GOTO(gnv14);				// jump if end of right length entries
        //b ||lct|8,wb|3,gnvnw||get word counter to control loop|23082
        wb= v.gnvnw;				// get word counter to control loop
        //b ||mov|7,xr|3,gnvst||point to chars of new name|23083
        xr= v.gnvst;				// point to chars of new name
//      loop to check for matching names
// gnv10:
        //b |gnv10|cne|9,(xr)|9,(xl)|6,gnv11|jump if name mismatch|23087
        C_GOTO(gnv10);
        } /* gnv09 */
        

        void gnv10() {
        if ((*(xr_it.wp) - *(xl_it.wp))!= 0) C_GOTO(gnv11);				// jump if name mismatch
        //b ||ica|7,xr|||else bump new name pointer|23088
        xr += CFP_B;				// else bump new name pointer
        //b ||ica|7,xl|||bump svblk pointer|23089
        xl += CFP_B;				// bump svblk pointer
        //b ||bct|8,wb|6,gnv10||else loop until all checked|23090
        if ((--wb))  C_GOTO(gnv10);				// else loop until all checked
//      here we have a match in the standard variable table
        //b ||zer|8,wc|||set vrlen value zero|23094
        wc=0;				// set vrlen value zero
        //b ||mov|8,wa|19,*vrsi_||set standard size|23095
        wa= CFP_B*VRSI_;				// set standard size
        //b ||brn|6,gnv15|||jump to build vrblk|23096
         C_GOTO(gnv15);				// jump to build vrblk
//      here if no match with table entry in svblks table
// gnv11:
        //b |gnv11|ica|7,xl|||bump past word of chars|23100
        } /* gnv10 */
        

        void gnv11() {
        xl += CFP_B;				// bump past word of chars
        //b ||bct|8,wb|6,gnv11||loop back if more to go|23101
        if ((--wb))  C_GOTO(gnv11);				// loop back if more to go
        //b ||rsh|8,wc|2,svnbt||remove uninteresting bits|23102
        wc >>= SVNBT;				// remove uninteresting bits
//      loop to bump table ptr for each flagged word
// gnv12:
        //b |gnv12|mov|8,wb|4,bits1||load bit to test|23106
        C_GOTO(gnv12);
        } /* gnv11 */
        

        void gnv12() {
        wb= c.bits1;				// load bit to test
        //b ||anb|8,wb|8,wc||test for word present|23107
        wb &= wc;				// test for word present
        //b ||zrb|8,wb|6,gnv13||jump if not present|23108
        if (!(wb)) C_GOTO(gnv13);				// jump if not present
        //b ||ica|7,xl|||else bump table pointer|23109
        xl += CFP_B;				// else bump table pointer
//      here after dealing with one word (one bit)
// gnv13:
        //b |gnv13|rsh|8,wc|1,1||remove bit already processed|23113
        C_GOTO(gnv13);
        } /* gnv12 */
        

        void gnv13() {
        wc >>= 1;				// remove bit already processed
        //b ||nzb|8,wc|6,gnv12||loop back if more bits to test|23114
        if (wc) C_GOTO(gnv12);				// loop back if more bits to test
        //b ||brn|6,gnv09|||else loop back for next svblk|23115
         C_GOTO(gnv09);				// else loop back for next svblk
//      here if not system variable
// gnv14:
        //b |gnv14|mov|8,wc|8,wa||copy vrlen value|23119
        } /* gnv13 */
        

        void gnv14() {
        wc= wa;				// copy vrlen value
        //b ||mov|8,wa|18,=vrchs||load standard size -chars|23120
        wa= VRCHS;				// load standard size -chars
        //b ||add|8,wa|3,gnvnw||adjust for chars of name|23121
        wa += v.gnvnw;				// adjust for chars of name
        //b ||wtb|8,wa|||convert length to bytes|23122
        wa <<= LOG_CFP_B;				// convert length to bytes
        //b ||ejc|||||23123
        
//      gtnvr (continued)
//      merge here to build vrblk
// gnv15:
        //b |gnv15|jsr|6,alost|||allocate space for vrblk (static)|23129
        C_GOTO(gnv15);
        } /* gnv14 */
        

        void gnv15() {
        C_JSR(alost);				// allocate space for vrblk (static)
        //b ||mov|8,wb|7,xr||save vrblk pointer|23130
        wb= xr;				// save vrblk pointer
        //b ||mov|7,xl|21,=stnvr||point to model variable block|23131
        xl= (word)(&c.stnvr);				// point to model variable block
        //b ||mov|8,wa|19,*vrlen||set length of standard fields|23132
        wa= CFP_B*VRLEN;				// set length of standard fields
        //b ||mvw||||set initial fields of new block|23133
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// set initial fields of new block
        //b ||mov|7,xl|3,gnvhe||load pointer to end of hash chain|23134
        xl= v.gnvhe;				// load pointer to end of hash chain
        //b ||mov|13,vrnxt(xl)|8,wb||add new block to end of chain|23135
        *((word *)(CFP_B*VRNXT + xl))= wb;				// add new block to end of chain
        //b ||mov|10,(xr)+|8,wc||set vrlen field, bump ptr|23136
        *(xr_it.wp++)= wc;				// set vrlen field, bump ptr
        //b ||mov|8,wa|3,gnvnw||get length in words|23137
        wa= v.gnvnw;				// get length in words
        //b ||wtb|8,wa|||convert to length in bytes|23138
        wa <<= LOG_CFP_B;				// convert to length in bytes
        //b ||bze|8,wc|6,gnv16||jump if system variable|23139
        if ( !( wc) ) C_GOTO(gnv16);				// jump if system variable
//      here for non-system variable -- set chars of name
        //b ||mov|7,xl|9,(xs)||point back to string name|23143
        xl= *(xs_it.wp);				// point back to string name
        //b ||add|7,xl|19,*schar||point to chars of name|23144
        xl += CFP_B*SCHAR;				// point to chars of name
        //b ||mvw||||move characters into place|23145
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// move characters into place
        //b ||mov|7,xr|8,wb||restore vrblk pointer|23146
        xr= wb;				// restore vrblk pointer
        //b ||brn|6,gnv06|||jump back to exit|23147
         C_GOTO(gnv06);				// jump back to exit
//      here for system variable case to fill in fields where
//      necessary from the fields present in the svblk.
// gnv16:
        //b |gnv16|mov|7,xl|3,gnvsp||load pointer to svblk|23152
        } /* gnv15 */
        

        void gnv16() {
        xl= v.gnvsp;				// load pointer to svblk
        //b ||mov|9,(xr)|7,xl||set svblk ptr in vrblk|23153
        *(xr_it.wp)= xl;				// set svblk ptr in vrblk
        //b ||mov|7,xr|8,wb||restore vrblk pointer|23154
        xr= wb;				// restore vrblk pointer
        //b ||mov|8,wb|13,svbit(xl)||load bit indicators|23155
        wb= *((word *)(CFP_B*SVBIT + xl));				// load bit indicators
        //b ||add|7,xl|19,*svchs||point to characters of name|23156
        xl += CFP_B*SVCHS;				// point to characters of name
        //b ||add|7,xl|8,wa||point past characters|23157
        xl += wa;				// point past characters
//      skip past keyword number (svknm) if present
        //b ||mov|8,wc|4,btknm||load test bit|23161
        wc= c.btknm;				// load test bit
        //b ||anb|8,wc|8,wb||and to test|23162
        wc &= wb;				// and to test
        //b ||zrb|8,wc|6,gnv17||jump if no keyword number|23163
        if (!(wc)) C_GOTO(gnv17);				// jump if no keyword number
        //b ||ica|7,xl|||else bump pointer|23164
        xl += CFP_B;				// else bump pointer
        //b ||ejc|||||23165
        
//      gtnvr (continued)
//      here test for function (svfnc and svnar)
// gnv17:
        //b |gnv17|mov|8,wc|4,btfnc||get test bit|23171
        C_GOTO(gnv17);
        } /* gnv16 */
        

        void gnv17() {
        wc= c.btfnc;				// get test bit
        //b ||anb|8,wc|8,wb||and to test|23172
        wc &= wb;				// and to test
        //b ||zrb|8,wc|6,gnv18||skip if no system function|23173
        if (!(wc)) C_GOTO(gnv18);				// skip if no system function
        //b ||mov|13,vrfnc(xr)|7,xl||else point vrfnc to svfnc field|23174
        *((word *)(CFP_B*VRFNC + xr))= xl;				// else point vrfnc to svfnc field
        //b ||add|7,xl|19,*num02||and bump past svfnc, svnar fields|23175
        xl += CFP_B*NUM02;				// and bump past svfnc, svnar fields
//      now test for label (svlbl)
// gnv18:
        //b |gnv18|mov|8,wc|4,btlbl||get test bit|23179
        C_GOTO(gnv18);
        } /* gnv17 */
        

        void gnv18() {
        wc= c.btlbl;				// get test bit
        //b ||anb|8,wc|8,wb||and to test|23180
        wc &= wb;				// and to test
        //b ||zrb|8,wc|6,gnv19||jump if bit is off (no system labl)|23181
        if (!(wc)) C_GOTO(gnv19);				// jump if bit is off (no system labl)
        //b ||mov|13,vrlbl(xr)|7,xl||else point vrlbl to svlbl field|23182
        *((word *)(CFP_B*VRLBL + xr))= xl;				// else point vrlbl to svlbl field
        //b ||ica|7,xl|||bump past svlbl field|23183
        xl += CFP_B;				// bump past svlbl field
//      now test for value (svval)
// gnv19:
        //b |gnv19|mov|8,wc|4,btval||load test bit|23187
        C_GOTO(gnv19);
        } /* gnv18 */
        

        void gnv19() {
        wc= c.btval;				// load test bit
        //b ||anb|8,wc|8,wb||and to test|23188
        wc &= wb;				// and to test
        //b ||zrb|8,wc|6,gnv06||all done if no value|23189
        if (!(wc)) C_GOTO(gnv06);				// all done if no value
        //b ||mov|13,vrval(xr)|9,(xl)||else set initial value|23190
        *((word *)(CFP_B*VRVAL + xr))= *(xl_it.wp);				// else set initial value
        //b ||mov|13,vrsto(xr)|22,=b_vre||set error store access|23191
        *((word *)(CFP_B*VRSTO + xr))= (word)(b_vre);				// set error store access
        //b ||brn|6,gnv06|||merge back to exit to caller|23192
         C_GOTO(gnv06);				// merge back to exit to caller
        //b ||ejc|||||23194
        
//      gtpat -- get pattern
//      gtpat is passed an object in (xr) and returns a
//      pattern after performing any necessary conversions
//      (xr)                  input argument
//      jsr  gtpat            call to convert to pattern
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  resulting pattern
//      (wa)                  destroyed
//      (wb)                  destroyed (only on convert error)
//      (xr)                  unchanged (only on convert error)
// gtpat:
        //b |gtpat|prc|25,e|1,1||entry point|23209
        } /* gnv19 */
        

        void gtpat() {
        //b ||bhi|9,(xr)|22,=p_aaa|6,gtpt5|jump if pattern already|23211
        if ((*(xr_it.wp)-(word)(p_aaa)) > 0) C_GOTO(gtpt5);				// jump if pattern already
//      here if not pattern, try for string
        //b ||mov|3,gtpsb|8,wb||save wb|23215
        v.gtpsb= wb;				// save wb
        //b ||mov|11,-(xs)|7,xr||stack argument for gtstg|23216
        C_PUSH(xr);				// stack argument for gtstg
        //b ||ppm|6,gtpt2|||jump if impossible|23218
        extern void _l0627();
        C_JMS(gtstg,P_PRC_GTSTG,_l0627);
        } /* gtpat */
        

        void _l0627() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(gtpt2));				// jump if impossible
//      here we have a string
        //b ||bnz|8,wa|6,gtpt1||jump if non-null|23222
        if (wa) C_GOTO(gtpt1);				// jump if non-null
//      here for null string. generate pointer to null pattern.
        //b ||mov|7,xr|21,=ndnth||point to nothen node|23226
        xr= (word)(&c.ndnth);				// point to nothen node
        //b ||brn|6,gtpt4|||jump to exit|23227
         C_GOTO(gtpt4);				// jump to exit
        //b ||ejc|||||23228
        
//      gtpat (continued)
//      here for non-null string
// gtpt1:
        //b |gtpt1|mov|8,wb|22,=p_str||load pcode for multi-char string|23234
        } /* _l0627 */
        

        void gtpt1() {
        wb= (word)(p_str);				// load pcode for multi-char string
        //b ||bne|8,wa|18,=num01|6,gtpt3|jump if multi-char string|23235
        if ((wa-NUM01) != 0) C_GOTO(gtpt3);				// jump if multi-char string
//      here for one character string, share one character any
        //b ||plc|7,xr|||point to character|23239
        xr += CFP_F;				// point to character
        //b ||lch|8,wa|9,(xr)||load character|23240
        wa = *(xr_it.chp);				// load character
        //b ||mov|7,xr|8,wa||set as parm1|23241
        xr= wa;				// set as parm1
        //b ||mov|8,wb|22,=p_ans||point to pcode for 1-char any|23242
        wb= (word)(p_ans);				// point to pcode for 1-char any
        //b ||brn|6,gtpt3|||jump to build node|23243
         C_GOTO(gtpt3);				// jump to build node
//      here if argument is not convertible to string
// gtpt2:
        //b |gtpt2|mov|8,wb|22,=p_exa||set pcode for expression in case|23247
        } /* gtpt1 */
        

        void gtpt2() {
        wb= (word)(p_exa);				// set pcode for expression in case
        //b ||blo|9,(xr)|22,=b_e__|6,gtpt3|jump to build node if expression|23248
        if ((*(xr_it.wp)-(word)(b_e__)) < 0) C_GOTO(gtpt3);				// jump to build node if expression
//      here we have an error (conversion impossible)
        //b ||exi|1,1|||take convert error exit|23252
        C_EXIT(1);				// take convert error exit
//      merge here to build node for string or expression
// gtpt3:
        //b |gtpt3|jsr|6,pbild|||call routine to build pattern node|23256
        } /* gtpt2 */
        

        void gtpt3() {
        C_JSR(pbild);				// call routine to build pattern node
//      common exit after successful conversion
// gtpt4:
        //b |gtpt4|mov|8,wb|3,gtpsb||restore wb|23260
        C_GOTO(gtpt4);
        } /* gtpt3 */
        

        void gtpt4() {
        wb= v.gtpsb;				// restore wb
//      merge here to exit if no conversion required
// gtpt5:
        //b |gtpt5|exi||||return to gtpat caller|23264
        C_GOTO(gtpt5);
        } /* gtpt4 */
        

        void gtpt5() {
        C_EXIT(0);				// return to gtpat caller
        //b ||ejc|||||23268
        
//      gtrea -- get real value
//      gtrea is passed an object and returns a real value
//      performing any necessary conversions.
//      (xr)                  object to be converted
//      jsr  gtrea            call to convert object to real
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  pointer to resulting real
//      (wa,wb,wc,ra)         destroyed
//      (xr)                  unchanged (convert error only)
// gtrea:
        //b |gtrea|prc|25,e|1,1||entry point|23282
        } /* gtpt5 */
        

        void gtrea() {
        //b ||mov|8,wa|9,(xr)||get first word of block|23283
        wa= *(xr_it.wp);				// get first word of block
        //b ||beq|8,wa|22,=b_rcl|6,gtre2|jump if real|23284
        if ((wa-(word)(b_rcl)) == 0) C_GOTO(gtre2);				// jump if real
        //b ||ppm|6,gtre3|||jump if unconvertible|23286
        C_JSR_1(gtnum,C_GOTO(gtre3));				// jump if unconvertible
        //b ||beq|8,wa|22,=b_rcl|6,gtre2|jump if real was returned|23287
        if ((wa-(word)(b_rcl)) == 0) C_GOTO(gtre2);				// jump if real was returned
//      here for case of an integer to convert to real
// gtre1:
        //b |gtre1|ldi|13,icval(xr)|||load integer|23291
        C_GOTO(gtre1);
        } /* gtrea */
        

        void gtre1() {
        ia = *((word *)(CFP_B*ICVAL + xr));				// load integer
        //b ||itr||||convert to real|23292
        ra =  (double) (ia);				// convert to real
        //b ||jsr|6,rcbld|||build rcblk|23293
        C_JSR(rcbld);				// build rcblk
//      exit with real
// gtre2:
        //b |gtre2|exi||||return to gtrea caller|23297
        C_GOTO(gtre2);
        } /* gtre1 */
        

        void gtre2() {
        C_EXIT(0);				// return to gtrea caller
//      here on conversion error
// gtre3:
        //b |gtre3|exi|1,1|||take convert error exit|23301
        } /* gtre2 */
        

        void gtre3() {
        C_EXIT(1);				// take convert error exit
        //b ||ejc|||||23304
        
//      gtsmi -- get small integer
//      gtsmi is passed a snobol object and returns an address
//      integer in the range (0 le n le dnamb). such a value can
//      only be derived from an integer in the appropriate range.
//      small integers never appear as snobol values. however,
//      they are used internally for a variety of purposes.
//      -(xs)                 argument to convert (on stack)
//      jsr  gtsmi            call to convert to small integer
//      ppm  loc              transfer loc for not integer
//      ppm  loc              transfer loc for lt 0, gt dnamb
//      (xr,wc)               resulting small int (two copies)
//      (xs)                  popped
//      (ra)                  destroyed
//      (wa,wb)               destroyed (on convert error only)
//      (xr)                  input arg (convert error only)
// gtsmi:
        //b |gtsmi|prc|25,n|1,2||entry point|23324
        } /* gtre3 */
        

        void gtsmi() {
        //b ||mov|7,xr|10,(xs)+||load argument|23325
        xr= C_POP();				// load argument
        //b ||beq|9,(xr)|22,=b_icl|6,gtsm1|skip if already an integer|23326
        if ((*(xr_it.wp)-(word)(b_icl)) == 0) C_GOTO(gtsm1);				// skip if already an integer
//      here if not an integer
        //b ||ppm|6,gtsm2|||jump if convert is impossible|23331
        C_JSR_1(gtint,C_GOTO(gtsm2));				// jump if convert is impossible
//      merge here with integer
// gtsm1:
        //b |gtsm1|ldi|13,icval(xr)|||load integer value|23335
        C_GOTO(gtsm1);
        } /* gtsmi */
        

        void gtsm1() {
        ia = *((word *)(CFP_B*ICVAL + xr));				// load integer value
        //b ||mfi|8,wc|6,gtsm3||move as one word, jump if ovflow|23336
        if (ia<0) C_GOTO( gtsm3);				// move as one word, jump if ovflow
        wc = ia;
        //b ||bgt|8,wc|3,mxlen|6,gtsm3|or if too large|23337
        if ((wc-v.mxlen) > 0) C_GOTO(gtsm3);				// or if too large
        //b ||mov|7,xr|8,wc||copy result to xr|23338
        xr= wc;				// copy result to xr
        //b ||exi||||return to gtsmi caller|23339
        C_NEXIT(P_PRC_GTSMI,0);				// return to gtsmi caller
//      here if unconvertible to integer
// gtsm2:
        //b |gtsm2|exi|1,1|||take non-integer error exit|23343
        } /* gtsm1 */
        

        void gtsm2() {
        C_NEXIT(P_PRC_GTSMI,1);				// take non-integer error exit
//      here if out of range
// gtsm3:
        //b |gtsm3|exi|1,2|||take out-of-range error exit|23347
        } /* gtsm2 */
        

        void gtsm3() {
        C_NEXIT(P_PRC_GTSMI,2);				// take out-of-range error exit
        //b ||ejc|||||23349
        
//      gtstg -- get string
//      gtstg is passed an object and returns a string with
//      any necessary conversions performed.
//      -(xs)                 input argument (on stack)
//      jsr  gtstg            call to convert to string
//      ppm  loc              transfer loc if convert impossible
//      (xr)                  pointer to resulting string
//      (wa)                  length of string in characters
//      (xs)                  popped
//      (ra)                  destroyed
//      (xr)                  input arg (convert error only)
// gtstg:
        //b |gtstg|prc|25,n|1,1||entry point|23415
        } /* gtsm3 */
        

        void gtstg() {
        //b ||mov|7,xr|10,(xs)+||load argument, pop stack|23416
        xr= C_POP();				// load argument, pop stack
        //b ||beq|9,(xr)|22,=b_scl|6,gts30|jump if already a string|23417
        if ((*(xr_it.wp)-(word)(b_scl)) == 0) C_GOTO(gts30);				// jump if already a string
//      here if not a string already
// gts01:
        //b |gts01|mov|11,-(xs)|7,xr||restack argument in case error|23421
        C_GOTO(gts01);
        } /* gtstg */
        

        void gts01() {
        C_PUSH(xr);				// restack argument in case error
        //b ||mov|11,-(xs)|7,xl||save xl|23422
        C_PUSH(xl);				// save xl
        //b ||mov|3,gtsvb|8,wb||save wb|23423
        v.gtsvb= wb;				// save wb
        //b ||mov|3,gtsvc|8,wc||save wc|23424
        v.gtsvc= wc;				// save wc
        //b ||mov|8,wa|9,(xr)||load first word of block|23425
        wa= *(xr_it.wp);				// load first word of block
        //b ||beq|8,wa|22,=b_icl|6,gts05|jump to convert integer|23426
        if ((wa-(word)(b_icl)) == 0) C_GOTO(gts05);				// jump to convert integer
        //b ||beq|8,wa|22,=b_rcl|6,gts10|jump to convert real|23429
        if ((wa-(word)(b_rcl)) == 0) C_GOTO(gts10);				// jump to convert real
        //b ||beq|8,wa|22,=b_nml|6,gts03|jump to convert name|23431
        if ((wa-(word)(b_nml)) == 0) C_GOTO(gts03);				// jump to convert name
//      here on conversion error
// gts02:
        //b |gts02|mov|7,xl|10,(xs)+||restore xl|23439
        C_GOTO(gts02);
        } /* gts01 */
        

        void gts02() {
        xl= C_POP();				// restore xl
        //b ||mov|7,xr|10,(xs)+||reload input argument|23440
        xr= C_POP();				// reload input argument
        //b ||exi|1,1|||take convert error exit|23441
        C_NEXIT(P_PRC_GTSTG,1);				// take convert error exit
        //b ||ejc|||||23442
        
//      gtstg (continued)
//      here to convert a name (only possible if natural var)
// gts03:
        //b |gts03|mov|7,xl|13,nmbas(xr)||load name base|23448
        } /* gts02 */
        

        void gts03() {
        xl= *((word *)(CFP_B*NMBAS + xr));				// load name base
        //b ||bhi|7,xl|3,state|6,gts02|error if not natural var (static)|23449
        if ((xl-v.state) > 0) C_GOTO(gts02);				// error if not natural var (static)
        //b ||add|7,xl|19,*vrsof||else point to possible string name|23450
        xl += CFP_B*VRSOF;				// else point to possible string name
        //b ||mov|8,wa|13,sclen(xl)||load length|23451
        wa= *((word *)(CFP_B*SCLEN + xl));				// load length
        //b ||bnz|8,wa|6,gts04||jump if not system variable|23452
        if (wa) C_GOTO(gts04);				// jump if not system variable
        //b ||mov|7,xl|13,vrsvo(xl)||else point to svblk|23453
        xl= *((word *)(CFP_B*VRSVO + xl));				// else point to svblk
        //b ||mov|8,wa|13,svlen(xl)||and load name length|23454
        wa= *((word *)(CFP_B*SVLEN + xl));				// and load name length
//      merge here with string in xr, length in wa
// gts04:
        //b |gts04|zer|8,wb|||set offset to zero|23458
        C_GOTO(gts04);
        } /* gts03 */
        

        void gts04() {
        wb=0;				// set offset to zero
        //b ||jsr|6,sbstr|||use sbstr to copy string|23459
        C_JSR(sbstr);				// use sbstr to copy string
        //b ||brn|6,gts29|||jump to exit|23460
         C_GOTO(gts29);				// jump to exit
//      come here to convert an integer
// gts05:
        //b |gts05|ldi|13,icval(xr)|||load integer value|23464
        } /* gts04 */
        

        void gts05() {
        ia = *((word *)(CFP_B*ICVAL + xr));				// load integer value
        //b ||mov|3,gtssf|18,=num01||set sign flag negative|23472
        v.gtssf= NUM01;				// set sign flag negative
        //b ||ilt|6,gts06|||skip if integer is negative|23473
        if (ia < 0)  C_GOTO(gts06);				// skip if integer is negative
        //b ||ngi||||else negate integer|23474
        ia= -ia;				// else negate integer
        //b ||zer|3,gtssf|||and reset negative flag|23475
        v.gtssf=0;				// and reset negative flag
        //b ||ejc|||||23476
        
//      gtstg (continued)
//      here with sign flag set and sign forced negative as
//      required by the cvd instruction.
// gts06:
        //b |gts06|mov|7,xr|3,gtswk||point to result work area|23483
        C_GOTO(gts06);
        } /* gts05 */
        

        void gts06() {
        xr= v.gtswk;				// point to result work area
        //b ||mov|8,wb|18,=nstmx||initialize counter to max length|23484
        wb= NSTMX;				// initialize counter to max length
        //b ||psc|7,xr|8,wb||prepare to store (right-left)|23485
        xr_it.chp += CFP_F + wb;				// prepare to store (right-left)
//      loop to convert digits into work area
// gts07:
        //b |gts07|cvd||||convert one digit into wa|23489
        C_GOTO(gts07);
        } /* gts06 */
        

        void gts07() {
        wa = ia % 10; ia /= 10; wa = -wa + 48; /*cvd*/				// convert one digit into wa
        //b ||sch|8,wa|11,-(xr)||store in work area|23490
        *(--xr_it.chp) = wa;				// store in work area
        //b ||dcv|8,wb|||decrement counter|23491
        (wb)--;				// decrement counter
        //b ||ine|6,gts07|||loop if more digits to go|23492
        if (ia != 0)  C_GOTO(gts07);				// loop if more digits to go
//      merge here after converting integer or real into work
//      area. wb is set to nstmx - (number of chars in result).
// gts08:
        //b ||csc|7,xr|||complete store characters|23493
        //b |gts08|mov|8,wa|18,=nstmx||get max number of characters|23499
        C_GOTO(gts08);
        } /* gts07 */
        

        void gts08() {
        wa= NSTMX;				// get max number of characters
        //b ||sub|8,wa|8,wb||compute length of result|23500
        wa -= wb;				// compute length of result
        //b ||mov|7,xl|8,wa||remember length for move later on|23501
        xl= wa;				// remember length for move later on
        //b ||add|8,wa|3,gtssf||add one for negative sign if needed|23502
        wa += v.gtssf;				// add one for negative sign if needed
        //b ||jsr|6,alocs|||allocate string for result|23503
        C_JSR(alocs);				// allocate string for result
        //b ||mov|8,wc|7,xr||save result pointer for the moment|23504
        wc= xr;				// save result pointer for the moment
        //b ||psc|7,xr|||point to chars of result block|23505
        xr += CFP_F;				// point to chars of result block
        //b ||bze|3,gtssf|6,gts09||skip if positive|23506
        if ( !( v.gtssf) ) C_GOTO(gts09);				// skip if positive
        //b ||mov|8,wa|18,=ch_mn||else load negative sign|23507
        wa= CH_MN;				// else load negative sign
        //b ||sch|8,wa|10,(xr)+||and store it|23508
        *(xr_it.chp++) = wa;				// and store it
//      here after dealing with sign
// gts09:
        //b ||csc|7,xr|||complete store characters|23509
        //b |gts09|mov|8,wa|7,xl||recall length to move|23513
        C_GOTO(gts09);
        } /* gts08 */
        

        void gts09() {
        wa= xl;				// recall length to move
        //b ||mov|7,xl|3,gtswk||point to result work area|23514
        xl= v.gtswk;				// point to result work area
        //b ||plc|7,xl|8,wb||point to first result character|23515
        xl_it.chp += CFP_F + wb;				// point to first result character
        //b ||mvc||||move chars to result string|23516
        do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);				// move chars to result string
        //b ||mov|7,xr|8,wc||restore result pointer|23517
        xr= wc;				// restore result pointer
        //b ||brn|6,gts29|||jump to exit|23520
         C_GOTO(gts29);				// jump to exit
        //b ||ejc|||||23521
        
//      gtstg (continued)
//      here to convert a real
// gts10:
        //b |gts10|ldr|13,rcval(xr)|||load real|23527
        } /* gts09 */
        

        void gts10() {
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load real
        //b ||zer|3,gtssf|||reset negative flag|23539
        v.gtssf=0;				// reset negative flag
        //b ||req|6,gts31|||skip if zero|23540
        if (ra_it.d == 0.0)  C_GOTO(gts31);				// skip if zero
        //b ||rge|6,gts11|||jump if real is positive|23541
        if (ra_it.d >= 0.0)  C_GOTO(gts11);				// jump if real is positive
        //b ||mov|3,gtssf|18,=num01||else set negative flag|23542
        v.gtssf= NUM01;				// else set negative flag
        //b ||ngr||||and get absolute value of real|23543
        {ra_it.d = - ra_it.d;fl=(!isgoodnum(ra_it.d));}				// and get absolute value of real
//      now scale the real to the range (0.1 le x lt 1.0)
// gts11:
        //b |gts11|ldi|4,intv0|||initialize exponent to zero|23547
        C_GOTO(gts11);
        } /* gts10 */
        

        void gts11() {
        ia = c.intv0;				// initialize exponent to zero
//      loop to scale up in steps of 10**10
// gts12:
        //b |gts12|str|3,gtsrs|||save real value|23551
        C_GOTO(gts12);
        } /* gts11 */
        

        void gts12() {
        v.gtsrs = (ra_it.d);				// save real value
        //b ||sbr|4,reap1|||subtract 0.1 to compare|23552
        {w0 = c.reap1;ra_it.d -= w0_it.d;fl=(!isgoodnum(ra_it.d));}				// subtract 0.1 to compare
        //b ||rge|6,gts13|||jump if scale up not required|23553
        if (ra_it.d >= 0.0)  C_GOTO(gts13);				// jump if scale up not required
        //b ||ldr|3,gtsrs|||else reload value|23554
        {ra_it.d = v.gtsrs;fl=(!isgoodnum(ra_it.d));}				// else reload value
        //b ||mlr|4,reatt|||multiply by 10**10|23555
        {w0 = c.reatt;ra_it.d *=  w0_it.d;fl=(!isgoodnum(ra_it.d));}				// multiply by 10**10
        //b ||sbi|4,intvt|||decrement exponent by 10|23556
        ia-=c.intvt;				// decrement exponent by 10
        //b ||brn|6,gts12|||loop back to test again|23557
         C_GOTO(gts12);				// loop back to test again
//      test for scale down required
// gts13:
        //b |gts13|ldr|3,gtsrs|||reload value|23561
        } /* gts12 */
        

        void gts13() {
        {ra_it.d = v.gtsrs;fl=(!isgoodnum(ra_it.d));}				// reload value
        //b ||sbr|4,reav1|||subtract 1.0|23562
        {w0 = c.reav1;ra_it.d -= w0_it.d;fl=(!isgoodnum(ra_it.d));}				// subtract 1.0
        //b ||rlt|6,gts17|||jump if no scale down required|23563
        if (ra_it.d < 0.0)  C_GOTO(gts17);				// jump if no scale down required
        //b ||ldr|3,gtsrs|||else reload value|23564
        {ra_it.d = v.gtsrs;fl=(!isgoodnum(ra_it.d));}				// else reload value
//      loop to scale down in steps of 10**10
// gts14:
        //b |gts14|sbr|4,reatt|||subtract 10**10 to compare|23568
        C_GOTO(gts14);
        } /* gts13 */
        

        void gts14() {
        {w0 = c.reatt;ra_it.d -= w0_it.d;fl=(!isgoodnum(ra_it.d));}				// subtract 10**10 to compare
        //b ||rlt|6,gts15|||jump if large step not required|23569
        if (ra_it.d < 0.0)  C_GOTO(gts15);				// jump if large step not required
        //b ||ldr|3,gtsrs|||else restore value|23570
        {ra_it.d = v.gtsrs;fl=(!isgoodnum(ra_it.d));}				// else restore value
        //b ||dvr|4,reatt|||divide by 10**10|23571
        {w0 = c.reatt; if (w0_it.d != 0.0) {ra_it.d /= w0_it.d;fl= (!isgoodnum(ra_it.d));} else {fl=1;}}				// divide by 10**10
        //b ||str|3,gtsrs|||store new value|23572
        v.gtsrs = (ra_it.d);				// store new value
        //b ||adi|4,intvt|||increment exponent by 10|23573
        ia+=c.intvt;				// increment exponent by 10
        //b ||brn|6,gts14|||loop back|23574
         C_GOTO(gts14);				// loop back
        //b ||ejc|||||23575
        
//      gtstg (continued)
//      at this point we have (1.0 le x lt 10**10)
//      complete scaling with powers of ten table
// gts15:
        //b |gts15|mov|7,xr|21,=reav1||point to powers of ten table|23582
        } /* gts14 */
        

        void gts15() {
        xr= (word)(&c.reav1);				// point to powers of ten table
//      loop to locate correct entry in table
// gts16:
        //b |gts16|ldr|3,gtsrs|||reload value|23586
        C_GOTO(gts16);
        } /* gts15 */
        

        void gts16() {
        {ra_it.d = v.gtsrs;fl=(!isgoodnum(ra_it.d));}				// reload value
        //b ||adi|4,intv1|||increment exponent|23587
        ia+=c.intv1;				// increment exponent
        //b ||add|7,xr|19,*cfp_r||point to next entry in table|23588
        xr += CFP_B*CFP_R;				// point to next entry in table
        //b ||sbr|9,(xr)|||subtract it to compare|23589
        {w0 = *(xr_it.wp);ra_it.d -= w0_it.d;fl=(!isgoodnum(ra_it.d));}				// subtract it to compare
        //b ||rge|6,gts16|||loop till we find a larger entry|23590
        if (ra_it.d >= 0.0)  C_GOTO(gts16);				// loop till we find a larger entry
        //b ||ldr|3,gtsrs|||then reload the value|23591
        {ra_it.d = v.gtsrs;fl=(!isgoodnum(ra_it.d));}				// then reload the value
        //b ||dvr|9,(xr)|||and complete scaling|23592
        {w0 = *(xr_it.wp); if (w0_it.d != 0.0) {ra_it.d /= w0_it.d;fl= (!isgoodnum(ra_it.d));} else {fl=1;}}				// and complete scaling
        //b ||str|3,gtsrs|||store value|23593
        v.gtsrs = (ra_it.d);				// store value
//      we are now scaled, so round by adding 0.5 * 10**(-cfp_s)
// gts17:
        //b |gts17|ldr|3,gtsrs|||get value again|23597
        C_GOTO(gts17);
        } /* gts16 */
        

        void gts17() {
        {ra_it.d = v.gtsrs;fl=(!isgoodnum(ra_it.d));}				// get value again
        //b ||adr|3,gtsrn|||add rounding factor|23598
        {w0 = v.gtsrn;ra_it.d += w0_it.d;fl=(!isgoodnum(ra_it.d));}				// add rounding factor
        //b ||str|3,gtsrs|||store result|23599
        v.gtsrs = (ra_it.d);				// store result
//      the rounding operation may have pushed us up past
//      1.0 again, so check one more time.
        //b ||sbr|4,reav1|||subtract 1.0 to compare|23604
        {w0 = c.reav1;ra_it.d -= w0_it.d;fl=(!isgoodnum(ra_it.d));}				// subtract 1.0 to compare
        //b ||rlt|6,gts18|||skip if ok|23605
        if (ra_it.d < 0.0)  C_GOTO(gts18);				// skip if ok
        //b ||adi|4,intv1|||else increment exponent|23606
        ia+=c.intv1;				// else increment exponent
        //b ||ldr|3,gtsrs|||reload value|23607
        {ra_it.d = v.gtsrs;fl=(!isgoodnum(ra_it.d));}				// reload value
        //b ||dvr|4,reavt|||divide by 10.0 to rescale|23608
        {w0 = c.reavt; if (w0_it.d != 0.0) {ra_it.d /= w0_it.d;fl= (!isgoodnum(ra_it.d));} else {fl=1;}}				// divide by 10.0 to rescale
        //b ||brn|6,gts19|||jump to merge|23609
         C_GOTO(gts19);				// jump to merge
//      here if rounding did not muck up scaling
// gts18:
        //b |gts18|ldr|3,gtsrs|||reload rounded value|23613
        } /* gts17 */
        

        void gts18() {
        {ra_it.d = v.gtsrs;fl=(!isgoodnum(ra_it.d));}				// reload rounded value
        //b ||ejc|||||23614
        
//      gtstg (continued)
//      now we have completed the scaling as follows
//      (ia)                  signed exponent
//      (ra)                  scaled real (absolute value)
//      if the exponent is negative or greater than cfp_s, then
//      we convert the number in the form.
//      (neg sign) 0 . (cpf_s digits) e (exp sign) (exp digits)
//      if the exponent is positive and less than or equal to
//      cfp_s, the number is converted in the form.
//      (neg sign) (exponent digits) . (cfp_s-exponent digits)
//      in both cases, the formats obtained from the above
//      rules are modified by deleting trailing zeros after the
//      decimal point. there are no leading zeros in the exponent
//      and the exponent sign is always present.
// gts19:
        //b |gts19|mov|7,xl|18,=cfp_s||set num dec digits = cfp_s|23638
        C_GOTO(gts19);
        } /* gts18 */
        

        void gts19() {
        xl= CFP_S;				// set num dec digits = cfp_s
        //b ||mov|3,gtses|18,=ch_mn||set exponent sign negative|23639
        v.gtses= CH_MN;				// set exponent sign negative
        //b ||ilt|6,gts21|||all set if exponent is negative|23640
        if (ia < 0)  C_GOTO(gts21);				// all set if exponent is negative
        //b ||mfi|8,wa|||else fetch exponent|23641
        wa = ia;				// else fetch exponent
        //b ||ble|8,wa|18,=cfp_s|6,gts20|skip if we can use special format|23642
        if ((wa-CFP_S) <= 0) C_GOTO(gts20);				// skip if we can use special format
        //b ||mti|8,wa|||else restore exponent|23643
        ia = (word)(wa);				// else restore exponent
        //b ||ngi||||set negative for cvd|23644
        ia= -ia;				// set negative for cvd
        //b ||mov|3,gtses|18,=ch_pl||set plus sign for exponent sign|23645
        v.gtses= CH_PL;				// set plus sign for exponent sign
        //b ||brn|6,gts21|||jump to generate exponent|23646
         C_GOTO(gts21);				// jump to generate exponent
//      here if we can use the format without an exponent
// gts20:
        //b |gts20|sub|7,xl|8,wa||compute digits after decimal point|23650
        } /* gts19 */
        

        void gts20() {
        xl -= wa;				// compute digits after decimal point
        //b ||ldi|4,intv0|||reset exponent to zero|23651
        ia = c.intv0;				// reset exponent to zero
        //b ||ejc|||||23652
        
//      gtstg (continued)
//      merge here as follows
//      (ia)                  exponent absolute value
//      gtses                 character for exponent sign
//      (ra)                  positive fraction
//      (xl)                  number of digits after dec point
// gts21:
        //b |gts21|mov|7,xr|3,gtswk||point to work area|23663
        C_GOTO(gts21);
        } /* gts20 */
        

        void gts21() {
        xr= v.gtswk;				// point to work area
        //b ||mov|8,wb|18,=nstmx||set character ctr to max length|23664
        wb= NSTMX;				// set character ctr to max length
        //b ||psc|7,xr|8,wb||prepare to store (right to left)|23665
        xr_it.chp += CFP_F + wb;				// prepare to store (right to left)
        //b ||ieq|6,gts23|||skip exponent if it is zero|23666
        if (ia == 0)  C_GOTO(gts23);				// skip exponent if it is zero
//      loop to generate digits of exponent
// gts22:
        //b |gts22|cvd||||convert a digit into wa|23670
        C_GOTO(gts22);
        } /* gts21 */
        

        void gts22() {
        wa = ia % 10; ia /= 10; wa = -wa + 48; /*cvd*/				// convert a digit into wa
        //b ||sch|8,wa|11,-(xr)||store in work area|23671
        *(--xr_it.chp) = wa;				// store in work area
        //b ||dcv|8,wb|||decrement counter|23672
        (wb)--;				// decrement counter
        //b ||ine|6,gts22|||loop back if more digits to go|23673
        if (ia != 0)  C_GOTO(gts22);				// loop back if more digits to go
//      here generate exponent sign and e
        //b ||mov|8,wa|3,gtses||load exponent sign|23677
        wa= v.gtses;				// load exponent sign
        //b ||sch|8,wa|11,-(xr)||store in work area|23678
        *(--xr_it.chp) = wa;				// store in work area
        //b ||mov|8,wa|18,=ch_le||get character letter e|23679
        wa= CH_LE;				// get character letter e
        //b ||sch|8,wa|11,-(xr)||store in work area|23680
        *(--xr_it.chp) = wa;				// store in work area
        //b ||sub|8,wb|18,=num02||decrement counter for sign and e|23681
        wb -= NUM02;				// decrement counter for sign and e
//      here to generate the fraction
// gts23:
        //b |gts23|mlr|3,gtssc|||convert real to integer (10**cfp_s)|23685
        C_GOTO(gts23);
        } /* gts22 */
        

        void gts23() {
        {w0 = v.gtssc;ra_it.d *=  w0_it.d;fl=(!isgoodnum(ra_it.d));}				// convert real to integer (10**cfp_s)
        //b ||rti||||get integer (overflow impossible)|23686
        ia =  ( ra_it.d);				// get integer (overflow impossible)
        //b ||ngi||||negate as required by cvd|23687
        ia= -ia;				// negate as required by cvd
//      loop to suppress trailing zeros
// gts24:
        //b |gts24|bze|7,xl|6,gts27||jump if no digits left to do|23691
        C_GOTO(gts24);
        } /* gts23 */
        

        void gts24() {
        if ( !( xl) ) C_GOTO(gts27);				// jump if no digits left to do
        //b ||cvd||||else convert one digit|23692
        wa = ia % 10; ia /= 10; wa = -wa + 48; /*cvd*/				// else convert one digit
        //b ||bne|8,wa|18,=ch_d0|6,gts26|jump if not a zero|23693
        if ((wa-CH_D0) != 0) C_GOTO(gts26);				// jump if not a zero
        //b ||dcv|7,xl|||decrement counter|23694
        (xl)--;				// decrement counter
        //b ||brn|6,gts24|||loop back for next digit|23695
         C_GOTO(gts24);				// loop back for next digit
        //b ||ejc|||||23696
        
//      gtstg (continued)
//      loop to generate digits after decimal point
// gts25:
        //b |gts25|cvd||||convert a digit into wa|23702
        } /* gts24 */
        

        void gts25() {
        wa = ia % 10; ia /= 10; wa = -wa + 48; /*cvd*/				// convert a digit into wa
//      merge here first time
// gts26:
        //b |gts26|sch|8,wa|11,-(xr)||store digit|23706
        C_GOTO(gts26);
        } /* gts25 */
        

        void gts26() {
        *(--xr_it.chp) = wa;				// store digit
        //b ||dcv|8,wb|||decrement counter|23707
        (wb)--;				// decrement counter
        //b ||dcv|7,xl|||decrement counter|23708
        (xl)--;				// decrement counter
        //b ||bnz|7,xl|6,gts25||loop back if more to go|23709
        if (xl) C_GOTO(gts25);				// loop back if more to go
//      here generate the decimal point
// gts27:
        //b |gts27|mov|8,wa|18,=ch_dt||load decimal point|23713
        C_GOTO(gts27);
        } /* gts26 */
        

        void gts27() {
        wa= CH_DT;				// load decimal point
        //b ||sch|8,wa|11,-(xr)||store in work area|23714
        *(--xr_it.chp) = wa;				// store in work area
        //b ||dcv|8,wb|||decrement counter|23715
        (wb)--;				// decrement counter
//      here generate the digits before the decimal point
// gts28:
        //b |gts28|cvd||||convert a digit into wa|23719
        C_GOTO(gts28);
        } /* gts27 */
        

        void gts28() {
        wa = ia % 10; ia /= 10; wa = -wa + 48; /*cvd*/				// convert a digit into wa
        //b ||sch|8,wa|11,-(xr)||store in work area|23720
        *(--xr_it.chp) = wa;				// store in work area
        //b ||dcv|8,wb|||decrement counter|23721
        (wb)--;				// decrement counter
        //b ||ine|6,gts28|||loop back if more to go|23722
        if (ia != 0)  C_GOTO(gts28);				// loop back if more to go
        //b ||csc|7,xr|||complete store characters|23723
        //b ||brn|6,gts08|||else jump back to exit|23724
         C_GOTO(gts08);				// else jump back to exit
//      exit point after successful conversion
// gts29:
        //b |gts29|mov|7,xl|10,(xs)+||restore xl|23730
        } /* gts28 */
        

        void gts29() {
        xl= C_POP();				// restore xl
        //b ||ica|7,xs|||pop argument|23731
        xs += CFP_B;				// pop argument
        //b ||mov|8,wb|3,gtsvb||restore wb|23732
        wb= v.gtsvb;				// restore wb
        //b ||mov|8,wc|3,gtsvc||restore wc|23733
        wc= v.gtsvc;				// restore wc
//      merge here if no conversion required
// gts30:
        //b |gts30|mov|8,wa|13,sclen(xr)||load string length|23737
        C_GOTO(gts30);
        } /* gts29 */
        

        void gts30() {
        wa= *((word *)(CFP_B*SCLEN + xr));				// load string length
        //b ||exi||||return to caller|23738
        C_NEXIT(P_PRC_GTSTG,0);				// return to caller
//      here to return string for real zero
// gts31:
        //b |gts31|mov|7,xl|21,=scre0||point to string|23744
        } /* gts30 */
        

        void gts31() {
        xl= (word)(&c.scre0);				// point to string
        //b ||mov|8,wa|18,=num02||2 chars|23745
        wa= NUM02;				// 2 chars
        //b ||zer|8,wb|||zero offset|23746
        wb=0;				// zero offset
        //b ||jsr|6,sbstr|||copy string|23747
        C_JSR(sbstr);				// copy string
        //b ||brn|6,gts29|||return|23748
         C_GOTO(gts29);				// return
        //b ||ejc|||||23776
        
//      gtvar -- get variable for i/o/trace association
//      gtvar is used to point to an actual variable location
//      for the detach,input,output,trace,stoptr system functions
//      (xr)                  argument to function
//      jsr  gtvar            call to locate variable pointer
//      ppm  loc              transfer loc if not ok variable
//      (xl,wa)               name base,offset of variable
//      (xr,ra)               destroyed
//      (wb,wc)               destroyed (convert error only)
//      (xr)                  input arg (convert error only)
// gtvar:
        //b |gtvar|prc|25,e|1,1||entry point|23791
        } /* gts31 */
        

        void gtvar() {
        //b ||bne|9,(xr)|22,=b_nml|6,gtvr2|jump if not a name|23792
        if ((*(xr_it.wp)-(word)(b_nml)) != 0) C_GOTO(gtvr2);				// jump if not a name
        //b ||mov|8,wa|13,nmofs(xr)||else load name offset|23793
        wa= *((word *)(CFP_B*NMOFS + xr));				// else load name offset
        //b ||mov|7,xl|13,nmbas(xr)||load name base|23794
        xl= *((word *)(CFP_B*NMBAS + xr));				// load name base
        //b ||beq|9,(xl)|22,=b_evt|6,gtvr1|error if expression variable|23795
        if ((*(xl_it.wp)-(word)(b_evt)) == 0) C_GOTO(gtvr1);				// error if expression variable
        //b ||bne|9,(xl)|22,=b_kvt|6,gtvr3|all ok if not keyword variable|23796
        if ((*(xl_it.wp)-(word)(b_kvt)) != 0) C_GOTO(gtvr3);				// all ok if not keyword variable
//      here on conversion error
// gtvr1:
        //b |gtvr1|exi|1,1|||take convert error exit|23800
        C_GOTO(gtvr1);
        } /* gtvar */
        

        void gtvr1() {
        C_EXIT(1);				// take convert error exit
//      here if not a name, try convert to natural variable
// gtvr2:
        //b |gtvr2|mov|3,gtvrc|8,wc||save wc|23804
        } /* gtvr1 */
        

        void gtvr2() {
        v.gtvrc= wc;				// save wc
        //b ||ppm|6,gtvr1|||jump if convert error|23806
        C_JSR_1(gtnvr,C_GOTO(gtvr1));				// jump if convert error
        //b ||mov|7,xl|7,xr||else copy vrblk name base|23807
        xl= xr;				// else copy vrblk name base
        //b ||mov|8,wa|19,*vrval||and set offset|23808
        wa= CFP_B*VRVAL;				// and set offset
        //b ||mov|8,wc|3,gtvrc||restore wc|23809
        wc= v.gtvrc;				// restore wc
//      here for name obtained
// gtvr3:
        //b |gtvr3|bhi|7,xl|3,state|6,gtvr4|all ok if not natural variable|23813
        C_GOTO(gtvr3);
        } /* gtvr2 */
        

        void gtvr3() {
        if ((xl-v.state) > 0) C_GOTO(gtvr4);				// all ok if not natural variable
        //b ||beq|13,vrsto(xl)|22,=b_vre|6,gtvr1|error if protected variable|23814
        if ((*((word *)(CFP_B*VRSTO + xl))-(word)(b_vre)) == 0) C_GOTO(gtvr1);				// error if protected variable
//      common exit point
// gtvr4:
        //b |gtvr4|exi||||return to caller|23818
        C_GOTO(gtvr4);
        } /* gtvr3 */
        

        void gtvr4() {
        C_EXIT(0);				// return to caller
        //b ||ejc|||||23820
        
        //b ||ejc|||||23821
        
//      hashs -- compute hash index for string
//      hashs is used to convert a string to a unique integer
//      value. the resulting hash value is a positive integer
//      in the range 0 to cfp_m
//      (xr)                  string to be hashed
//      jsr  hashs            call to hash string
//      (ia)                  hash value
//      (xr,wb,wc)            destroyed
//      the hash function used is as follows.
//      start with the length of the string.
//      if there is more than one character in a word,
//      take the first e_hnw words of the characters from
//      the string or all the words if fewer than e_hnw.
//      compute the exclusive or of all these words treating
//      them as one word bit string values.
//      if there is just one character in a word,
//      then mimic the word by word hash by shifting
//      successive characters to get a similar effect.
//      e_hnw is set to zero in case only one character per word.
//      move the result as an integer with the mti instruction.
//      the test on e_hnw is done dynamically. this should be done
//      eventually using conditional assembly, but that would require
//      changes to the build process (ds 8 may 2013).
// hashs:
        //b |hashs|prc|25,e|1,0||entry point|23857
        } /* gtvr4 */
        

        void hashs() {
        //b ||mov|8,wc|18,=e_hnw||get number of words to use|23859
        wc= E_HNW;				// get number of words to use
        //b ||bze|8,wc|6,hshsa||branch if one character per word|23860
        if ( !( wc) ) C_GOTO(hshsa);				// branch if one character per word
        //b ||mov|8,wc|13,sclen(xr)||load string length in characters|23861
        wc= *((word *)(CFP_B*SCLEN + xr));				// load string length in characters
        //b ||mov|8,wb|8,wc||initialize with length|23862
        wb= wc;				// initialize with length
        //b ||bze|8,wc|6,hshs3||jump if null string|23863
        if ( !( wc) ) C_GOTO(hshs3);				// jump if null string
        //b ||ctw|8,wc|1,0||get number of words of chars|23865
        wc = (wc+(CFP_C-1)+CFP_C* 0) >> LOG_CFP_C;				// get number of words of chars
        //b ||add|7,xr|19,*schar||point to characters of string|23866
        xr += CFP_B*SCHAR;				// point to characters of string
        //b ||blo|8,wc|18,=e_hnw|6,hshs1|use whole string if short|23867
        if ((wc-E_HNW) < 0) C_GOTO(hshs1);				// use whole string if short
        //b ||mov|8,wc|18,=e_hnw||else set to involve first e_hnw wds|23868
        wc= E_HNW;				// else set to involve first e_hnw wds
//      here with count of words to check in wc
// hshs1:
        //b |hshs1|lct|8,wc|8,wc||set counter to control loop|23872
        C_GOTO(hshs1);
        } /* hashs */
        

        void hshs1() {
        wc= wc;				// set counter to control loop
//      loop to compute exclusive or
// hshs2:
        //b |hshs2|xob|8,wb|10,(xr)+||exclusive or next word of chars|23876
        C_GOTO(hshs2);
        } /* hshs1 */
        

        void hshs2() {
        wb ^= *(xr_it.wp++);				// exclusive or next word of chars
        //b ||bct|8,wc|6,hshs2||loop till all processed|23877
        if ((--wc))  C_GOTO(hshs2);				// loop till all processed
//      merge here with exclusive or in wb
// hshs3:
        //b |hshs3|zgb|8,wb|||zeroise undefined bits|23881
        C_GOTO(hshs3);
        } /* hshs2 */
        

        void hshs3() {
        //b ||anb|8,wb|4,bitsm||ensure in range 0 to cfp_m|23882
        wb &= c.bitsm;				// ensure in range 0 to cfp_m
        //b ||mti|8,wb|||move result as integer|23883
        ia = (word)(wb);				// move result as integer
        //b ||zer|7,xr|||clear garbage value in xr|23884
        xr=0;				// clear garbage value in xr
        //b ||exi||||return to hashs caller|23885
        C_EXIT(0);				// return to hashs caller
//      here if just one character per word
// hshsa:
        //b |hshsa|mov|8,wc|13,sclen(xr)||load string length in characters|23889
        } /* hshs3 */
        

        void hshsa() {
        wc= *((word *)(CFP_B*SCLEN + xr));				// load string length in characters
        //b ||mov|8,wb|8,wc||initialize with length|23890
        wb= wc;				// initialize with length
        //b ||bze|8,wc|6,hshs3||jump if null string|23891
        if ( !( wc) ) C_GOTO(hshs3);				// jump if null string
        //b ||ctw|8,wc|1,0||get number of words of chars|23893
        wc = (wc+(CFP_C-1)+CFP_C* 0) >> LOG_CFP_C;				// get number of words of chars
        //b ||plc|7,xr||||23894
        xr += CFP_F;
        //b ||mov|11,-(xs)|7,xl||save xl|23895
        C_PUSH(xl);				// save xl
        //b ||mov|7,xl|8,wc||load length for branch|23896
        xl= wc;				// load length for branch
        //b ||bge|7,xl|18,=num25|6,hsh24|use first characters if longer|23897
        if ((xl-NUM25) >= 0) C_GOTO(hsh24);				// use first characters if longer
        //b ||bsw|7,xl|1,25||merge to compute hash|23898
        extern word _l0639 [];				// merge to compute hash
        { w0 = ((word *)_l0639)[xl];  C_GOTO(w0_it.callp);}
        }  /* hshsa */
        

        word  _l0639 [] = {
        //b ||iff|1,0|6,hsh00|||23924
        	(word)((word)(hsh00)),
        //b ||iff|1,1|6,hsh01|||23924
        	(word)((word)(hsh01)),
        //b ||iff|1,2|6,hsh02|||23924
        	(word)((word)(hsh02)),
        //b ||iff|1,3|6,hsh03|||23924
        	(word)((word)(hsh03)),
        //b ||iff|1,4|6,hsh04|||23924
        	(word)((word)(hsh04)),
        //b ||iff|1,5|6,hsh05|||23924
        	(word)((word)(hsh05)),
        //b ||iff|1,6|6,hsh06|||23924
        	(word)((word)(hsh06)),
        //b ||iff|1,7|6,hsh07|||23924
        	(word)((word)(hsh07)),
        //b ||iff|1,8|6,hsh08|||23924
        	(word)((word)(hsh08)),
        //b ||iff|1,9|6,hsh09|||23924
        	(word)((word)(hsh09)),
        //b ||iff|1,10|6,hsh10|||23924
        	(word)((word)(hsh10)),
        //b ||iff|1,11|6,hsh11|||23924
        	(word)((word)(hsh11)),
        //b ||iff|1,12|6,hsh12|||23924
        	(word)((word)(hsh12)),
        //b ||iff|1,13|6,hsh13|||23924
        	(word)((word)(hsh13)),
        //b ||iff|1,14|6,hsh14|||23924
        	(word)((word)(hsh14)),
        //b ||iff|1,15|6,hsh15|||23924
        	(word)((word)(hsh15)),
        //b ||iff|1,16|6,hsh16|||23924
        	(word)((word)(hsh16)),
        //b ||iff|1,17|6,hsh17|||23924
        	(word)((word)(hsh17)),
        //b ||iff|1,18|6,hsh18|||23924
        	(word)((word)(hsh18)),
        //b ||iff|1,19|6,hsh19|||23924
        	(word)((word)(hsh19)),
        //b ||iff|1,20|6,hsh20|||23924
        	(word)((word)(hsh20)),
        //b ||iff|1,21|6,hsh21|||23924
        	(word)((word)(hsh21)),
        //b ||iff|1,22|6,hsh22|||23924
        	(word)((word)(hsh22)),
        //b ||iff|1,23|6,hsh23|||23924
        	(word)((word)(hsh23)),
        //b ||iff|1,24|6,hsh24|||23924
        	(word)((word)(hsh24)),
        //b ||esw|||||23924
             }; /* bsw list for _l0639 */
// hsh24:
        //b |hsh24|lch|8,wc|10,(xr)+||load next character|23925
        void hsh24() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,24||shift for hash|23926
        wc <<= 24;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23927
        wb ^= wc;				// hash character
// hsh23:
        //b |hsh23|lch|8,wc|10,(xr)+||load next character|23928
        C_GOTO(hsh23);
        } /* hsh24 */
        

        void hsh23() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,16||shift for hash|23929
        wc <<= 16;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23930
        wb ^= wc;				// hash character
// hsh22:
        //b |hsh22|lch|8,wc|10,(xr)+||load next character|23931
        C_GOTO(hsh22);
        } /* hsh23 */
        

        void hsh22() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,8||shift for hash|23932
        wc <<= 8;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23933
        wb ^= wc;				// hash character
// hsh21:
        //b |hsh21|lch|8,wc|10,(xr)+||load next character|23934
        C_GOTO(hsh21);
        } /* hsh22 */
        

        void hsh21() {
        wc = *(xr_it.chp++);				// load next character
        //b ||xob|8,wb|8,wc||hash character|23935
        wb ^= wc;				// hash character
// hsh20:
        //b |hsh20|lch|8,wc|10,(xr)+||load next character|23936
        C_GOTO(hsh20);
        } /* hsh21 */
        

        void hsh20() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,24||shift for hash|23937
        wc <<= 24;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23938
        wb ^= wc;				// hash character
// hsh19:
        //b |hsh19|lch|8,wc|10,(xr)+||load next character|23939
        C_GOTO(hsh19);
        } /* hsh20 */
        

        void hsh19() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,16||shift for hash|23940
        wc <<= 16;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23941
        wb ^= wc;				// hash character
// hsh18:
        //b |hsh18|lch|8,wc|10,(xr)+||load next character|23942
        C_GOTO(hsh18);
        } /* hsh19 */
        

        void hsh18() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,8||shift for hash|23943
        wc <<= 8;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23944
        wb ^= wc;				// hash character
// hsh17:
        //b |hsh17|lch|8,wc|10,(xr)+||load next character|23945
        C_GOTO(hsh17);
        } /* hsh18 */
        

        void hsh17() {
        wc = *(xr_it.chp++);				// load next character
        //b ||xob|8,wb|8,wc||hash character|23946
        wb ^= wc;				// hash character
// hsh16:
        //b |hsh16|lch|8,wc|10,(xr)+||load next character|23947
        C_GOTO(hsh16);
        } /* hsh17 */
        

        void hsh16() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,24||shift for hash|23948
        wc <<= 24;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23949
        wb ^= wc;				// hash character
// hsh15:
        //b |hsh15|lch|8,wc|10,(xr)+||load next character|23950
        C_GOTO(hsh15);
        } /* hsh16 */
        

        void hsh15() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,16||shift for hash|23951
        wc <<= 16;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23952
        wb ^= wc;				// hash character
// hsh14:
        //b |hsh14|lch|8,wc|10,(xr)+||load next character|23953
        C_GOTO(hsh14);
        } /* hsh15 */
        

        void hsh14() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,8||shift for hash|23954
        wc <<= 8;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23955
        wb ^= wc;				// hash character
// hsh13:
        //b |hsh13|lch|8,wc|10,(xr)+||load next character|23956
        C_GOTO(hsh13);
        } /* hsh14 */
        

        void hsh13() {
        wc = *(xr_it.chp++);				// load next character
        //b ||xob|8,wb|8,wc||hash character|23957
        wb ^= wc;				// hash character
// hsh12:
        //b |hsh12|lch|8,wc|10,(xr)+||load next character|23958
        C_GOTO(hsh12);
        } /* hsh13 */
        

        void hsh12() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,24||shift for hash|23959
        wc <<= 24;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23960
        wb ^= wc;				// hash character
// hsh11:
        //b |hsh11|lch|8,wc|10,(xr)+||load next character|23961
        C_GOTO(hsh11);
        } /* hsh12 */
        

        void hsh11() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,16||shift for hash|23962
        wc <<= 16;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23963
        wb ^= wc;				// hash character
// hsh10:
        //b |hsh10|lch|8,wc|10,(xr)+||load next character|23964
        C_GOTO(hsh10);
        } /* hsh11 */
        

        void hsh10() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,8||shift for hash|23965
        wc <<= 8;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23966
        wb ^= wc;				// hash character
// hsh09:
        //b |hsh09|lch|8,wc|10,(xr)+||load next character|23967
        C_GOTO(hsh09);
        } /* hsh10 */
        

        void hsh09() {
        wc = *(xr_it.chp++);				// load next character
        //b ||xob|8,wb|8,wc||hash character|23968
        wb ^= wc;				// hash character
// hsh08:
        //b |hsh08|lch|8,wc|10,(xr)+||load next character|23969
        C_GOTO(hsh08);
        } /* hsh09 */
        

        void hsh08() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,24||shift for hash|23970
        wc <<= 24;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23971
        wb ^= wc;				// hash character
// hsh07:
        //b |hsh07|lch|8,wc|10,(xr)+||load next character|23972
        C_GOTO(hsh07);
        } /* hsh08 */
        

        void hsh07() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,16||shift for hash|23973
        wc <<= 16;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23974
        wb ^= wc;				// hash character
// hsh06:
        //b |hsh06|lch|8,wc|10,(xr)+||load next character|23975
        C_GOTO(hsh06);
        } /* hsh07 */
        

        void hsh06() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,8||shift for hash|23976
        wc <<= 8;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23977
        wb ^= wc;				// hash character
// hsh05:
        //b |hsh05|lch|8,wc|10,(xr)+||load next character|23978
        C_GOTO(hsh05);
        } /* hsh06 */
        

        void hsh05() {
        wc = *(xr_it.chp++);				// load next character
        //b ||xob|8,wb|8,wc||hash character|23979
        wb ^= wc;				// hash character
// hsh04:
        //b |hsh04|lch|8,wc|10,(xr)+||load next character|23980
        C_GOTO(hsh04);
        } /* hsh05 */
        

        void hsh04() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,24||shift for hash|23981
        wc <<= 24;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23982
        wb ^= wc;				// hash character
// hsh03:
        //b |hsh03|lch|8,wc|10,(xr)+||load next character|23983
        C_GOTO(hsh03);
        } /* hsh04 */
        

        void hsh03() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,16||shift for hash|23984
        wc <<= 16;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23985
        wb ^= wc;				// hash character
// hsh02:
        //b |hsh02|lch|8,wc|10,(xr)+||load next character|23986
        C_GOTO(hsh02);
        } /* hsh03 */
        

        void hsh02() {
        wc = *(xr_it.chp++);				// load next character
        //b ||lsh|8,wc|1,8||shift for hash|23987
        wc <<= 8;				// shift for hash
        //b ||xob|8,wb|8,wc||hash character|23988
        wb ^= wc;				// hash character
// hsh01:
        //b |hsh01|lch|8,wc|10,(xr)+||load next character|23989
        C_GOTO(hsh01);
        } /* hsh02 */
        

        void hsh01() {
        wc = *(xr_it.chp++);				// load next character
        //b ||xob|8,wb|8,wc||hash character|23990
        wb ^= wc;				// hash character
// hsh00:
        //b |hsh00|mov|7,xl|10,(xs)+||restore xl|23991
        C_GOTO(hsh00);
        } /* hsh01 */
        

        void hsh00() {
        xl= C_POP();				// restore xl
        //b ||brn|6,hshs3|||merge to complete hash|23992
         C_GOTO(hshs3);				// merge to complete hash
//      icbld -- build integer block
//      (ia)                  integer value for icblk
//      jsr  icbld            call to build integer block
//      (xr)                  pointer to result icblk
//      (wa)                  destroyed
// icbld:
        //b |icbld|prc|25,e|1,0||entry point|24002
        } /* hsh00 */
        

        void icbld() {
        //b ||mfi|7,xr|6,icbl1||copy small integers|24004
        if (ia<0) C_GOTO( icbl1);				// copy small integers
        xr = ia;
        //b ||ble|7,xr|18,=num02|6,icbl3|jump if 0,1 or 2|24005
        if ((xr-NUM02) <= 0) C_GOTO(icbl3);				// jump if 0,1 or 2
//      construct icblk
// icbl1:
        //b |icbl1|mov|7,xr|3,dnamp||load pointer to next available loc|24009
        C_GOTO(icbl1);
        } /* icbld */
        

        void icbl1() {
        xr= v.dnamp;				// load pointer to next available loc
        //b ||add|7,xr|19,*icsi_||point past new icblk|24010
        xr += CFP_B*ICSI_;				// point past new icblk
        //b ||blo|7,xr|3,dname|6,icbl2|jump if there is room|24011
        if ((xr-v.dname) < 0) C_GOTO(icbl2);				// jump if there is room
        //b ||mov|8,wa|19,*icsi_||else load length of icblk|24012
        wa= CFP_B*ICSI_;				// else load length of icblk
        //b ||jsr|6,alloc|||use standard allocator to get block|24013
        C_JSR(alloc);				// use standard allocator to get block
        //b ||add|7,xr|8,wa||point past block to merge|24014
        xr += wa;				// point past block to merge
//      merge here with xr pointing past the block obtained
// icbl2:
        //b |icbl2|mov|3,dnamp|7,xr||set new pointer|24018
        C_GOTO(icbl2);
        } /* icbl1 */
        

        void icbl2() {
        v.dnamp= xr;				// set new pointer
        //b ||sub|7,xr|19,*icsi_||point back to start of block|24019
        xr -= CFP_B*ICSI_;				// point back to start of block
        //b ||mov|9,(xr)|22,=b_icl||store type word|24020
        *(xr_it.wp)= (word)(b_icl);				// store type word
        //b ||sti|13,icval(xr)|||store integer value in icblk|24021
        *((word *)(CFP_B*ICVAL + xr))= ia;				// store integer value in icblk
        //b ||exi||||return to icbld caller|24022
        C_EXIT(0);				// return to icbld caller
//      optimise by not building icblks for small integers
// icbl3:
        //b |icbl3|wtb|7,xr|||convert integer to offset|24026
        } /* icbl2 */
        

        void icbl3() {
        xr <<= LOG_CFP_B;				// convert integer to offset
        //b ||mov|7,xr|14,intab(xr)||point to pre-built icblk|24027
        xr= *((word *)( ((word)&c.intab) + xr));				// point to pre-built icblk
        //b ||exi||||return|24028
        C_EXIT(0);				// return
        //b ||ejc|||||24030
        
//      ident -- compare two values
//      ident compares two values in the sense of the ident
//      differ functions available at the snobol level.
//      (xr)                  first argument
//      (xl)                  second argument
//      jsr  ident            call to compare arguments
//      ppm  loc              transfer loc if ident
//      (normal return if differ)
//      (xr,xl,wc,ra)         destroyed
// ident:
        //b |ident|prc|25,e|1,1||entry point|24044
        } /* icbl3 */
        

        void ident() {
        //b ||beq|7,xr|7,xl|6,iden7|jump if same pointer (ident)|24045
        if ((xr-xl) == 0) C_GOTO(iden7);				// jump if same pointer (ident)
        //b ||mov|8,wc|9,(xr)||else load arg 1 type word|24046
        wc= *(xr_it.wp);				// else load arg 1 type word
        //b ||bne|8,wc|9,(xl)|6,iden1|differ if arg 2 type word differ|24048
        if ((wc-*(xl_it.wp)) != 0) C_GOTO(iden1);				// differ if arg 2 type word differ
        //b ||beq|8,wc|22,=b_scl|6,iden2|jump if strings|24052
        if ((wc-(word)(b_scl)) == 0) C_GOTO(iden2);				// jump if strings
        //b ||beq|8,wc|22,=b_icl|6,iden4|jump if integers|24053
        if ((wc-(word)(b_icl)) == 0) C_GOTO(iden4);				// jump if integers
        //b ||beq|8,wc|22,=b_rcl|6,iden5|jump if reals|24056
        if ((wc-(word)(b_rcl)) == 0) C_GOTO(iden5);				// jump if reals
        //b ||beq|8,wc|22,=b_nml|6,iden6|jump if names|24058
        if ((wc-(word)(b_nml)) == 0) C_GOTO(iden6);				// jump if names
//      for all other datatypes, must be differ if xr ne xl
//      merge here for differ
// iden1:
        //b |iden1|exi||||take differ exit|24101
        C_GOTO(iden1);
        } /* ident */
        

        void iden1() {
        C_EXIT(0);				// take differ exit
//      here for strings, ident only if lengths and chars same
// iden2:
        //b |iden2|mov|8,wc|13,sclen(xr)||load arg 1 length|24105
        } /* iden1 */
        

        void iden2() {
        wc= *((word *)(CFP_B*SCLEN + xr));				// load arg 1 length
        //b ||bne|8,wc|13,sclen(xl)|6,iden1|differ if lengths differ|24106
        if ((wc-*((word *)(CFP_B*SCLEN + xl))) != 0) C_GOTO(iden1);				// differ if lengths differ
//      buffer and string comparisons merge here
// idn2a:
        //b |idn2a|add|7,xr|19,*schar||point to chars of arg 1|24110
        C_GOTO(idn2a);
        } /* iden2 */
        

        void idn2a() {
        xr += CFP_B*SCHAR;				// point to chars of arg 1
        //b ||add|7,xl|19,*schar||point to chars of arg 2|24111
        xl += CFP_B*SCHAR;				// point to chars of arg 2
        //b ||ctw|8,wc|1,0||get number of words in strings|24112
        wc = (wc+(CFP_C-1)+CFP_C* 0) >> LOG_CFP_C;				// get number of words in strings
        //b ||lct|8,wc|8,wc||set loop counter|24113
        wc= wc;				// set loop counter
//      loop to compare characters. note that wc cannot be zero
//      since all null strings point to nulls and give xl=xr.
// iden3:
        //b |iden3|cne|9,(xr)|9,(xl)|6,iden8|differ if chars do not match|24118
        C_GOTO(iden3);
        } /* idn2a */
        

        void iden3() {
        if ((*(xr_it.wp) - *(xl_it.wp))!= 0) C_GOTO(iden8);				// differ if chars do not match
        //b ||ica|7,xr|||else bump arg one pointer|24119
        xr += CFP_B;				// else bump arg one pointer
        //b ||ica|7,xl|||bump arg two pointer|24120
        xl += CFP_B;				// bump arg two pointer
        //b ||bct|8,wc|6,iden3||loop back till all checked|24121
        if ((--wc))  C_GOTO(iden3);				// loop back till all checked
        //b ||ejc|||||24122
        
//      ident (continued)
//      here to exit for case of two ident strings
        //b ||zer|7,xl|||clear garbage value in xl|24128
        xl=0;				// clear garbage value in xl
        //b ||zer|7,xr|||clear garbage value in xr|24129
        xr=0;				// clear garbage value in xr
        //b ||exi|1,1|||take ident exit|24130
        C_EXIT(1);				// take ident exit
//      here for integers, ident if same values
// iden4:
        //b |iden4|ldi|13,icval(xr)|||load arg 1|24134
        } /* iden3 */
        

        void iden4() {
        ia = *((word *)(CFP_B*ICVAL + xr));				// load arg 1
        //b ||sbi|13,icval(xl)|||subtract arg 2 to compare|24135
        ia-=*((word *)(CFP_B*ICVAL + xl));				// subtract arg 2 to compare
        //b ||iov|6,iden1|||differ if overflow|24136
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// differ if overflow
        //b ||ine|6,iden1|||differ if result is not zero|24137
        if (ia != 0)  C_GOTO(iden1);				// differ if result is not zero
        //b ||exi|1,1|||take ident exit|24138
        C_EXIT(1);				// take ident exit
//      here for reals, ident if same values
// iden5:
        //b |iden5|ldr|13,rcval(xr)|||load arg 1|24144
        } /* iden4 */
        

        void iden5() {
        {ra_it.d = *((word *)(CFP_B*RCVAL + xr));fl=(!isgoodnum(ra_it.d));}				// load arg 1
        //b ||sbr|13,rcval(xl)|||subtract arg 2 to compare|24145
        {w0 = *((word *)(CFP_B*RCVAL + xl));ra_it.d -= w0_it.d;fl=(!isgoodnum(ra_it.d));}				// subtract arg 2 to compare
        //b ||rov|6,iden1|||differ if overflow|24146
        if (fl) C_GOTO(iden1);				// differ if overflow
        //b ||rne|6,iden1|||differ if result is not zero|24147
        if (ra_it.d != 0.0)  C_GOTO(iden1);				// differ if result is not zero
        //b ||exi|1,1|||take ident exit|24148
        C_EXIT(1);				// take ident exit
//      here for names, ident if bases and offsets same
// iden6:
        //b |iden6|bne|13,nmofs(xr)|13,nmofs(xl)|6,iden1|differ if different offset|24153
        } /* iden5 */
        

        void iden6() {
        if ((*((word *)(CFP_B*NMOFS + xr))-*((word *)(CFP_B*NMOFS + xl))) != 0) C_GOTO(iden1);				// differ if different offset
        //b ||bne|13,nmbas(xr)|13,nmbas(xl)|6,iden1|differ if different base|24154
        if ((*((word *)(CFP_B*NMBAS + xr))-*((word *)(CFP_B*NMBAS + xl))) != 0) C_GOTO(iden1);				// differ if different base
//      merge here to signal ident for identical pointers
// iden7:
        //b |iden7|exi|1,1|||take ident exit|24158
        C_GOTO(iden7);
        } /* iden6 */
        

        void iden7() {
        C_EXIT(1);				// take ident exit
//      here for differ strings
// iden8:
        //b |iden8|zer|7,xr|||clear garbage ptr in xr|24162
        } /* iden7 */
        

        void iden8() {
        xr=0;				// clear garbage ptr in xr
        //b ||zer|7,xl|||clear garbage ptr in xl|24163
        xl=0;				// clear garbage ptr in xl
        //b ||exi||||return to caller (differ)|24164
        C_EXIT(0);				// return to caller (differ)
        //b ||ejc|||||24166
        
//      inout - used to initialise input and output variables
//      (xl)                  pointer to vbl name string
//      (wb)                  trblk type
//      jsr  inout            call to perform initialisation
//      (xl)                  vrblk ptr
//      (xr)                  trblk ptr
//      (wa,wc)               destroyed
//      note that trter (= trtrf) field of standard i/o variables
//      points to corresponding svblk not to a trblk as is the
//      case for ordinary variables.
// inout:
        //b |inout|prc|25,e|1,0||entry point|24181
        } /* iden8 */
        

        void inout() {
        //b ||mov|11,-(xs)|8,wb||stack trblk type|24182
        C_PUSH(wb);				// stack trblk type
        //b ||mov|8,wa|13,sclen(xl)||get name length|24183
        wa= *((word *)(CFP_B*SCLEN + xl));				// get name length
        //b ||zer|8,wb|||point to start of name|24184
        wb=0;				// point to start of name
        //b ||jsr|6,sbstr|||build a proper scblk|24185
        C_JSR(sbstr);				// build a proper scblk
        //b ||ppm||||no error return|24187
        C_JSR_1(gtnvr,(C_ERR(299)));				// no error return
        //b ||mov|8,wc|7,xr||save vrblk pointer|24188
        wc= xr;				// save vrblk pointer
        //b ||mov|8,wb|10,(xs)+||get trter field|24189
        wb= C_POP();				// get trter field
        //b ||zer|7,xl|||zero trfpt|24190
        xl=0;				// zero trfpt
        //b ||jsr|6,trbld|||build trblk|24191
        C_JSR(trbld);				// build trblk
        //b ||mov|7,xl|8,wc||recall vrblk pointer|24192
        xl= wc;				// recall vrblk pointer
        //b ||mov|13,trter(xr)|13,vrsvp(xl)||store svblk pointer|24193
        *((word *)(CFP_B*TRTER + xr))= *((word *)(CFP_B*VRSVP + xl));				// store svblk pointer
        //b ||mov|13,vrval(xl)|7,xr||store trblk ptr in vrblk|24194
        *((word *)(CFP_B*VRVAL + xl))= xr;				// store trblk ptr in vrblk
        //b ||mov|13,vrget(xl)|22,=b_vra||set trapped access|24195
        *((word *)(CFP_B*VRGET + xl))= (word)(b_vra);				// set trapped access
        //b ||mov|13,vrsto(xl)|22,=b_vrv||set trapped store|24196
        *((word *)(CFP_B*VRSTO + xl))= (word)(b_vrv);				// set trapped store
        //b ||exi||||return to caller|24197
        C_EXIT(0);				// return to caller
        //b ||ejc|||||24199
        
//      insta - used to initialize structures in static region
//      (xr)                  pointer to starting static location
//      jsr  insta            call to initialize static structure
//      (xr)                  ptr to next free static location
//      (wa,wb,wc)            destroyed
//      note that this procedure establishes the pointers
//      prbuf, gtswk, and kvalp.
// insta:
        //b |insta|prc|25,e|1,0||entry point|24378
        } /* inout */
        

        void insta() {
//      initialize print buffer with blank words
        //b ||mov|8,wc|3,prlen||no. of chars in print bfr|24383
        wc= v.prlen;				// no. of chars in print bfr
        //b ||mov|3,prbuf|7,xr||print bfr is put at static start|24384
        v.prbuf= xr;				// print bfr is put at static start
        //b ||mov|10,(xr)+|22,=b_scl||store string type code|24385
        *(xr_it.wp++)= (word)(b_scl);				// store string type code
        //b ||mov|10,(xr)+|8,wc||and string length|24386
        *(xr_it.wp++)= wc;				// and string length
        //b ||ctw|8,wc|1,0||get number of words in buffer|24387
        wc = (wc+(CFP_C-1)+CFP_C* 0) >> LOG_CFP_C;				// get number of words in buffer
        //b ||mov|3,prlnw|8,wc||store for buffer clear|24388
        v.prlnw= wc;				// store for buffer clear
        //b ||lct|8,wc|8,wc||words to clear|24389
        wc= wc;				// words to clear
//      loop to clear buffer
// inst1:
        //b |inst1|mov|10,(xr)+|4,nullw||store blank|24393
        C_GOTO(inst1);
        } /* insta */
        

        void inst1() {
        *(xr_it.wp++)= c.nullw;				// store blank
        //b ||bct|8,wc|6,inst1||loop|24394
        if ((--wc))  C_GOTO(inst1);				// loop
//      allocate work area for gtstg conversion procedure
        //b ||mov|8,wa|18,=nstmx||get max num chars in output number|24398
        wa= NSTMX;				// get max num chars in output number
        //b ||ctb|8,wa|2,scsi_||no of bytes needed|24399
        wa += (CFP_B-1)+CFP_B*SCSI_;				// no of bytes needed
        wa &= 0xfffffffffffffff8;
        //b ||mov|3,gtswk|7,xr||store bfr adrs|24400
        v.gtswk= xr;				// store bfr adrs
        //b ||add|7,xr|8,wa||bump for work bfr|24401
        xr += wa;				// bump for work bfr
//      build alphabet string for alphabet keyword and replace
        //b ||mov|3,kvalp|7,xr||save alphabet pointer|24405
        v.kvalp= xr;				// save alphabet pointer
        //b ||mov|9,(xr)|22,=b_scl||string blk type|24406
        *(xr_it.wp)= (word)(b_scl);				// string blk type
        //b ||mov|8,wc|18,=cfp_a||no of chars in alphabet|24407
        wc= CFP_A;				// no of chars in alphabet
        //b ||mov|13,sclen(xr)|8,wc||store as string length|24408
        *((word *)(CFP_B*SCLEN + xr))= wc;				// store as string length
        //b ||mov|8,wb|8,wc||copy char count|24409
        wb= wc;				// copy char count
        //b ||ctb|8,wb|2,scsi_||no. of bytes needed|24410
        wb += (CFP_B-1)+CFP_B*SCSI_;				// no. of bytes needed
        wb &= 0xfffffffffffffff8;
        //b ||add|8,wb|7,xr||current end address for static|24411
        wb += xr;				// current end address for static
        //b ||mov|8,wa|8,wb||save adrs past alphabet string|24412
        wa= wb;				// save adrs past alphabet string
        //b ||lct|8,wc|8,wc||loop counter|24413
        wc= wc;				// loop counter
        //b ||psc|7,xr|||point to chars of string|24414
        xr += CFP_F;				// point to chars of string
        //b ||zer|8,wb|||set initial character value|24415
        wb=0;				// set initial character value
//      loop to enter character codes in order
// inst2:
        //b |inst2|sch|8,wb|10,(xr)+||store next code|24419
        C_GOTO(inst2);
        } /* inst1 */
        

        void inst2() {
        *(xr_it.chp++) = wb;				// store next code
        //b ||icv|8,wb|||bump code value|24420
        (wb)++;				// bump code value
        //b ||bct|8,wc|6,inst2||loop till all stored|24421
        if ((--wc))  C_GOTO(inst2);				// loop till all stored
        //b ||csc|7,xr|||complete store characters|24422
        //b ||mov|7,xr|8,wa||return current static ptr|24423
        xr= wa;				// return current static ptr
        //b ||exi||||return to caller|24424
        C_EXIT(0);				// return to caller
        //b ||ejc|||||24426
        
//      iofcb -- get input/output fcblk pointer
//      used by endfile, eject and rewind to find the fcblk
//      (if any) corresponding to their argument.
//      -(xs)                 argument
//      jsr  iofcb            call to find fcblk
//      ppm  loc              arg is an unsuitable name
//      ppm  loc              arg is null string
//      ppm  loc              arg file not found
//      (xs)                  popped
//      (xl)                  ptr to filearg1 vrblk
//      (xr)                  argument
//      (wa)                  fcblk ptr or 0
//      (wb,wc)               destroyed
// iofcb:
        //b |iofcb|prc|25,n|1,3||entry point|24444
        } /* inst2 */
        

        void iofcb() {
        //b ||ppm|6,iofc2|||fail|24447
        extern void _l0668();
        C_JMS(gtstg,P_PRC_GTSTG,_l0668);
        } /* iofcb */
        

        void _l0668() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(iofc2));				// fail
        //b ||mov|7,xl|7,xr||copy string ptr|24448
        xl= xr;				// copy string ptr
        //b ||ppm|6,iofc3|||fail if null|24450
        C_JSR_1(gtnvr,C_GOTO(iofc3));				// fail if null
        //b ||mov|8,wb|7,xl||copy string pointer again|24451
        wb= xl;				// copy string pointer again
        //b ||mov|7,xl|7,xr||copy vrblk ptr for return|24452
        xl= xr;				// copy vrblk ptr for return
        //b ||zer|8,wa|||in case no trblk found|24453
        wa=0;				// in case no trblk found
//      loop to find file arg1 trblk
// iofc1:
        //b |iofc1|mov|7,xr|13,vrval(xr)||get possible trblk ptr|24457
        C_GOTO(iofc1);
        } /* _l0668 */
        

        void iofc1() {
        xr= *((word *)(CFP_B*VRVAL + xr));				// get possible trblk ptr
        //b ||bne|9,(xr)|22,=b_trt|6,iofc4|fail if end of chain|24458
        if ((*(xr_it.wp)-(word)(b_trt)) != 0) C_GOTO(iofc4);				// fail if end of chain
        //b ||bne|13,trtyp(xr)|18,=trtfc|6,iofc1|loop if not file arg trblk|24459
        if ((*((word *)(CFP_B*TRTYP + xr))-TRTFC) != 0) C_GOTO(iofc1);				// loop if not file arg trblk
        //b ||mov|8,wa|13,trfpt(xr)||get fcblk ptr|24460
        wa= *((word *)(CFP_B*TRFPT + xr));				// get fcblk ptr
        //b ||mov|7,xr|8,wb||copy arg|24461
        xr= wb;				// copy arg
        //b ||exi||||return|24462
        C_NEXIT(P_PRC_IOFCB,0);				// return
//      fail return
// iofc2:
        //b |iofc2|exi|1,1|||fail|24466
        } /* iofc1 */
        

        void iofc2() {
        C_NEXIT(P_PRC_IOFCB,1);				// fail
//      null arg
// iofc3:
        //b |iofc3|exi|1,2|||null arg return|24470
        } /* iofc2 */
        

        void iofc3() {
        C_NEXIT(P_PRC_IOFCB,2);				// null arg return
//      file not found
// iofc4:
        //b |iofc4|exi|1,3|||file not found return|24474
        } /* iofc3 */
        

        void iofc4() {
        C_NEXIT(P_PRC_IOFCB,3);				// file not found return
        //b ||ejc|||||24476
        
//      ioppf -- process filearg2 for ioput
//      (r_xsc)               filearg2 ptr
//      jsr  ioppf            call to process filearg2
//      (xl)                  filearg1 ptr
//      (xr)                  file arg2 ptr
//      -(xs)...-(xs)         fields extracted from filearg2
//      (wc)                  no. of fields extracted
//      (wb)                  input/output flag
//      (wa)                  fcblk ptr or 0
// ioppf:
        //b |ioppf|prc|25,n|1,0||entry point|24489
        } /* iofc4 */
        

        void ioppf() {
        //b ||zer|8,wb|||to count fields extracted|24490
        wb=0;				// to count fields extracted
//      loop to extract fields
// iopp1:
        //b |iopp1|mov|7,xl|18,=iodel||get delimiter|24494
        C_GOTO(iopp1);
        } /* ioppf */
        

        void iopp1() {
        xl= IODEL;				// get delimiter
        //b ||mov|8,wc|7,xl||copy it|24495
        wc= xl;				// copy it
        //b ||zer|8,wa|||retain leading blanks in filearg2|24496
        wa=0;				// retain leading blanks in filearg2
        //b ||jsr|6,xscan|||get next field|24497
        C_JSR(xscan);				// get next field
        //b ||mov|11,-(xs)|7,xr||stack it|24498
        C_PUSH(xr);				// stack it
        //b ||icv|8,wb|||increment count|24499
        (wb)++;				// increment count
        //b ||bnz|8,wa|6,iopp1||loop|24500
        if (wa) C_GOTO(iopp1);				// loop
        //b ||mov|8,wc|8,wb||count of fields|24501
        wc= wb;				// count of fields
        //b ||mov|8,wb|3,ioptt||i/o marker|24502
        wb= v.ioptt;				// i/o marker
        //b ||mov|8,wa|3,r_iof||fcblk ptr or 0|24503
        wa= v.r_iof;				// fcblk ptr or 0
        //b ||mov|7,xr|3,r_io2||file arg2 ptr|24504
        xr= v.r_io2;				// file arg2 ptr
        //b ||mov|7,xl|3,r_io1||filearg1|24505
        xl= v.r_io1;				// filearg1
        //b ||exi||||return|24506
        C_NEXIT(P_PRC_IOPPF,0);				// return
        //b ||ejc|||||24508
        
//      ioput -- routine used by input and output
//      ioput sets up input/output  associations. it builds
//      such trace and file control blocks as are necessary and
//      calls sysfc,sysio to perform checks on the
//      arguments and to open the files.
//         +-----------+   +---------------+       +-----------+
//      +-.i           i   i               i------.i   =b_xrt  i
//      i  +-----------+   +---------------+       +-----------+
//      i  /           /        (r_fcb)            i    *4     i
//      i  /           /                           +-----------+
//      i  +-----------+   +---------------+       i           i-
//      i  i   name    +--.i    =b_trt     i       +-----------+
//      i  /           /   +---------------+       i           i
//      i   (first arg)    i =trtin/=trtou i       +-----------+
//      i                  +---------------+             i
//      i                  i     value     i             i
//      i                  +---------------+             i
//      i                  i(trtrf) 0   or i--+          i
//      i                  +---------------+  i          i
//      i                  i(trfpt) 0   or i----+        i
//      i                  +---------------+  i i        i
//      i                     (i/o trblk)     i i        i
//      i  +-----------+                      i i        i
//      i  i           i                      i i        i
//      i  +-----------+                      i i        i
//      i  i           i                      i i        i
//      i  +-----------+   +---------------+  i i        i
//      i  i           +--.i    =b_trt     i.-+ i        i
//      i  +-----------+   +---------------+    i        i
//      i  /           /   i    =trtfc     i    i        i
//      i  /           /   +---------------+    i        i
//      i    (filearg1     i     value     i    i        i
//      i         vrblk)   +---------------+    i        i
//      i                  i(trtrf) 0   or i--+ i        .
//      i                  +---------------+  i .  +-----------+
//      i                  i(trfpt) 0   or i------./   fcblk   /
//      i                  +---------------+  i    +-----------+
//      i                       (trtrf)       i
//      i                                     i
//      i                                     i
//      i                  +---------------+  i
//      i                  i    =b_xrt     i.-+
//      i                  +---------------+
//      i                  i      *5       i
//      i                  +---------------+
//      +------------------i               i
//                         +---------------+       +-----------+
//                         i(trtrf) o   or i------.i  =b_xrt   i
//                         +---------------+       +-----------+
//                         i  name offset  i       i    etc    i
//                         +---------------+
//                           (iochn - chain of name pointers)
        //b ||ejc|||||24564
        
//      ioput (continued)
//      no additional trap blocks are used for standard input/out
//      files. otherwise an i/o trap block is attached to second
//      arg (filearg1) vrblk. see diagram above for details of
//      the structure built.
//      -(xs)                 1st arg (vbl to be associated)
//      -(xs)                 2nd arg (file arg1)
//      -(xs)                 3rd arg (file arg2)
//      (wb)                  0 for input, 3 for output assoc.
//      jsr  ioput            call for input/output association
//      ppm  loc              3rd arg not a string
//      ppm  loc              2nd arg not a suitable name
//      ppm  loc              1st arg not a suitable name
//      ppm  loc              inappropriate file spec for i/o
//      ppm  loc              i/o file does not exist
//      ppm  loc              i/o file cannot be read/written
//      ppm  loc              i/o fcblk currently in use
//      (xs)                  popped
//      (xl,xr,wa,wb,wc)      destroyed
// ioput:
        //b |ioput|prc|25,n|1,7||entry point|24588
        } /* iopp1 */
        

        void ioput() {
        //b ||zer|3,r_iot|||in case no trtrf block used|24589
        v.r_iot=0;				// in case no trtrf block used
        //b ||zer|3,r_iof|||in case no fcblk alocated|24590
        v.r_iof=0;				// in case no fcblk alocated
        //b ||zer|3,r_iop|||in case sysio fails|24591
        v.r_iop=0;				// in case sysio fails
        //b ||mov|3,ioptt|8,wb||store i/o trace type|24592
        v.ioptt= wb;				// store i/o trace type
        //b ||ppm|6,iopa0|||null file arg2|24595
        extern void _l0669();
        C_JMS(xscni,P_PRC_XSCNI,_l0669);
        } /* ioput */
        

        void _l0669() {
        C_JMS_HANDLE_2(xscni,C_GOTO(iop13),C_GOTO(iopa0));				// null file arg2
// iopa0:
        //b |iopa0|mov|3,r_io2|7,xr||keep file arg2|24597
        C_GOTO(iopa0);
        } /* _l0669 */
        

        void iopa0() {
        v.r_io2= xr;				// keep file arg2
        //b ||mov|7,xl|8,wa||copy length|24598
        xl= wa;				// copy length
        //b ||ppm|6,iop14|||fail|24600
        extern void _l0670();
        C_JMS(gtstg,P_PRC_GTSTG,_l0670);
        } /* iopa0 */
        

        void _l0670() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(iop14));				// fail
        //b ||mov|3,r_io1|7,xr||keep filearg1 ptr|24601
        v.r_io1= xr;				// keep filearg1 ptr
        //b ||ppm|6,iop00|||jump if null|24603
        C_JSR_1(gtnvr,C_GOTO(iop00));				// jump if null
        //b ||brn|6,iop04|||jump to process non-null args|24604
         C_GOTO(iop04);				// jump to process non-null args
//      null filearg1
// iop00:
        //b |iop00|bze|7,xl|6,iop01||skip if both args null|24608
        } /* _l0670 */
        

        void iop00() {
        if ( !( xl) ) C_GOTO(iop01);				// skip if both args null
        //b ||jsr|6,ioppf|||process filearg2|24609
        extern void _l0671();
        C_JMS(ioppf,P_PRC_IOPPF,_l0671);
        } /* iop00 */
        

        void _l0671() {
        //b ||ppm|6,iop26|||fail|24612
        C_JSR_2(sysfc,C_GOTO(iop16),C_GOTO(iop26));				// fail
        //b ||brn|6,iop11|||complete file association|24613
         C_GOTO(iop11);				// complete file association
        //b ||ejc|||||24614
        
//      ioput (continued)
//      here with 0 or fcblk ptr in (xl)
// iop01:
        //b |iop01|mov|8,wb|3,ioptt||get trace type|24620
        } /* _l0671 */
        

        void iop01() {
        wb= v.ioptt;				// get trace type
        //b ||mov|7,xr|3,r_iot||get 0 or trtrf ptr|24621
        xr= v.r_iot;				// get 0 or trtrf ptr
        //b ||jsr|6,trbld|||build trblk|24622
        C_JSR(trbld);				// build trblk
        //b ||mov|8,wc|7,xr||copy trblk pointer|24623
        wc= xr;				// copy trblk pointer
        //b ||mov|7,xr|10,(xs)+||get variable from stack|24624
        xr= C_POP();				// get variable from stack
        //b ||mov|11,-(xs)|8,wc||make trblk collectable|24625
        C_PUSH(wc);				// make trblk collectable
        //b ||ppm|6,iop15|||fail|24627
        C_JSR_1(gtvar,C_GOTO(iop15));				// fail
        //b ||mov|8,wc|10,(xs)+||recover trblk pointer|24628
        wc= C_POP();				// recover trblk pointer
        //b ||mov|3,r_ion|7,xl||save name pointer|24629
        v.r_ion= xl;				// save name pointer
        //b ||mov|7,xr|7,xl||copy name pointer|24630
        xr= xl;				// copy name pointer
        //b ||add|7,xr|8,wa||point to variable|24631
        xr += wa;				// point to variable
        //b ||sub|7,xr|19,*vrval||subtract offset,merge into loop|24632
        xr -= CFP_B*VRVAL;				// subtract offset,merge into loop
//      loop to end of trblk chain if any
// iop02:
        //b |iop02|mov|7,xl|7,xr||copy blk ptr|24636
        C_GOTO(iop02);
        } /* iop01 */
        

        void iop02() {
        xl= xr;				// copy blk ptr
        //b ||mov|7,xr|13,vrval(xr)||load ptr to next trblk|24637
        xr= *((word *)(CFP_B*VRVAL + xr));				// load ptr to next trblk
        //b ||bne|9,(xr)|22,=b_trt|6,iop03|jump if not trapped|24638
        if ((*(xr_it.wp)-(word)(b_trt)) != 0) C_GOTO(iop03);				// jump if not trapped
        //b ||bne|13,trtyp(xr)|3,ioptt|6,iop02|loop if not same assocn|24639
        if ((*((word *)(CFP_B*TRTYP + xr))-v.ioptt) != 0) C_GOTO(iop02);				// loop if not same assocn
        //b ||mov|7,xr|13,trnxt(xr)||get value and delete old trblk|24640
        xr= *((word *)(CFP_B*TRNXT + xr));				// get value and delete old trblk
//      ioput (continued)
//      store new association
// iop03:
        //b |iop03|mov|13,vrval(xl)|8,wc||link to this trblk|24646
        C_GOTO(iop03);
        } /* iop02 */
        

        void iop03() {
        *((word *)(CFP_B*VRVAL + xl))= wc;				// link to this trblk
        //b ||mov|7,xl|8,wc||copy pointer|24647
        xl= wc;				// copy pointer
        //b ||mov|13,trnxt(xl)|7,xr||store value in trblk|24648
        *((word *)(CFP_B*TRNXT + xl))= xr;				// store value in trblk
        //b ||mov|7,xr|3,r_ion||restore possible vrblk pointer|24649
        xr= v.r_ion;				// restore possible vrblk pointer
        //b ||mov|8,wb|8,wa||keep offset to name|24650
        wb= wa;				// keep offset to name
        //b ||jsr|6,setvr|||if vrblk, set vrget,vrsto|24651
        C_JSR(setvr);				// if vrblk, set vrget,vrsto
        //b ||mov|7,xr|3,r_iot||get 0 or trtrf ptr|24652
        xr= v.r_iot;				// get 0 or trtrf ptr
        //b ||bnz|7,xr|6,iop19||jump if trtrf block exists|24653
        if (xr) C_GOTO(iop19);				// jump if trtrf block exists
        //b ||exi||||return to caller|24654
        C_NEXIT(P_PRC_IOPUT,0);				// return to caller
//      non standard file
//      see if an fcblk has already been allocated.
// iop04:
        //b |iop04|zer|8,wa|||in case no fcblk found|24659
        } /* iop03 */
        

        void iop04() {
        wa=0;				// in case no fcblk found
        //b ||ejc|||||24660
        
//      ioput (continued)
//      search possible trblk chain to pick up the fcblk
// iop05:
        //b |iop05|mov|8,wb|7,xr||remember blk ptr|24666
        C_GOTO(iop05);
        } /* iop04 */
        

        void iop05() {
        wb= xr;				// remember blk ptr
        //b ||mov|7,xr|13,vrval(xr)||chain along|24667
        xr= *((word *)(CFP_B*VRVAL + xr));				// chain along
        //b ||bne|9,(xr)|22,=b_trt|6,iop06|jump if end of trblk chain|24668
        if ((*(xr_it.wp)-(word)(b_trt)) != 0) C_GOTO(iop06);				// jump if end of trblk chain
        //b ||bne|13,trtyp(xr)|18,=trtfc|6,iop05|loop if more to go|24669
        if ((*((word *)(CFP_B*TRTYP + xr))-TRTFC) != 0) C_GOTO(iop05);				// loop if more to go
        //b ||mov|3,r_iot|7,xr||point to file arg1 trblk|24670
        v.r_iot= xr;				// point to file arg1 trblk
        //b ||mov|8,wa|13,trfpt(xr)||get fcblk ptr from trblk|24671
        wa= *((word *)(CFP_B*TRFPT + xr));				// get fcblk ptr from trblk
//      wa = 0 or fcblk ptr
//      wb = ptr to preceding blk to which any trtrf block
//           for file arg1 must be chained.
// iop06:
        //b |iop06|mov|3,r_iof|8,wa||keep possible fcblk ptr|24677
        C_GOTO(iop06);
        } /* iop05 */
        

        void iop06() {
        v.r_iof= wa;				// keep possible fcblk ptr
        //b ||mov|3,r_iop|8,wb||keep preceding blk ptr|24678
        v.r_iop= wb;				// keep preceding blk ptr
        //b ||jsr|6,ioppf|||process filearg2|24679
        extern void _l0672();
        C_JMS(ioppf,P_PRC_IOPPF,_l0672);
        } /* iop06 */
        

        void _l0672() {
        //b ||ppm|6,iop26|||fail|24682
        C_JSR_2(sysfc,C_GOTO(iop16),C_GOTO(iop26));				// fail
        //b ||bze|8,wa|6,iop12||skip if no new fcblk wanted|24683
        if ( !( wa) ) C_GOTO(iop12);				// skip if no new fcblk wanted
        //b ||blt|8,wc|18,=num02|6,iop6a|jump if fcblk in dynamic|24684
        if ((wc-NUM02) < 0) C_GOTO(iop6a);				// jump if fcblk in dynamic
        //b ||jsr|6,alost|||get it in static|24685
        C_JSR(alost);				// get it in static
        //b ||brn|6,iop6b|||skip|24686
         C_GOTO(iop6b);				// skip
//      obtain fcblk in dynamic
// iop6a:
        //b |iop6a|jsr|6,alloc|||get space for fcblk|24690
        } /* _l0672 */
        

        void iop6a() {
        C_JSR(alloc);				// get space for fcblk
//      merge
// iop6b:
        //b |iop6b|mov|7,xl|7,xr||point to fcblk|24694
        C_GOTO(iop6b);
        } /* iop6a */
        

        void iop6b() {
        xl= xr;				// point to fcblk
        //b ||mov|8,wb|8,wa||copy its length|24695
        wb= wa;				// copy its length
        //b ||btw|8,wb|||get count as words (sgd apr80)|24696
        wb >>= LOG_CFP_B;				// get count as words (sgd apr80)
        //b ||lct|8,wb|8,wb||loop counter|24697
        wb= wb;				// loop counter
//      clear fcblk
// iop07:
        //b |iop07|zer|10,(xr)+|||clear a word|24701
        C_GOTO(iop07);
        } /* iop6b */
        

        void iop07() {
        *(xr_it.wp++)=0;				// clear a word
        //b ||bct|8,wb|6,iop07||loop|24702
        if ((--wb))  C_GOTO(iop07);				// loop
        //b ||beq|8,wc|18,=num02|6,iop09|skip if in static - dont set fields|24703
        if ((wc-NUM02) == 0) C_GOTO(iop09);				// skip if in static - dont set fields
        //b ||mov|9,(xl)|22,=b_xnt||store xnblk code in case|24704
        *(xl_it.wp)= (word)(b_xnt);				// store xnblk code in case
        //b ||mov|13,num01(xl)|8,wa||store length|24705
        *((word *)(CFP_B*NUM01 + xl))= wa;				// store length
        //b ||bnz|8,wc|6,iop09||jump if xnblk wanted|24706
        if (wc) C_GOTO(iop09);				// jump if xnblk wanted
        //b ||mov|9,(xl)|22,=b_xrt||xrblk code requested|24707
        *(xl_it.wp)= (word)(b_xrt);				// xrblk code requested
        //b ||ejc|||||24709
        
//      ioput (continued)
//      complete fcblk initialisation
// iop09:
        //b |iop09|mov|7,xr|3,r_iot||get possible trblk ptr|24714
        C_GOTO(iop09);
        } /* iop07 */
        

        void iop09() {
        xr= v.r_iot;				// get possible trblk ptr
        //b ||mov|3,r_iof|7,xl||store fcblk ptr|24715
        v.r_iof= xl;				// store fcblk ptr
        //b ||bnz|7,xr|6,iop10||jump if trblk already found|24716
        if (xr) C_GOTO(iop10);				// jump if trblk already found
//      a new trblk is needed
        //b ||mov|8,wb|18,=trtfc||trtyp for fcblk trap blk|24720
        wb= TRTFC;				// trtyp for fcblk trap blk
        //b ||jsr|6,trbld|||make the block|24721
        C_JSR(trbld);				// make the block
        //b ||mov|3,r_iot|7,xr||copy trtrf ptr|24722
        v.r_iot= xr;				// copy trtrf ptr
        //b ||mov|7,xl|3,r_iop||point to preceding blk|24723
        xl= v.r_iop;				// point to preceding blk
        //b ||mov|13,vrval(xr)|13,vrval(xl)||copy value field to trblk|24724
        *((word *)(CFP_B*VRVAL + xr))= *((word *)(CFP_B*VRVAL + xl));				// copy value field to trblk
        //b ||mov|13,vrval(xl)|7,xr||link new trblk into chain|24725
        *((word *)(CFP_B*VRVAL + xl))= xr;				// link new trblk into chain
        //b ||mov|7,xr|7,xl||point to predecessor blk|24726
        xr= xl;				// point to predecessor blk
        //b ||jsr|6,setvr|||set trace intercepts|24727
        C_JSR(setvr);				// set trace intercepts
        //b ||mov|7,xr|13,vrval(xr)||recover trblk ptr|24728
        xr= *((word *)(CFP_B*VRVAL + xr));				// recover trblk ptr
        //b ||brn|6,iop1a|||store fcblk ptr|24729
         C_GOTO(iop1a);				// store fcblk ptr
//      here if existing trblk
// iop10:
        //b |iop10|zer|3,r_iop|||do not release if sysio fails|24733
        } /* iop09 */
        

        void iop10() {
        v.r_iop=0;				// do not release if sysio fails
//      xr is ptr to trblk, xl is fcblk ptr or 0
// iop1a:
        //b |iop1a|mov|13,trfpt(xr)|3,r_iof||store fcblk ptr|24737
        C_GOTO(iop1a);
        } /* iop10 */
        

        void iop1a() {
        *((word *)(CFP_B*TRFPT + xr))= v.r_iof;				// store fcblk ptr
//      call sysio to complete file accessing
// iop11:
        //b |iop11|mov|8,wa|3,r_iof||copy fcblk ptr or 0|24741
        C_GOTO(iop11);
        } /* iop1a */
        

        void iop11() {
        wa= v.r_iof;				// copy fcblk ptr or 0
        //b ||mov|8,wb|3,ioptt||get input/output flag|24742
        wb= v.ioptt;				// get input/output flag
        //b ||mov|7,xr|3,r_io2||get file arg2|24743
        xr= v.r_io2;				// get file arg2
        //b ||mov|7,xl|3,r_io1||get file arg1|24744
        xl= v.r_io1;				// get file arg1
        //b ||ppm|6,iop18|||fail|24747
        C_JSR_2(sysio,C_GOTO(iop17),C_GOTO(iop18));				// fail
        //b ||bnz|3,r_iot|6,iop01||not std input if non-null trtrf blk|24748
        if (v.r_iot) C_GOTO(iop01);				// not std input if non-null trtrf blk
        //b ||bnz|3,ioptt|6,iop01||jump if output|24749
        if (v.ioptt) C_GOTO(iop01);				// jump if output
        //b ||bze|8,wc|6,iop01||no change to standard read length|24750
        if ( !( wc) ) C_GOTO(iop01);				// no change to standard read length
        //b ||mov|3,cswin|8,wc||store new read length for std file|24751
        v.cswin= wc;				// store new read length for std file
        //b ||brn|6,iop01|||merge to finish the task|24752
         C_GOTO(iop01);				// merge to finish the task
//      sysfc may have returned a pointer to a private fcblk
// iop12:
        //b |iop12|bnz|7,xl|6,iop09||jump if private fcblk|24756
        } /* iop11 */
        

        void iop12() {
        if (xl) C_GOTO(iop09);				// jump if private fcblk
        //b ||brn|6,iop11|||finish the association|24757
         C_GOTO(iop11);				// finish the association
//      failure returns
// iop13:
        //b |iop13|exi|1,1|||3rd arg not a string|24761
        } /* iop12 */
        

        void iop13() {
        C_NEXIT(P_PRC_IOPUT,1);				// 3rd arg not a string
// iop14:
        //b |iop14|exi|1,2|||2nd arg unsuitable|24762
        } /* iop13 */
        

        void iop14() {
        C_NEXIT(P_PRC_IOPUT,2);				// 2nd arg unsuitable
// iop15:
        //b |iop15|ica|7,xs|||discard trblk pointer|24763
        } /* iop14 */
        

        void iop15() {
        xs += CFP_B;				// discard trblk pointer
        //b ||exi|1,3|||1st arg unsuitable|24764
        C_NEXIT(P_PRC_IOPUT,3);				// 1st arg unsuitable
// iop16:
        //b |iop16|exi|1,4|||file spec wrong|24765
        } /* iop15 */
        

        void iop16() {
        C_NEXIT(P_PRC_IOPUT,4);				// file spec wrong
// iop26:
        //b |iop26|exi|1,7|||fcblk in use|24766
        } /* iop16 */
        

        void iop26() {
        C_NEXIT(P_PRC_IOPUT,7);				// fcblk in use
//      i/o file does not exist
// iop17:
        //b |iop17|mov|7,xr|3,r_iop||is there a trblk to release|24770
        } /* iop26 */
        

        void iop17() {
        xr= v.r_iop;				// is there a trblk to release
        //b ||bze|7,xr|6,iopa7||if not|24771
        if ( !( xr) ) C_GOTO(iopa7);				// if not
        //b ||mov|7,xl|13,vrval(xr)||point to trblk|24772
        xl= *((word *)(CFP_B*VRVAL + xr));				// point to trblk
        //b ||mov|13,vrval(xr)|13,vrval(xl)||unsplice it|24773
        *((word *)(CFP_B*VRVAL + xr))= *((word *)(CFP_B*VRVAL + xl));				// unsplice it
        //b ||jsr|6,setvr|||adjust trace intercepts|24774
        C_JSR(setvr);				// adjust trace intercepts
// iopa7:
        //b |iopa7|exi|1,5|||i/o file does not exist|24775
        C_GOTO(iopa7);
        } /* iop17 */
        

        void iopa7() {
        C_NEXIT(P_PRC_IOPUT,5);				// i/o file does not exist
//      i/o file cannot be read/written
// iop18:
        //b |iop18|mov|7,xr|3,r_iop||is there a trblk to release|24779
        } /* iopa7 */
        

        void iop18() {
        xr= v.r_iop;				// is there a trblk to release
        //b ||bze|7,xr|6,iopa7||if not|24780
        if ( !( xr) ) C_GOTO(iopa7);				// if not
        //b ||mov|7,xl|13,vrval(xr)||point to trblk|24781
        xl= *((word *)(CFP_B*VRVAL + xr));				// point to trblk
        //b ||mov|13,vrval(xr)|13,vrval(xl)||unsplice it|24782
        *((word *)(CFP_B*VRVAL + xr))= *((word *)(CFP_B*VRVAL + xl));				// unsplice it
        //b ||jsr|6,setvr|||adjust trace intercepts|24783
        C_JSR(setvr);				// adjust trace intercepts
// iopa8:
        //b |iopa8|exi|1,6|||i/o file cannot be read/written|24784
        C_GOTO(iopa8);
        } /* iop18 */
        

        void iopa8() {
        C_NEXIT(P_PRC_IOPUT,6);				// i/o file cannot be read/written
        //b ||ejc|||||24785
        
//      ioput (continued)
//      add to iochn chain of associated variables unless
//      already present.
// iop19:
        //b |iop19|mov|8,wc|3,r_ion||wc = name base, wb = name offset|24792
        } /* iopa8 */
        

        void iop19() {
        wc= v.r_ion;				// wc = name base, wb = name offset
//      search loop
// iop20:
        //b |iop20|mov|7,xr|13,trtrf(xr)||next link of chain|24796
        C_GOTO(iop20);
        } /* iop19 */
        

        void iop20() {
        xr= *((word *)(CFP_B*TRTRF + xr));				// next link of chain
        //b ||bze|7,xr|6,iop21||not found|24797
        if ( !( xr) ) C_GOTO(iop21);				// not found
        //b ||bne|8,wc|13,ionmb(xr)|6,iop20|no match|24798
        if ((wc-*((word *)(CFP_B*IONMB + xr))) != 0) C_GOTO(iop20);				// no match
        //b ||beq|8,wb|13,ionmo(xr)|6,iop22|exit if matched|24799
        if ((wb-*((word *)(CFP_B*IONMO + xr))) == 0) C_GOTO(iop22);				// exit if matched
        //b ||brn|6,iop20|||loop|24800
         C_GOTO(iop20);				// loop
//      not found
// iop21:
        //b |iop21|mov|8,wa|19,*num05||space needed|24804
        } /* iop20 */
        

        void iop21() {
        wa= CFP_B*NUM05;				// space needed
        //b ||jsr|6,alloc|||get it|24805
        C_JSR(alloc);				// get it
        //b ||mov|9,(xr)|22,=b_xrt||store xrblk code|24806
        *(xr_it.wp)= (word)(b_xrt);				// store xrblk code
        //b ||mov|13,num01(xr)|8,wa||store length|24807
        *((word *)(CFP_B*NUM01 + xr))= wa;				// store length
        //b ||mov|13,ionmb(xr)|8,wc||store name base|24808
        *((word *)(CFP_B*IONMB + xr))= wc;				// store name base
        //b ||mov|13,ionmo(xr)|8,wb||store name offset|24809
        *((word *)(CFP_B*IONMO + xr))= wb;				// store name offset
        //b ||mov|7,xl|3,r_iot||point to trtrf blk|24810
        xl= v.r_iot;				// point to trtrf blk
        //b ||mov|8,wa|13,trtrf(xl)||get ptr field contents|24811
        wa= *((word *)(CFP_B*TRTRF + xl));				// get ptr field contents
        //b ||mov|13,trtrf(xl)|7,xr||store ptr to new block|24812
        *((word *)(CFP_B*TRTRF + xl))= xr;				// store ptr to new block
        //b ||mov|13,trtrf(xr)|8,wa||complete the linking|24813
        *((word *)(CFP_B*TRTRF + xr))= wa;				// complete the linking
//      insert fcblk on fcblk chain for sysej, sysxi
// iop22:
        //b |iop22|bze|3,r_iof|6,iop25||skip if no fcblk|24817
        C_GOTO(iop22);
        } /* iop21 */
        

        void iop22() {
        if ( !( v.r_iof) ) C_GOTO(iop25);				// skip if no fcblk
        //b ||mov|7,xl|3,r_fcb||ptr to head of existing chain|24818
        xl= v.r_fcb;				// ptr to head of existing chain
//      see if fcblk already on chain
// iop23:
        //b |iop23|bze|7,xl|6,iop24||not on if end of chain|24822
        C_GOTO(iop23);
        } /* iop22 */
        

        void iop23() {
        if ( !( xl) ) C_GOTO(iop24);				// not on if end of chain
        //b ||beq|13,num03(xl)|3,r_iof|6,iop25|dont duplicate if find it|24823
        if ((*((word *)(CFP_B*NUM03 + xl))-v.r_iof) == 0) C_GOTO(iop25);				// dont duplicate if find it
        //b ||mov|7,xl|13,num02(xl)||get next link|24824
        xl= *((word *)(CFP_B*NUM02 + xl));				// get next link
        //b ||brn|6,iop23|||loop|24825
         C_GOTO(iop23);				// loop
//      not found so add an entry for this fcblk
// iop24:
        //b |iop24|mov|8,wa|19,*num04||space needed|24829
        } /* iop23 */
        

        void iop24() {
        wa= CFP_B*NUM04;				// space needed
        //b ||jsr|6,alloc|||get it|24830
        C_JSR(alloc);				// get it
        //b ||mov|9,(xr)|22,=b_xrt||store block code|24831
        *(xr_it.wp)= (word)(b_xrt);				// store block code
        //b ||mov|13,num01(xr)|8,wa||store length|24832
        *((word *)(CFP_B*NUM01 + xr))= wa;				// store length
        //b ||mov|13,num02(xr)|3,r_fcb||store previous link in this node|24833
        *((word *)(CFP_B*NUM02 + xr))= v.r_fcb;				// store previous link in this node
        //b ||mov|13,num03(xr)|3,r_iof||store fcblk ptr|24834
        *((word *)(CFP_B*NUM03 + xr))= v.r_iof;				// store fcblk ptr
        //b ||mov|3,r_fcb|7,xr||insert node into fcblk chain|24835
        v.r_fcb= xr;				// insert node into fcblk chain
//      return
// iop25:
        //b |iop25|exi||||return to caller|24839
        C_GOTO(iop25);
        } /* iop24 */
        

        void iop25() {
        C_NEXIT(P_PRC_IOPUT,0);				// return to caller
        //b ||ejc|||||24841
        
//      ktrex -- execute keyword trace
//      ktrex is used to execute a possible keyword trace. it
//      includes the test on trace and tests for trace active.
//      (xl)                  ptr to trblk (or 0 if untraced)
//      jsr  ktrex            call to execute keyword trace
//      (xl,wa,wb,wc)         destroyed
//      (ra)                  destroyed
// ktrex:
        //b |ktrex|prc|25,r|1,0||entry point (recursive)|24853
        } /* iop25 */
        

        void ktrex() {
        //b ||bze|7,xl|6,ktrx3||immediate exit if keyword untraced|24854
        if ( !( xl) ) C_GOTO(ktrx3);				// immediate exit if keyword untraced
        //b ||bze|3,kvtra|6,ktrx3||immediate exit if trace = 0|24855
        if ( !( v.kvtra) ) C_GOTO(ktrx3);				// immediate exit if trace = 0
        //b ||dcv|3,kvtra|||else decrement trace|24856
        (v.kvtra)--;				// else decrement trace
        //b ||mov|11,-(xs)|7,xr||save xr|24857
        C_PUSH(xr);				// save xr
        //b ||mov|7,xr|7,xl||copy trblk pointer|24858
        xr= xl;				// copy trblk pointer
        //b ||mov|7,xl|13,trkvr(xr)||load vrblk pointer (nmbas)|24859
        xl= *((word *)(CFP_B*TRKVR + xr));				// load vrblk pointer (nmbas)
        //b ||mov|8,wa|19,*vrval||set name offset|24860
        wa= CFP_B*VRVAL;				// set name offset
        //b ||bze|13,trfnc(xr)|6,ktrx1||jump if print trace|24861
        if ( !( *((word *)(CFP_B*TRFNC + xr))) ) C_GOTO(ktrx1);				// jump if print trace
        //b ||jsr|6,trxeq|||else execute full trace|24862
        C_JSR(trxeq);				// else execute full trace
        //b ||brn|6,ktrx2|||and jump to exit|24863
         C_GOTO(ktrx2);				// and jump to exit
//      here for print trace
// ktrx1:
        //b |ktrx1|mov|11,-(xs)|7,xl||stack vrblk ptr for kwnam|24867
        } /* ktrex */
        

        void ktrx1() {
        C_PUSH(xl);				// stack vrblk ptr for kwnam
        //b ||mov|11,-(xs)|8,wa||stack offset for kwnam|24868
        C_PUSH(wa);				// stack offset for kwnam
        //b ||jsr|6,prtsn|||print statement number|24869
        C_JSR(prtsn);				// print statement number
        //b ||mov|8,wa|18,=ch_am||load ampersand|24870
        wa= CH_AM;				// load ampersand
        //b ||jsr|6,prtch|||print ampersand|24871
        C_JSR(prtch);				// print ampersand
        //b ||jsr|6,prtnm|||print keyword name|24872
        C_JSR(prtnm);				// print keyword name
        //b ||mov|7,xr|21,=tmbeb||point to blank-equal-blank|24873
        xr= (word)(&c.tmbeb);				// point to blank-equal-blank
        //b ||jsr|6,prtst|||print blank-equal-blank|24874
        C_JSR(prtst);				// print blank-equal-blank
        //b ||jsr|6,kwnam|||get keyword pseudo-variable name|24875
        extern void _l0674();
        C_JMS(kwnam,P_PRC_KWNAM,_l0674);
        } /* ktrx1 */
        

        void _l0674() {
        //b ||mov|3,dnamp|7,xr||reset ptr to delete kvblk|24876
        v.dnamp= xr;				// reset ptr to delete kvblk
        //b ||ppm||||failure is impossible|24878
        C_JSR_1(acess,(C_ERR(299)));				// failure is impossible
        //b ||jsr|6,prtvl|||print keyword value|24879
        C_JSR(prtvl);				// print keyword value
        //b ||jsr|6,prtnl|||terminate print line|24880
        C_JSR(prtnl);				// terminate print line
//      here to exit after completing trace
// ktrx2:
        //b |ktrx2|mov|7,xr|10,(xs)+||restore entry xr|24884
        C_GOTO(ktrx2);
        } /* _l0674 */
        

        void ktrx2() {
        xr= C_POP();				// restore entry xr
//      merge here to exit if no trace required
// ktrx3:
        //b |ktrx3|exi||||return to ktrex caller|24888
        C_GOTO(ktrx3);
        } /* ktrx2 */
        

        void ktrx3() {
        C_EXIT(0);				// return to ktrex caller
        //b ||ejc|||||24890
        
//      kwnam -- get pseudo-variable name for keyword
//      1(xs)                 name base for vrblk
//      0(xs)                 offset (should be *vrval)
//      jsr  kwnam            call to get pseudo-variable name
//      (xs)                  popped twice
//      (xl,wa)               resulting pseudo-variable name
//      (xr,wa,wb)            destroyed
// kwnam:
        //b |kwnam|prc|25,n|1,0||entry point|24901
        } /* ktrx3 */
        

        void kwnam() {
        //b ||ica|7,xs|||ignore name offset|24902
        xs += CFP_B;				// ignore name offset
        //b ||mov|7,xr|10,(xs)+||load name base|24903
        xr= C_POP();				// load name base
        //b ||bge|7,xr|3,state|6,kwnm1|jump if not natural variable name|24904
        if ((xr-v.state) >= 0) C_GOTO(kwnm1);				// jump if not natural variable name
        //b ||bnz|13,vrlen(xr)|6,kwnm1||error if not system variable|24905
        if (*((word *)(CFP_B*VRLEN + xr))) C_GOTO(kwnm1);				// error if not system variable
        //b ||mov|7,xr|13,vrsvp(xr)||else point to svblk|24906
        xr= *((word *)(CFP_B*VRSVP + xr));				// else point to svblk
        //b ||mov|8,wa|13,svbit(xr)||load bit mask|24907
        wa= *((word *)(CFP_B*SVBIT + xr));				// load bit mask
        //b ||anb|8,wa|4,btknm||and with keyword bit|24908
        wa &= c.btknm;				// and with keyword bit
        //b ||zrb|8,wa|6,kwnm1||error if no keyword association|24909
        if (!(wa)) C_GOTO(kwnm1);				// error if no keyword association
        //b ||mov|8,wa|13,svlen(xr)||else load name length in characters|24910
        wa= *((word *)(CFP_B*SVLEN + xr));				// else load name length in characters
        //b ||ctb|8,wa|2,svchs||compute offset to field we want|24911
        wa += (CFP_B-1)+CFP_B*SVCHS;				// compute offset to field we want
        wa &= 0xfffffffffffffff8;
        //b ||add|7,xr|8,wa||point to svknm field|24912
        xr += wa;				// point to svknm field
        //b ||mov|8,wb|9,(xr)||load svknm value|24913
        wb= *(xr_it.wp);				// load svknm value
        //b ||mov|8,wa|19,*kvsi_||set size of kvblk|24914
        wa= CFP_B*KVSI_;				// set size of kvblk
        //b ||jsr|6,alloc|||allocate kvblk|24915
        C_JSR(alloc);				// allocate kvblk
        //b ||mov|9,(xr)|22,=b_kvt||store type word|24916
        *(xr_it.wp)= (word)(b_kvt);				// store type word
        //b ||mov|13,kvnum(xr)|8,wb||store keyword number|24917
        *((word *)(CFP_B*KVNUM + xr))= wb;				// store keyword number
        //b ||mov|13,kvvar(xr)|21,=trbkv||set dummy trblk pointer|24918
        *((word *)(CFP_B*KVVAR + xr))= (word)(&c.trbkv);				// set dummy trblk pointer
        //b ||mov|7,xl|7,xr||copy kvblk pointer|24919
        xl= xr;				// copy kvblk pointer
        //b ||mov|8,wa|19,*kvvar||set proper offset|24920
        wa= CFP_B*KVVAR;				// set proper offset
        //b ||exi||||return to kvnam caller|24921
        C_NEXIT(P_PRC_KWNAM,0);				// return to kvnam caller
//      here if not keyword name
// kwnm1:
        //b |kwnm1|erb|1,251|26,keyword operand is not name of defined keyword|||24925
        } /* kwnam */
        

        void kwnm1() {
        C_ERB(251)
        //b ||ejc|||||24927
        
//      lcomp-- compare two strings lexically
//      1(xs)                 first argument
//      0(xs)                 second argument
//      jsr  lcomp            call to compare aruments
//      ppm  loc              transfer loc for arg1 not string
//      ppm  loc              transfer loc for arg2 not string
//      ppm  loc              transfer loc if arg1 llt arg2
//      ppm  loc              transfer loc if arg1 leq arg2
//      ppm  loc              transfer loc if arg1 lgt arg2
//      (the normal return is never taken)
//      (xs)                  popped twice
//      (xr,xl)               destroyed
//      (wa,wb,wc,ra)         destroyed
// lcomp:
        //b |lcomp|prc|25,n|1,5||entry point|24944
        } /* kwnm1 */
        

        void lcomp() {
        //b ||ppm|6,lcmp6|||jump if second arg not string|24950
        extern void _l0675();
        C_JMS(gtstg,P_PRC_GTSTG,_l0675);
        } /* lcomp */
        

        void _l0675() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(lcmp6));				// jump if second arg not string
        //b ||mov|7,xl|7,xr||else save pointer|24951
        xl= xr;				// else save pointer
        //b ||mov|8,wc|8,wa||and length|24952
        wc= wa;				// and length
        //b ||ppm|6,lcmp5|||jump if not string|24958
        extern void _l0676();
        C_JMS(gtstg,P_PRC_GTSTG,_l0676);
        } /* _l0675 */
        

        void _l0676() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(lcmp5));				// jump if not string
        //b ||mov|8,wb|8,wa||save arg 1 length|24959
        wb= wa;				// save arg 1 length
        //b ||plc|7,xr|||point to chars of arg 1|24960
        xr += CFP_F;				// point to chars of arg 1
        //b ||plc|7,xl|||point to chars of arg 2|24961
        xl += CFP_F;				// point to chars of arg 2
        //b ||blo|8,wa|8,wc|6,lcmp1|jump if arg 1 length is smaller|24973
        if ((wa-wc) < 0) C_GOTO(lcmp1);				// jump if arg 1 length is smaller
        //b ||mov|8,wa|8,wc||else set arg 2 length as smaller|24974
        wa= wc;				// else set arg 2 length as smaller
//      here with smaller length in (wa)
// lcmp1:
        //b |lcmp1|bze|8,wa|6,lcmp7||if null string, compare lengths|24978
        C_GOTO(lcmp1);
        } /* _l0676 */
        

        void lcmp1() {
        if ( !( wa) ) C_GOTO(lcmp7);				// if null string, compare lengths
        //b ||cmc|6,lcmp4|6,lcmp3||compare strings, jump if unequal|24979
        C_CMC(xl_it,xr_it,wa_it,lcmp4,lcmp3);				// compare strings, jump if unequal
// lcmp7:
        //b |lcmp7|bne|8,wb|8,wc|6,lcmp2|if equal, jump if lengths unequal|24980
        C_GOTO(lcmp7);
        } /* lcmp1 */
        

        void lcmp7() {
        if ((wb-wc) != 0) C_GOTO(lcmp2);				// if equal, jump if lengths unequal
        //b ||exi|1,4|||else identical strings, leq exit|24981
        C_NEXIT(P_PRC_LCOMP,4);				// else identical strings, leq exit
        //b ||ejc|||||24982
        
//      lcomp (continued)
//      here if initial strings identical, but lengths unequal
// lcmp2:
        //b |lcmp2|bhi|8,wb|8,wc|6,lcmp4|jump if arg 1 length gt arg 2 leng|24988
        } /* lcmp7 */
        

        void lcmp2() {
        if ((wb-wc) > 0) C_GOTO(lcmp4);				// jump if arg 1 length gt arg 2 leng
//      here if first arg llt second arg
// lcmp3:
        //b |lcmp3|exi|1,3|||take llt exit|24993
        C_GOTO(lcmp3);
        } /* lcmp2 */
        

        void lcmp3() {
        C_NEXIT(P_PRC_LCOMP,3);				// take llt exit
//      here if first arg lgt second arg
// lcmp4:
        //b |lcmp4|exi|1,5|||take lgt exit|24997
        } /* lcmp3 */
        

        void lcmp4() {
        C_NEXIT(P_PRC_LCOMP,5);				// take lgt exit
//      here if first arg is not a string
// lcmp5:
        //b |lcmp5|exi|1,1|||take bad first arg exit|25001
        } /* lcmp4 */
        

        void lcmp5() {
        C_NEXIT(P_PRC_LCOMP,1);				// take bad first arg exit
//      here for second arg not a string
// lcmp6:
        //b |lcmp6|exi|1,2|||take bad second arg error exit|25005
        } /* lcmp5 */
        

        void lcmp6() {
        C_NEXIT(P_PRC_LCOMP,2);				// take bad second arg error exit
        //b ||ejc|||||25007
        
//      listr -- list source line
//      listr is used to list a source line during the initial
//      compilation. it is called from scane and scanl.
//      jsr  listr            call to list line
//      (xr,xl,wa,wb,wc)      destroyed
//      global locations used by listr
//      cnttl                 flag for -title, -stitl
//      erlst                 if listing on account of an error
//      lstid                 include depth of current image
//      lstlc                 count lines on current page
//      lstnp                 max number of lines/page
//      lstpf                 set non-zero if the current source
//                            line has been listed, else zero.
//      lstpg                 compiler listing page number
//      lstsn                 set if stmnt num to be listed
//      r_cim                 pointer to current input line.
//      r_ttl                 title for source listing
//      r_stl                 ptr to sub-title string
//      entry point
// listr:
        //b |listr|prc|25,e|1,0||entry point|25046
        } /* lcmp6 */
        

        void listr() {
        //b ||bnz|3,cnttl|6,list5||jump if -title or -stitl|25047
        if (v.cnttl) C_GOTO(list5);				// jump if -title or -stitl
        //b ||bnz|3,lstpf|6,list4||immediate exit if already listed|25048
        if (v.lstpf) C_GOTO(list4);				// immediate exit if already listed
        //b ||bge|3,lstlc|3,lstnp|6,list6|jump if no room|25049
        if ((v.lstlc-v.lstnp) >= 0) C_GOTO(list6);				// jump if no room
//      here after printing title (if needed)
// list0:
        //b |list0|mov|7,xr|3,r_cim||load pointer to current image|25053
        C_GOTO(list0);
        } /* listr */
        

        void list0() {
        xr= v.r_cim;				// load pointer to current image
        //b ||bze|7,xr|6,list4||jump if no image to print|25054
        if ( !( xr) ) C_GOTO(list4);				// jump if no image to print
        //b ||plc|7,xr|||point to characters|25055
        xr += CFP_F;				// point to characters
        //b ||lch|8,wa|9,(xr)||load first character|25056
        wa = *(xr_it.chp);				// load first character
        //b ||mov|7,xr|3,lstsn||load statement number|25057
        xr= v.lstsn;				// load statement number
        //b ||bze|7,xr|6,list2||jump if no statement number|25058
        if ( !( xr) ) C_GOTO(list2);				// jump if no statement number
        //b ||mti|7,xr|||else get stmnt number as integer|25059
        ia = (word)(xr);				// else get stmnt number as integer
        //b ||bne|3,stage|18,=stgic|6,list1|skip if execute time|25060
        if ((v.stage-STGIC) != 0) C_GOTO(list1);				// skip if execute time
        //b ||beq|8,wa|18,=ch_as|6,list2|no stmnt number list if comment|25061
        if ((wa-CH_AS) == 0) C_GOTO(list2);				// no stmnt number list if comment
        //b ||beq|8,wa|18,=ch_mn|6,list2|no stmnt no. if control card|25062
        if ((wa-CH_MN) == 0) C_GOTO(list2);				// no stmnt no. if control card
//      print statement number
// list1:
        //b |list1|jsr|6,prtin|||else print statement number|25066
        C_GOTO(list1);
        } /* list0 */
        

        void list1() {
        C_JSR(prtin);				// else print statement number
        //b ||zer|3,lstsn|||and clear for next time in|25067
        v.lstsn=0;				// and clear for next time in
//      here to test for printing include depth
// list2:
        //b |list2|mov|7,xr|3,lstid||include depth of image|25072
        C_GOTO(list2);
        } /* list1 */
        

        void list2() {
        xr= v.lstid;				// include depth of image
        //b ||bze|7,xr|6,list8||if not from an include file|25073
        if ( !( xr) ) C_GOTO(list8);				// if not from an include file
        //b ||mov|8,wa|18,=stnpd||position for start of statement|25074
        wa= STNPD;				// position for start of statement
        //b ||sub|8,wa|18,=num03||position to place include depth|25075
        wa -= NUM03;				// position to place include depth
        //b ||mov|3,profs|8,wa||set as starting position|25076
        v.profs= wa;				// set as starting position
        //b ||mti|7,xr|||include depth as integer|25077
        ia = (word)(xr);				// include depth as integer
        //b ||jsr|6,prtin|||print include depth|25078
        C_JSR(prtin);				// print include depth
        //b ||ejc|||||25079
        
//      listr (continued)
//      here after printing statement number and include depth
// list8:
        //b |list8|mov|3,profs|18,=stnpd||point past statement number|25085
        C_GOTO(list8);
        } /* list2 */
        

        void list8() {
        v.profs= STNPD;				// point past statement number
        //b ||mov|7,xr|3,r_cim||load pointer to current image|25095
        xr= v.r_cim;				// load pointer to current image
        //b ||jsr|6,prtst|||print it|25096
        C_JSR(prtst);				// print it
        //b ||icv|3,lstlc|||bump line counter|25097
        (v.lstlc)++;				// bump line counter
        //b ||bnz|3,erlst|6,list3||jump if error copy to int.ch.|25098
        if (v.erlst) C_GOTO(list3);				// jump if error copy to int.ch.
        //b ||jsr|6,prtnl|||terminate line|25099
        C_JSR(prtnl);				// terminate line
        //b ||bze|3,cswdb|6,list3||jump if -single mode|25100
        if ( !( v.cswdb) ) C_GOTO(list3);				// jump if -single mode
        //b ||jsr|6,prtnl|||else add a blank line|25101
        C_JSR(prtnl);				// else add a blank line
        //b ||icv|3,lstlc|||and bump line counter|25102
        (v.lstlc)++;				// and bump line counter
//      here after printing source image
// list3:
        //b |list3|mnz|3,lstpf|||set flag for line printed|25106
        C_GOTO(list3);
        } /* list8 */
        

        void list3() {
        v.lstpf = 0xffffffffffffffff;				// set flag for line printed
//      merge here to exit
// list4:
        //b |list4|exi||||return to listr caller|25110
        C_GOTO(list4);
        } /* list3 */
        

        void list4() {
        C_EXIT(0);				// return to listr caller
//      print title after -title or -stitl card
// list5:
        //b |list5|zer|3,cnttl|||clear flag|25114
        } /* list4 */
        

        void list5() {
        v.cnttl=0;				// clear flag
//      eject to new page and list title
// list6:
        //b |list6|jsr|6,prtps|||eject|25118
        C_GOTO(list6);
        } /* list5 */
        

        void list6() {
        C_JSR(prtps);				// eject
        //b ||bze|3,prich|6,list7||skip if listing to regular printer|25119
        if ( !( v.prich) ) C_GOTO(list7);				// skip if listing to regular printer
        //b ||beq|3,r_ttl|21,=nulls|6,list0|terminal listing omits null title|25120
        if ((v.r_ttl-(word)(&c.nulls)) == 0) C_GOTO(list0);				// terminal listing omits null title
//      list title
// list7:
        //b |list7|jsr|6,listt|||list title|25124
        C_GOTO(list7);
        } /* list6 */
        

        void list7() {
        C_JSR(listt);				// list title
        //b ||brn|6,list0|||merge|25125
         C_GOTO(list0);				// merge
        //b ||ejc|||||25127
        
//      listt -- list title and subtitle
//      used during compilation to print page heading
//      jsr  listt            call to list title
//      (xr,wa)               destroyed
// listt:
        //b |listt|prc|25,e|1,0||entry point|25136
        } /* list7 */
        

        void listt() {
        //b ||mov|7,xr|3,r_ttl||point to source listing title|25137
        xr= v.r_ttl;				// point to source listing title
        //b ||jsr|6,prtst|||print title|25138
        C_JSR(prtst);				// print title
        //b ||mov|3,profs|3,lstpo||set offset|25139
        v.profs= v.lstpo;				// set offset
        //b ||mov|7,xr|21,=lstms||set page message|25140
        xr= (word)(&c.lstms);				// set page message
        //b ||jsr|6,prtst|||print page message|25141
        C_JSR(prtst);				// print page message
        //b ||icv|3,lstpg|||bump page number|25142
        (v.lstpg)++;				// bump page number
        //b ||mti|3,lstpg|||load page number as integer|25143
        ia = (word)(v.lstpg);				// load page number as integer
        //b ||jsr|6,prtin|||print page number|25144
        C_JSR(prtin);				// print page number
        //b ||jsr|6,prtnl|||terminate title line|25145
        C_JSR(prtnl);				// terminate title line
        //b ||add|3,lstlc|18,=num02||count title line and blank line|25146
        v.lstlc += NUM02;				// count title line and blank line
//      print sub-title (if any)
        //b ||mov|7,xr|3,r_stl||load pointer to sub-title|25150
        xr= v.r_stl;				// load pointer to sub-title
        //b ||bze|7,xr|6,lstt1||jump if no sub-title|25151
        if ( !( xr) ) C_GOTO(lstt1);				// jump if no sub-title
        //b ||jsr|6,prtst|||else print sub-title|25152
        C_JSR(prtst);				// else print sub-title
        //b ||jsr|6,prtnl|||terminate line|25153
        C_JSR(prtnl);				// terminate line
        //b ||icv|3,lstlc|||bump line count|25154
        (v.lstlc)++;				// bump line count
//      return point
// lstt1:
        //b |lstt1|jsr|6,prtnl|||print a blank line|25158
        C_GOTO(lstt1);
        } /* listt */
        

        void lstt1() {
        C_JSR(prtnl);				// print a blank line
        //b ||exi||||return to caller|25159
        C_EXIT(0);				// return to caller
        //b ||ejc|||||25161
        
//      newfn -- record new source file name
//      newfn is used after switching to a new include file, or
//      after a -line statement which contains a file name.
//      (xr)                  file name scblk
//      jsr  newfn
//      (wa,wb,wc,xl,xr,ra)   destroyed
//      on return, the table that maps statement numbers to file
//      names has been updated to include this new file name and
//      the current statement number.  the entry is made only if
//      the file name had changed from its previous value.
// newfn:
        //b |newfn|prc|25,e|1,0||entry point|25178
        } /* lstt1 */
        

        void newfn() {
        //b ||mov|11,-(xs)|7,xr||save new name|25179
        C_PUSH(xr);				// save new name
        //b ||mov|7,xl|3,r_sfc||load previous name|25180
        xl= v.r_sfc;				// load previous name
        //b ||ppm|6,nwfn1|||jump if identical|25182
        C_JSR_1(ident,C_GOTO(nwfn1));				// jump if identical
        //b ||mov|7,xr|10,(xs)+||different, restore name|25183
        xr= C_POP();				// different, restore name
        //b ||mov|3,r_sfc|7,xr||record current file name|25184
        v.r_sfc= xr;				// record current file name
        //b ||mov|8,wb|3,cmpsn||get current statement|25185
        wb= v.cmpsn;				// get current statement
        //b ||mti|8,wb|||convert to integer|25186
        ia = (word)(wb);				// convert to integer
        //b ||jsr|6,icbld|||build icblk for stmt number|25187
        C_JSR(icbld);				// build icblk for stmt number
        //b ||mov|7,xl|3,r_sfn||file name table|25188
        xl= v.r_sfn;				// file name table
        //b ||mnz|8,wb|||lookup statement number by name|25189
        wb = 0xffffffffffffffff;				// lookup statement number by name
        //b ||ppm||||always possible to allocate block|25191
        C_JSR_1(tfind,(C_ERR(299)));				// always possible to allocate block
        //b ||mov|13,teval(xl)|3,r_sfc||record file name as entry value|25192
        *((word *)(CFP_B*TEVAL + xl))= v.r_sfc;				// record file name as entry value
        //b ||exi|||||25193
        C_EXIT(0);
//     here if new name and old name identical
// nwfn1:
        //b |nwfn1|ica|7,xs|||pop stack|25197
        } /* newfn */
        

        void nwfn1() {
        xs += CFP_B;				// pop stack
        //b ||exi|||||25198
        C_EXIT(0);
        //b ||ejc|||||25199
        
//      nexts -- acquire next source image
//      nexts is used to acquire the next source image at compile
//      time. it assumes that a prior call to readr has input
//      a line image (see procedure readr). before the current
//      image is finally lost it may be listed here.
//      jsr  nexts            call to acquire next input line
//      (xr,xl,wa,wb,wc)      destroyed
//      global values affected
//      lstid                 include depth of next image
//      r_cni                 on input, next image. on
//                            exit reset to zero
//      r_cim                 on exit, set to point to image
//      rdcln                 current ln set from next line num
//      scnil                 input image length on exit
//      scnse                 reset to zero on exit
//      lstpf                 set on exit if line is listed
// nexts:
        //b |nexts|prc|25,e|1,0||entry point|25231
        } /* nwfn1 */
        

        void nexts() {
        //b ||bze|3,cswls|6,nxts2||jump if -nolist|25232
        if ( !( v.cswls) ) C_GOTO(nxts2);				// jump if -nolist
        //b ||mov|7,xr|3,r_cim||point to image|25233
        xr= v.r_cim;				// point to image
        //b ||bze|7,xr|6,nxts2||jump if no image|25234
        if ( !( xr) ) C_GOTO(nxts2);				// jump if no image
        //b ||plc|7,xr|||get char ptr|25235
        xr += CFP_F;				// get char ptr
        //b ||lch|8,wa|9,(xr)||get first char|25236
        wa = *(xr_it.chp);				// get first char
        //b ||bne|8,wa|18,=ch_mn|6,nxts1|jump if not ctrl card|25237
        if ((wa-CH_MN) != 0) C_GOTO(nxts1);				// jump if not ctrl card
        //b ||bze|3,cswpr|6,nxts2||jump if -noprint|25238
        if ( !( v.cswpr) ) C_GOTO(nxts2);				// jump if -noprint
//      here to call lister
// nxts1:
        //b |nxts1|jsr|6,listr|||list line|25242
        C_GOTO(nxts1);
        } /* nexts */
        

        void nxts1() {
        C_JSR(listr);				// list line
//      here after possible listing
// nxts2:
        //b |nxts2|mov|7,xr|3,r_cni||point to next image|25246
        C_GOTO(nxts2);
        } /* nxts1 */
        

        void nxts2() {
        xr= v.r_cni;				// point to next image
        //b ||mov|3,r_cim|7,xr||set as next image|25247
        v.r_cim= xr;				// set as next image
        //b ||mov|3,rdcln|3,rdnln||set as current line number|25248
        v.rdcln= v.rdnln;				// set as current line number
        //b ||mov|3,lstid|3,cnind||set as current include depth|25250
        v.lstid= v.cnind;				// set as current include depth
        //b ||zer|3,r_cni|||clear next image pointer|25252
        v.r_cni=0;				// clear next image pointer
        //b ||mov|8,wa|13,sclen(xr)||get input image length|25253
        wa= *((word *)(CFP_B*SCLEN + xr));				// get input image length
        //b ||mov|8,wb|3,cswin||get max allowable length|25254
        wb= v.cswin;				// get max allowable length
        //b ||blo|8,wa|8,wb|6,nxts3|skip if not too long|25255
        if ((wa-wb) < 0) C_GOTO(nxts3);				// skip if not too long
        //b ||mov|8,wa|8,wb||else truncate|25256
        wa= wb;				// else truncate
//      here with length in (wa)
// nxts3:
        //b |nxts3|mov|3,scnil|8,wa||use as record length|25260
        C_GOTO(nxts3);
        } /* nxts2 */
        

        void nxts3() {
        v.scnil= wa;				// use as record length
        //b ||zer|3,scnse|||reset scnse|25261
        v.scnse=0;				// reset scnse
        //b ||zer|3,lstpf|||set line not listed yet|25262
        v.lstpf=0;				// set line not listed yet
        //b ||exi||||return to nexts caller|25263
        C_EXIT(0);				// return to nexts caller
        //b ||ejc|||||25265
        
//      patin -- pattern construction for len,pos,rpos,tab,rtab
//      these pattern types all generate a similar node type. so
//      the construction code is shared. see functions section
//      for actual entry points for these five functions.
//      (wa)                  pcode for expression arg case
//      (wb)                  pcode for integer arg case
//      jsr  patin            call to build pattern node
//      ppm  loc              transfer loc for not integer or exp
//      ppm  loc              transfer loc for int out of range
//      (xr)                  pointer to constructed node
//      (xl,wa,wb,wc,ia)      destroyed
// patin:
        //b |patin|prc|25,n|1,2||entry point|25281
        } /* nxts3 */
        

        void patin() {
        //b ||mov|7,xl|8,wa||preserve expression arg pcode|25282
        xl= wa;				// preserve expression arg pcode
        //b ||ppm|6,ptin3|||jump if out of range|25285
        extern void _l0677();
        C_JMS(gtsmi,P_PRC_GTSMI,_l0677);
        } /* patin */
        

        void _l0677() {
        C_JMS_HANDLE_2(gtsmi,C_GOTO(ptin2),C_GOTO(ptin3));				// jump if out of range
//      common successful exit point
// ptin1:
        //b |ptin1|jsr|6,pbild|||build pattern node|25289
        C_GOTO(ptin1);
        } /* _l0677 */
        

        void ptin1() {
        C_JSR(pbild);				// build pattern node
        //b ||exi||||return to caller|25290
        C_NEXIT(P_PRC_PATIN,0);				// return to caller
//      here if argument is not an integer
// ptin2:
        //b |ptin2|mov|8,wb|7,xl||copy expr arg case pcode|25294
        } /* ptin1 */
        

        void ptin2() {
        wb= xl;				// copy expr arg case pcode
        //b ||blo|9,(xr)|22,=b_e__|6,ptin1|all ok if expression arg|25295
        if ((*(xr_it.wp)-(word)(b_e__)) < 0) C_GOTO(ptin1);				// all ok if expression arg
        //b ||exi|1,1|||else take error exit for wrong type|25296
        C_NEXIT(P_PRC_PATIN,1);				// else take error exit for wrong type
//      here for error of out of range integer argument
// ptin3:
        //b |ptin3|exi|1,2|||take out-of-range error exit|25300
        } /* ptin2 */
        

        void ptin3() {
        C_NEXIT(P_PRC_PATIN,2);				// take out-of-range error exit
        //b ||ejc|||||25302
        
//      patst -- pattern construction for any,notany,
//               break,span and breakx pattern functions.
//      these pattern functions build similar types of nodes and
//      the construction code is shared. see functions section
//      for actual entry points for these five pattern functions.
//      0(xs)                 string argument
//      (wb)                  pcode for one char argument
//      (xl)                  pcode for multi-char argument
//      (wc)                  pcode for expression argument
//      jsr  patst            call to build node
//      ppm  loc              if not string or expr (or null)
//      (xs)                  popped past string argument
//      (xr)                  pointer to constructed node
//      (xl)                  destroyed
//      (wa,wb,wc,ra)         destroyed
//      note that there is a special call to patst in the evals
//      procedure with a slightly different form. see evals
//      for details of the form of this call.
// patst:
        //b |patst|prc|25,n|1,1||entry point|25326
        } /* ptin3 */
        

        void patst() {
        //b ||ppm|6,pats7|||jump if not string|25328
        extern void _l0678();
        C_JMS(gtstg,P_PRC_GTSTG,_l0678);
        } /* patst */
        

        void _l0678() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(pats7));				// jump if not string
        //b ||bze|8,wa|6,pats7||jump if null string (catspaw)|25329
        if ( !( wa) ) C_GOTO(pats7);				// jump if null string (catspaw)
        //b ||bne|8,wa|18,=num01|6,pats2|jump if not one char string|25330
        if ((wa-NUM01) != 0) C_GOTO(pats2);				// jump if not one char string
//      here for one char string case
        //b ||bze|8,wb|6,pats2||treat as multi-char if evals call|25334
        if ( !( wb) ) C_GOTO(pats2);				// treat as multi-char if evals call
        //b ||plc|7,xr|||point to character|25335
        xr += CFP_F;				// point to character
        //b ||lch|7,xr|9,(xr)||load character|25336
        xr = *(xr_it.chp);				// load character
//      common exit point after successful construction
// pats1:
        //b |pats1|jsr|6,pbild|||call routine to build node|25340
        C_GOTO(pats1);
        } /* _l0678 */
        

        void pats1() {
        C_JSR(pbild);				// call routine to build node
        //b ||exi||||return to patst caller|25341
        C_NEXIT(P_PRC_PATST,0);				// return to patst caller
        //b ||ejc|||||25342
        
//      patst (continued)
//      here for multi-character string case
// pats2:
        //b |pats2|mov|11,-(xs)|7,xl||save multi-char pcode|25348
        } /* pats1 */
        

        void pats2() {
        C_PUSH(xl);				// save multi-char pcode
        //b ||mov|8,wc|3,ctmsk||load current mask bit|25349
        wc= v.ctmsk;				// load current mask bit
        //b ||beq|7,xr|3,r_cts|6,pats6|jump if same as last string c3.738|25350
        if ((xr-v.r_cts) == 0) C_GOTO(pats6);				// jump if same as last string c3.738
        //b ||mov|11,-(xs)|7,xr||save string pointer|25351
        C_PUSH(xr);				// save string pointer
        //b ||lsh|8,wc|1,1||shift to next position|25352
        wc <<= 1;				// shift to next position
        //b ||nzb|8,wc|6,pats4||skip if position left in this tbl|25353
        if (wc) C_GOTO(pats4);				// skip if position left in this tbl
//      here we must allocate a new character table
        //b ||mov|8,wa|19,*ctsi_||set size of ctblk|25357
        wa= CFP_B*CTSI_;				// set size of ctblk
        //b ||jsr|6,alloc|||allocate ctblk|25358
        C_JSR(alloc);				// allocate ctblk
        //b ||mov|3,r_ctp|7,xr||store ptr to new ctblk|25359
        v.r_ctp= xr;				// store ptr to new ctblk
        //b ||mov|10,(xr)+|22,=b_ctt||store type code, bump ptr|25360
        *(xr_it.wp++)= (word)(b_ctt);				// store type code, bump ptr
        //b ||lct|8,wb|18,=cfp_a||set number of words to clear|25361
        wb= CFP_A;				// set number of words to clear
        //b ||mov|8,wc|4,bits0||load all zero bits|25362
        wc= c.bits0;				// load all zero bits
//      loop to clear all bits in table to zeros
// pats3:
        //b |pats3|mov|10,(xr)+|8,wc||move word of zero bits|25366
        C_GOTO(pats3);
        } /* pats2 */
        

        void pats3() {
        *(xr_it.wp++)= wc;				// move word of zero bits
        //b ||bct|8,wb|6,pats3||loop till all cleared|25367
        if ((--wb))  C_GOTO(pats3);				// loop till all cleared
        //b ||mov|8,wc|4,bits1||set initial bit position|25368
        wc= c.bits1;				// set initial bit position
//      merge here with bit position available
// pats4:
        //b |pats4|mov|3,ctmsk|8,wc||save parm2 (new bit position)|25372
        C_GOTO(pats4);
        } /* pats3 */
        

        void pats4() {
        v.ctmsk= wc;				// save parm2 (new bit position)
        //b ||mov|7,xl|10,(xs)+||restore pointer to argument string|25373
        xl= C_POP();				// restore pointer to argument string
        //b ||mov|3,r_cts|7,xl||save for next time   c3.738|25374
        v.r_cts= xl;				// save for next time   c3.738
        //b ||mov|8,wb|13,sclen(xl)||load string length|25375
        wb= *((word *)(CFP_B*SCLEN + xl));				// load string length
        //b ||bze|8,wb|6,pats6||jump if null string case|25376
        if ( !( wb) ) C_GOTO(pats6);				// jump if null string case
        //b ||lct|8,wb|8,wb||else set loop counter|25377
        wb= wb;				// else set loop counter
        //b ||plc|7,xl|||point to characters in argument|25378
        xl += CFP_F;				// point to characters in argument
        //b ||ejc|||||25379
        
//      patst (continued)
//      loop to set bits in column of table
// pats5:
        //b |pats5|lch|8,wa|10,(xl)+||load next character|25385
        C_GOTO(pats5);
        } /* pats4 */
        

        void pats5() {
        wa = *(xl_it.chp++);				// load next character
        //b ||wtb|8,wa|||convert to byte offset|25386
        wa <<= LOG_CFP_B;				// convert to byte offset
        //b ||mov|7,xr|3,r_ctp||point to ctblk|25387
        xr= v.r_ctp;				// point to ctblk
        //b ||add|7,xr|8,wa||point to ctblk entry|25388
        xr += wa;				// point to ctblk entry
        //b ||mov|8,wa|8,wc||copy bit mask|25389
        wa= wc;				// copy bit mask
        //b ||orb|8,wa|13,ctchs(xr)||or in bits already set|25390
        wa |= *((word *)(CFP_B*CTCHS + xr));				// or in bits already set
        //b ||mov|13,ctchs(xr)|8,wa||store resulting bit string|25391
        *((word *)(CFP_B*CTCHS + xr))= wa;				// store resulting bit string
        //b ||bct|8,wb|6,pats5||loop till all bits set|25392
        if ((--wb))  C_GOTO(pats5);				// loop till all bits set
//      complete processing for multi-char string case
// pats6:
        //b |pats6|mov|7,xr|3,r_ctp||load ctblk ptr as parm1 for pbild|25396
        C_GOTO(pats6);
        } /* pats5 */
        

        void pats6() {
        xr= v.r_ctp;				// load ctblk ptr as parm1 for pbild
        //b ||zer|7,xl|||clear garbage ptr in xl|25397
        xl=0;				// clear garbage ptr in xl
        //b ||mov|8,wb|10,(xs)+||load pcode for multi-char str case|25398
        wb= C_POP();				// load pcode for multi-char str case
        //b ||brn|6,pats1|||back to exit (wc=bitstring=parm2)|25399
         C_GOTO(pats1);				// back to exit (wc=bitstring=parm2)
//      here if argument is not a string
//      note that the call from evals cannot pass an expression
//      since evalp always reevaluates expressions.
// pats7:
        //b |pats7|mov|8,wb|8,wc||set pcode for expression argument|25406
        } /* pats6 */
        

        void pats7() {
        wb= wc;				// set pcode for expression argument
        //b ||blo|9,(xr)|22,=b_e__|6,pats1|jump to exit if expression arg|25407
        if ((*(xr_it.wp)-(word)(b_e__)) < 0) C_GOTO(pats1);				// jump to exit if expression arg
        //b ||exi|1,1|||else take wrong type error exit|25408
        C_NEXIT(P_PRC_PATST,1);				// else take wrong type error exit
        //b ||ejc|||||25410
        
//      pbild -- build pattern node
//      (xr)                  parm1 (only if required)
//      (wb)                  pcode for node
//      (wc)                  parm2 (only if required)
//      jsr  pbild            call to build node
//      (xr)                  pointer to constructed node
//      (wa)                  destroyed
// pbild:
        //b |pbild|prc|25,e|1,0||entry point|25421
        } /* pats7 */
        

        void pbild() {
        //b ||mov|11,-(xs)|7,xr||stack possible parm1|25422
        C_PUSH(xr);				// stack possible parm1
        //b ||mov|7,xr|8,wb||copy pcode|25423
        xr= wb;				// copy pcode
        //b ||lei|7,xr|||load entry point id (bl_px)|25424
        xr = find_elab(xr);    /* get entry code */				// load entry point id (bl_px)
        //b ||beq|7,xr|18,=bl_p1|6,pbld1|jump if one parameter|25425
        if ((xr-BL_P1) == 0) C_GOTO(pbld1);				// jump if one parameter
        //b ||beq|7,xr|18,=bl_p0|6,pbld3|jump if no parameters|25426
        if ((xr-BL_P0) == 0) C_GOTO(pbld3);				// jump if no parameters
//      here for two parameter case
        //b ||mov|8,wa|19,*pcsi_||set size of p2blk|25430
        wa= CFP_B*PCSI_;				// set size of p2blk
        //b ||jsr|6,alloc|||allocate block|25431
        C_JSR(alloc);				// allocate block
        //b ||mov|13,parm2(xr)|8,wc||store second parameter|25432
        *((word *)(CFP_B*PARM2 + xr))= wc;				// store second parameter
        //b ||brn|6,pbld2|||merge with one parm case|25433
         C_GOTO(pbld2);				// merge with one parm case
//      here for one parameter case
// pbld1:
        //b |pbld1|mov|8,wa|19,*pbsi_||set size of p1blk|25437
        } /* pbild */
        

        void pbld1() {
        wa= CFP_B*PBSI_;				// set size of p1blk
        //b ||jsr|6,alloc|||allocate node|25438
        C_JSR(alloc);				// allocate node
//      merge here from two parm case
// pbld2:
        //b |pbld2|mov|13,parm1(xr)|9,(xs)||store first parameter|25442
        C_GOTO(pbld2);
        } /* pbld1 */
        

        void pbld2() {
        *((word *)(CFP_B*PARM1 + xr))= *(xs_it.wp);				// store first parameter
        //b ||brn|6,pbld4|||merge with no parameter case|25443
         C_GOTO(pbld4);				// merge with no parameter case
//      here for case of no parameters
// pbld3:
        //b |pbld3|mov|8,wa|19,*pasi_||set size of p0blk|25447
        } /* pbld2 */
        

        void pbld3() {
        wa= CFP_B*PASI_;				// set size of p0blk
        //b ||jsr|6,alloc|||allocate node|25448
        C_JSR(alloc);				// allocate node
//      merge here from other cases
// pbld4:
        //b |pbld4|mov|9,(xr)|8,wb||store pcode|25452
        C_GOTO(pbld4);
        } /* pbld3 */
        

        void pbld4() {
        *(xr_it.wp)= wb;				// store pcode
        //b ||ica|7,xs|||pop first parameter|25453
        xs += CFP_B;				// pop first parameter
        //b ||mov|13,pthen(xr)|21,=ndnth||set nothen successor pointer|25454
        *((word *)(CFP_B*PTHEN + xr))= (word)(&c.ndnth);				// set nothen successor pointer
        //b ||exi||||return to pbild caller|25455
        C_EXIT(0);				// return to pbild caller
        //b ||ejc|||||25457
        
//      pconc -- concatenate two patterns
//      (xl)                  ptr to right pattern
//      (xr)                  ptr to left pattern
//      jsr  pconc            call to concatenate patterns
//      (xr)                  ptr to concatenated pattern
//      (xl,wa,wb,wc)         destroyed
//      to concatenate two patterns, all successors in the left
//      pattern which point to the nothen node must be changed to
//      point to the right pattern. however, this modification
//      must be performed on a copy of the left argument rather
//      than the left argument itself, since the left argument
//      may be pointed to by some other variable value.
//      accordingly, it is necessary to copy the left argument.
//      this is not a trivial process since we must avoid copying
//      nodes more than once and the pattern is a graph structure
//      the following algorithm is employed.
//      the stack is used to store a list of nodes which
//      have already been copied. the format of the entries on
//      this list consists of a two word block. the first word
//      is the old address and the second word is the address
//      of the copy. this list is searched by the pcopy
//      routine to avoid making duplicate copies. a trick is
//      used to accomplish the concatenation at the same time.
//      a special entry is made to start with on the stack. this
//      entry records that the nothen node has been copied
//      already and the address of its copy is the right pattern.
//      this automatically performs the correct replacements.
// pconc:
        //b |pconc|prc|25,e|1,0||entry point|25492
        } /* pbld4 */
        

        void pconc() {
        //b ||zer|11,-(xs)|||make room for one entry at bottom|25493
        *(--xs_it.wp)=0;				// make room for one entry at bottom
        //b ||mov|8,wc|7,xs||store pointer to start of list|25494
        wc= xs;				// store pointer to start of list
        //b ||mov|11,-(xs)|21,=ndnth||stack nothen node as old node|25495
        C_PUSH((word)(&c.ndnth));				// stack nothen node as old node
        //b ||mov|11,-(xs)|7,xl||store right arg as copy of nothen|25496
        C_PUSH(xl);				// store right arg as copy of nothen
        //b ||mov|7,xt|7,xs||initialize pointer to stack entries|25497
        xt= xs;				// initialize pointer to stack entries
        //b ||jsr|6,pcopy|||copy first node of left arg|25498
        extern void _l0683();
        C_JMS(pcopy,P_PRC_PCOPY,_l0683);
        } /* pconc */
        

        void _l0683() {
        //b ||mov|13,num02(xt)|8,wa||store as result under list|25499
        *((word *)(CFP_B*NUM02 + xt))= wa;				// store as result under list
        //b ||ejc|||||25500
        
//      pconc (continued)
//      the following loop scans entries in the list and makes
//      sure that their successors have been copied.
// pcnc1:
        //b |pcnc1|beq|7,xt|7,xs|6,pcnc2|jump if all entries processed|25507
        C_GOTO(pcnc1);
        } /* _l0683 */
        

        void pcnc1() {
        if ((xt-xs) == 0) C_GOTO(pcnc2);				// jump if all entries processed
        //b ||mov|7,xr|11,-(xt)||else load next old address|25508
        xr= *(--xt_it.wp);				// else load next old address
        //b ||mov|7,xr|13,pthen(xr)||load pointer to successor|25509
        xr= *((word *)(CFP_B*PTHEN + xr));				// load pointer to successor
        //b ||jsr|6,pcopy|||copy successor node|25510
        extern void _l0686();
        C_JMS(pcopy,P_PRC_PCOPY,_l0686);
        } /* pcnc1 */
        

        void _l0686() {
        //b ||mov|7,xr|11,-(xt)||load pointer to new node (copy)|25511
        xr= *(--xt_it.wp);				// load pointer to new node (copy)
        //b ||mov|13,pthen(xr)|8,wa||store ptr to new successor|25512
        *((word *)(CFP_B*PTHEN + xr))= wa;				// store ptr to new successor
//      now check for special case of alternation node where
//      parm1 points to a node and must be copied like pthen.
        //b ||bne|9,(xr)|22,=p_alt|6,pcnc1|loop back if not|25517
        if ((*(xr_it.wp)-(word)(p_alt)) != 0) C_GOTO(pcnc1);				// loop back if not
        //b ||mov|7,xr|13,parm1(xr)||else load pointer to alternative|25518
        xr= *((word *)(CFP_B*PARM1 + xr));				// else load pointer to alternative
        //b ||jsr|6,pcopy|||copy it|25519
        extern void _l0689();
        C_JMS(pcopy,P_PRC_PCOPY,_l0689);
        } /* _l0686 */
        

        void _l0689() {
        //b ||mov|7,xr|9,(xt)||restore ptr to new node|25520
        xr= *(xt_it.wp);				// restore ptr to new node
        //b ||mov|13,parm1(xr)|8,wa||store ptr to copied alternative|25521
        *((word *)(CFP_B*PARM1 + xr))= wa;				// store ptr to copied alternative
        //b ||brn|6,pcnc1|||loop back for next entry|25522
         C_GOTO(pcnc1);				// loop back for next entry
//      here at end of copy process
// pcnc2:
        //b |pcnc2|mov|7,xs|8,wc||restore stack pointer|25526
        } /* _l0689 */
        

        void pcnc2() {
        xs= wc;				// restore stack pointer
        //b ||mov|7,xr|10,(xs)+||load pointer to copy|25527
        xr= C_POP();				// load pointer to copy
        //b ||exi||||return to pconc caller|25528
        C_EXIT(0);				// return to pconc caller
        //b ||ejc|||||25530
        
//      pcopy -- copy a pattern node
//      pcopy is called from the pconc procedure to copy a single
//      pattern node. the copy is only carried out if the node
//      has not been copied already.
//      (xr)                  pointer to node to be copied
//      (xt)                  ptr to current loc in copy list
//      (wc)                  pointer to list of copied nodes
//      jsr  pcopy            call to copy a node
//      (wa)                  pointer to copy
//      (wb,xr)               destroyed
// pcopy:
        //b |pcopy|prc|25,n|1,0||entry point|25545
        } /* pcnc2 */
        

        void pcopy() {
        //b ||mov|8,wb|7,xt||save xt|25546
        wb= xt;				// save xt
        //b ||mov|7,xt|8,wc||point to start of list|25547
        xt= wc;				// point to start of list
//      loop to search list of nodes copied already
// pcop1:
        //b |pcop1|dca|7,xt|||point to next entry on list|25551
        C_GOTO(pcop1);
        } /* pcopy */
        

        void pcop1() {
        xt -= CFP_B;				// point to next entry on list
        //b ||beq|7,xr|9,(xt)|6,pcop2|jump if match|25552
        if ((xr-*(xt_it.wp)) == 0) C_GOTO(pcop2);				// jump if match
        //b ||dca|7,xt|||else skip over copied address|25553
        xt -= CFP_B;				// else skip over copied address
        //b ||bne|7,xt|7,xs|6,pcop1|loop back if more to test|25554
        if ((xt-xs) != 0) C_GOTO(pcop1);				// loop back if more to test
//      here if not in list, perform copy
        //b ||mov|8,wa|9,(xr)||load first word of block|25558
        wa= *(xr_it.wp);				// load first word of block
        //b ||jsr|6,blkln|||get length of block|25559
        C_JSR(blkln);				// get length of block
        //b ||mov|7,xl|7,xr||save pointer to old node|25560
        xl= xr;				// save pointer to old node
        //b ||jsr|6,alloc|||allocate space for copy|25561
        C_JSR(alloc);				// allocate space for copy
        //b ||mov|11,-(xs)|7,xl||store old address on list|25562
        C_PUSH(xl);				// store old address on list
        //b ||mov|11,-(xs)|7,xr||store new address on list|25563
        C_PUSH(xr);				// store new address on list
        //b ||chk||||check for stack overflow|25564
        if(xs<v.lowspmin) { C_GOTO(sec06); } /* stack overflow check */				// check for stack overflow
        //b ||mvw||||move words from old block to copy|25565
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// move words from old block to copy
        //b ||mov|8,wa|9,(xs)||load pointer to copy|25566
        wa= *(xs_it.wp);				// load pointer to copy
        //b ||brn|6,pcop3|||jump to exit|25567
         C_GOTO(pcop3);				// jump to exit
//      here if we find entry in list
// pcop2:
        //b |pcop2|mov|8,wa|11,-(xt)||load address of copy from list|25571
        } /* pcop1 */
        

        void pcop2() {
        wa= *(--xt_it.wp);				// load address of copy from list
//      common exit point
// pcop3:
        //b |pcop3|mov|7,xt|8,wb||restore xt|25575
        C_GOTO(pcop3);
        } /* pcop2 */
        

        void pcop3() {
        xt= wb;				// restore xt
        //b ||exi||||return to pcopy caller|25576
        C_NEXIT(P_PRC_PCOPY,0);				// return to pcopy caller
        //b ||ejc|||||25578
        
//      prflr -- print profile
//      prflr is called to print the contents of the profile
//      table in a fairly readable tabular format.
//      jsr  prflr            call to print profile
//      (wa,ia)               destroyed
// prflr:
        //b |prflr|prc|25,e|1,0|||25589
        } /* pcop3 */
        

        void prflr() {
        //b ||bze|3,pfdmp|6,prfl4||no printing if no profiling done|25590
        if ( !( v.pfdmp) ) C_GOTO(prfl4);				// no printing if no profiling done
        //b ||mov|11,-(xs)|7,xr||preserve entry xr|25591
        C_PUSH(xr);				// preserve entry xr
        //b ||mov|3,pfsvw|8,wb||and also wb|25592
        v.pfsvw= wb;				// and also wb
        //b ||jsr|6,prtpg|||eject|25593
        C_JSR(prtpg);				// eject
        //b ||mov|7,xr|21,=pfms1||load msg /program profile/|25594
        xr= (word)(&c.pfms1);				// load msg /program profile/
        //b ||jsr|6,prtst|||and print it|25595
        C_JSR(prtst);				// and print it
        //b ||jsr|6,prtnl|||followed by newline|25596
        C_JSR(prtnl);				// followed by newline
        //b ||jsr|6,prtnl|||and another|25597
        C_JSR(prtnl);				// and another
        //b ||mov|7,xr|21,=pfms2||point to first hdr|25598
        xr= (word)(&c.pfms2);				// point to first hdr
        //b ||jsr|6,prtst|||print it|25599
        C_JSR(prtst);				// print it
        //b ||jsr|6,prtnl|||new line|25600
        C_JSR(prtnl);				// new line
        //b ||mov|7,xr|21,=pfms3||second hdr|25601
        xr= (word)(&c.pfms3);				// second hdr
        //b ||jsr|6,prtst|||print it|25602
        C_JSR(prtst);				// print it
        //b ||jsr|6,prtnl|||new line|25603
        C_JSR(prtnl);				// new line
        //b ||jsr|6,prtnl|||and another blank line|25604
        C_JSR(prtnl);				// and another blank line
        //b ||zer|8,wb|||initial stmt count|25605
        wb=0;				// initial stmt count
        //b ||mov|7,xr|3,pftbl||point to table origin|25606
        xr= v.pftbl;				// point to table origin
        //b ||add|7,xr|19,*xndta||bias past xnblk header (sgd07)|25607
        xr += CFP_B*XNDTA;				// bias past xnblk header (sgd07)
//      loop here to print successive entries
// prfl1:
        //b |prfl1|icv|8,wb|||bump stmt nr|25611
        C_GOTO(prfl1);
        } /* prflr */
        

        void prfl1() {
        (wb)++;				// bump stmt nr
        //b ||ldi|9,(xr)|||load nr of executions|25612
        ia = *(xr_it.wp);				// load nr of executions
        //b ||ieq|6,prfl3|||no printing if zero|25613
        if (ia == 0)  C_GOTO(prfl3);				// no printing if zero
        //b ||mov|3,profs|18,=pfpd1||point where to print|25614
        v.profs= PFPD1;				// point where to print
        //b ||jsr|6,prtin|||and print it|25615
        C_JSR(prtin);				// and print it
        //b ||zer|3,profs|||back to start of line|25616
        v.profs=0;				// back to start of line
        //b ||mti|8,wb|||load stmt nr|25617
        ia = (word)(wb);				// load stmt nr
        //b ||jsr|6,prtin|||print it there|25618
        C_JSR(prtin);				// print it there
        //b ||mov|3,profs|18,=pfpd2||and pad past count|25619
        v.profs= PFPD2;				// and pad past count
        //b ||ldi|13,cfp_i(xr)|||load total exec time|25620
        ia = *((word *)(CFP_B*CFP_I + xr));				// load total exec time
        //b ||jsr|6,prtin|||print that too|25621
        C_JSR(prtin);				// print that too
        //b ||ldi|13,cfp_i(xr)|||reload time|25622
        ia = *((word *)(CFP_B*CFP_I + xr));				// reload time
        //b ||mli|4,intth|||convert to microsec|25623
        ia*=c.intth;				// convert to microsec
        //b ||iov|6,prfl2|||omit next bit if overflow|25624
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// omit next bit if overflow
        //b ||dvi|9,(xr)|||divide by executions|25625
        ia=ia / *(xr_it.wp);				// divide by executions
        //b ||mov|3,profs|18,=pfpd3||pad last print|25626
        v.profs= PFPD3;				// pad last print
        //b ||jsr|6,prtin|||and print mcsec/execn|25627
        C_JSR(prtin);				// and print mcsec/execn
//      merge after printing time
// prfl2:
        //b |prfl2|jsr|6,prtnl|||thats another line|25631
        C_GOTO(prfl2);
        } /* prfl1 */
        

        void prfl2() {
        C_JSR(prtnl);				// thats another line
//      here to go to next entry
// prfl3:
        //b |prfl3|add|7,xr|19,*pf_i2||bump index ptr (sgd07)|25635
        C_GOTO(prfl3);
        } /* prfl2 */
        

        void prfl3() {
        xr += CFP_B*PF_I2;				// bump index ptr (sgd07)
        //b ||blt|8,wb|3,pfnte|6,prfl1|loop if more stmts|25636
        if ((wb-v.pfnte) < 0) C_GOTO(prfl1);				// loop if more stmts
        //b ||mov|7,xr|10,(xs)+||restore callers xr|25637
        xr= C_POP();				// restore callers xr
        //b ||mov|8,wb|3,pfsvw||and wb too|25638
        wb= v.pfsvw;				// and wb too
//      here to exit
// prfl4:
        //b |prfl4|exi||||return|25642
        C_GOTO(prfl4);
        } /* prfl3 */
        

        void prfl4() {
        C_EXIT(0);				// return
        //b ||ejc|||||25644
        
//      prflu -- update an entry in the profile table
//      on entry, kvstn contains nr of stmt to profile
//      jsr  prflu            call to update entry
//      (ia)                  destroyed
// prflu:
        //b |prflu|prc|25,e|1,0|||25653
        } /* prfl4 */
        

        void prflu() {
        //b ||bnz|3,pffnc|6,pflu4||skip if just entered function|25654
        if (v.pffnc) C_GOTO(pflu4);				// skip if just entered function
        //b ||mov|11,-(xs)|7,xr||preserve entry xr|25655
        C_PUSH(xr);				// preserve entry xr
        //b ||mov|3,pfsvw|8,wa||save wa (sgd07)|25656
        v.pfsvw= wa;				// save wa (sgd07)
        //b ||bnz|3,pftbl|6,pflu2||branch if table allocated|25657
        if (v.pftbl) C_GOTO(pflu2);				// branch if table allocated
//      here if space for profile table not yet allocated.
//      calculate size needed, allocate a static xnblk, and
//      initialize it all to zero.
//      the time taken for this will be attributed to the current
//      statement (assignment to keywd profile), but since the
//      timing for this statement is up the pole anyway, this
//      doesnt really matter...
        //b ||sub|3,pfnte|18,=num01||adjust for extra count (sgd07)|25667
        v.pfnte -= NUM01;				// adjust for extra count (sgd07)
        //b ||mti|4,pfi2a|||convrt entry size to int|25668
        ia = (word)(c.pfi2a);				// convrt entry size to int
        //b ||sti|3,pfste|||and store safely for later|25669
        v.pfste= ia;				// and store safely for later
        //b ||mti|3,pfnte|||load table length as integer|25670
        ia = (word)(v.pfnte);				// load table length as integer
        //b ||mli|3,pfste|||multiply by entry size|25671
        ia*=v.pfste;				// multiply by entry size
        //b ||mfi|8,wa|||get back address-style|25672
        wa = ia;				// get back address-style
        //b ||add|8,wa|18,=num02||add on 2 word overhead|25673
        wa += NUM02;				// add on 2 word overhead
        //b ||wtb|8,wa|||convert the whole lot to bytes|25674
        wa <<= LOG_CFP_B;				// convert the whole lot to bytes
        //b ||jsr|6,alost|||gimme the space|25675
        C_JSR(alost);				// gimme the space
        //b ||mov|3,pftbl|7,xr||save block pointer|25676
        v.pftbl= xr;				// save block pointer
        //b ||mov|10,(xr)+|22,=b_xnt||put block type and ...|25677
        *(xr_it.wp++)= (word)(b_xnt);				// put block type and ...
        //b ||mov|10,(xr)+|8,wa||... length into header|25678
        *(xr_it.wp++)= wa;				// ... length into header
        //b ||mfi|8,wa|||get back nr of wds in data area|25679
        wa = ia;				// get back nr of wds in data area
        //b ||lct|8,wa|8,wa||load the counter|25680
        wa= wa;				// load the counter
//      loop here to zero the block data
// pflu1:
        //b |pflu1|zer|10,(xr)+|||blank a word|25684
        C_GOTO(pflu1);
        } /* prflu */
        

        void pflu1() {
        *(xr_it.wp++)=0;				// blank a word
        //b ||bct|8,wa|6,pflu1||and alllllll the rest|25685
        if ((--wa))  C_GOTO(pflu1);				// and alllllll the rest
//      end of allocation. merge back into routine
// pflu2:
        //b |pflu2|mti|3,kvstn|||load nr of stmt just ended|25689
        C_GOTO(pflu2);
        } /* pflu1 */
        

        void pflu2() {
        ia = (word)(v.kvstn);				// load nr of stmt just ended
        //b ||sbi|4,intv1|||make into index offset|25690
        ia-=c.intv1;				// make into index offset
        //b ||mli|3,pfste|||make offset of table entry|25691
        ia*=v.pfste;				// make offset of table entry
        //b ||mfi|8,wa|||convert to address|25692
        wa = ia;				// convert to address
        //b ||wtb|8,wa|||get as baus|25693
        wa <<= LOG_CFP_B;				// get as baus
        //b ||add|8,wa|19,*num02||offset includes table header|25694
        wa += CFP_B*NUM02;				// offset includes table header
        //b ||mov|7,xr|3,pftbl||get table start|25695
        xr= v.pftbl;				// get table start
        //b ||bge|8,wa|13,num01(xr)|6,pflu3|if out of table, skip it|25696
        if ((wa-*((word *)(CFP_B*NUM01 + xr))) >= 0) C_GOTO(pflu3);				// if out of table, skip it
        //b ||add|7,xr|8,wa||else point to entry|25697
        xr += wa;				// else point to entry
        //b ||ldi|9,(xr)|||get nr of executions so far|25698
        ia = *(xr_it.wp);				// get nr of executions so far
        //b ||adi|4,intv1|||nudge up one|25699
        ia+=c.intv1;				// nudge up one
        //b ||sti|9,(xr)|||and put back|25700
        *(xr_it.wp)= ia;				// and put back
        //b ||jsr|6,systm|||get time now|25701
        C_JSR(systm);				// get time now
        //b ||sti|3,pfetm|||stash ending time|25702
        v.pfetm= ia;				// stash ending time
        //b ||sbi|3,pfstm|||subtract start time|25703
        ia-=v.pfstm;				// subtract start time
        //b ||adi|13,cfp_i(xr)|||add cumulative time so far|25704
        ia+=*((word *)(CFP_B*CFP_I + xr));				// add cumulative time so far
        //b ||sti|13,cfp_i(xr)|||and put back new total|25705
        *((word *)(CFP_B*CFP_I + xr))= ia;				// and put back new total
        //b ||ldi|3,pfetm|||load end time of this stmt ...|25706
        ia = v.pfetm;				// load end time of this stmt ...
        //b ||sti|3,pfstm|||... which is start time of next|25707
        v.pfstm= ia;				// ... which is start time of next
//      merge here to exit
// pflu3:
        //b |pflu3|mov|7,xr|10,(xs)+||restore callers xr|25711
        C_GOTO(pflu3);
        } /* pflu2 */
        

        void pflu3() {
        xr= C_POP();				// restore callers xr
        //b ||mov|8,wa|3,pfsvw||restore saved reg|25712
        wa= v.pfsvw;				// restore saved reg
        //b ||exi||||and return|25713
        C_EXIT(0);				// and return
//      here if profile is suppressed because a program defined
//      function is about to be entered, and so the current stmt
//      has not yet finished
// pflu4:
        //b |pflu4|zer|3,pffnc|||reset the condition flag|25719
        } /* pflu3 */
        

        void pflu4() {
        v.pffnc=0;				// reset the condition flag
        //b ||exi||||and immediate return|25720
        C_EXIT(0);				// and immediate return
        //b ||ejc|||||25722
        
//      prpar - process print parameters
//      (wc)                  if nonzero associate terminal only
//      jsr  prpar            call to process print parameters
//      (xl,xr,wa,wb,wc)      destroyed
//      since memory allocation is undecided on initial call,
//      terminal cannot be associated. the entry with wc non-zero
//      is provided so a later call can be made to complete this.
// prpar:
        //b |prpar|prc|25,e|1,0||entry point|25735
        } /* pflu4 */
        

        void prpar() {
        //b ||bnz|8,wc|6,prpa8||jump to associate terminal|25736
        if (wc) C_GOTO(prpa8);				// jump to associate terminal
        //b ||jsr|6,syspp|||get print parameters|25737
        C_JSR(syspp);				// get print parameters
        //b ||bnz|8,wb|6,prpa1||jump if lines/page specified|25738
        if (wb) C_GOTO(prpa1);				// jump if lines/page specified
        //b ||mov|8,wb|3,mxint||else use a large value|25739
        wb= v.mxint;				// else use a large value
        //b ||rsh|8,wb|1,1||but not too large|25740
        wb >>= 1;				// but not too large
//      store line count/page
// prpa1:
        //b |prpa1|mov|3,lstnp|8,wb||store number of lines/page|25744
        C_GOTO(prpa1);
        } /* prpar */
        

        void prpa1() {
        v.lstnp= wb;				// store number of lines/page
        //b ||mov|3,lstlc|8,wb||pretend page is full initially|25745
        v.lstlc= wb;				// pretend page is full initially
        //b ||zer|3,lstpg|||clear page number|25746
        v.lstpg=0;				// clear page number
        //b ||mov|8,wb|3,prlen||get prior length if any|25747
        wb= v.prlen;				// get prior length if any
        //b ||bze|8,wb|6,prpa2||skip if no length|25748
        if ( !( wb) ) C_GOTO(prpa2);				// skip if no length
        //b ||bgt|8,wa|8,wb|6,prpa3|skip storing if too big|25749
        if ((wa-wb) > 0) C_GOTO(prpa3);				// skip storing if too big
//      store print buffer length
// prpa2:
        //b |prpa2|mov|3,prlen|8,wa||store value|25753
        C_GOTO(prpa2);
        } /* prpa1 */
        

        void prpa2() {
        v.prlen= wa;				// store value
//      process bits options
// prpa3:
        //b |prpa3|mov|8,wb|4,bits3||bit 3 mask|25757
        C_GOTO(prpa3);
        } /* prpa2 */
        

        void prpa3() {
        wb= c.bits3;				// bit 3 mask
        //b ||anb|8,wb|8,wc||get -nolist bit|25758
        wb &= wc;				// get -nolist bit
        //b ||zrb|8,wb|6,prpa4||skip if clear|25759
        if (!(wb)) C_GOTO(prpa4);				// skip if clear
        //b ||zer|3,cswls|||set -nolist|25760
        v.cswls=0;				// set -nolist
//      check if fail reports goto interactive channel
// prpa4:
        //b |prpa4|mov|8,wb|4,bits1||bit 1 mask|25764
        C_GOTO(prpa4);
        } /* prpa3 */
        

        void prpa4() {
        wb= c.bits1;				// bit 1 mask
        //b ||anb|8,wb|8,wc||get bit|25765
        wb &= wc;				// get bit
        //b ||mov|3,erich|8,wb||store int. chan. error flag|25766
        v.erich= wb;				// store int. chan. error flag
        //b ||mov|8,wb|4,bits2||bit 2 mask|25767
        wb= c.bits2;				// bit 2 mask
        //b ||anb|8,wb|8,wc||get bit|25768
        wb &= wc;				// get bit
        //b ||mov|3,prich|8,wb||flag for std printer on int. chan.|25769
        v.prich= wb;				// flag for std printer on int. chan.
        //b ||mov|8,wb|4,bits4||bit 4 mask|25770
        wb= c.bits4;				// bit 4 mask
        //b ||anb|8,wb|8,wc||get bit|25771
        wb &= wc;				// get bit
        //b ||mov|3,cpsts|8,wb||flag for compile stats suppressn.|25772
        v.cpsts= wb;				// flag for compile stats suppressn.
        //b ||mov|8,wb|4,bits5||bit 5 mask|25773
        wb= c.bits5;				// bit 5 mask
        //b ||anb|8,wb|8,wc||get bit|25774
        wb &= wc;				// get bit
        //b ||mov|3,exsts|8,wb||flag for exec stats suppression|25775
        v.exsts= wb;				// flag for exec stats suppression
        //b ||ejc|||||25776
        
//      prpar (continued)
        //b ||mov|8,wb|4,bits6||bit 6 mask|25780
        wb= c.bits6;				// bit 6 mask
        //b ||anb|8,wb|8,wc||get bit|25781
        wb &= wc;				// get bit
        //b ||mov|3,precl|8,wb||extended/compact listing flag|25782
        v.precl= wb;				// extended/compact listing flag
        //b ||sub|8,wa|18,=num08||point 8 chars from line end|25783
        wa -= NUM08;				// point 8 chars from line end
        //b ||zrb|8,wb|6,prpa5||jump if not extended|25784
        if (!(wb)) C_GOTO(prpa5);				// jump if not extended
        //b ||mov|3,lstpo|8,wa||store for listing page headings|25785
        v.lstpo= wa;				// store for listing page headings
//       continue option processing
// prpa5:
        //b |prpa5|mov|8,wb|4,bits7||bit 7 mask|25789
        C_GOTO(prpa5);
        } /* prpa4 */
        

        void prpa5() {
        wb= c.bits7;				// bit 7 mask
        //b ||anb|8,wb|8,wc||get bit 7|25790
        wb &= wc;				// get bit 7
        //b ||mov|3,cswex|8,wb||set -noexecute if non-zero|25791
        v.cswex= wb;				// set -noexecute if non-zero
        //b ||mov|8,wb|4,bit10||bit 10 mask|25792
        wb= c.bit10;				// bit 10 mask
        //b ||anb|8,wb|8,wc||get bit 10|25793
        wb &= wc;				// get bit 10
        //b ||mov|3,headp|8,wb||pretend printed to omit headers|25794
        v.headp= wb;				// pretend printed to omit headers
        //b ||mov|8,wb|4,bits9||bit 9 mask|25795
        wb= c.bits9;				// bit 9 mask
        //b ||anb|8,wb|8,wc||get bit 9|25796
        wb &= wc;				// get bit 9
        //b ||mov|3,prsto|8,wb||keep it as std listing option|25797
        v.prsto= wb;				// keep it as std listing option
        //b ||mov|8,wb|4,bit12||bit 12 mask|25804
        wb= c.bit12;				// bit 12 mask
        //b ||anb|8,wb|8,wc||get bit 12|25805
        wb &= wc;				// get bit 12
        //b ||mov|3,cswer|8,wb||keep it as errors/noerrors option|25806
        v.cswer= wb;				// keep it as errors/noerrors option
        //b ||zrb|8,wb|6,prpa6||skip if clear|25807
        if (!(wb)) C_GOTO(prpa6);				// skip if clear
        //b ||mov|8,wa|3,prlen||get print buffer length|25808
        wa= v.prlen;				// get print buffer length
        //b ||sub|8,wa|18,=num08||point 8 chars from line end|25809
        wa -= NUM08;				// point 8 chars from line end
        //b ||mov|3,lstpo|8,wa||store page offset|25810
        v.lstpo= wa;				// store page offset
//      check for -print/-noprint
// prpa6:
        //b |prpa6|mov|8,wb|4,bit11||bit 11 mask|25814
        C_GOTO(prpa6);
        } /* prpa5 */
        

        void prpa6() {
        wb= c.bit11;				// bit 11 mask
        //b ||anb|8,wb|8,wc||get bit 11|25815
        wb &= wc;				// get bit 11
        //b ||mov|3,cswpr|8,wb||set -print if non-zero|25816
        v.cswpr= wb;				// set -print if non-zero
//      check for terminal
        //b ||anb|8,wc|4,bits8||see if terminal to be activated|25820
        wc &= c.bits8;				// see if terminal to be activated
        //b ||bnz|8,wc|6,prpa8||jump if terminal required|25821
        if (wc) C_GOTO(prpa8);				// jump if terminal required
        //b ||bze|3,initr|6,prpa9||jump if no terminal to detach|25822
        if ( !( v.initr) ) C_GOTO(prpa9);				// jump if no terminal to detach
        //b ||mov|7,xl|21,=v_ter||ptr to /terminal/|25823
        xl= (word)(&c.v_ter);				// ptr to /terminal/
        //b ||ppm||||cant fail|25825
        C_JSR_1(gtnvr,(C_ERR(299)));				// cant fail
        //b ||mov|13,vrval(xr)|21,=nulls||clear value of terminal|25826
        *((word *)(CFP_B*VRVAL + xr))= (word)(&c.nulls);				// clear value of terminal
        //b ||jsr|6,setvr|||remove association|25827
        C_JSR(setvr);				// remove association
        //b ||brn|6,prpa9|||return|25828
         C_GOTO(prpa9);				// return
//      associate terminal
// prpa8:
        //b |prpa8|mnz|3,initr|||note terminal associated|25832
        } /* prpa6 */
        

        void prpa8() {
        v.initr = 0xffffffffffffffff;				// note terminal associated
        //b ||bze|3,dnamb|6,prpa9||cant if memory not organised|25833
        if ( !( v.dnamb) ) C_GOTO(prpa9);				// cant if memory not organised
        //b ||mov|7,xl|21,=v_ter||point to terminal string|25834
        xl= (word)(&c.v_ter);				// point to terminal string
        //b ||mov|8,wb|18,=trtou||output trace type|25835
        wb= TRTOU;				// output trace type
        //b ||jsr|6,inout|||attach output trblk to vrblk|25836
        C_JSR(inout);				// attach output trblk to vrblk
        //b ||mov|11,-(xs)|7,xr||stack trblk ptr|25837
        C_PUSH(xr);				// stack trblk ptr
        //b ||mov|7,xl|21,=v_ter||point to terminal string|25838
        xl= (word)(&c.v_ter);				// point to terminal string
        //b ||mov|8,wb|18,=trtin||input trace type|25839
        wb= TRTIN;				// input trace type
        //b ||jsr|6,inout|||attach input trace blk|25840
        C_JSR(inout);				// attach input trace blk
        //b ||mov|13,vrval(xr)|10,(xs)+||add output trblk to chain|25841
        *((word *)(CFP_B*VRVAL + xr))= C_POP();				// add output trblk to chain
//      return point
// prpa9:
        //b |prpa9|exi||||return|25845
        C_GOTO(prpa9);
        } /* prpa8 */
        

        void prpa9() {
        C_EXIT(0);				// return
        //b ||ejc|||||25847
        
//      prtch -- print a character
//      prtch is used to print a single character
//      (wa)                  character to be printed
//      jsr  prtch            call to print character
// prtch:
        //b |prtch|prc|25,e|1,0||entry point|25856
        } /* prpa9 */
        

        void prtch() {
        //b ||mov|11,-(xs)|7,xr||save xr|25857
        C_PUSH(xr);				// save xr
        //b ||bne|3,profs|3,prlen|6,prch1|jump if room in buffer|25858
        if ((v.profs-v.prlen) != 0) C_GOTO(prch1);				// jump if room in buffer
        //b ||jsr|6,prtnl|||else print this line|25859
        C_JSR(prtnl);				// else print this line
//      here after making sure we have room
// prch1:
        //b |prch1|mov|7,xr|3,prbuf||point to print buffer|25863
        C_GOTO(prch1);
        } /* prtch */
        

        void prch1() {
        xr= v.prbuf;				// point to print buffer
        //b ||psc|7,xr|3,profs||point to next character location|25864
        xr_it.chp += CFP_F + v.profs;				// point to next character location
        //b ||sch|8,wa|9,(xr)||store new character|25865
        *(xr_it.chp) = wa;				// store new character
        //b ||csc|7,xr|||complete store characters|25866
        //b ||icv|3,profs|||bump pointer|25867
        (v.profs)++;				// bump pointer
        //b ||mov|7,xr|10,(xs)+||restore entry xr|25868
        xr= C_POP();				// restore entry xr
        //b ||exi||||return to prtch caller|25869
        C_EXIT(0);				// return to prtch caller
        //b ||ejc|||||25871
        
//      prtic -- print to interactive channel
//      prtic is called to print the contents of the standard
//      print buffer to the interactive channel. it is only
//      called after prtst has set up the string for printing.
//      it does not clear the buffer.
//      jsr  prtic            call for print
//      (wa,wb)               destroyed
// prtic:
        //b |prtic|prc|25,e|1,0||entry point|25883
        } /* prch1 */
        

        void prtic() {
        //b ||mov|11,-(xs)|7,xr||save xr|25884
        C_PUSH(xr);				// save xr
        //b ||mov|7,xr|3,prbuf||point to buffer|25885
        xr= v.prbuf;				// point to buffer
        //b ||mov|8,wa|3,profs||no of chars|25886
        wa= v.profs;				// no of chars
        //b ||ppm|6,prtc2|||fail return|25888
        C_JSR_1(syspi,C_GOTO(prtc2));				// fail return
//      return
// prtc1:
        //b |prtc1|mov|7,xr|10,(xs)+||restore xr|25892
        C_GOTO(prtc1);
        } /* prtic */
        

        void prtc1() {
        xr= C_POP();				// restore xr
        //b ||exi||||return|25893
        C_EXIT(0);				// return
//      error occured
// prtc2:
        //b |prtc2|zer|3,erich|||prevent looping|25897
        } /* prtc1 */
        

        void prtc2() {
        v.erich=0;				// prevent looping
        //b ||erb|1,252|26,error on printing to interactive channel|||25898
        C_ERB(252)
        //b ||brn|6,prtc1|||return|25899
         C_GOTO(prtc1);				// return
        //b ||ejc|||||25901
        
//      prtis -- print to interactive and standard printer
//      prtis puts a line from the print buffer onto the
//      interactive channel (if any) and the standard printer.
//      it always prints to the standard printer but does
//      not duplicate lines if the standard printer is
//      interactive.  it clears down the print buffer.
//      jsr  prtis            call for printing
//      (wa,wb)               destroyed
// prtis:
        //b |prtis|prc|25,e|1,0||entry point|25914
        } /* prtc2 */
        

        void prtis() {
        //b ||bnz|3,prich|6,prts1||jump if standard printer is int.ch.|25915
        if (v.prich) C_GOTO(prts1);				// jump if standard printer is int.ch.
        //b ||bze|3,erich|6,prts1||skip if not doing int. error reps.|25916
        if ( !( v.erich) ) C_GOTO(prts1);				// skip if not doing int. error reps.
        //b ||jsr|6,prtic|||print to interactive channel|25917
        C_JSR(prtic);				// print to interactive channel
//      merge and exit
// prts1:
        //b |prts1|jsr|6,prtnl|||print to standard printer|25921
        C_GOTO(prts1);
        } /* prtis */
        

        void prts1() {
        C_JSR(prtnl);				// print to standard printer
        //b ||exi||||return|25922
        C_EXIT(0);				// return
        //b ||ejc|||||25924
        
//      prtin -- print an integer
//      prtin prints the integer value which is in the integer
//      accumulator. blocks built in dynamic storage
//      during this process are immediately deleted.
//      (ia)                  integer value to be printed
//      jsr  prtin            call to print integer
//      (ia,ra)               destroyed
// prtin:
        //b |prtin|prc|25,e|1,0||entry point|25936
        } /* prts1 */
        

        void prtin() {
        //b ||mov|11,-(xs)|7,xr||save xr|25937
        C_PUSH(xr);				// save xr
        //b ||jsr|6,icbld|||build integer block|25938
        C_JSR(icbld);				// build integer block
        //b ||blo|7,xr|3,dnamb|6,prti1|jump if icblk below dynamic|25939
        if ((xr-v.dnamb) < 0) C_GOTO(prti1);				// jump if icblk below dynamic
        //b ||bhi|7,xr|3,dnamp|6,prti1|jump if above dynamic|25940
        if ((xr-v.dnamp) > 0) C_GOTO(prti1);				// jump if above dynamic
        //b ||mov|3,dnamp|7,xr||immediately delete it|25941
        v.dnamp= xr;				// immediately delete it
//      delete icblk from dynamic store
// prti1:
        //b |prti1|mov|11,-(xs)|7,xr||stack ptr for gtstg|25945
        C_GOTO(prti1);
        } /* prtin */
        

        void prti1() {
        C_PUSH(xr);				// stack ptr for gtstg
        //b ||ppm||||convert error is impossible|25947
        extern void _l0696();
        C_JMS(gtstg,P_PRC_GTSTG,_l0696);
        } /* prti1 */
        

        void _l0696() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(299)));				// convert error is impossible
        //b ||mov|3,dnamp|7,xr||reset pointer to delete scblk|25948
        v.dnamp= xr;				// reset pointer to delete scblk
        //b ||jsr|6,prtst|||print integer string|25949
        C_JSR(prtst);				// print integer string
        //b ||mov|7,xr|10,(xs)+||restore entry xr|25950
        xr= C_POP();				// restore entry xr
        //b ||exi||||return to prtin caller|25951
        C_EXIT(0);				// return to prtin caller
        //b ||ejc|||||25953
        
//      prtmi -- print message and integer
//      prtmi is used to print messages together with an integer
//      value starting in column 15 (used by the routines at
//      the end of compilation).
//      jsr  prtmi            call to print message and integer
// prtmi:
        //b |prtmi|prc|25,e|1,0||entry point|25963
        } /* _l0696 */
        

        void prtmi() {
        //b ||jsr|6,prtst|||print string message|25964
        C_JSR(prtst);				// print string message
        //b ||mov|3,profs|18,=prtmf||set column offset|25965
        v.profs= PRTMF;				// set column offset
        //b ||jsr|6,prtin|||print integer|25966
        C_JSR(prtin);				// print integer
        //b ||jsr|6,prtnl|||print line|25967
        C_JSR(prtnl);				// print line
        //b ||exi||||return to prtmi caller|25968
        C_EXIT(0);				// return to prtmi caller
        //b ||ejc|||||25970
        
//      prtmm -- print memory used and available
//      prtmm is used to provide memory usage information in
//      both the end-of-compile and end-of-run statistics.
//      jsr  prtmm            call to print memory stats
// prtmm:
        //b |prtmm|prc|25,e|1,0|||25979
        } /* prtmi */
        

        void prtmm() {
        //b ||mov|8,wa|3,dnamp||next available loc|25980
        wa= v.dnamp;				// next available loc
        //b ||sub|8,wa|3,statb||minus start|25981
        wa -= v.statb;				// minus start
        //b ||mti|8,wa|||convert to integer|25986
        ia = (word)(wa);				// convert to integer
        //b ||mov|7,xr|21,=encm1||point to /memory used (words)/|25987
        xr= (word)(&c.encm1);				// point to /memory used (words)/
        //b ||jsr|6,prtmi|||print message|25988
        C_JSR(prtmi);				// print message
        //b ||mov|8,wa|3,dname||end of memory|25989
        wa= v.dname;				// end of memory
        //b ||sub|8,wa|3,dnamp||minus next available loc|25990
        wa -= v.dnamp;				// minus next available loc
        //b ||mti|8,wa|||convert to integer|25995
        ia = (word)(wa);				// convert to integer
        //b ||mov|7,xr|21,=encm2||point to /memory available (words)/|25996
        xr= (word)(&c.encm2);				// point to /memory available (words)/
        //b ||jsr|6,prtmi|||print line|25997
        C_JSR(prtmi);				// print line
        //b ||exi||||return to prtmm caller|25998
        C_EXIT(0);				// return to prtmm caller
        //b ||ejc|||||26000
        
//      prtmx  -- as prtmi with extra copy to interactive chan.
//      jsr  prtmx            call for printing
//      (wa,wb)               destroyed
// prtmx:
        //b |prtmx|prc|25,e|1,0||entry point|26007
        } /* prtmm */
        

        void prtmx() {
        //b ||jsr|6,prtst|||print string message|26008
        C_JSR(prtst);				// print string message
        //b ||mov|3,profs|18,=prtmf||set column offset|26009
        v.profs= PRTMF;				// set column offset
        //b ||jsr|6,prtin|||print integer|26010
        C_JSR(prtin);				// print integer
        //b ||jsr|6,prtis|||print line|26011
        C_JSR(prtis);				// print line
        //b ||exi||||return|26012
        C_EXIT(0);				// return
        //b ||ejc|||||26014
        
//      prtnl -- print new line (end print line)
//      prtnl prints the contents of the print buffer, resets
//      the buffer to all blanks and resets the print pointer.
//      jsr  prtnl            call to print line
// prtnl:
        //b |prtnl|prc|25,r|1,0||entry point|26023
        } /* prtmx */
        

        void prtnl() {
        //b ||bnz|3,headp|6,prnl0||were headers printed|26024
        if (v.headp) C_GOTO(prnl0);				// were headers printed
        //b ||jsr|6,prtps|||no - print them|26025
        C_JSR(prtps);				// no - print them
//      call syspr
// prnl0:
        //b |prnl0|mov|11,-(xs)|7,xr||save entry xr|26029
        C_GOTO(prnl0);
        } /* prtnl */
        

        void prnl0() {
        C_PUSH(xr);				// save entry xr
        //b ||mov|3,prtsa|8,wa||save wa|26030
        v.prtsa= wa;				// save wa
        //b ||mov|3,prtsb|8,wb||save wb|26031
        v.prtsb= wb;				// save wb
        //b ||mov|7,xr|3,prbuf||load pointer to buffer|26032
        xr= v.prbuf;				// load pointer to buffer
        //b ||mov|8,wa|3,profs||load number of chars in buffer|26033
        wa= v.profs;				// load number of chars in buffer
        //b ||ppm|6,prnl2|||jump if failed|26035
        C_JSR_1(syspr,C_GOTO(prnl2));				// jump if failed
        //b ||lct|8,wa|3,prlnw||load length of buffer in words|26036
        wa= v.prlnw;				// load length of buffer in words
        //b ||add|7,xr|19,*schar||point to chars of buffer|26037
        xr += CFP_B*SCHAR;				// point to chars of buffer
        //b ||mov|8,wb|4,nullw||get word of blanks|26038
        wb= c.nullw;				// get word of blanks
//      loop to blank buffer
// prnl1:
        //b |prnl1|mov|10,(xr)+|8,wb||store word of blanks, bump ptr|26042
        C_GOTO(prnl1);
        } /* prnl0 */
        

        void prnl1() {
        *(xr_it.wp++)= wb;				// store word of blanks, bump ptr
        //b ||bct|8,wa|6,prnl1||loop till all blanked|26043
        if ((--wa))  C_GOTO(prnl1);				// loop till all blanked
//      exit point
        //b ||mov|8,wb|3,prtsb||restore wb|26047
        wb= v.prtsb;				// restore wb
        //b ||mov|8,wa|3,prtsa||restore wa|26048
        wa= v.prtsa;				// restore wa
        //b ||mov|7,xr|10,(xs)+||restore entry xr|26049
        xr= C_POP();				// restore entry xr
        //b ||zer|3,profs|||reset print buffer pointer|26050
        v.profs=0;				// reset print buffer pointer
        //b ||exi||||return to prtnl caller|26051
        C_EXIT(0);				// return to prtnl caller
//      file full or no output file for load module
// prnl2:
        //b |prnl2|bnz|3,prtef|6,prnl3||jump if not first time|26055
        } /* prnl1 */
        

        void prnl2() {
        if (v.prtef) C_GOTO(prnl3);				// jump if not first time
        //b ||mnz|3,prtef|||mark first occurrence|26056
        v.prtef = 0xffffffffffffffff;				// mark first occurrence
        //b ||erb|1,253|26,print limit exceeded on standard output channel|||26057
        C_ERB(253)
//      stop at once
// prnl3:
        //b |prnl3|mov|8,wb|18,=nini8||ending code|26061
        } /* prnl2 */
        

        void prnl3() {
        wb= NINI8;				// ending code
        //b ||mov|8,wa|3,kvstn||statement number|26062
        wa= v.kvstn;				// statement number
        //b ||mov|7,xl|3,r_fcb||get fcblk chain head|26063
        xl= v.r_fcb;				// get fcblk chain head
        //b ||jsr|6,sysej|||stop|26064
        C_JSR(sysej);				// stop
        //b ||ejc|||||26066
        
//      prtnm -- print variable name
//      prtnm is used to print a character representation of the
//      name of a variable (not a value of datatype name)
//      names of pseudo-variables may not be passed to prtnm.
//      (xl)                  name base
//      (wa)                  name offset
//      jsr  prtnm            call to print name
//      (wb,wc,ra)            destroyed
// prtnm:
        //b |prtnm|prc|25,r|1,0||entry point (recursive, see prtvl)|26079
        C_GOTO(prtnm);
        } /* prnl3 */
        

        void prtnm() {
        //b ||mov|11,-(xs)|8,wa||save wa (offset is collectable)|26080
        C_PUSH(wa);				// save wa (offset is collectable)
        //b ||mov|11,-(xs)|7,xr||save entry xr|26081
        C_PUSH(xr);				// save entry xr
        //b ||mov|11,-(xs)|7,xl||save name base|26082
        C_PUSH(xl);				// save name base
        //b ||bhi|7,xl|3,state|6,prn02|jump if not natural variable|26083
        if ((xl-v.state) > 0) C_GOTO(prn02);				// jump if not natural variable
//      here for natural variable name, recognized by the fact
//      that the name base points into the static area.
        //b ||mov|7,xr|7,xl||point to vrblk|26088
        xr= xl;				// point to vrblk
        //b ||jsr|6,prtvn|||print name of variable|26089
        C_JSR(prtvn);				// print name of variable
//      common exit point
// prn01:
        //b |prn01|mov|7,xl|10,(xs)+||restore name base|26093
        C_GOTO(prn01);
        } /* prtnm */
        

        void prn01() {
        xl= C_POP();				// restore name base
        //b ||mov|7,xr|10,(xs)+||restore entry value of xr|26094
        xr= C_POP();				// restore entry value of xr
        //b ||mov|8,wa|10,(xs)+||restore wa|26095
        wa= C_POP();				// restore wa
        //b ||exi||||return to prtnm caller|26096
        C_EXIT(0);				// return to prtnm caller
//      here for case of non-natural variable
// prn02:
        //b |prn02|mov|8,wb|8,wa||copy name offset|26100
        } /* prn01 */
        

        void prn02() {
        wb= wa;				// copy name offset
        //b ||bne|9,(xl)|22,=b_pdt|6,prn03|jump if array or table|26101
        if ((*(xl_it.wp)-(word)(b_pdt)) != 0) C_GOTO(prn03);				// jump if array or table
//      for program defined datatype, prt fld name, left paren
        //b ||mov|7,xr|13,pddfp(xl)||load pointer to dfblk|26105
        xr= *((word *)(CFP_B*PDDFP + xl));				// load pointer to dfblk
        //b ||add|7,xr|8,wa||add name offset|26106
        xr += wa;				// add name offset
        //b ||mov|7,xr|13,pdfof(xr)||load vrblk pointer for field|26107
        xr= *((word *)(CFP_B*PDFOF + xr));				// load vrblk pointer for field
        //b ||jsr|6,prtvn|||print field name|26108
        C_JSR(prtvn);				// print field name
        //b ||mov|8,wa|18,=ch_pp||load left paren|26109
        wa= CH_PP;				// load left paren
        //b ||jsr|6,prtch|||print character|26110
        C_JSR(prtch);				// print character
        //b ||ejc|||||26111
        
//      prtnm (continued)
//      now we print an identifying name for the object if one
//      can be found. the following code searches for a natural
//      variable which contains this object as value. if such a
//      variable is found, its name is printed, else the value
//      of the object (as printed by prtvl) is used instead.
//      first we point to the parent tbblk if this is the case of
//      a table element. to do this, chase down the trnxt chain.
// prn03:
        //b |prn03|bne|9,(xl)|22,=b_tet|6,prn04|jump if we got there (or not te)|26124
        C_GOTO(prn03);
        } /* prn02 */
        

        void prn03() {
        if ((*(xl_it.wp)-(word)(b_tet)) != 0) C_GOTO(prn04);				// jump if we got there (or not te)
        //b ||mov|7,xl|13,tenxt(xl)||else move out on chain|26125
        xl= *((word *)(CFP_B*TENXT + xl));				// else move out on chain
        //b ||brn|6,prn03|||and loop back|26126
         C_GOTO(prn03);				// and loop back
//      now we are ready for the search. to speed things up in
//      the case of calls from dump where the same name base
//      will occur repeatedly while dumping an array or table,
//      we remember the last vrblk pointer found in prnmv. so
//      first check to see if we have this one again.
// prn04:
        //b |prn04|mov|7,xr|3,prnmv||point to vrblk we found last time|26134
        } /* prn03 */
        

        void prn04() {
        xr= v.prnmv;				// point to vrblk we found last time
        //b ||mov|8,wa|3,hshtb||point to hash table in case not|26135
        wa= v.hshtb;				// point to hash table in case not
        //b ||brn|6,prn07|||jump into search for special check|26136
         C_GOTO(prn07);				// jump into search for special check
//      loop through hash slots
// prn05:
        //b |prn05|mov|7,xr|8,wa||copy slot pointer|26140
        } /* prn04 */
        

        void prn05() {
        xr= wa;				// copy slot pointer
        //b ||ica|8,wa|||bump slot pointer|26141
        wa += CFP_B;				// bump slot pointer
        //b ||sub|7,xr|19,*vrnxt||introduce standard vrblk offset|26142
        xr -= CFP_B*VRNXT;				// introduce standard vrblk offset
//      loop through vrblks on one hash chain
// prn06:
        //b |prn06|mov|7,xr|13,vrnxt(xr)||point to next vrblk on hash chain|26146
        C_GOTO(prn06);
        } /* prn05 */
        

        void prn06() {
        xr= *((word *)(CFP_B*VRNXT + xr));				// point to next vrblk on hash chain
//      merge here first time to check block we found last time
// prn07:
        //b |prn07|mov|8,wc|7,xr||copy vrblk pointer|26150
        C_GOTO(prn07);
        } /* prn06 */
        

        void prn07() {
        wc= xr;				// copy vrblk pointer
        //b ||bze|8,wc|6,prn09||jump if chain end (or prnmv zero)|26151
        if ( !( wc) ) C_GOTO(prn09);				// jump if chain end (or prnmv zero)
        //b ||ejc|||||26152
        
//      prtnm (continued)
//      loop to find value (chase down possible trblk chain)
// prn08:
        //b |prn08|mov|7,xr|13,vrval(xr)||load value|26158
        C_GOTO(prn08);
        } /* prn07 */
        

        void prn08() {
        xr= *((word *)(CFP_B*VRVAL + xr));				// load value
        //b ||beq|9,(xr)|22,=b_trt|6,prn08|loop if that was a trblk|26159
        if ((*(xr_it.wp)-(word)(b_trt)) == 0) C_GOTO(prn08);				// loop if that was a trblk
//      now we have the value, is this the block we want
        //b ||beq|7,xr|7,xl|6,prn10|jump if this matches the name base|26163
        if ((xr-xl) == 0) C_GOTO(prn10);				// jump if this matches the name base
        //b ||mov|7,xr|8,wc||else point back to that vrblk|26164
        xr= wc;				// else point back to that vrblk
        //b ||brn|6,prn06|||and loop back|26165
         C_GOTO(prn06);				// and loop back
//      here to move to next hash slot
// prn09:
        //b |prn09|blt|8,wa|3,hshte|6,prn05|loop back if more to go|26169
        } /* prn08 */
        

        void prn09() {
        if ((wa-v.hshte) < 0) C_GOTO(prn05);				// loop back if more to go
        //b ||mov|7,xr|7,xl||else not found, copy value pointer|26170
        xr= xl;				// else not found, copy value pointer
        //b ||jsr|6,prtvl|||print value|26171
        C_JSR(prtvl);				// print value
        //b ||brn|6,prn11|||and merge ahead|26172
         C_GOTO(prn11);				// and merge ahead
//      here when we find a matching entry
// prn10:
        //b |prn10|mov|7,xr|8,wc||copy vrblk pointer|26176
        } /* prn09 */
        

        void prn10() {
        xr= wc;				// copy vrblk pointer
        //b ||mov|3,prnmv|7,xr||save for next time in|26177
        v.prnmv= xr;				// save for next time in
        //b ||jsr|6,prtvn|||print variable name|26178
        C_JSR(prtvn);				// print variable name
//      merge here if no entry found
// prn11:
        //b |prn11|mov|8,wc|9,(xl)||load first word of name base|26182
        C_GOTO(prn11);
        } /* prn10 */
        

        void prn11() {
        wc= *(xl_it.wp);				// load first word of name base
        //b ||bne|8,wc|22,=b_pdt|6,prn13|jump if not program defined|26183
        if ((wc-(word)(b_pdt)) != 0) C_GOTO(prn13);				// jump if not program defined
//      for program defined datatype, add right paren and exit
        //b ||mov|8,wa|18,=ch_rp||load right paren, merge|26187
        wa= CH_RP;				// load right paren, merge
//      merge here to print final right paren or bracket
// prn12:
        //b |prn12|jsr|6,prtch|||print final character|26191
        C_GOTO(prn12);
        } /* prn11 */
        

        void prn12() {
        C_JSR(prtch);				// print final character
        //b ||mov|8,wa|8,wb||restore name offset|26192
        wa= wb;				// restore name offset
        //b ||brn|6,prn01|||merge back to exit|26193
         C_GOTO(prn01);				// merge back to exit
        //b ||ejc|||||26194
        
//      prtnm (continued)
//      here for array or table
// prn13:
        //b |prn13|mov|8,wa|18,=ch_bb||load left bracket|26200
        } /* prn12 */
        

        void prn13() {
        wa= CH_BB;				// load left bracket
        //b ||jsr|6,prtch|||and print it|26201
        C_JSR(prtch);				// and print it
        //b ||mov|7,xl|9,(xs)||restore block pointer|26202
        xl= *(xs_it.wp);				// restore block pointer
        //b ||mov|8,wc|9,(xl)||load type word again|26203
        wc= *(xl_it.wp);				// load type word again
        //b ||bne|8,wc|22,=b_tet|6,prn15|jump if not table|26204
        if ((wc-(word)(b_tet)) != 0) C_GOTO(prn15);				// jump if not table
//      here for table, print subscript value
        //b ||mov|7,xr|13,tesub(xl)||load subscript value|26208
        xr= *((word *)(CFP_B*TESUB + xl));				// load subscript value
        //b ||mov|7,xl|8,wb||save name offset|26209
        xl= wb;				// save name offset
        //b ||jsr|6,prtvl|||print subscript value|26210
        C_JSR(prtvl);				// print subscript value
        //b ||mov|8,wb|7,xl||restore name offset|26211
        wb= xl;				// restore name offset
//      merge here from array case to print right bracket
// prn14:
        //b |prn14|mov|8,wa|18,=ch_rb||load right bracket|26215
        C_GOTO(prn14);
        } /* prn13 */
        

        void prn14() {
        wa= CH_RB;				// load right bracket
        //b ||brn|6,prn12|||merge back to print it|26216
         C_GOTO(prn12);				// merge back to print it
//      here for array or vector, to print subscript(s)
// prn15:
        //b |prn15|mov|8,wa|8,wb||copy name offset|26220
        } /* prn14 */
        

        void prn15() {
        wa= wb;				// copy name offset
        //b ||btw|8,wa|||convert to words|26221
        wa >>= LOG_CFP_B;				// convert to words
        //b ||beq|8,wc|22,=b_art|6,prn16|jump if arblk|26222
        if ((wc-(word)(b_art)) == 0) C_GOTO(prn16);				// jump if arblk
//      here for vector
        //b ||sub|8,wa|18,=vcvlb||adjust for standard fields|26226
        wa -= VCVLB;				// adjust for standard fields
        //b ||mti|8,wa|||move to integer accum|26227
        ia = (word)(wa);				// move to integer accum
        //b ||jsr|6,prtin|||print linear subscript|26228
        C_JSR(prtin);				// print linear subscript
        //b ||brn|6,prn14|||merge back for right bracket|26229
         C_GOTO(prn14);				// merge back for right bracket
        //b ||ejc|||||26230
        
//      prtnm (continued)
//      here for array. first calculate absolute subscript
//      offsets by successive divisions by the dimension values.
//      this must be done right to left since the elements are
//      stored row-wise. the subscripts are stacked as integers.
// prn16:
        //b |prn16|mov|8,wc|13,arofs(xl)||load length of bounds info|26239
        } /* prn15 */
        

        void prn16() {
        wc= *((word *)(CFP_B*AROFS + xl));				// load length of bounds info
        //b ||ica|8,wc|||adjust for arpro field|26240
        wc += CFP_B;				// adjust for arpro field
        //b ||btw|8,wc|||convert to words|26241
        wc >>= LOG_CFP_B;				// convert to words
        //b ||sub|8,wa|8,wc||get linear zero-origin subscript|26242
        wa -= wc;				// get linear zero-origin subscript
        //b ||mti|8,wa|||get integer value|26243
        ia = (word)(wa);				// get integer value
        //b ||lct|8,wa|13,arndm(xl)||set num of dimensions as loop count|26244
        wa= *((word *)(CFP_B*ARNDM + xl));				// set num of dimensions as loop count
        //b ||add|7,xl|13,arofs(xl)||point past bounds information|26245
        xl += *((word *)(CFP_B*AROFS + xl));				// point past bounds information
        //b ||sub|7,xl|19,*arlbd||set ok offset for proper ptr later|26246
        xl -= CFP_B*ARLBD;				// set ok offset for proper ptr later
//      loop to stack subscript offsets
// prn17:
        //b |prn17|sub|7,xl|19,*ardms||point to next set of bounds|26250
        C_GOTO(prn17);
        } /* prn16 */
        

        void prn17() {
        xl -= CFP_B*ARDMS;				// point to next set of bounds
        //b ||sti|3,prnsi|||save current offset|26251
        v.prnsi= ia;				// save current offset
        //b ||rmi|13,ardim(xl)|||get remainder on dividing by dimens|26252
        ia=ia % *((word *)(CFP_B*ARDIM + xl));				// get remainder on dividing by dimens
        //b ||mfi|11,-(xs)|||store on stack (one word)|26253
        C_PUSH(ia);				// store on stack (one word)
        //b ||ldi|3,prnsi|||reload argument|26254
        ia = v.prnsi;				// reload argument
        //b ||dvi|13,ardim(xl)|||divide to get quotient|26255
        ia=ia / *((word *)(CFP_B*ARDIM + xl));				// divide to get quotient
        //b ||bct|8,wa|6,prn17||loop till all stacked|26256
        if ((--wa))  C_GOTO(prn17);				// loop till all stacked
        //b ||zer|7,xr|||set offset to first set of bounds|26257
        xr=0;				// set offset to first set of bounds
        //b ||lct|8,wb|13,arndm(xl)||load count of dims to control loop|26258
        wb= *((word *)(CFP_B*ARNDM + xl));				// load count of dims to control loop
        //b ||brn|6,prn19|||jump into print loop|26259
         C_GOTO(prn19);				// jump into print loop
//      loop to print subscripts from stack adjusting by adding
//      the appropriate low bound value from the arblk
// prn18:
        //b |prn18|mov|8,wa|18,=ch_cm||load a comma|26264
        } /* prn17 */
        

        void prn18() {
        wa= CH_CM;				// load a comma
        //b ||jsr|6,prtch|||print it|26265
        C_JSR(prtch);				// print it
//      merge here first time in (no comma required)
// prn19:
        //b |prn19|mti|10,(xs)+|||load subscript offset as integer|26269
        C_GOTO(prn19);
        } /* prn18 */
        

        void prn19() {
        ia = C_POP();				// load subscript offset as integer
        //b ||add|7,xl|7,xr||point to current lbd|26270
        xl += xr;				// point to current lbd
        //b ||adi|13,arlbd(xl)|||add lbd to get signed subscript|26271
        ia+=*((word *)(CFP_B*ARLBD + xl));				// add lbd to get signed subscript
        //b ||sub|7,xl|7,xr||point back to start of arblk|26272
        xl -= xr;				// point back to start of arblk
        //b ||jsr|6,prtin|||print subscript|26273
        C_JSR(prtin);				// print subscript
        //b ||add|7,xr|19,*ardms||bump offset to next bounds|26274
        xr += CFP_B*ARDMS;				// bump offset to next bounds
        //b ||bct|8,wb|6,prn18||loop back till all printed|26275
        if ((--wb))  C_GOTO(prn18);				// loop back till all printed
        //b ||brn|6,prn14|||merge back to print right bracket|26276
         C_GOTO(prn14);				// merge back to print right bracket
        //b ||ejc|||||26278
        
//      prtnv -- print name value
//      prtnv is used by the trace and dump routines to print
//      a line of the form
//      name = value
//      note that the name involved can never be a pseudo-var
//      (xl)                  name base
//      (wa)                  name offset
//      jsr  prtnv            call to print name = value
//      (wb,wc,ra)            destroyed
// prtnv:
        //b |prtnv|prc|25,e|1,0||entry point|26294
        } /* prn19 */
        

        void prtnv() {
        //b ||jsr|6,prtnm|||print argument name|26295
        C_JSR(prtnm);				// print argument name
        //b ||mov|11,-(xs)|7,xr||save entry xr|26296
        C_PUSH(xr);				// save entry xr
        //b ||mov|11,-(xs)|8,wa||save name offset (collectable)|26297
        C_PUSH(wa);				// save name offset (collectable)
        //b ||mov|7,xr|21,=tmbeb||point to blank equal blank|26298
        xr= (word)(&c.tmbeb);				// point to blank equal blank
        //b ||jsr|6,prtst|||print it|26299
        C_JSR(prtst);				// print it
        //b ||mov|7,xr|7,xl||copy name base|26300
        xr= xl;				// copy name base
        //b ||add|7,xr|8,wa||point to value|26301
        xr += wa;				// point to value
        //b ||mov|7,xr|9,(xr)||load value pointer|26302
        xr= *(xr_it.wp);				// load value pointer
        //b ||jsr|6,prtvl|||print value|26303
        C_JSR(prtvl);				// print value
        //b ||jsr|6,prtnl|||terminate line|26304
        C_JSR(prtnl);				// terminate line
        //b ||mov|8,wa|10,(xs)+||restore name offset|26305
        wa= C_POP();				// restore name offset
        //b ||mov|7,xr|10,(xs)+||restore entry xr|26306
        xr= C_POP();				// restore entry xr
        //b ||exi||||return to caller|26307
        C_EXIT(0);				// return to caller
        //b ||ejc|||||26309
        
//      prtpg  -- print a page throw
//      prints a page throw or a few blank lines on the standard
//      listing channel depending on the listing options chosen.
//      jsr  prtpg            call for page eject
// prtpg:
        //b |prtpg|prc|25,e|1,0||entry point|26318
        } /* prtnv */
        

        void prtpg() {
        //b ||beq|3,stage|18,=stgxt|6,prp01|jump if execution time|26319
        if ((v.stage-STGXT) == 0) C_GOTO(prp01);				// jump if execution time
        //b ||bze|3,lstlc|6,prp06||return if top of page already|26320
        if ( !( v.lstlc) ) C_GOTO(prp06);				// return if top of page already
        //b ||zer|3,lstlc|||clear line count|26321
        v.lstlc=0;				// clear line count
//      check type of listing
// prp01:
        //b |prp01|mov|11,-(xs)|7,xr||preserve xr|26325
        C_GOTO(prp01);
        } /* prtpg */
        

        void prp01() {
        C_PUSH(xr);				// preserve xr
        //b ||bnz|3,prstd|6,prp02||eject if flag set|26326
        if (v.prstd) C_GOTO(prp02);				// eject if flag set
        //b ||bnz|3,prich|6,prp03||jump if interactive listing channel|26327
        if (v.prich) C_GOTO(prp03);				// jump if interactive listing channel
        //b ||bze|3,precl|6,prp03||jump if compact listing|26328
        if ( !( v.precl) ) C_GOTO(prp03);				// jump if compact listing
//      perform an eject
// prp02:
        //b |prp02|jsr|6,sysep|||eject|26332
        C_GOTO(prp02);
        } /* prp01 */
        

        void prp02() {
        C_JSR(sysep);				// eject
        //b ||brn|6,prp04|||merge|26333
         C_GOTO(prp04);				// merge
//      compact or interactive channel listing. cant print
//      blanks until check made for headers printed and flag set.
// prp03:
        //b |prp03|mov|7,xr|3,headp||remember headp|26339
        } /* prp02 */
        

        void prp03() {
        xr= v.headp;				// remember headp
        //b ||mnz|3,headp|||set to avoid repeated prtpg calls|26340
        v.headp = 0xffffffffffffffff;				// set to avoid repeated prtpg calls
        //b ||jsr|6,prtnl|||print blank line|26341
        C_JSR(prtnl);				// print blank line
        //b ||jsr|6,prtnl|||print blank line|26342
        C_JSR(prtnl);				// print blank line
        //b ||jsr|6,prtnl|||print blank line|26343
        C_JSR(prtnl);				// print blank line
        //b ||mov|3,lstlc|18,=num03||count blank lines|26344
        v.lstlc= NUM03;				// count blank lines
        //b ||mov|3,headp|7,xr||restore header flag|26345
        v.headp= xr;				// restore header flag
        //b ||ejc|||||26346
        
//      prptg (continued)
//      print the heading
// prp04:
        //b |prp04|bnz|3,headp|6,prp05||jump if header listed|26352
        C_GOTO(prp04);
        } /* prp03 */
        

        void prp04() {
        if (v.headp) C_GOTO(prp05);				// jump if header listed
        //b ||mnz|3,headp|||mark headers printed|26353
        v.headp = 0xffffffffffffffff;				// mark headers printed
        //b ||mov|11,-(xs)|7,xl||keep xl|26354
        C_PUSH(xl);				// keep xl
        //b ||mov|7,xr|21,=headr||point to listing header|26355
        xr= (word)(&c.headr);				// point to listing header
        //b ||jsr|6,prtst|||place it|26356
        C_JSR(prtst);				// place it
        //b ||jsr|6,sysid|||get system identification|26357
        C_JSR(sysid);				// get system identification
        //b ||jsr|6,prtst|||append extra chars|26358
        C_JSR(prtst);				// append extra chars
        //b ||jsr|6,prtnl|||print it|26359
        C_JSR(prtnl);				// print it
        //b ||mov|7,xr|7,xl||extra header line|26360
        xr= xl;				// extra header line
        //b ||jsr|6,prtst|||place it|26361
        C_JSR(prtst);				// place it
        //b ||jsr|6,prtnl|||print it|26362
        C_JSR(prtnl);				// print it
        //b ||jsr|6,prtnl|||print a blank|26363
        C_JSR(prtnl);				// print a blank
        //b ||jsr|6,prtnl|||and another|26364
        C_JSR(prtnl);				// and another
        //b ||add|3,lstlc|18,=num04||four header lines printed|26365
        v.lstlc += NUM04;				// four header lines printed
        //b ||mov|7,xl|10,(xs)+||restore xl|26366
        xl= C_POP();				// restore xl
//      merge if header not printed
// prp05:
        //b |prp05|mov|7,xr|10,(xs)+||restore xr|26370
        C_GOTO(prp05);
        } /* prp04 */
        

        void prp05() {
        xr= C_POP();				// restore xr
//      return
// prp06:
        //b |prp06|exi||||return|26374
        C_GOTO(prp06);
        } /* prp05 */
        

        void prp06() {
        C_EXIT(0);				// return
        //b ||ejc|||||26376
        
//      prtps - print page with test for standard listing option
//      if the standard listing option is selected, insist that
//      an eject be done
//      jsr  prtps            call for eject
// prtps:
        //b |prtps|prc|25,e|1,0||entry point|26385
        } /* prp06 */
        

        void prtps() {
        //b ||mov|3,prstd|3,prsto||copy option flag|26386
        v.prstd= v.prsto;				// copy option flag
        //b ||jsr|6,prtpg|||print page|26387
        C_JSR(prtpg);				// print page
        //b ||zer|3,prstd|||clear flag|26388
        v.prstd=0;				// clear flag
        //b ||exi||||return|26389
        C_EXIT(0);				// return
        //b ||ejc|||||26391
        
//      prtsn -- print statement number
//      prtsn is used to initiate a print trace line by printing
//      asterisks and the current statement number. the actual
//      format of the output generated is.
//      ***nnnnn**** iii.....iiii
//      nnnnn is the statement number with leading zeros replaced
//      by asterisks (e.g. *******9****)
//      iii...iii represents a variable length output consisting
//      of a number of letter i characters equal to fnclevel.
//      jsr  prtsn            call to print statement number
//      (wc)                  destroyed
// prtsn:
        //b |prtsn|prc|25,e|1,0||entry point|26410
        } /* prtps */
        

        void prtsn() {
        //b ||mov|11,-(xs)|7,xr||save entry xr|26411
        C_PUSH(xr);				// save entry xr
        //b ||mov|3,prsna|8,wa||save entry wa|26412
        v.prsna= wa;				// save entry wa
        //b ||mov|7,xr|21,=tmasb||point to asterisks|26413
        xr= (word)(&c.tmasb);				// point to asterisks
        //b ||jsr|6,prtst|||print asterisks|26414
        C_JSR(prtst);				// print asterisks
        //b ||mov|3,profs|18,=num04||point into middle of asterisks|26415
        v.profs= NUM04;				// point into middle of asterisks
        //b ||mti|3,kvstn|||load statement number as integer|26416
        ia = (word)(v.kvstn);				// load statement number as integer
        //b ||jsr|6,prtin|||print integer statement number|26417
        C_JSR(prtin);				// print integer statement number
        //b ||mov|3,profs|18,=prsnf||point past asterisks plus blank|26418
        v.profs= PRSNF;				// point past asterisks plus blank
        //b ||mov|7,xr|3,kvfnc||get fnclevel|26419
        xr= v.kvfnc;				// get fnclevel
        //b ||mov|8,wa|18,=ch_li||set letter i|26420
        wa= CH_LI;				// set letter i
//      loop to generate letter i fnclevel times
// prsn1:
        //b |prsn1|bze|7,xr|6,prsn2||jump if all set|26424
        C_GOTO(prsn1);
        } /* prtsn */
        

        void prsn1() {
        if ( !( xr) ) C_GOTO(prsn2);				// jump if all set
        //b ||jsr|6,prtch|||else print an i|26425
        C_JSR(prtch);				// else print an i
        //b ||dcv|7,xr|||decrement counter|26426
        (xr)--;				// decrement counter
        //b ||brn|6,prsn1|||loop back|26427
         C_GOTO(prsn1);				// loop back
//      merge with all letter i characters generated
// prsn2:
        //b |prsn2|mov|8,wa|18,=ch_bl||get blank|26431
        } /* prsn1 */
        

        void prsn2() {
        wa= CH_BL;				// get blank
        //b ||jsr|6,prtch|||print blank|26432
        C_JSR(prtch);				// print blank
        //b ||mov|8,wa|3,prsna||restore entry wa|26433
        wa= v.prsna;				// restore entry wa
        //b ||mov|7,xr|10,(xs)+||restore entry xr|26434
        xr= C_POP();				// restore entry xr
        //b ||exi||||return to prtsn caller|26435
        C_EXIT(0);				// return to prtsn caller
        //b ||ejc|||||26437
        
//      prtst -- print string
//      prtst places a string of characters in the print buffer
//      see prtnl for global locations used
//      note that the first word of the block (normally b_scl)
//      is not used and need not be set correctly (see prtvn)
//      (xr)                  string to be printed
//      jsr  prtst            call to print string
//      (profs)               updated past chars placed
// prtst:
        //b |prtst|prc|25,r|1,0||entry point|26452
        } /* prsn2 */
        

        void prtst() {
        //b ||bnz|3,headp|6,prst0||were headers printed|26453
        if (v.headp) C_GOTO(prst0);				// were headers printed
        //b ||jsr|6,prtps|||no - print them|26454
        C_JSR(prtps);				// no - print them
//      call syspr
// prst0:
        //b |prst0|mov|3,prsva|8,wa||save wa|26458
        C_GOTO(prst0);
        } /* prtst */
        

        void prst0() {
        v.prsva= wa;				// save wa
        //b ||mov|3,prsvb|8,wb||save wb|26459
        v.prsvb= wb;				// save wb
        //b ||zer|8,wb|||set chars printed count to zero|26460
        wb=0;				// set chars printed count to zero
//      loop to print successive lines for long string
// prst1:
        //b |prst1|mov|8,wa|13,sclen(xr)||load string length|26464
        C_GOTO(prst1);
        } /* prst0 */
        

        void prst1() {
        wa= *((word *)(CFP_B*SCLEN + xr));				// load string length
        //b ||sub|8,wa|8,wb||subtract count of chars already out|26465
        wa -= wb;				// subtract count of chars already out
        //b ||bze|8,wa|6,prst4||jump to exit if none left|26466
        if ( !( wa) ) C_GOTO(prst4);				// jump to exit if none left
        //b ||mov|11,-(xs)|7,xl||else stack entry xl|26467
        C_PUSH(xl);				// else stack entry xl
        //b ||mov|11,-(xs)|7,xr||save argument|26468
        C_PUSH(xr);				// save argument
        //b ||mov|7,xl|7,xr||copy for eventual move|26469
        xl= xr;				// copy for eventual move
        //b ||mov|7,xr|3,prlen||load print buffer length|26470
        xr= v.prlen;				// load print buffer length
        //b ||sub|7,xr|3,profs||get chars left in print buffer|26471
        xr -= v.profs;				// get chars left in print buffer
        //b ||bnz|7,xr|6,prst2||skip if room left on this line|26472
        if (xr) C_GOTO(prst2);				// skip if room left on this line
        //b ||jsr|6,prtnl|||else print this line|26473
        C_JSR(prtnl);				// else print this line
        //b ||mov|7,xr|3,prlen||and set full width available|26474
        xr= v.prlen;				// and set full width available
        //b ||ejc|||||26475
        
//      prtst (continued)
//      here with chars to print and some room in buffer
// prst2:
        //b |prst2|blo|8,wa|7,xr|6,prst3|jump if room for rest of string|26481
        C_GOTO(prst2);
        } /* prst1 */
        

        void prst2() {
        if ((wa-xr) < 0) C_GOTO(prst3);				// jump if room for rest of string
        //b ||mov|8,wa|7,xr||else set to fill line|26482
        wa= xr;				// else set to fill line
//      merge here with character count in wa
// prst3:
        //b |prst3|mov|7,xr|3,prbuf||point to print buffer|26486
        C_GOTO(prst3);
        } /* prst2 */
        

        void prst3() {
        xr= v.prbuf;				// point to print buffer
        //b ||plc|7,xl|8,wb||point to location in string|26487
        xl_it.chp += CFP_F + wb;				// point to location in string
        //b ||psc|7,xr|3,profs||point to location in buffer|26488
        xr_it.chp += CFP_F + v.profs;				// point to location in buffer
        //b ||add|8,wb|8,wa||bump string chars count|26489
        wb += wa;				// bump string chars count
        //b ||add|3,profs|8,wa||bump buffer pointer|26490
        v.profs += wa;				// bump buffer pointer
        //b ||mov|3,prsvc|8,wb||preserve char counter|26491
        v.prsvc= wb;				// preserve char counter
        //b ||mvc||||move characters to buffer|26492
        do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);				// move characters to buffer
        //b ||mov|8,wb|3,prsvc||recover char counter|26493
        wb= v.prsvc;				// recover char counter
        //b ||mov|7,xr|10,(xs)+||restore argument pointer|26494
        xr= C_POP();				// restore argument pointer
        //b ||mov|7,xl|10,(xs)+||restore entry xl|26495
        xl= C_POP();				// restore entry xl
        //b ||brn|6,prst1|||loop back to test for more|26496
         C_GOTO(prst1);				// loop back to test for more
//      here to exit after printing string
// prst4:
        //b |prst4|mov|8,wb|3,prsvb||restore entry wb|26500
        } /* prst3 */
        

        void prst4() {
        wb= v.prsvb;				// restore entry wb
        //b ||mov|8,wa|3,prsva||restore entry wa|26501
        wa= v.prsva;				// restore entry wa
        //b ||exi||||return to prtst caller|26502
        C_EXIT(0);				// return to prtst caller
        //b ||ejc|||||26504
        
//      prttr -- print to terminal
//      called to print contents of standard print buffer to
//      online terminal. clears buffer down and resets profs.
//      jsr  prttr            call for print
//      (wa,wb)               destroyed
// prttr:
        //b |prttr|prc|25,e|1,0||entry point|26514
        } /* prst4 */
        

        void prttr() {
        //b ||mov|11,-(xs)|7,xr||save xr|26515
        C_PUSH(xr);				// save xr
        //b ||jsr|6,prtic|||print buffer contents|26516
        C_JSR(prtic);				// print buffer contents
        //b ||mov|7,xr|3,prbuf||point to print bfr to clear it|26517
        xr= v.prbuf;				// point to print bfr to clear it
        //b ||lct|8,wa|3,prlnw||get buffer length|26518
        wa= v.prlnw;				// get buffer length
        //b ||add|7,xr|19,*schar||point past scblk header|26519
        xr += CFP_B*SCHAR;				// point past scblk header
        //b ||mov|8,wb|4,nullw||get blanks|26520
        wb= c.nullw;				// get blanks
//      loop to clear buffer
// prtt1:
        //b |prtt1|mov|10,(xr)+|8,wb||clear a word|26524
        C_GOTO(prtt1);
        } /* prttr */
        

        void prtt1() {
        *(xr_it.wp++)= wb;				// clear a word
        //b ||bct|8,wa|6,prtt1||loop|26525
        if ((--wa))  C_GOTO(prtt1);				// loop
        //b ||zer|3,profs|||reset profs|26526
        v.profs=0;				// reset profs
        //b ||mov|7,xr|10,(xs)+||restore xr|26527
        xr= C_POP();				// restore xr
        //b ||exi||||return|26528
        C_EXIT(0);				// return
        //b ||ejc|||||26530
        
//      prtvl -- print a value
//      prtvl places an appropriate character representation of
//      a data value in the print buffer for dump/trace use.
//      (xr)                  value to be printed
//      jsr  prtvl            call to print value
//      (wa,wb,wc,ra)         destroyed
// prtvl:
        //b |prtvl|prc|25,r|1,0||entry point, recursive|26541
        } /* prtt1 */
        

        void prtvl() {
        //b ||mov|11,-(xs)|7,xl||save entry xl|26542
        C_PUSH(xl);				// save entry xl
        //b ||mov|11,-(xs)|7,xr||save argument|26543
        C_PUSH(xr);				// save argument
        //b ||chk||||check for stack overflow|26544
        if(xs<v.lowspmin) { C_GOTO(sec06); } /* stack overflow check */				// check for stack overflow
//      loop back here after finding a trap block (trblk)
// prv01:
        //b |prv01|mov|3,prvsi|13,idval(xr)||copy idval (if any)|26548
        C_GOTO(prv01);
        } /* prtvl */
        

        void prv01() {
        v.prvsi= *((word *)(CFP_B*IDVAL + xr));				// copy idval (if any)
        //b ||mov|7,xl|9,(xr)||load first word of block|26549
        xl= *(xr_it.wp);				// load first word of block
        //b ||lei|7,xl|||load entry point id|26550
        xl = find_elab(xl);    /* get entry code */				// load entry point id
        //b ||bsw|7,xl|2,bl__t|6,prv02|switch on block type|26551
        if (xl - (word)(BL__T) >=0 )  { C_GOTO(prv02);}				// switch on block type
        extern word _l0700 [];
        { w0 = ((word *)_l0700)[xl];  C_GOTO(w0_it.callp);}
        }  /* prv01 */
        

        word  _l0700 [] = {
        //b ||iff|2,bl_ar|6,prv05||arblk|26569
        	(word)((word)(prv05)),				// arblk
        //b ||iff|1,1|6,prv02|||26569
        	(word)((word)(prv02)),
        //b ||iff|1,2|6,prv02|||26569
        	(word)((word)(prv02)),
        //b ||iff|2,bl_ic|6,prv08||icblk|26569
        	(word)((word)(prv08)),				// icblk
        //b ||iff|2,bl_nm|6,prv09||nmblk|26569
        	(word)((word)(prv09)),				// nmblk
        //b ||iff|1,5|6,prv02|||26569
        	(word)((word)(prv02)),
        //b ||iff|1,6|6,prv02|||26569
        	(word)((word)(prv02)),
        //b ||iff|1,7|6,prv02|||26569
        	(word)((word)(prv02)),
        //b ||iff|2,bl_rc|6,prv08||rcblk|26569
        	(word)((word)(prv08)),				// rcblk
        //b ||iff|2,bl_sc|6,prv11||scblk|26569
        	(word)((word)(prv11)),				// scblk
        //b ||iff|2,bl_se|6,prv12||seblk|26569
        	(word)((word)(prv12)),				// seblk
        //b ||iff|2,bl_tb|6,prv13||tbblk|26569
        	(word)((word)(prv13)),				// tbblk
        //b ||iff|2,bl_vc|6,prv13||vcblk|26569
        	(word)((word)(prv13)),				// vcblk
        //b ||iff|1,13|6,prv02|||26569
        	(word)((word)(prv02)),
        //b ||iff|1,14|6,prv02|||26569
        	(word)((word)(prv02)),
        //b ||iff|1,15|6,prv02|||26569
        	(word)((word)(prv02)),
        //b ||iff|2,bl_pd|6,prv10||pdblk|26569
        	(word)((word)(prv10)),				// pdblk
        //b ||iff|2,bl_tr|6,prv04||trblk|26569
        	(word)((word)(prv04)),				// trblk
        //b ||esw||||end of switch on block type|26569
             }; /* bsw list for _l0700 */				// end of switch on block type
//      here for blocks for which we just print datatype name
// prv02:
        //b |prv02|jsr|6,dtype|||get datatype name|26573
        void prv02() {
        C_JSR(dtype);				// get datatype name
        //b ||jsr|6,prtst|||print datatype name|26574
        C_JSR(prtst);				// print datatype name
//      common exit point
// prv03:
        //b |prv03|mov|7,xr|10,(xs)+||reload argument|26578
        C_GOTO(prv03);
        } /* prv02 */
        

        void prv03() {
        xr= C_POP();				// reload argument
        //b ||mov|7,xl|10,(xs)+||restore xl|26579
        xl= C_POP();				// restore xl
        //b ||exi||||return to prtvl caller|26580
        C_EXIT(0);				// return to prtvl caller
//      here for trblk
// prv04:
        //b |prv04|mov|7,xr|13,trval(xr)||load real value|26584
        } /* prv03 */
        

        void prv04() {
        xr= *((word *)(CFP_B*TRVAL + xr));				// load real value
        //b ||brn|6,prv01|||and loop back|26585
         C_GOTO(prv01);				// and loop back
        //b ||ejc|||||26586
        
//      prtvl (continued)
//      here for array (arblk)
//      print array ( prototype ) blank number idval
// prv05:
        //b |prv05|mov|7,xl|7,xr||preserve argument|26594
        } /* prv04 */
        

        void prv05() {
        xl= xr;				// preserve argument
        //b ||mov|7,xr|21,=scarr||point to datatype name (array)|26595
        xr= (word)(&c.scarr);				// point to datatype name (array)
        //b ||jsr|6,prtst|||print it|26596
        C_JSR(prtst);				// print it
        //b ||mov|8,wa|18,=ch_pp||load left paren|26597
        wa= CH_PP;				// load left paren
        //b ||jsr|6,prtch|||print left paren|26598
        C_JSR(prtch);				// print left paren
        //b ||add|7,xl|13,arofs(xl)||point to prototype|26599
        xl += *((word *)(CFP_B*AROFS + xl));				// point to prototype
        //b ||mov|7,xr|9,(xl)||load prototype|26600
        xr= *(xl_it.wp);				// load prototype
        //b ||jsr|6,prtst|||print prototype|26601
        C_JSR(prtst);				// print prototype
//      vcblk, tbblk, bcblk merge here for ) blank number idval
// prv06:
        //b |prv06|mov|8,wa|18,=ch_rp||load right paren|26605
        C_GOTO(prv06);
        } /* prv05 */
        

        void prv06() {
        wa= CH_RP;				// load right paren
        //b ||jsr|6,prtch|||print right paren|26606
        C_JSR(prtch);				// print right paren
//      pdblk merges here to print blank number idval
// prv07:
        //b |prv07|mov|8,wa|18,=ch_bl||load blank|26610
        C_GOTO(prv07);
        } /* prv06 */
        

        void prv07() {
        wa= CH_BL;				// load blank
        //b ||jsr|6,prtch|||print it|26611
        C_JSR(prtch);				// print it
        //b ||mov|8,wa|18,=ch_nm||load number sign|26612
        wa= CH_NM;				// load number sign
        //b ||jsr|6,prtch|||print it|26613
        C_JSR(prtch);				// print it
        //b ||mti|3,prvsi|||get idval|26614
        ia = (word)(v.prvsi);				// get idval
        //b ||jsr|6,prtin|||print id number|26615
        C_JSR(prtin);				// print id number
        //b ||brn|6,prv03|||back to exit|26616
         C_GOTO(prv03);				// back to exit
//      here for integer (icblk), real (rcblk)
//      print character representation of value
// prv08:
        //b |prv08|mov|11,-(xs)|7,xr||stack argument for gtstg|26622
        } /* prv07 */
        

        void prv08() {
        C_PUSH(xr);				// stack argument for gtstg
        //b ||ppm||||error return is impossible|26624
        extern void _l0701();
        C_JMS(gtstg,P_PRC_GTSTG,_l0701);
        } /* prv08 */
        

        void _l0701() {
        C_JMS_HANDLE_1(gtstg,(C_ERR(299)));				// error return is impossible
        //b ||jsr|6,prtst|||print the string|26625
        C_JSR(prtst);				// print the string
        //b ||mov|3,dnamp|7,xr||delete garbage string from storage|26626
        v.dnamp= xr;				// delete garbage string from storage
        //b ||brn|6,prv03|||back to exit|26627
         C_GOTO(prv03);				// back to exit
        //b ||ejc|||||26628
        
//      prtvl (continued)
//      name (nmblk)
//      for pseudo-variable, just print datatype name (name)
//      for all other names, print dot followed by name rep
// prv09:
        //b |prv09|mov|7,xl|13,nmbas(xr)||load name base|26637
        } /* _l0701 */
        

        void prv09() {
        xl= *((word *)(CFP_B*NMBAS + xr));				// load name base
        //b ||mov|8,wa|9,(xl)||load first word of block|26638
        wa= *(xl_it.wp);				// load first word of block
        //b ||beq|8,wa|22,=b_kvt|6,prv02|just print name if keyword|26639
        if ((wa-(word)(b_kvt)) == 0) C_GOTO(prv02);				// just print name if keyword
        //b ||beq|8,wa|22,=b_evt|6,prv02|just print name if expression var|26640
        if ((wa-(word)(b_evt)) == 0) C_GOTO(prv02);				// just print name if expression var
        //b ||mov|8,wa|18,=ch_dt||else get dot|26641
        wa= CH_DT;				// else get dot
        //b ||jsr|6,prtch|||and print it|26642
        C_JSR(prtch);				// and print it
        //b ||mov|8,wa|13,nmofs(xr)||load name offset|26643
        wa= *((word *)(CFP_B*NMOFS + xr));				// load name offset
        //b ||jsr|6,prtnm|||print name|26644
        C_JSR(prtnm);				// print name
        //b ||brn|6,prv03|||back to exit|26645
         C_GOTO(prv03);				// back to exit
//      program datatype (pdblk)
//      print datatype name ch_bl ch_nm idval
// prv10:
        //b |prv10|jsr|6,dtype|||get datatype name|26651
        } /* prv09 */
        

        void prv10() {
        C_JSR(dtype);				// get datatype name
        //b ||jsr|6,prtst|||print datatype name|26652
        C_JSR(prtst);				// print datatype name
        //b ||brn|6,prv07|||merge back to print id|26653
         C_GOTO(prv07);				// merge back to print id
//      here for string (scblk)
//      print quote string-characters quote
// prv11:
        //b |prv11|mov|8,wa|18,=ch_sq||load single quote|26659
        } /* prv10 */
        

        void prv11() {
        wa= CH_SQ;				// load single quote
        //b ||jsr|6,prtch|||print quote|26660
        C_JSR(prtch);				// print quote
        //b ||jsr|6,prtst|||print string value|26661
        C_JSR(prtst);				// print string value
        //b ||jsr|6,prtch|||print another quote|26662
        C_JSR(prtch);				// print another quote
        //b ||brn|6,prv03|||back to exit|26663
         C_GOTO(prv03);				// back to exit
        //b ||ejc|||||26664
        
//      prtvl (continued)
//      here for simple expression (seblk)
//      print asterisk variable-name
// prv12:
        //b |prv12|mov|8,wa|18,=ch_as||load asterisk|26672
        } /* prv11 */
        

        void prv12() {
        wa= CH_AS;				// load asterisk
        //b ||jsr|6,prtch|||print asterisk|26673
        C_JSR(prtch);				// print asterisk
        //b ||mov|7,xr|13,sevar(xr)||load variable pointer|26674
        xr= *((word *)(CFP_B*SEVAR + xr));				// load variable pointer
        //b ||jsr|6,prtvn|||print variable name|26675
        C_JSR(prtvn);				// print variable name
        //b ||brn|6,prv03|||jump back to exit|26676
         C_GOTO(prv03);				// jump back to exit
//      here for table (tbblk) and array (vcblk)
//      print datatype ( prototype ) blank number idval
// prv13:
        //b |prv13|mov|7,xl|7,xr||preserve argument|26682
        } /* prv12 */
        

        void prv13() {
        xl= xr;				// preserve argument
        //b ||jsr|6,dtype|||get datatype name|26683
        C_JSR(dtype);				// get datatype name
        //b ||jsr|6,prtst|||print datatype name|26684
        C_JSR(prtst);				// print datatype name
        //b ||mov|8,wa|18,=ch_pp||load left paren|26685
        wa= CH_PP;				// load left paren
        //b ||jsr|6,prtch|||print left paren|26686
        C_JSR(prtch);				// print left paren
        //b ||mov|8,wa|13,tblen(xl)||load length of block (=vclen)|26687
        wa= *((word *)(CFP_B*TBLEN + xl));				// load length of block (=vclen)
        //b ||btw|8,wa|||convert to word count|26688
        wa >>= LOG_CFP_B;				// convert to word count
        //b ||sub|8,wa|18,=tbsi_||allow for standard fields|26689
        wa -= TBSI_;				// allow for standard fields
        //b ||beq|9,(xl)|22,=b_tbt|6,prv14|jump if table|26690
        if ((*(xl_it.wp)-(word)(b_tbt)) == 0) C_GOTO(prv14);				// jump if table
        //b ||add|8,wa|18,=vctbd||for vcblk, adjust size|26691
        wa += VCTBD;				// for vcblk, adjust size
//      print prototype
// prv14:
        //b |prv14|mti|8,wa|||move as integer|26695
        C_GOTO(prv14);
        } /* prv13 */
        

        void prv14() {
        ia = (word)(wa);				// move as integer
        //b ||jsr|6,prtin|||print integer prototype|26696
        C_JSR(prtin);				// print integer prototype
        //b ||brn|6,prv06|||merge back for rest|26697
         C_GOTO(prv06);				// merge back for rest
        //b ||ejc|||||26721
        
//      prtvn -- print natural variable name
//      prtvn prints the name of a natural variable
//      (xr)                  pointer to vrblk
//      jsr  prtvn            call to print variable name
// prtvn:
        //b |prtvn|prc|25,e|1,0||entry point|26730
        } /* prv14 */
        

        void prtvn() {
        //b ||mov|11,-(xs)|7,xr||stack vrblk pointer|26731
        C_PUSH(xr);				// stack vrblk pointer
        //b ||add|7,xr|19,*vrsof||point to possible string name|26732
        xr += CFP_B*VRSOF;				// point to possible string name
        //b ||bnz|13,sclen(xr)|6,prvn1||jump if not system variable|26733
        if (*((word *)(CFP_B*SCLEN + xr))) C_GOTO(prvn1);				// jump if not system variable
        //b ||mov|7,xr|13,vrsvo(xr)||point to svblk with name|26734
        xr= *((word *)(CFP_B*VRSVO + xr));				// point to svblk with name
//      merge here with dummy scblk pointer in xr
// prvn1:
        //b |prvn1|jsr|6,prtst|||print string name of variable|26738
        C_GOTO(prvn1);
        } /* prtvn */
        

        void prvn1() {
        C_JSR(prtst);				// print string name of variable
        //b ||mov|7,xr|10,(xs)+||restore vrblk pointer|26739
        xr= C_POP();				// restore vrblk pointer
        //b ||exi||||return to prtvn caller|26740
        C_EXIT(0);				// return to prtvn caller
        //b ||ejc|||||26744
        
//      rcbld -- build a real block
//      (ra)                  real value for rcblk
//      jsr  rcbld            call to build real block
//      (xr)                  pointer to result rcblk
//      (wa)                  destroyed
// rcbld:
        //b |rcbld|prc|25,e|1,0||entry point|26753
        } /* prvn1 */
        

        void rcbld() {
        //b ||mov|7,xr|3,dnamp||load pointer to next available loc|26754
        xr= v.dnamp;				// load pointer to next available loc
        //b ||add|7,xr|19,*rcsi_||point past new rcblk|26755
        xr += CFP_B*RCSI_;				// point past new rcblk
        //b ||blo|7,xr|3,dname|6,rcbl1|jump if there is room|26756
        if ((xr-v.dname) < 0) C_GOTO(rcbl1);				// jump if there is room
        //b ||mov|8,wa|19,*rcsi_||else load rcblk length|26757
        wa= CFP_B*RCSI_;				// else load rcblk length
        //b ||jsr|6,alloc|||use standard allocator to get block|26758
        C_JSR(alloc);				// use standard allocator to get block
        //b ||add|7,xr|8,wa||point past block to merge|26759
        xr += wa;				// point past block to merge
//      merge here with xr pointing past the block obtained
// rcbl1:
        //b |rcbl1|mov|3,dnamp|7,xr||set new pointer|26763
        C_GOTO(rcbl1);
        } /* rcbld */
        

        void rcbl1() {
        v.dnamp= xr;				// set new pointer
        //b ||sub|7,xr|19,*rcsi_||point back to start of block|26764
        xr -= CFP_B*RCSI_;				// point back to start of block
        //b ||mov|9,(xr)|22,=b_rcl||store type word|26765
        *(xr_it.wp)= (word)(b_rcl);				// store type word
        //b ||str|13,rcval(xr)|||store real value in rcblk|26766
        *((word *)(CFP_B*RCVAL + xr)) = (ra_it.d);				// store real value in rcblk
        //b ||exi||||return to rcbld caller|26767
        C_EXIT(0);				// return to rcbld caller
        //b ||ejc|||||26770
        
//      readr -- read next source image at compile time
//      readr is used to read the next source image. to process
//      continuation cards properly, the compiler must read one
//      line ahead. thus readr does not destroy the current image
//      see also the nexts routine which actually gets the image.
//      jsr  readr            call to read next image
//      (xr)                  ptr to next image (0 if none)
//      (r_cni)               copy of pointer
//      (wa,wb,wc,xl)         destroyed
// readr:
        //b |readr|prc|25,e|1,0||entry point|26784
        } /* rcbl1 */
        

        void readr() {
        //b ||mov|7,xr|3,r_cni||get ptr to next image|26785
        xr= v.r_cni;				// get ptr to next image
        //b ||bnz|7,xr|6,read3||exit if already read|26786
        if (xr) C_GOTO(read3);				// exit if already read
        //b ||bnz|3,cnind|6,reada||if within include file|26788
        if (v.cnind) C_GOTO(reada);				// if within include file
        //b ||bne|3,stage|18,=stgic|6,read3|exit if not initial compile|26790
        if ((v.stage-STGIC) != 0) C_GOTO(read3);				// exit if not initial compile
// reada:
        //b |reada|mov|8,wa|3,cswin||max read length|26791
        C_GOTO(reada);
        } /* readr */
        

        void reada() {
        wa= v.cswin;				// max read length
        //b ||zer|7,xl|||clear any dud value in xl|26792
        xl=0;				// clear any dud value in xl
        //b ||jsr|6,alocs|||allocate buffer|26793
        C_JSR(alocs);				// allocate buffer
        //b ||ppm|6,read4|||jump if eof or new file name|26795
        C_JSR_1(sysrd,C_GOTO(read4));				// jump if eof or new file name
        //b ||icv|3,rdnln|||increment next line number|26796
        (v.rdnln)++;				// increment next line number
        //b ||dcv|3,polct|||test if time to poll interface|26798
        (v.polct)--;				// test if time to poll interface
        //b ||bnz|3,polct|6,read0||not yet|26799
        if (v.polct) C_GOTO(read0);				// not yet
        //b ||zer|8,wa|||=0 for poll|26800
        wa=0;				// =0 for poll
        //b ||mov|8,wb|3,rdnln||line number|26801
        wb= v.rdnln;				// line number
        //b ||ppm||||expression evaluation|26805
        C_JSR_3(syspl,(C_ERR(320)),(C_ERR(299)),(C_ERR(299)));				// expression evaluation
        //b ||mov|3,polcs|8,wa||new countdown start value|26806
        v.polcs= wa;				// new countdown start value
        //b ||mov|3,polct|8,wa||new counter value|26807
        v.polct= wa;				// new counter value
// read0:
        //b |read0|ble|13,sclen(xr)|3,cswin|6,read1|use smaller of string lnth ...|26809
        C_GOTO(read0);
        } /* reada */
        

        void read0() {
        if ((*((word *)(CFP_B*SCLEN + xr))-v.cswin) <= 0) C_GOTO(read1);				// use smaller of string lnth ...
        //b ||mov|13,sclen(xr)|3,cswin||... and xxx of -inxxx|26810
        *((word *)(CFP_B*SCLEN + xr))= v.cswin;				// ... and xxx of -inxxx
//      perform the trim
// read1:
        //b |read1|mnz|8,wb|||set trimr to perform trim|26814
        C_GOTO(read1);
        } /* read0 */
        

        void read1() {
        wb = 0xffffffffffffffff;				// set trimr to perform trim
        //b ||jsr|6,trimr|||trim trailing blanks|26815
        C_JSR(trimr);				// trim trailing blanks
//      merge here after read
// read2:
        //b |read2|mov|3,r_cni|7,xr||store copy of pointer|26819
        C_GOTO(read2);
        } /* read1 */
        

        void read2() {
        v.r_cni= xr;				// store copy of pointer
//      merge here if no read attempted
// read3:
        //b |read3|exi||||return to readr caller|26823
        C_GOTO(read3);
        } /* read2 */
        

        void read3() {
        C_EXIT(0);				// return to readr caller
//      here on end of file or new source file name.
//      if this is a new source file name, the r_sfn table will
//      be augmented with a new table entry consisting of the
//      current compiler statement number as subscript, and the
//      file name as value.
// read4:
        //b |read4|bze|13,sclen(xr)|6,read5||jump if true end of file|26832
        } /* read3 */
        

        void read4() {
        if ( !( *((word *)(CFP_B*SCLEN + xr))) ) C_GOTO(read5);				// jump if true end of file
        //b ||zer|8,wb|||new source file name|26833
        wb=0;				// new source file name
        //b ||mov|3,rdnln|8,wb||restart line counter for new file|26834
        v.rdnln= wb;				// restart line counter for new file
        //b ||jsr|6,trimr|||remove unused space in block|26835
        C_JSR(trimr);				// remove unused space in block
        //b ||jsr|6,newfn|||record new file name|26836
        C_JSR(newfn);				// record new file name
        //b ||brn|6,reada|||now reissue read for record data|26837
         C_GOTO(reada);				// now reissue read for record data
//      here on end of file
// read5:
        //b |read5|mov|3,dnamp|7,xr||pop unused scblk|26841
        } /* read4 */
        

        void read5() {
        v.dnamp= xr;				// pop unused scblk
        //b ||bze|3,cnind|6,read6||jump if not within an include file|26843
        if ( !( v.cnind) ) C_GOTO(read6);				// jump if not within an include file
        //b ||zer|7,xl|||eof within include file|26844
        xl=0;				// eof within include file
        //b ||ppm|||||26846
        C_JSR_1(sysif,(C_ERR(299)));
        //b ||mov|8,wa|3,cnind||restore prev line number, file name|26847
        wa= v.cnind;				// restore prev line number, file name
        //b ||add|8,wa|18,=vcvlb||vector offset in words|26848
        wa += VCVLB;				// vector offset in words
        //b ||wtb|8,wa|||convert to bytes|26849
        wa <<= LOG_CFP_B;				// convert to bytes
        //b ||mov|7,xr|3,r_ifa||file name array|26850
        xr= v.r_ifa;				// file name array
        //b ||add|7,xr|8,wa||ptr to element|26851
        xr += wa;				// ptr to element
        //b ||mov|3,r_sfc|9,(xr)||change source file name|26852
        v.r_sfc= *(xr_it.wp);				// change source file name
        //b ||mov|9,(xr)|21,=nulls||release scblk|26853
        *(xr_it.wp)= (word)(&c.nulls);				// release scblk
        //b ||mov|7,xr|3,r_ifl||line number array|26854
        xr= v.r_ifl;				// line number array
        //b ||add|7,xr|8,wa||ptr to element|26855
        xr += wa;				// ptr to element
        //b ||mov|7,xl|9,(xr)||icblk containing saved line number|26856
        xl= *(xr_it.wp);				// icblk containing saved line number
        //b ||ldi|13,icval(xl)|||line number integer|26857
        ia = *((word *)(CFP_B*ICVAL + xl));				// line number integer
        //b ||mfi|3,rdnln|||change source line number|26858
        v.rdnln = ia;				// change source line number
        //b ||mov|9,(xr)|21,=inton||release icblk|26859
        *(xr_it.wp)= (word)(&c.inton);				// release icblk
        //b ||dcv|3,cnind|||decrement nesting level|26860
        (v.cnind)--;				// decrement nesting level
        //b ||mov|8,wb|3,cmpsn||current statement number|26861
        wb= v.cmpsn;				// current statement number
        //b ||icv|8,wb|||anticipate end of previous stmt|26862
        (wb)++;				// anticipate end of previous stmt
        //b ||mti|8,wb|||convert to integer|26863
        ia = (word)(wb);				// convert to integer
        //b ||jsr|6,icbld|||build icblk for stmt number|26864
        C_JSR(icbld);				// build icblk for stmt number
        //b ||mov|7,xl|3,r_sfn||file name table|26865
        xl= v.r_sfn;				// file name table
        //b ||mnz|8,wb|||lookup statement number by name|26866
        wb = 0xffffffffffffffff;				// lookup statement number by name
        //b ||ppm||||always possible to allocate block|26868
        C_JSR_1(tfind,(C_ERR(299)));				// always possible to allocate block
        //b ||mov|13,teval(xl)|3,r_sfc||record file name as entry value|26869
        *((word *)(CFP_B*TEVAL + xl))= v.r_sfc;				// record file name as entry value
        //b ||beq|3,stage|18,=stgic|6,reada|if initial compile, reissue read|26870
        if ((v.stage-STGIC) == 0) C_GOTO(reada);				// if initial compile, reissue read
        //b ||bnz|3,cnind|6,reada||still reading from include file|26871
        if (v.cnind) C_GOTO(reada);				// still reading from include file
//      outer nesting of execute-time compile of -include
//      resume with any string remaining prior to -include.
        //b ||mov|7,xl|3,r_ici||restore code argument string|26876
        xl= v.r_ici;				// restore code argument string
        //b ||zer|3,r_ici|||release original string|26877
        v.r_ici=0;				// release original string
        //b ||mov|8,wa|3,cnsil||get length of string|26878
        wa= v.cnsil;				// get length of string
        //b ||mov|8,wb|3,cnspt||offset of characters left|26879
        wb= v.cnspt;				// offset of characters left
        //b ||sub|8,wa|8,wb||number of characters left|26880
        wa -= wb;				// number of characters left
        //b ||mov|3,scnil|8,wa||set new scan length|26881
        v.scnil= wa;				// set new scan length
        //b ||zer|3,scnpt|||scan from start of substring|26882
        v.scnpt=0;				// scan from start of substring
        //b ||jsr|6,sbstr|||create substring of remainder|26883
        C_JSR(sbstr);				// create substring of remainder
        //b ||mov|3,r_cim|7,xr||set scan image|26884
        v.r_cim= xr;				// set scan image
        //b ||brn|6,read2|||return|26885
         C_GOTO(read2);				// return
// read6:
        //b |read6|zer|7,xr|||zero ptr as result|26901
        } /* read5 */
        

        void read6() {
        xr=0;				// zero ptr as result
        //b ||brn|6,read2|||merge|26902
         C_GOTO(read2);				// merge
        //b ||ejc|||||26904
        
//      sbstr -- build a substring
//      (xl)                  ptr to scblk/bfblk with chars
//      (wa)                  number of chars in substring
//      (wb)                  offset to first char in scblk
//      jsr  sbstr            call to build substring
//      (xr)                  ptr to new scblk with substring
//      (xl)                  zero
//      (wa,wb,wc,xl,ia)      destroyed
//      note that sbstr is called with a dummy string pointer
//      (pointing into a vrblk or svblk) to copy the name of a
//      variable as a standard string value.
// sbstr:
        //b |sbstr|prc|25,e|1,0||entry point|26999
        } /* read6 */
        

        void sbstr() {
        //b ||bze|8,wa|6,sbst2||jump if null substring|27000
        if ( !( wa) ) C_GOTO(sbst2);				// jump if null substring
        //b ||jsr|6,alocs|||else allocate scblk|27001
        C_JSR(alocs);				// else allocate scblk
        //b ||mov|8,wa|8,wc||move number of characters|27002
        wa= wc;				// move number of characters
        //b ||mov|8,wc|7,xr||save ptr to new scblk|27003
        wc= xr;				// save ptr to new scblk
        //b ||plc|7,xl|8,wb||prepare to load chars from old blk|27004
        xl_it.chp += CFP_F + wb;				// prepare to load chars from old blk
        //b ||psc|7,xr|||prepare to store chars in new blk|27005
        xr += CFP_F;				// prepare to store chars in new blk
        //b ||mvc||||move characters to new string|27006
        do  { *(xr_it.chp++)= *(xl_it.chp++); } while (--wa);				// move characters to new string
        //b ||mov|7,xr|8,wc||then restore scblk pointer|27007
        xr= wc;				// then restore scblk pointer
//      return point
// sbst1:
        //b |sbst1|zer|7,xl|||clear garbage pointer in xl|27011
        C_GOTO(sbst1);
        } /* sbstr */
        

        void sbst1() {
        xl=0;				// clear garbage pointer in xl
        //b ||exi||||return to sbstr caller|27012
        C_EXIT(0);				// return to sbstr caller
//      here for null substring
// sbst2:
        //b |sbst2|mov|7,xr|21,=nulls||set null string as result|27016
        } /* sbst1 */
        

        void sbst2() {
        xr= (word)(&c.nulls);				// set null string as result
        //b ||brn|6,sbst1|||return|27017
         C_GOTO(sbst1);				// return
        //b ||ejc|||||27019
        
//      stgcc -- compute counters for stmt startup testing
//      jsr  stgcc            call to recompute counters
//      (wa,wb)               destroyed
//      on exit, stmcs and stmct contain the counter value to
//      tested in stmgo.
// stgcc:
        //b |stgcc|prc|25,e|1,0|||27030
        } /* sbst2 */
        

        void stgcc() {
        //b ||mov|8,wa|3,polcs||assume no profiling or stcount tracing|27032
        wa= v.polcs;				// assume no profiling or stcount tracing
        //b ||mov|8,wb|18,=num01||poll each time polcs expires|27033
        wb= NUM01;				// poll each time polcs expires
        //b ||ldi|3,kvstl|||get stmt limit|27037
        ia = v.kvstl;				// get stmt limit
        //b ||bnz|3,kvpfl|6,stgc1||jump if profiling enabled|27038
        if (v.kvpfl) C_GOTO(stgc1);				// jump if profiling enabled
        //b ||ilt|6,stgc3|||no stcount tracing if negative|27039
        if (ia < 0)  C_GOTO(stgc3);				// no stcount tracing if negative
        //b ||bze|3,r_stc|6,stgc2||jump if not stcount tracing|27040
        if ( !( v.r_stc) ) C_GOTO(stgc2);				// jump if not stcount tracing
//      here if profiling or if stcount tracing enabled
// stgc1:
        //b |stgc1|mov|8,wb|8,wa||count polcs times within stmg|27045
        C_GOTO(stgc1);
        } /* stgcc */
        

        void stgc1() {
        wb= wa;				// count polcs times within stmg
        //b ||mov|8,wa|18,=num01||break out of stmgo on each stmt|27046
        wa= NUM01;				// break out of stmgo on each stmt
        //b ||brn|6,stgc3||||27050
         C_GOTO(stgc3);
//      check that stmcs does not exceed kvstl
// stgc2:
        //b |stgc2|mti|8,wa|||breakout count start value|27054
        } /* stgc1 */
        

        void stgc2() {
        ia = (word)(wa);				// breakout count start value
        //b ||sbi|3,kvstl|||proposed stmcs minus stmt limit|27055
        ia-=v.kvstl;				// proposed stmcs minus stmt limit
        //b ||ile|6,stgc3|||jump if stmt count does not limit|27056
        if (ia <= 0)  C_GOTO(stgc3);				// jump if stmt count does not limit
        //b ||ldi|3,kvstl|||stlimit limits breakcount count|27057
        ia = v.kvstl;				// stlimit limits breakcount count
        //b ||mfi|8,wa|||use it instead|27058
        wa = ia;				// use it instead
//      re-initialize counter
// stgc3:
        //b |stgc3|mov|3,stmcs|8,wa||update breakout count start value|27062
        C_GOTO(stgc3);
        } /* stgc2 */
        

        void stgc3() {
        v.stmcs= wa;				// update breakout count start value
        //b ||mov|3,stmct|8,wa||reset breakout counter|27063
        v.stmct= wa;				// reset breakout counter
        //b ||mov|3,polct|8,wb|||27065
        v.polct= wb;
        //b ||exi|||||27067
        C_EXIT(0);
        //b ||ejc|||||27068
        
//      tfind -- locate table element
//      (xr)                  subscript value for element
//      (xl)                  pointer to table
//      (wb)                  zero by value, non-zero by name
//      jsr  tfind            call to locate element
//      ppm  loc              transfer location if access fails
//      (xr)                  element value (if by value)
//      (xr)                  destroyed (if by name)
//      (xl,wa)               teblk name (if by name)
//      (xl,wa)               destroyed (if by value)
//      (wc,ra)               destroyed
//      note that if a call by value specifies a non-existent
//      subscript, the default value is returned without building
//      a new teblk.
// tfind:
        //b |tfind|prc|25,e|1,1||entry point|27087
        } /* stgc3 */
        

        void tfind() {
        //b ||mov|11,-(xs)|8,wb||save name/value indicator|27088
        C_PUSH(wb);				// save name/value indicator
        //b ||mov|11,-(xs)|7,xr||save subscript value|27089
        C_PUSH(xr);				// save subscript value
        //b ||mov|11,-(xs)|7,xl||save table pointer|27090
        C_PUSH(xl);				// save table pointer
        //b ||mov|8,wa|13,tblen(xl)||load length of tbblk|27091
        wa= *((word *)(CFP_B*TBLEN + xl));				// load length of tbblk
        //b ||btw|8,wa|||convert to word count|27092
        wa >>= LOG_CFP_B;				// convert to word count
        //b ||sub|8,wa|18,=tbbuk||get number of buckets|27093
        wa -= TBBUK;				// get number of buckets
        //b ||mti|8,wa|||convert to integer value|27094
        ia = (word)(wa);				// convert to integer value
        //b ||sti|3,tfnsi|||save for later|27095
        v.tfnsi= ia;				// save for later
        //b ||mov|7,xl|9,(xr)||load first word of subscript|27096
        xl= *(xr_it.wp);				// load first word of subscript
        //b ||lei|7,xl|||load block entry id (bl_xx)|27097
        xl = find_elab(xl);    /* get entry code */				// load block entry id (bl_xx)
        //b ||bsw|7,xl|2,bl__d|6,tfn00|switch on block type|27098
        if (xl - (word)(BL__D) >=0 )  { C_GOTO(tfn00);}				// switch on block type
        extern word _l0703 [];
        { w0 = ((word *)_l0703)[xl];  C_GOTO(w0_it.callp);}
        }  /* tfind */
        

        word  _l0703 [] = {
        //b ||iff|1,0|6,tfn00|||27109
        	(word)((word)(tfn00)),
        //b ||iff|1,1|6,tfn00|||27109
        	(word)((word)(tfn00)),
        //b ||iff|1,2|6,tfn00|||27109
        	(word)((word)(tfn00)),
        //b ||iff|2,bl_ic|6,tfn02||jump if integer|27109
        	(word)((word)(tfn02)),				// jump if integer
        //b ||iff|2,bl_nm|6,tfn04||jump if name|27109
        	(word)((word)(tfn04)),				// jump if name
        //b ||iff|2,bl_p0|6,tfn03||jump if pattern|27109
        	(word)((word)(tfn03)),				// jump if pattern
        //b ||iff|2,bl_p1|6,tfn03||jump if pattern|27109
        	(word)((word)(tfn03)),				// jump if pattern
        //b ||iff|2,bl_p2|6,tfn03||jump if pattern|27109
        	(word)((word)(tfn03)),				// jump if pattern
        //b ||iff|2,bl_rc|6,tfn02||real|27109
        	(word)((word)(tfn02)),				// real
        //b ||iff|2,bl_sc|6,tfn05||jump if string|27109
        	(word)((word)(tfn05)),				// jump if string
        //b ||iff|1,10|6,tfn00|||27109
        	(word)((word)(tfn00)),
        //b ||iff|1,11|6,tfn00|||27109
        	(word)((word)(tfn00)),
        //b ||iff|1,12|6,tfn00|||27109
        	(word)((word)(tfn00)),
        //b ||iff|1,13|6,tfn00|||27109
        	(word)((word)(tfn00)),
        //b ||iff|1,14|6,tfn00|||27109
        	(word)((word)(tfn00)),
        //b ||iff|1,15|6,tfn00|||27109
        	(word)((word)(tfn00)),
        //b ||iff|1,16|6,tfn00|||27109
        	(word)((word)(tfn00)),
        //b ||esw||||end switch on block type|27109
             }; /* bsw list for _l0703 */				// end switch on block type
//      here for blocks for which we use the second word of the
//      block as the hash source (see block formats for details).
// tfn00:
        //b |tfn00|mov|8,wa|12,1(xr)||load second word|27114
        void tfn00() {
        wa= *((word *)(CFP_B*1 + xr));				// load second word
//      merge here with one word hash source in wa
// tfn01:
        //b |tfn01|mti|8,wa|||convert to integer|27118
        C_GOTO(tfn01);
        } /* tfn00 */
        

        void tfn01() {
        ia = (word)(wa);				// convert to integer
        //b ||brn|6,tfn06|||jump to merge|27119
         C_GOTO(tfn06);				// jump to merge
        //b ||ejc|||||27120
        
//      tfind (continued)
//      here for integer or real
//      possibility of overflow exist on twos complement
//      machine if hash source is most negative integer or is
//      a real having the same bit pattern.
// tfn02:
        //b |tfn02|ldi|12,1(xr)|||load value as hash source|27130
        } /* tfn01 */
        

        void tfn02() {
        ia = *((word *)(CFP_B*1 + xr));				// load value as hash source
        //b ||ige|6,tfn06|||ok if positive or zero|27131
        if (ia >= 0)  C_GOTO(tfn06);				// ok if positive or zero
        //b ||ngi||||make positive|27132
        ia= -ia;				// make positive
        //b ||iov|6,tfn06|||clear possible overflow|27133
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// clear possible overflow
        //b ||brn|6,tfn06|||merge|27134
         C_GOTO(tfn06);				// merge
//      for pattern, use first word (pcode) as source
// tfn03:
        //b |tfn03|mov|8,wa|9,(xr)||load first word as hash source|27138
        } /* tfn02 */
        

        void tfn03() {
        wa= *(xr_it.wp);				// load first word as hash source
        //b ||brn|6,tfn01|||merge back|27139
         C_GOTO(tfn01);				// merge back
//      for name, use offset as hash source
// tfn04:
        //b |tfn04|mov|8,wa|13,nmofs(xr)||load offset as hash source|27143
        } /* tfn03 */
        

        void tfn04() {
        wa= *((word *)(CFP_B*NMOFS + xr));				// load offset as hash source
        //b ||brn|6,tfn01|||merge back|27144
         C_GOTO(tfn01);				// merge back
//      here for string
// tfn05:
        //b |tfn05|jsr|6,hashs|||call routine to compute hash|27148
        } /* tfn04 */
        

        void tfn05() {
        C_JSR(hashs);				// call routine to compute hash
//      merge here with hash source in (ia)
// tfn06:
        //b |tfn06|rmi|3,tfnsi|||compute hash index by remaindering|27152
        C_GOTO(tfn06);
        } /* tfn05 */
        

        void tfn06() {
        ia=ia % v.tfnsi;				// compute hash index by remaindering
        //b ||mfi|8,wc|||get as one word integer|27153
        wc = ia;				// get as one word integer
        //b ||wtb|8,wc|||convert to byte offset|27154
        wc <<= LOG_CFP_B;				// convert to byte offset
        //b ||mov|7,xl|9,(xs)||get table ptr again|27155
        xl= *(xs_it.wp);				// get table ptr again
        //b ||add|7,xl|8,wc||point to proper bucket|27156
        xl += wc;				// point to proper bucket
        //b ||mov|7,xr|13,tbbuk(xl)||load first teblk pointer|27157
        xr= *((word *)(CFP_B*TBBUK + xl));				// load first teblk pointer
        //b ||beq|7,xr|9,(xs)|6,tfn10|jump if no teblks on chain|27158
        if ((xr-*(xs_it.wp)) == 0) C_GOTO(tfn10);				// jump if no teblks on chain
//      loop through teblks on hash chain
// tfn07:
        //b |tfn07|mov|8,wb|7,xr||save teblk pointer|27162
        C_GOTO(tfn07);
        } /* tfn06 */
        

        void tfn07() {
        wb= xr;				// save teblk pointer
        //b ||mov|7,xr|13,tesub(xr)||load subscript value|27163
        xr= *((word *)(CFP_B*TESUB + xr));				// load subscript value
        //b ||mov|7,xl|12,1(xs)||load input argument subscript val|27164
        xl= *((word *)(CFP_B*1 + xs));				// load input argument subscript val
        //b ||ppm|6,tfn08|||jump if equal (ident)|27166
        C_JSR_1(ident,C_GOTO(tfn08));				// jump if equal (ident)
//      here if no match with that teblk
        //b ||mov|7,xl|8,wb||restore teblk pointer|27170
        xl= wb;				// restore teblk pointer
        //b ||mov|7,xr|13,tenxt(xl)||point to next teblk on chain|27171
        xr= *((word *)(CFP_B*TENXT + xl));				// point to next teblk on chain
        //b ||bne|7,xr|9,(xs)|6,tfn07|jump if there is one|27172
        if ((xr-*(xs_it.wp)) != 0) C_GOTO(tfn07);				// jump if there is one
//      here if no match with any teblk on chain
        //b ||mov|8,wc|19,*tenxt||set offset to link field (xl base)|27176
        wc= CFP_B*TENXT;				// set offset to link field (xl base)
        //b ||brn|6,tfn11|||jump to merge|27177
         C_GOTO(tfn11);				// jump to merge
        //b ||ejc|||||27178
        
//      tfind (continued)
//      here we have found a matching element
// tfn08:
        //b |tfn08|mov|7,xl|8,wb||restore teblk pointer|27184
        } /* tfn07 */
        

        void tfn08() {
        xl= wb;				// restore teblk pointer
        //b ||mov|8,wa|19,*teval||set teblk name offset|27185
        wa= CFP_B*TEVAL;				// set teblk name offset
        //b ||mov|8,wb|12,2(xs)||restore name/value indicator|27186
        wb= *((word *)(CFP_B*2 + xs));				// restore name/value indicator
        //b ||bnz|8,wb|6,tfn09||jump if called by name|27187
        if (wb) C_GOTO(tfn09);				// jump if called by name
        //b ||ppm|6,tfn12|||jump if reference fails|27189
        C_JSR_1(acess,C_GOTO(tfn12));				// jump if reference fails
        //b ||zer|8,wb|||restore name/value indicator|27190
        wb=0;				// restore name/value indicator
//      common exit for entry found
// tfn09:
        //b |tfn09|add|7,xs|19,*num03||pop stack entries|27194
        C_GOTO(tfn09);
        } /* tfn08 */
        

        void tfn09() {
        xs += CFP_B*NUM03;				// pop stack entries
        //b ||exi||||return to tfind caller|27195
        C_EXIT(0);				// return to tfind caller
//      here if no teblks on the hash chain
// tfn10:
        //b |tfn10|add|8,wc|19,*tbbuk||get offset to bucket ptr|27199
        } /* tfn09 */
        

        void tfn10() {
        wc += CFP_B*TBBUK;				// get offset to bucket ptr
        //b ||mov|7,xl|9,(xs)||set tbblk ptr as base|27200
        xl= *(xs_it.wp);				// set tbblk ptr as base
//      merge here with (xl,wc) base,offset of final link
// tfn11:
        //b |tfn11|mov|7,xr|9,(xs)||tbblk pointer|27204
        C_GOTO(tfn11);
        } /* tfn10 */
        

        void tfn11() {
        xr= *(xs_it.wp);				// tbblk pointer
        //b ||mov|7,xr|13,tbinv(xr)||load default value in case|27205
        xr= *((word *)(CFP_B*TBINV + xr));				// load default value in case
        //b ||mov|8,wb|12,2(xs)||load name/value indicator|27206
        wb= *((word *)(CFP_B*2 + xs));				// load name/value indicator
        //b ||bze|8,wb|6,tfn09||exit with default if value call|27207
        if ( !( wb) ) C_GOTO(tfn09);				// exit with default if value call
        //b ||mov|8,wb|7,xr||copy default value|27208
        wb= xr;				// copy default value
//      here we must build a new teblk
        //b ||mov|8,wa|19,*tesi_||set size of teblk|27212
        wa= CFP_B*TESI_;				// set size of teblk
        //b ||jsr|6,alloc|||allocate teblk|27213
        C_JSR(alloc);				// allocate teblk
        //b ||add|7,xl|8,wc||point to hash link|27214
        xl += wc;				// point to hash link
        //b ||mov|9,(xl)|7,xr||link new teblk at end of chain|27215
        *(xl_it.wp)= xr;				// link new teblk at end of chain
        //b ||mov|9,(xr)|22,=b_tet||store type word|27216
        *(xr_it.wp)= (word)(b_tet);				// store type word
        //b ||mov|13,teval(xr)|8,wb||set default as initial value|27217
        *((word *)(CFP_B*TEVAL + xr))= wb;				// set default as initial value
        //b ||mov|13,tenxt(xr)|10,(xs)+||set tbblk ptr to mark end of chain|27218
        *((word *)(CFP_B*TENXT + xr))= C_POP();				// set tbblk ptr to mark end of chain
        //b ||mov|13,tesub(xr)|10,(xs)+||store subscript value|27219
        *((word *)(CFP_B*TESUB + xr))= C_POP();				// store subscript value
        //b ||mov|8,wb|10,(xs)+||restore name/value indicator|27220
        wb= C_POP();				// restore name/value indicator
        //b ||mov|7,xl|7,xr||copy teblk pointer (name base)|27221
        xl= xr;				// copy teblk pointer (name base)
        //b ||mov|8,wa|19,*teval||set offset|27222
        wa= CFP_B*TEVAL;				// set offset
        //b ||exi||||return to caller with new teblk|27223
        C_EXIT(0);				// return to caller with new teblk
//      acess fail return
// tfn12:
        //b |tfn12|exi|1,1|||alternative return|27227
        } /* tfn11 */
        

        void tfn12() {
        C_EXIT(1);				// alternative return
        //b ||ejc|||||27229
        
//      tmake -- make new table
//      (xl)                  initial lookup value
//      (wc)                  number of buckets desired
//      jsr  tmake            call to make new table
//      (xr)                  new table
//      (wa,wb)               destroyed
// tmake:
        //b |tmake|prc|25,e|1,0|||27239
        } /* tfn12 */
        

        void tmake() {
        //b ||mov|8,wa|8,wc||copy number of headers|27240
        wa= wc;				// copy number of headers
        //b ||add|8,wa|18,=tbsi_||adjust for standard fields|27241
        wa += TBSI_;				// adjust for standard fields
        //b ||wtb|8,wa|||convert length to bytes|27242
        wa <<= LOG_CFP_B;				// convert length to bytes
        //b ||jsr|6,alloc|||allocate space for tbblk|27243
        C_JSR(alloc);				// allocate space for tbblk
        //b ||mov|8,wb|7,xr||copy pointer to tbblk|27244
        wb= xr;				// copy pointer to tbblk
        //b ||mov|10,(xr)+|22,=b_tbt||store type word|27245
        *(xr_it.wp++)= (word)(b_tbt);				// store type word
        //b ||zer|10,(xr)+|||zero id for the moment|27246
        *(xr_it.wp++)=0;				// zero id for the moment
        //b ||mov|10,(xr)+|8,wa||store length (tblen)|27247
        *(xr_it.wp++)= wa;				// store length (tblen)
        //b ||mov|10,(xr)+|7,xl||store initial lookup value|27248
        *(xr_it.wp++)= xl;				// store initial lookup value
        //b ||lct|8,wc|8,wc||set loop counter (num headers)|27249
        wc= wc;				// set loop counter (num headers)
//      loop to initialize all bucket pointers
// tma01:
        //b |tma01|mov|10,(xr)+|8,wb||store tbblk ptr in bucket header|27253
        C_GOTO(tma01);
        } /* tmake */
        

        void tma01() {
        *(xr_it.wp++)= wb;				// store tbblk ptr in bucket header
        //b ||bct|8,wc|6,tma01||loop till all stored|27254
        if ((--wc))  C_GOTO(tma01);				// loop till all stored
        //b ||mov|7,xr|8,wb||recall pointer to tbblk|27255
        xr= wb;				// recall pointer to tbblk
        //b ||exi|||||27256
        C_EXIT(0);
        //b ||ejc|||||27258
        
//      vmake -- create a vector
//      (wa)                  number of elements in vector
//      (xl)                  default value for vector elements
//      jsr  vmake            call to create vector
//      ppm  loc              if vector too large
//      (xr)                  pointer to vcblk
//      (wa,wb,wc,xl)         destroyed
// vmake:
        //b |vmake|prc|25,e|1,1||entry point|27270
        } /* tma01 */
        

        void vmake() {
        //b ||lct|8,wb|8,wa||copy elements for loop later on|27271
        wb= wa;				// copy elements for loop later on
        //b ||add|8,wa|18,=vcsi_||add space for standard fields|27272
        wa += VCSI_;				// add space for standard fields
        //b ||wtb|8,wa|||convert length to bytes|27273
        wa <<= LOG_CFP_B;				// convert length to bytes
        //b ||bgt|8,wa|3,mxlen|6,vmak2|fail if too large|27274
        if ((wa-v.mxlen) > 0) C_GOTO(vmak2);				// fail if too large
        //b ||jsr|6,alloc|||allocate space for vcblk|27275
        C_JSR(alloc);				// allocate space for vcblk
        //b ||mov|9,(xr)|22,=b_vct||store type word|27276
        *(xr_it.wp)= (word)(b_vct);				// store type word
        //b ||zer|13,idval(xr)|||initialize idval|27277
        *((word *)(CFP_B*IDVAL + xr))=0;				// initialize idval
        //b ||mov|13,vclen(xr)|8,wa||set length|27278
        *((word *)(CFP_B*VCLEN + xr))= wa;				// set length
        //b ||mov|8,wc|7,xl||copy default value|27279
        wc= xl;				// copy default value
        //b ||mov|7,xl|7,xr||copy vcblk pointer|27280
        xl= xr;				// copy vcblk pointer
        //b ||add|7,xl|19,*vcvls||point to first element value|27281
        xl += CFP_B*VCVLS;				// point to first element value
//      loop to set vector elements to default value
// vmak1:
        //b |vmak1|mov|10,(xl)+|8,wc||store one value|27285
        C_GOTO(vmak1);
        } /* vmake */
        

        void vmak1() {
        *(xl_it.wp++)= wc;				// store one value
        //b ||bct|8,wb|6,vmak1||loop till all stored|27286
        if ((--wb))  C_GOTO(vmak1);				// loop till all stored
        //b ||exi||||success return|27287
        C_EXIT(0);				// success return
//      here if desired vector size too large
// vmak2:
        //b |vmak2|exi|1,1|||fail return|27291
        } /* vmak1 */
        

        void vmak2() {
        C_EXIT(1);				// fail return
        //b ||ejc|||||27293
        
//      scane -- scan an element
//      scane is called at compile time (by expan ,cmpil,cncrd)
//      to scan one element from the input image.
//      (scncc)               non-zero if called from cncrd
//      jsr  scane            call to scan element
//      (xr)                  result pointer (see below)
//      (xl)                  syntax type code (t_xxx)
//      the following global locations are used.
//      r_cim                 pointer to string block (scblk)
//                            for current input image.
//      r_cni                 pointer to next input image string
//                            pointer (zero if none).
//      r_scp                 save pointer (exit xr) from last
//                            call in case rescan is set.
//      scnbl                 this location is set non-zero on
//                            exit if scane scanned past blanks
//                            before locating the current element
//                            the end of a line counts as blanks.
//      scncc                 cncrd sets this non-zero to scan
//                            control card names and clears it
//                            on return
//      scnil                 length of current input image
//      scngo                 if set non-zero on entry, f and s
//                            are returned as separate syntax
//                            types (not letters) (goto pro-
//                            cessing). scngo is reset on exit.
//      scnpt                 offset to current loc in r_cim
//      scnrs                 if set non-zero on entry, scane
//                            returns the same result as on the
//                            last call (rescan). scnrs is reset
//                            on exit from any call to scane.
//      scntp                 save syntax type from last
//                            call (in case rescan is set).
        //b ||ejc|||||27341
        
//      scane (continued)
//      element scanned       xl        xr
//      ---------------       --        --
//      control card name     0         pointer to scblk for name
//      unary operator        t_uop     ptr to operator dvblk
//      left paren            t_lpr     t_lpr
//      left bracket          t_lbr     t_lbr
//      comma                 t_cma     t_cma
//      function call         t_fnc     ptr to function vrblk
//      variable              t_var     ptr to vrblk
//      string constant       t_con     ptr to scblk
//      integer constant      t_con     ptr to icblk
//      real constant         t_con     ptr to rcblk
//      binary operator       t_bop     ptr to operator dvblk
//      right paren           t_rpr     t_rpr
//      right bracket         t_rbr     t_rbr
//      colon                 t_col     t_col
//      semi-colon            t_smc     t_smc
//      f (scngo ne 0)        t_fgo     t_fgo
//      s (scngo ne 0)        t_sgo     t_sgo
        //b ||ejc|||||27386
        
//      scane (continued)
//      entry point
// scane:
        //b |scane|prc|25,e|1,0||entry point|27392
        } /* vmak2 */
        

        void scane() {
        //b ||zer|3,scnbl|||reset blanks flag|27393
        v.scnbl=0;				// reset blanks flag
        //b ||mov|3,scnsa|8,wa||save wa|27394
        v.scnsa= wa;				// save wa
        //b ||mov|3,scnsb|8,wb||save wb|27395
        v.scnsb= wb;				// save wb
        //b ||mov|3,scnsc|8,wc||save wc|27396
        v.scnsc= wc;				// save wc
        //b ||bze|3,scnrs|6,scn03||jump if no rescan|27397
        if ( !( v.scnrs) ) C_GOTO(scn03);				// jump if no rescan
//      here for rescan request
        //b ||mov|7,xl|3,scntp||set previous returned scan type|27401
        xl= v.scntp;				// set previous returned scan type
        //b ||mov|7,xr|3,r_scp||set previous returned pointer|27402
        xr= v.r_scp;				// set previous returned pointer
        //b ||zer|3,scnrs|||reset rescan switch|27403
        v.scnrs=0;				// reset rescan switch
        //b ||brn|6,scn13|||jump to exit|27404
         C_GOTO(scn13);				// jump to exit
//      come here to read new image to test for continuation
// scn01:
        //b |scn01|jsr|6,readr|||read next image|27408
        } /* scane */
        

        void scn01() {
        C_JSR(readr);				// read next image
        //b ||mov|8,wb|19,*dvubs||set wb for not reading name|27409
        wb= CFP_B*DVUBS;				// set wb for not reading name
        //b ||bze|7,xr|6,scn30||treat as semi-colon if none|27410
        if ( !( xr) ) C_GOTO(scn30);				// treat as semi-colon if none
        //b ||plc|7,xr|||else point to first character|27411
        xr += CFP_F;				// else point to first character
        //b ||lch|8,wc|9,(xr)||load first character|27412
        wc = *(xr_it.chp);				// load first character
        //b ||beq|8,wc|18,=ch_dt|6,scn02|jump if dot for continuation|27413
        if ((wc-CH_DT) == 0) C_GOTO(scn02);				// jump if dot for continuation
        //b ||bne|8,wc|18,=ch_pl|6,scn30|else treat as semicolon unless plus|27414
        if ((wc-CH_PL) != 0) C_GOTO(scn30);				// else treat as semicolon unless plus
//      here for continuation line
// scn02:
        //b |scn02|jsr|6,nexts|||acquire next source image|27418
        C_GOTO(scn02);
        } /* scn01 */
        

        void scn02() {
        C_JSR(nexts);				// acquire next source image
        //b ||mov|3,scnpt|18,=num01||set scan pointer past continuation|27419
        v.scnpt= NUM01;				// set scan pointer past continuation
        //b ||mnz|3,scnbl|||set blanks flag|27420
        v.scnbl = 0xffffffffffffffff;				// set blanks flag
        //b ||ejc|||||27421
        
//      scane (continued)
//      merge here to scan next element on current line
// scn03:
        //b |scn03|mov|8,wa|3,scnpt||load current offset|27427
        C_GOTO(scn03);
        } /* scn02 */
        

        void scn03() {
        wa= v.scnpt;				// load current offset
        //b ||beq|8,wa|3,scnil|6,scn01|check continuation if end|27428
        if ((wa-v.scnil) == 0) C_GOTO(scn01);				// check continuation if end
        //b ||mov|7,xl|3,r_cim||point to current line|27429
        xl= v.r_cim;				// point to current line
        //b ||plc|7,xl|8,wa||point to current character|27430
        xl_it.chp += CFP_F + wa;				// point to current character
        //b ||mov|3,scnse|8,wa||set start of element location|27431
        v.scnse= wa;				// set start of element location
        //b ||mov|8,wc|21,=opdvs||point to operator dv list|27432
        wc= (word)(&c.opdvs);				// point to operator dv list
        //b ||mov|8,wb|19,*dvubs||set constant for operator circuit|27433
        wb= CFP_B*DVUBS;				// set constant for operator circuit
        //b ||brn|6,scn06|||start scanning|27434
         C_GOTO(scn06);				// start scanning
//      loop here to ignore leading blanks and tabs
// scn05:
        //b |scn05|bze|8,wb|6,scn10||jump if trailing|27438
        } /* scn03 */
        

        void scn05() {
        if ( !( wb) ) C_GOTO(scn10);				// jump if trailing
        //b ||icv|3,scnse|||increment start of element|27439
        (v.scnse)++;				// increment start of element
        //b ||beq|8,wa|3,scnil|6,scn01|jump if end of image|27440
        if ((wa-v.scnil) == 0) C_GOTO(scn01);				// jump if end of image
        //b ||mnz|3,scnbl|||note blanks seen|27441
        v.scnbl = 0xffffffffffffffff;				// note blanks seen
//      the following jump is used repeatedly for scanning out
//      the characters of a numeric constant or variable name.
//      the registers are used as follows.
//      (xr)                  scratch
//      (xl)                  ptr to next character
//      (wa)                  current scan offset
//      (wb)                  *dvubs (0 if scanning name,const)
//      (wc)                  =opdvs (0 if scanning constant)
// scn06:
        //b |scn06|lch|7,xr|10,(xl)+||get next character|27453
        C_GOTO(scn06);
        } /* scn05 */
        

        void scn06() {
        xr = *(xl_it.chp++);				// get next character
        //b ||icv|8,wa|||bump scan offset|27454
        (wa)++;				// bump scan offset
        //b ||mov|3,scnpt|8,wa||store offset past char scanned|27455
        v.scnpt= wa;				// store offset past char scanned
        //b ||bsw|7,xr|2,cfp_u|6,scn07|switch on scanned character|27457
        if (xr - (word)(CFP_U) >=0 )  { C_GOTO(scn07);}				// switch on scanned character
        extern word _l0714 [];
        { w0 = ((word *)_l0714)[xr];  C_GOTO(w0_it.callp);}
        }  /* scn06 */
        

        word  _l0714 [] = {
//      switch table for switch on character
        //b ||ejc|||||27484
        
//      scane (continued)
        //b ||ejc|||||27540
        
//      scane (continued)
        //b ||iff|1,0|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,1|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,2|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,3|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,4|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,5|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,6|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,7|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,8|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|2,ch_ht|6,scn05||horizontal tab|27573
        	(word)((word)(scn05)),				// horizontal tab
        //b ||iff|1,10|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,11|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,12|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,13|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,14|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,15|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,16|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,17|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,18|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,19|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,20|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,21|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,22|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,23|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,24|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,25|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,26|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,27|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,28|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,29|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,30|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|1,31|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|2,ch_bl|6,scn05||blank|27573
        	(word)((word)(scn05)),				// blank
        //b ||iff|2,ch_ex|6,scn37||exclamation mark|27573
        	(word)((word)(scn37)),				// exclamation mark
        //b ||iff|2,ch_dq|6,scn17||double quote|27573
        	(word)((word)(scn17)),				// double quote
        //b ||iff|2,ch_nm|6,scn41||number sign|27573
        	(word)((word)(scn41)),				// number sign
        //b ||iff|2,ch_dl|6,scn36||dollar|27573
        	(word)((word)(scn36)),				// dollar
        //b ||iff|1,37|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|2,ch_am|6,scn44||ampersand|27573
        	(word)((word)(scn44)),				// ampersand
        //b ||iff|2,ch_sq|6,scn16||single quote|27573
        	(word)((word)(scn16)),				// single quote
        //b ||iff|2,ch_pp|6,scn25||left paren|27573
        	(word)((word)(scn25)),				// left paren
        //b ||iff|2,ch_rp|6,scn26||right paren|27573
        	(word)((word)(scn26)),				// right paren
        //b ||iff|2,ch_as|6,scn49||asterisk|27573
        	(word)((word)(scn49)),				// asterisk
        //b ||iff|2,ch_pl|6,scn33||plus|27573
        	(word)((word)(scn33)),				// plus
        //b ||iff|2,ch_cm|6,scn31||comma|27573
        	(word)((word)(scn31)),				// comma
        //b ||iff|2,ch_mn|6,scn34||minus|27573
        	(word)((word)(scn34)),				// minus
        //b ||iff|2,ch_dt|6,scn32||dot|27573
        	(word)((word)(scn32)),				// dot
        //b ||iff|2,ch_sl|6,scn40||slash|27573
        	(word)((word)(scn40)),				// slash
        //b ||iff|2,ch_d0|6,scn08||digit 0|27573
        	(word)((word)(scn08)),				// digit 0
        //b ||iff|2,ch_d1|6,scn08||digit 1|27573
        	(word)((word)(scn08)),				// digit 1
        //b ||iff|2,ch_d2|6,scn08||digit 2|27573
        	(word)((word)(scn08)),				// digit 2
        //b ||iff|2,ch_d3|6,scn08||digit 3|27573
        	(word)((word)(scn08)),				// digit 3
        //b ||iff|2,ch_d4|6,scn08||digit 4|27573
        	(word)((word)(scn08)),				// digit 4
        //b ||iff|2,ch_d5|6,scn08||digit 5|27573
        	(word)((word)(scn08)),				// digit 5
        //b ||iff|2,ch_d6|6,scn08||digit 6|27573
        	(word)((word)(scn08)),				// digit 6
        //b ||iff|2,ch_d7|6,scn08||digit 7|27573
        	(word)((word)(scn08)),				// digit 7
        //b ||iff|2,ch_d8|6,scn08||digit 8|27573
        	(word)((word)(scn08)),				// digit 8
        //b ||iff|2,ch_d9|6,scn08||digit 9|27573
        	(word)((word)(scn08)),				// digit 9
        //b ||iff|2,ch_cl|6,scn29||colon|27573
        	(word)((word)(scn29)),				// colon
        //b ||iff|2,ch_sm|6,scn30||semi-colon|27573
        	(word)((word)(scn30)),				// semi-colon
        //b ||iff|2,ch_bb|6,scn28||left bracket|27573
        	(word)((word)(scn28)),				// left bracket
        //b ||iff|2,ch_eq|6,scn46||equal|27573
        	(word)((word)(scn46)),				// equal
        //b ||iff|2,ch_rb|6,scn27||right bracket|27573
        	(word)((word)(scn27)),				// right bracket
        //b ||iff|2,ch_qu|6,scn45||question mark|27573
        	(word)((word)(scn45)),				// question mark
        //b ||iff|2,ch_at|6,scn42||at|27573
        	(word)((word)(scn42)),				// at
        //b ||iff|2,ch_ua|6,scn09||shifted a|27573
        	(word)((word)(scn09)),				// shifted a
        //b ||iff|2,ch_ub|6,scn09||shifted b|27573
        	(word)((word)(scn09)),				// shifted b
        //b ||iff|2,ch_uc|6,scn09||shifted c|27573
        	(word)((word)(scn09)),				// shifted c
        //b ||iff|2,ch_ud|6,scn09||shifted d|27573
        	(word)((word)(scn09)),				// shifted d
        //b ||iff|2,ch_ue|6,scn09||shifted e|27573
        	(word)((word)(scn09)),				// shifted e
        //b ||iff|2,ch_uf|6,scn20||shifted f|27573
        	(word)((word)(scn20)),				// shifted f
        //b ||iff|2,ch_ug|6,scn09||shifted g|27573
        	(word)((word)(scn09)),				// shifted g
        //b ||iff|2,ch_uh|6,scn09||shifted h|27573
        	(word)((word)(scn09)),				// shifted h
        //b ||iff|2,ch_ui|6,scn09||shifted i|27573
        	(word)((word)(scn09)),				// shifted i
        //b ||iff|2,ch_uj|6,scn09||shifted j|27573
        	(word)((word)(scn09)),				// shifted j
        //b ||iff|2,ch_uk|6,scn09||shifted k|27573
        	(word)((word)(scn09)),				// shifted k
        //b ||iff|2,ch_ul|6,scn09||shifted l|27573
        	(word)((word)(scn09)),				// shifted l
        //b ||iff|2,ch_um|6,scn09||shifted m|27573
        	(word)((word)(scn09)),				// shifted m
        //b ||iff|2,ch_un|6,scn09||shifted n|27573
        	(word)((word)(scn09)),				// shifted n
        //b ||iff|2,ch_uo|6,scn09||shifted o|27573
        	(word)((word)(scn09)),				// shifted o
        //b ||iff|2,ch_up|6,scn09||shifted p|27573
        	(word)((word)(scn09)),				// shifted p
        //b ||iff|2,ch_uq|6,scn09||shifted q|27573
        	(word)((word)(scn09)),				// shifted q
        //b ||iff|2,ch_ur|6,scn09||shifted r|27573
        	(word)((word)(scn09)),				// shifted r
        //b ||iff|2,ch_us|6,scn21||shifted s|27573
        	(word)((word)(scn21)),				// shifted s
        //b ||iff|2,ch_ut|6,scn09||shifted t|27573
        	(word)((word)(scn09)),				// shifted t
        //b ||iff|2,ch_uu|6,scn09||shifted u|27573
        	(word)((word)(scn09)),				// shifted u
        //b ||iff|2,ch_uv|6,scn09||shifted v|27573
        	(word)((word)(scn09)),				// shifted v
        //b ||iff|2,ch_uw|6,scn09||shifted w|27573
        	(word)((word)(scn09)),				// shifted w
        //b ||iff|2,ch_ux|6,scn09||shifted x|27573
        	(word)((word)(scn09)),				// shifted x
        //b ||iff|2,ch_uy|6,scn09||shifted y|27573
        	(word)((word)(scn09)),				// shifted y
        //b ||iff|2,ch_uz|6,scn09||shifted z|27573
        	(word)((word)(scn09)),				// shifted z
        //b ||iff|2,ch_ob|6,scn28||left bracket|27573
        	(word)((word)(scn28)),				// left bracket
        //b ||iff|1,92|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|2,ch_cb|6,scn27||right bracket|27573
        	(word)((word)(scn27)),				// right bracket
        //b ||iff|2,ch_pc|6,scn38||percent|27573
        	(word)((word)(scn38)),				// percent
        //b ||iff|2,ch_u_|6,scn24||underline|27573
        	(word)((word)(scn24)),				// underline
        //b ||iff|1,96|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|2,ch_la|6,scn09||letter a|27573
        	(word)((word)(scn09)),				// letter a
        //b ||iff|2,ch_lb|6,scn09||letter b|27573
        	(word)((word)(scn09)),				// letter b
        //b ||iff|2,ch_lc|6,scn09||letter c|27573
        	(word)((word)(scn09)),				// letter c
        //b ||iff|2,ch_ld|6,scn09||letter d|27573
        	(word)((word)(scn09)),				// letter d
        //b ||iff|2,ch_le|6,scn09||letter e|27573
        	(word)((word)(scn09)),				// letter e
        //b ||iff|2,ch_lf|6,scn20||letter f|27573
        	(word)((word)(scn20)),				// letter f
        //b ||iff|2,ch_lg|6,scn09||letter g|27573
        	(word)((word)(scn09)),				// letter g
        //b ||iff|2,ch_lh|6,scn09||letter h|27573
        	(word)((word)(scn09)),				// letter h
        //b ||iff|2,ch_li|6,scn09||letter i|27573
        	(word)((word)(scn09)),				// letter i
        //b ||iff|2,ch_lj|6,scn09||letter j|27573
        	(word)((word)(scn09)),				// letter j
        //b ||iff|2,ch_lk|6,scn09||letter k|27573
        	(word)((word)(scn09)),				// letter k
        //b ||iff|2,ch_ll|6,scn09||letter l|27573
        	(word)((word)(scn09)),				// letter l
        //b ||iff|2,ch_lm|6,scn09||letter m|27573
        	(word)((word)(scn09)),				// letter m
        //b ||iff|2,ch_ln|6,scn09||letter n|27573
        	(word)((word)(scn09)),				// letter n
        //b ||iff|2,ch_lo|6,scn09||letter o|27573
        	(word)((word)(scn09)),				// letter o
        //b ||iff|2,ch_lp|6,scn09||letter p|27573
        	(word)((word)(scn09)),				// letter p
        //b ||iff|2,ch_lq|6,scn09||letter q|27573
        	(word)((word)(scn09)),				// letter q
        //b ||iff|2,ch_lr|6,scn09||letter r|27573
        	(word)((word)(scn09)),				// letter r
        //b ||iff|2,ch_ls|6,scn21||letter s|27573
        	(word)((word)(scn21)),				// letter s
        //b ||iff|2,ch_lt|6,scn09||letter t|27573
        	(word)((word)(scn09)),				// letter t
        //b ||iff|2,ch_lu|6,scn09||letter u|27573
        	(word)((word)(scn09)),				// letter u
        //b ||iff|2,ch_lv|6,scn09||letter v|27573
        	(word)((word)(scn09)),				// letter v
        //b ||iff|2,ch_lw|6,scn09||letter w|27573
        	(word)((word)(scn09)),				// letter w
        //b ||iff|2,ch_lx|6,scn09||letter x|27573
        	(word)((word)(scn09)),				// letter x
        //b ||iff|2,ch_ly|6,scn09||letter y|27573
        	(word)((word)(scn09)),				// letter y
        //b ||iff|2,ch_l_|6,scn09||letter z|27573
        	(word)((word)(scn09)),				// letter z
        //b ||iff|1,123|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|2,ch_br|6,scn43||vertical bar|27573
        	(word)((word)(scn43)),				// vertical bar
        //b ||iff|1,125|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||iff|2,ch_nt|6,scn35||not|27573
        	(word)((word)(scn35)),				// not
        //b ||iff|1,127|6,scn07|||27573
        	(word)((word)(scn07)),
        //b ||esw||||end switch on character|27573
             }; /* bsw list for _l0714 */				// end switch on character
//      here for illegal character (underline merges)
// scn07:
        //b |scn07|bze|8,wb|6,scn10||jump if scanning name or constant|27577
        void scn07() {
        if ( !( wb) ) C_GOTO(scn10);				// jump if scanning name or constant
        //b ||erb|1,230|26,syntax error: illegal character|||27578
        C_ERB(230)
        //b ||ejc|||||27579
        
//      scane (continued)
//      here for digits 0-9
// scn08:
        //b |scn08|bze|8,wb|6,scn09||keep scanning if name/constant|27585
        } /* scn07 */
        

        void scn08() {
        if ( !( wb) ) C_GOTO(scn09);				// keep scanning if name/constant
        //b ||zer|8,wc|||else set flag for scanning constant|27586
        wc=0;				// else set flag for scanning constant
//      here for letter. loop here when scanning name/constant
// scn09:
        //b |scn09|beq|8,wa|3,scnil|6,scn11|jump if end of image|27590
        C_GOTO(scn09);
        } /* scn08 */
        

        void scn09() {
        if ((wa-v.scnil) == 0) C_GOTO(scn11);				// jump if end of image
        //b ||zer|8,wb|||set flag for scanning name/const|27591
        wb=0;				// set flag for scanning name/const
        //b ||brn|6,scn06|||merge back to continue scan|27592
         C_GOTO(scn06);				// merge back to continue scan
//      come here for delimiter ending name or constant
// scn10:
        //b |scn10|dcv|8,wa|||reset offset to point to delimiter|27596
        } /* scn09 */
        

        void scn10() {
        (wa)--;				// reset offset to point to delimiter
//      come here after finishing scan of name or constant
// scn11:
        //b |scn11|mov|3,scnpt|8,wa||store updated scan offset|27600
        C_GOTO(scn11);
        } /* scn10 */
        

        void scn11() {
        v.scnpt= wa;				// store updated scan offset
        //b ||mov|8,wb|3,scnse||point to start of element|27601
        wb= v.scnse;				// point to start of element
        //b ||sub|8,wa|8,wb||get number of characters|27602
        wa -= wb;				// get number of characters
        //b ||mov|7,xl|3,r_cim||point to line image|27603
        xl= v.r_cim;				// point to line image
        //b ||bnz|8,wc|6,scn15||jump if name|27604
        if (wc) C_GOTO(scn15);				// jump if name
//      here after scanning out numeric constant
        //b ||jsr|6,sbstr|||get string for constant|27608
        C_JSR(sbstr);				// get string for constant
        //b ||mov|3,dnamp|7,xr||delete from storage (not needed)|27609
        v.dnamp= xr;				// delete from storage (not needed)
        //b ||ppm|6,scn14|||jump if conversion failure|27611
        C_JSR_1(gtnum,C_GOTO(scn14));				// jump if conversion failure
//      merge here to exit with constant
// scn12:
        //b |scn12|mov|7,xl|18,=t_con||set result type of constant|27615
        C_GOTO(scn12);
        } /* scn11 */
        

        void scn12() {
        xl= T_CON;				// set result type of constant
        //b ||ejc|||||27616
        
//      scane (continued)
//      common exit point (xr,xl) set
// scn13:
        //b |scn13|mov|8,wa|3,scnsa||restore wa|27622
        C_GOTO(scn13);
        } /* scn12 */
        

        void scn13() {
        wa= v.scnsa;				// restore wa
        //b ||mov|8,wb|3,scnsb||restore wb|27623
        wb= v.scnsb;				// restore wb
        //b ||mov|8,wc|3,scnsc||restore wc|27624
        wc= v.scnsc;				// restore wc
        //b ||mov|3,r_scp|7,xr||save xr in case rescan|27625
        v.r_scp= xr;				// save xr in case rescan
        //b ||mov|3,scntp|7,xl||save xl in case rescan|27626
        v.scntp= xl;				// save xl in case rescan
        //b ||zer|3,scngo|||reset possible goto flag|27627
        v.scngo=0;				// reset possible goto flag
        //b ||exi||||return to scane caller|27628
        C_EXIT(0);				// return to scane caller
//      here if conversion error on numeric item
// scn14:
        //b |scn14|erb|1,231|26,syntax error: invalid numeric item|||27632
        } /* scn13 */
        

        void scn14() {
        C_ERB(231)
//      here after scanning out variable name
// scn15:
        //b |scn15|jsr|6,sbstr|||build string name of variable|27636
        } /* scn14 */
        

        void scn15() {
        C_JSR(sbstr);				// build string name of variable
        //b ||bnz|3,scncc|6,scn13||return if cncrd call|27637
        if (v.scncc) C_GOTO(scn13);				// return if cncrd call
        //b ||ppm||||dummy (unused) error return|27639
        C_JSR_1(gtnvr,(C_ERR(299)));				// dummy (unused) error return
        //b ||mov|7,xl|18,=t_var||set type as variable|27640
        xl= T_VAR;				// set type as variable
        //b ||brn|6,scn13|||back to exit|27641
         C_GOTO(scn13);				// back to exit
//      here for single quote (start of string constant)
// scn16:
        //b |scn16|bze|8,wb|6,scn10||terminator if scanning name or cnst|27645
        } /* scn15 */
        

        void scn16() {
        if ( !( wb) ) C_GOTO(scn10);				// terminator if scanning name or cnst
        //b ||mov|8,wb|18,=ch_sq||set terminator as single quote|27646
        wb= CH_SQ;				// set terminator as single quote
        //b ||brn|6,scn18|||merge|27647
         C_GOTO(scn18);				// merge
//      here for double quote (start of string constant)
// scn17:
        //b |scn17|bze|8,wb|6,scn10||terminator if scanning name or cnst|27651
        } /* scn16 */
        

        void scn17() {
        if ( !( wb) ) C_GOTO(scn10);				// terminator if scanning name or cnst
        //b ||mov|8,wb|18,=ch_dq||set double quote terminator, merge|27652
        wb= CH_DQ;				// set double quote terminator, merge
//      loop to scan out string constant
// scn18:
        //b |scn18|beq|8,wa|3,scnil|6,scn19|error if end of image|27656
        C_GOTO(scn18);
        } /* scn17 */
        

        void scn18() {
        if ((wa-v.scnil) == 0) C_GOTO(scn19);				// error if end of image
        //b ||lch|8,wc|10,(xl)+||else load next character|27657
        wc = *(xl_it.chp++);				// else load next character
        //b ||icv|8,wa|||bump offset|27658
        (wa)++;				// bump offset
        //b ||bne|8,wc|8,wb|6,scn18|loop back if not terminator|27659
        if ((wc-wb) != 0) C_GOTO(scn18);				// loop back if not terminator
        //b ||ejc|||||27660
        
//      scane (continued)
//      here after scanning out string constant
        //b ||mov|8,wb|3,scnpt||point to first character|27666
        wb= v.scnpt;				// point to first character
        //b ||mov|3,scnpt|8,wa||save offset past final quote|27667
        v.scnpt= wa;				// save offset past final quote
        //b ||dcv|8,wa|||point back past last character|27668
        (wa)--;				// point back past last character
        //b ||sub|8,wa|8,wb||get number of characters|27669
        wa -= wb;				// get number of characters
        //b ||mov|7,xl|3,r_cim||point to input image|27670
        xl= v.r_cim;				// point to input image
        //b ||jsr|6,sbstr|||build substring value|27671
        C_JSR(sbstr);				// build substring value
        //b ||brn|6,scn12|||back to exit with constant result|27672
         C_GOTO(scn12);				// back to exit with constant result
//      here if no matching quote found
// scn19:
        //b |scn19|mov|3,scnpt|8,wa||set updated scan pointer|27676
        } /* scn18 */
        

        void scn19() {
        v.scnpt= wa;				// set updated scan pointer
        //b ||erb|1,232|26,syntax error: unmatched string quote|||27677
        C_ERB(232)
//      here for f (possible failure goto)
// scn20:
        //b |scn20|mov|7,xr|18,=t_fgo||set return code for fail goto|27681
        } /* scn19 */
        

        void scn20() {
        xr= T_FGO;				// set return code for fail goto
        //b ||brn|6,scn22|||jump to merge|27682
         C_GOTO(scn22);				// jump to merge
//      here for s (possible success goto)
// scn21:
        //b |scn21|mov|7,xr|18,=t_sgo||set success goto as return code|27686
        } /* scn20 */
        

        void scn21() {
        xr= T_SGO;				// set success goto as return code
//      special goto cases merge here
// scn22:
        //b |scn22|bze|3,scngo|6,scn09||treat as normal letter if not goto|27690
        C_GOTO(scn22);
        } /* scn21 */
        

        void scn22() {
        if ( !( v.scngo) ) C_GOTO(scn09);				// treat as normal letter if not goto
//      merge here for special character exit
// scn23:
        //b |scn23|bze|8,wb|6,scn10||jump if end of name/constant|27694
        C_GOTO(scn23);
        } /* scn22 */
        

        void scn23() {
        if ( !( wb) ) C_GOTO(scn10);				// jump if end of name/constant
        //b ||mov|7,xl|7,xr||else copy code|27695
        xl= xr;				// else copy code
        //b ||brn|6,scn13|||and jump to exit|27696
         C_GOTO(scn13);				// and jump to exit
//      here for underline
// scn24:
        //b |scn24|bze|8,wb|6,scn09||part of name if scanning name|27700
        } /* scn23 */
        

        void scn24() {
        if ( !( wb) ) C_GOTO(scn09);				// part of name if scanning name
        //b ||brn|6,scn07|||else illegal|27701
         C_GOTO(scn07);				// else illegal
        //b ||ejc|||||27702
        
//      scane (continued)
//      here for left paren
// scn25:
        //b |scn25|mov|7,xr|18,=t_lpr||set left paren return code|27708
        } /* scn24 */
        

        void scn25() {
        xr= T_LPR;				// set left paren return code
        //b ||bnz|8,wb|6,scn23||return left paren unless name|27709
        if (wb) C_GOTO(scn23);				// return left paren unless name
        //b ||bze|8,wc|6,scn10||delimiter if scanning constant|27710
        if ( !( wc) ) C_GOTO(scn10);				// delimiter if scanning constant
//      here for left paren after name (function call)
        //b ||mov|8,wb|3,scnse||point to start of name|27714
        wb= v.scnse;				// point to start of name
        //b ||mov|3,scnpt|8,wa||set pointer past left paren|27715
        v.scnpt= wa;				// set pointer past left paren
        //b ||dcv|8,wa|||point back past last char of name|27716
        (wa)--;				// point back past last char of name
        //b ||sub|8,wa|8,wb||get name length|27717
        wa -= wb;				// get name length
        //b ||mov|7,xl|3,r_cim||point to input image|27718
        xl= v.r_cim;				// point to input image
        //b ||jsr|6,sbstr|||get string name for function|27719
        C_JSR(sbstr);				// get string name for function
        //b ||ppm||||dummy (unused) error return|27721
        C_JSR_1(gtnvr,(C_ERR(299)));				// dummy (unused) error return
        //b ||mov|7,xl|18,=t_fnc||set code for function call|27722
        xl= T_FNC;				// set code for function call
        //b ||brn|6,scn13|||back to exit|27723
         C_GOTO(scn13);				// back to exit
//      processing for special characters
// scn26:
        //b |scn26|mov|7,xr|18,=t_rpr||right paren, set code|27727
        } /* scn25 */
        

        void scn26() {
        xr= T_RPR;				// right paren, set code
        //b ||brn|6,scn23|||take special character exit|27728
         C_GOTO(scn23);				// take special character exit
// scn27:
        //b |scn27|mov|7,xr|18,=t_rbr||right bracket, set code|27730
        } /* scn26 */
        

        void scn27() {
        xr= T_RBR;				// right bracket, set code
        //b ||brn|6,scn23|||take special character exit|27731
         C_GOTO(scn23);				// take special character exit
// scn28:
        //b |scn28|mov|7,xr|18,=t_lbr||left bracket, set code|27733
        } /* scn27 */
        

        void scn28() {
        xr= T_LBR;				// left bracket, set code
        //b ||brn|6,scn23|||take special character exit|27734
         C_GOTO(scn23);				// take special character exit
// scn29:
        //b |scn29|mov|7,xr|18,=t_col||colon, set code|27736
        } /* scn28 */
        

        void scn29() {
        xr= T_COL;				// colon, set code
        //b ||brn|6,scn23|||take special character exit|27737
         C_GOTO(scn23);				// take special character exit
// scn30:
        //b |scn30|mov|7,xr|18,=t_smc||semi-colon, set code|27739
        } /* scn29 */
        

        void scn30() {
        xr= T_SMC;				// semi-colon, set code
        //b ||brn|6,scn23|||take special character exit|27740
         C_GOTO(scn23);				// take special character exit
// scn31:
        //b |scn31|mov|7,xr|18,=t_cma||comma, set code|27742
        } /* scn30 */
        

        void scn31() {
        xr= T_CMA;				// comma, set code
        //b ||brn|6,scn23|||take special character exit|27743
         C_GOTO(scn23);				// take special character exit
        //b ||ejc|||||27744
        
//      scane (continued)
//      here for operators. on entry, wc points to the table of
//      operator dope vectors and wb is the increment to step
//      to the next pair (binary/unary) of dope vectors in the
//      list. on reaching scn46, the pointer has been adjusted to
//      point to the appropriate pair of dope vectors.
//      the first three entries are special since they can occur
//      as part of a variable name (.) or constant (.+-).
// scn32:
        //b |scn32|bze|8,wb|6,scn09||dot can be part of name or constant|27756
        } /* scn31 */
        

        void scn32() {
        if ( !( wb) ) C_GOTO(scn09);				// dot can be part of name or constant
        //b ||add|8,wc|8,wb||else bump pointer|27757
        wc += wb;				// else bump pointer
// scn33:
        //b |scn33|bze|8,wc|6,scn09||plus can be part of constant|27759
        C_GOTO(scn33);
        } /* scn32 */
        

        void scn33() {
        if ( !( wc) ) C_GOTO(scn09);				// plus can be part of constant
        //b ||bze|8,wb|6,scn48||plus cannot be part of name|27760
        if ( !( wb) ) C_GOTO(scn48);				// plus cannot be part of name
        //b ||add|8,wc|8,wb||else bump pointer|27761
        wc += wb;				// else bump pointer
// scn34:
        //b |scn34|bze|8,wc|6,scn09||minus can be part of constant|27763
        C_GOTO(scn34);
        } /* scn33 */
        

        void scn34() {
        if ( !( wc) ) C_GOTO(scn09);				// minus can be part of constant
        //b ||bze|8,wb|6,scn48||minus cannot be part of name|27764
        if ( !( wb) ) C_GOTO(scn48);				// minus cannot be part of name
        //b ||add|8,wc|8,wb||else bump pointer|27765
        wc += wb;				// else bump pointer
// scn35:
        //b |scn35|add|8,wc|8,wb||not|27767
        C_GOTO(scn35);
        } /* scn34 */
        

        void scn35() {
        wc += wb;				// not
// scn36:
        //b |scn36|add|8,wc|8,wb||dollar|27768
        C_GOTO(scn36);
        } /* scn35 */
        

        void scn36() {
        wc += wb;				// dollar
// scn37:
        //b |scn37|add|8,wc|8,wb||exclamation|27769
        C_GOTO(scn37);
        } /* scn36 */
        

        void scn37() {
        wc += wb;				// exclamation
// scn38:
        //b |scn38|add|8,wc|8,wb||percent|27770
        C_GOTO(scn38);
        } /* scn37 */
        

        void scn38() {
        wc += wb;				// percent
// scn39:
        //b |scn39|add|8,wc|8,wb||asterisk|27771
        C_GOTO(scn39);
        } /* scn38 */
        

        void scn39() {
        wc += wb;				// asterisk
// scn40:
        //b |scn40|add|8,wc|8,wb||slash|27772
        C_GOTO(scn40);
        } /* scn39 */
        

        void scn40() {
        wc += wb;				// slash
// scn41:
        //b |scn41|add|8,wc|8,wb||number sign|27773
        C_GOTO(scn41);
        } /* scn40 */
        

        void scn41() {
        wc += wb;				// number sign
// scn42:
        //b |scn42|add|8,wc|8,wb||at sign|27774
        C_GOTO(scn42);
        } /* scn41 */
        

        void scn42() {
        wc += wb;				// at sign
// scn43:
        //b |scn43|add|8,wc|8,wb||vertical bar|27775
        C_GOTO(scn43);
        } /* scn42 */
        

        void scn43() {
        wc += wb;				// vertical bar
// scn44:
        //b |scn44|add|8,wc|8,wb||ampersand|27776
        C_GOTO(scn44);
        } /* scn43 */
        

        void scn44() {
        wc += wb;				// ampersand
// scn45:
        //b |scn45|add|8,wc|8,wb||question mark|27777
        C_GOTO(scn45);
        } /* scn44 */
        

        void scn45() {
        wc += wb;				// question mark
//      all operators come here (equal merges directly)
//      (wc) points to the binary/unary pair of operator dvblks.
// scn46:
        //b |scn46|bze|8,wb|6,scn10||operator terminates name/constant|27782
        C_GOTO(scn46);
        } /* scn45 */
        

        void scn46() {
        if ( !( wb) ) C_GOTO(scn10);				// operator terminates name/constant
        //b ||mov|7,xr|8,wc||else copy dv pointer|27783
        xr= wc;				// else copy dv pointer
        //b ||lch|8,wc|9,(xl)||load next character|27784
        wc = *(xl_it.chp);				// load next character
        //b ||mov|7,xl|18,=t_bop||set binary op in case|27785
        xl= T_BOP;				// set binary op in case
        //b ||beq|8,wa|3,scnil|6,scn47|should be binary if image end|27786
        if ((wa-v.scnil) == 0) C_GOTO(scn47);				// should be binary if image end
        //b ||beq|8,wc|18,=ch_bl|6,scn47|should be binary if followed by blk|27787
        if ((wc-CH_BL) == 0) C_GOTO(scn47);				// should be binary if followed by blk
        //b ||beq|8,wc|18,=ch_ht|6,scn47|jump if horizontal tab|27789
        if ((wc-CH_HT) == 0) C_GOTO(scn47);				// jump if horizontal tab
        //b ||beq|8,wc|18,=ch_sm|6,scn47|semicolon can immediately follow =|27794
        if ((wc-CH_SM) == 0) C_GOTO(scn47);				// semicolon can immediately follow =
        //b ||beq|8,wc|18,=ch_cl|6,scn47|colon can immediately follow =|27795
        if ((wc-CH_CL) == 0) C_GOTO(scn47);				// colon can immediately follow =
        //b ||beq|8,wc|18,=ch_rp|6,scn47|right paren can immediately follow =|27796
        if ((wc-CH_RP) == 0) C_GOTO(scn47);				// right paren can immediately follow =
        //b ||beq|8,wc|18,=ch_rb|6,scn47|right bracket can immediately follow =|27797
        if ((wc-CH_RB) == 0) C_GOTO(scn47);				// right bracket can immediately follow =
        //b ||beq|8,wc|18,=ch_cb|6,scn47|right bracket can immediately follow =|27798
        if ((wc-CH_CB) == 0) C_GOTO(scn47);				// right bracket can immediately follow =
//      here for unary operator
        //b ||add|7,xr|19,*dvbs_||point to dv for unary op|27802
        xr += CFP_B*DVBS_;				// point to dv for unary op
        //b ||mov|7,xl|18,=t_uop||set type for unary operator|27803
        xl= T_UOP;				// set type for unary operator
        //b ||ble|3,scntp|18,=t_uok|6,scn13|ok unary if ok preceding element|27804
        if ((v.scntp-T_UOK) <= 0) C_GOTO(scn13);				// ok unary if ok preceding element
        //b ||ejc|||||27805
        
//      scane (continued)
//      merge here to require preceding blanks
// scn47:
        //b |scn47|bnz|3,scnbl|6,scn13||all ok if preceding blanks, exit|27811
        C_GOTO(scn47);
        } /* scn46 */
        

        void scn47() {
        if (v.scnbl) C_GOTO(scn13);				// all ok if preceding blanks, exit
//      fail operator in this position
// scn48:
        //b |scn48|erb|1,233|26,syntax error: invalid use of operator|||27815
        C_GOTO(scn48);
        } /* scn47 */
        

        void scn48() {
        C_ERB(233)
//      here for asterisk, could be ** substitute for exclamation
// scn49:
        //b |scn49|bze|8,wb|6,scn10||end of name if scanning name|27819
        } /* scn48 */
        

        void scn49() {
        if ( !( wb) ) C_GOTO(scn10);				// end of name if scanning name
        //b ||beq|8,wa|3,scnil|6,scn39|not ** if * at image end|27820
        if ((wa-v.scnil) == 0) C_GOTO(scn39);				// not ** if * at image end
        //b ||mov|7,xr|8,wa||else save offset past first *|27821
        xr= wa;				// else save offset past first *
        //b ||mov|3,scnof|8,wa||save another copy|27822
        v.scnof= wa;				// save another copy
        //b ||lch|8,wa|10,(xl)+||load next character|27823
        wa = *(xl_it.chp++);				// load next character
        //b ||bne|8,wa|18,=ch_as|6,scn50|not ** if next char not *|27824
        if ((wa-CH_AS) != 0) C_GOTO(scn50);				// not ** if next char not *
        //b ||icv|7,xr|||else step offset past second *|27825
        (xr)++;				// else step offset past second *
        //b ||beq|7,xr|3,scnil|6,scn51|ok exclam if end of image|27826
        if ((xr-v.scnil) == 0) C_GOTO(scn51);				// ok exclam if end of image
        //b ||lch|8,wa|9,(xl)||else load next character|27827
        wa = *(xl_it.chp);				// else load next character
        //b ||beq|8,wa|18,=ch_bl|6,scn51|exclamation if blank|27828
        if ((wa-CH_BL) == 0) C_GOTO(scn51);				// exclamation if blank
        //b ||beq|8,wa|18,=ch_ht|6,scn51|exclamation if horizontal tab|27830
        if ((wa-CH_HT) == 0) C_GOTO(scn51);				// exclamation if horizontal tab
//      unary *
// scn50:
        //b |scn50|mov|8,wa|3,scnof||recover stored offset|27838
        C_GOTO(scn50);
        } /* scn49 */
        

        void scn50() {
        wa= v.scnof;				// recover stored offset
        //b ||mov|7,xl|3,r_cim||point to line again|27839
        xl= v.r_cim;				// point to line again
        //b ||plc|7,xl|8,wa||point to current char|27840
        xl_it.chp += CFP_F + wa;				// point to current char
        //b ||brn|6,scn39|||merge with unary *|27841
         C_GOTO(scn39);				// merge with unary *
//      here for ** as substitute for exclamation
// scn51:
        //b |scn51|mov|3,scnpt|7,xr||save scan pointer past 2nd *|27845
        } /* scn50 */
        

        void scn51() {
        v.scnpt= xr;				// save scan pointer past 2nd *
        //b ||mov|8,wa|7,xr||copy scan pointer|27846
        wa= xr;				// copy scan pointer
        //b ||brn|6,scn37|||merge with exclamation|27847
         C_GOTO(scn37);				// merge with exclamation
        //b ||ejc|||||27849
        
//      scngf -- scan goto field
//      scngf is called from cmpil to scan and analyze a goto
//      field including the surrounding brackets or parentheses.
//      for a normal goto, the result returned is either a vrblk
//      pointer for a simple label operand, or a pointer to an
//      expression tree with a special outer unary operator
//      (o_goc). for a direct goto, the result returned is a
//      pointer to an expression tree with the special outer
//      unary operator o_god.
//      jsr  scngf            call to scan goto field
//      (xr)                  result (see above)
//      (xl,wa,wb,wc)         destroyed
// scngf:
        //b |scngf|prc|25,e|1,0||entry point|27866
        } /* scn51 */
        

        void scngf() {
        //b ||jsr|6,scane|||scan initial element|27867
        C_JSR(scane);				// scan initial element
        //b ||beq|7,xl|18,=t_lpr|6,scng1|skip if left paren (normal goto)|27868
        if ((xl-T_LPR) == 0) C_GOTO(scng1);				// skip if left paren (normal goto)
        //b ||beq|7,xl|18,=t_lbr|6,scng2|skip if left bracket (direct goto)|27869
        if ((xl-T_LBR) == 0) C_GOTO(scng2);				// skip if left bracket (direct goto)
        //b ||erb|1,234|26,syntax error: goto field incorrect|||27870
        C_ERB(234)
//      here for left paren (normal goto)
// scng1:
        //b |scng1|mov|8,wb|18,=num01||set expan flag for normal goto|27874
        } /* scngf */
        

        void scng1() {
        wb= NUM01;				// set expan flag for normal goto
        //b ||jsr|6,expan|||analyze goto field|27875
        C_JSR(expan);				// analyze goto field
        //b ||mov|8,wa|21,=opdvn||point to opdv for complex goto|27876
        wa= (word)(&c.opdvn);				// point to opdv for complex goto
        //b ||ble|7,xr|3,statb|6,scng3|jump if not in static (sgd15)|27877
        if ((xr-v.statb) <= 0) C_GOTO(scng3);				// jump if not in static (sgd15)
        //b ||blo|7,xr|3,state|6,scng4|jump to exit if simple label name|27878
        if ((xr-v.state) < 0) C_GOTO(scng4);				// jump to exit if simple label name
        //b ||brn|6,scng3|||complex goto - merge|27879
         C_GOTO(scng3);				// complex goto - merge
//      here for left bracket (direct goto)
// scng2:
        //b |scng2|mov|8,wb|18,=num02||set expan flag for direct goto|27883
        } /* scng1 */
        

        void scng2() {
        wb= NUM02;				// set expan flag for direct goto
        //b ||jsr|6,expan|||scan goto field|27884
        C_JSR(expan);				// scan goto field
        //b ||mov|8,wa|21,=opdvd||set opdv pointer for direct goto|27885
        wa= (word)(&c.opdvd);				// set opdv pointer for direct goto
        //b ||ejc|||||27886
        
//      scngf (continued)
//      merge here to build outer unary operator block
// scng3:
        //b |scng3|mov|11,-(xs)|8,wa||stack operator dv pointer|27892
        C_GOTO(scng3);
        } /* scng2 */
        

        void scng3() {
        C_PUSH(wa);				// stack operator dv pointer
        //b ||mov|11,-(xs)|7,xr||stack pointer to expression tree|27893
        C_PUSH(xr);				// stack pointer to expression tree
        //b ||jsr|6,expop|||pop operator off|27894
        extern void _l0717();
        C_JMS(expop,P_PRC_EXPOP,_l0717);
        } /* scng3 */
        

        void _l0717() {
        //b ||mov|7,xr|10,(xs)+||reload new expression tree pointer|27895
        xr= C_POP();				// reload new expression tree pointer
//      common exit point
// scng4:
        //b |scng4|exi||||return to caller|27899
        C_GOTO(scng4);
        } /* _l0717 */
        

        void scng4() {
        C_EXIT(0);				// return to caller
        //b ||ejc|||||27901
        
//      setvr -- set vrget,vrsto fields of vrblk
//      setvr sets the proper values in the vrget and vrsto
//      fields of a vrblk. it is called whenever trblks are
//      added or subtracted (trace,stoptr,input,output,detach)
//      (xr)                  pointer to vrblk
//      jsr  setvr            call to set fields
//      (xl,wa)               destroyed
//      note that setvr ignores the call if xr does not point
//      into the static region (i.e. is some other name base)
// setvr:
        //b |setvr|prc|25,e|1,0||entry point|27916
        } /* scng4 */
        

        void setvr() {
        //b ||bhi|7,xr|3,state|6,setv1|exit if not natural variable|27917
        if ((xr-v.state) > 0) C_GOTO(setv1);				// exit if not natural variable
//      here if we have a vrblk
        //b ||mov|7,xl|7,xr||copy vrblk pointer|27921
        xl= xr;				// copy vrblk pointer
        //b ||mov|13,vrget(xr)|22,=b_vrl||store normal get value|27922
        *((word *)(CFP_B*VRGET + xr))= (word)(b_vrl);				// store normal get value
        //b ||beq|13,vrsto(xr)|22,=b_vre|6,setv1|skip if protected variable|27923
        if ((*((word *)(CFP_B*VRSTO + xr))-(word)(b_vre)) == 0) C_GOTO(setv1);				// skip if protected variable
        //b ||mov|13,vrsto(xr)|22,=b_vrs||store normal store value|27924
        *((word *)(CFP_B*VRSTO + xr))= (word)(b_vrs);				// store normal store value
        //b ||mov|7,xl|13,vrval(xl)||point to next entry on chain|27925
        xl= *((word *)(CFP_B*VRVAL + xl));				// point to next entry on chain
        //b ||bne|9,(xl)|22,=b_trt|6,setv1|jump if end of trblk chain|27926
        if ((*(xl_it.wp)-(word)(b_trt)) != 0) C_GOTO(setv1);				// jump if end of trblk chain
        //b ||mov|13,vrget(xr)|22,=b_vra||store trapped routine address|27927
        *((word *)(CFP_B*VRGET + xr))= (word)(b_vra);				// store trapped routine address
        //b ||mov|13,vrsto(xr)|22,=b_vrv||set trapped routine address|27928
        *((word *)(CFP_B*VRSTO + xr))= (word)(b_vrv);				// set trapped routine address
//      merge here to exit to caller
// setv1:
        //b |setv1|exi||||return to setvr caller|27932
        C_GOTO(setv1);
        } /* setvr */
        

        void setv1() {
        C_EXIT(0);				// return to setvr caller
        //b ||ejc|||||27936
        
//      sorta -- sort array
//      routine to sort an array or table on same basis as in
//      sitbol. a table is converted to an array, leaving two
//      dimensional arrays and vectors as cases to be considered.
//      whole rows of arrays are permuted according to the
//      ordering of the keys they contain, and the stride
//      referred to, is the the length of a row. it is one
//      for a vector.
//      the sort used is heapsort, fundamentals of data structure
//      horowitz and sahni, pitman 1977, page 347.
//      it is an order n*log(n) algorithm. in order
//      to make it stable, comparands may not compare equal. this
//      is achieved by sorting a copy array (referred to as the
//      sort array) containing at its high address end, byte
//      offsets to the rows to be sorted held in the original
//      array (referred to as the key array). sortc, the
//      comparison routine, accesses the keys through these
//      offsets and in the case of equality, resolves it by
//      comparing the offsets themselves. the sort permutes the
//      offsets which are then used in a final operation to copy
//      the actual items into the new array in sorted order.
//      references to zeroth item are to notional item
//      preceding first actual item.
//      reverse sorting for rsort is done by having the less than
//      test for keys effectively be replaced by a
//      greater than test.
//      1(xs)                 first arg - array or table
//      0(xs)                 2nd arg - index or pdtype name
//      (wa)                  0 , non-zero for sort , rsort
//      jsr  sorta            call to sort array
//      ppm  loc              transfer loc if table is empty
//      (xr)                  sorted array
//      (xl,wa,wb,wc)         destroyed
        //b ||ejc|||||27973
        
//      sorta (continued)
// sorta:
        //b |sorta|prc|25,n|1,1||entry point|27977
        } /* setv1 */
        

        void sorta() {
        //b ||mov|3,srtsr|8,wa||sort/rsort indicator|27978
        v.srtsr= wa;				// sort/rsort indicator
        //b ||mov|3,srtst|19,*num01||default stride of 1|27979
        v.srtst= CFP_B*NUM01;				// default stride of 1
        //b ||zer|3,srtof|||default zero offset to sort key|27980
        v.srtof=0;				// default zero offset to sort key
        //b ||mov|3,srtdf|21,=nulls||clear datatype field name|27981
        v.srtdf= (word)(&c.nulls);				// clear datatype field name
        //b ||mov|3,r_sxr|10,(xs)+||unstack argument 2|27982
        v.r_sxr= C_POP();				// unstack argument 2
        //b ||mov|7,xr|10,(xs)+||get first argument|27983
        xr= C_POP();				// get first argument
        //b ||mnz|8,wa|||use key/values of table entries|27984
        wa = 0xffffffffffffffff;				// use key/values of table entries
        //b ||ppm|6,srt16|||error if non-convertable|27987
        C_JSR_2(gtarr,C_GOTO(srt18),C_GOTO(srt16));				// error if non-convertable
        //b ||mov|11,-(xs)|7,xr||stack ptr to resulting key array|27988
        C_PUSH(xr);				// stack ptr to resulting key array
        //b ||mov|11,-(xs)|7,xr||another copy for copyb|27989
        C_PUSH(xr);				// another copy for copyb
        //b ||ppm||||cant fail|27991
        extern void _l0719();
        C_JMS(copyb,P_PRC_COPYB,_l0719);
        } /* sorta */
        

        void _l0719() {
        C_JMS_HANDLE_1(copyb,(C_ERR(299)));				// cant fail
        //b ||mov|11,-(xs)|7,xr||stack pointer to sort array|27992
        C_PUSH(xr);				// stack pointer to sort array
        //b ||mov|7,xr|3,r_sxr||get second arg|27993
        xr= v.r_sxr;				// get second arg
        //b ||mov|7,xl|13,num01(xs)||get ptr to key array|27994
        xl= *((word *)(CFP_B*NUM01 + xs));				// get ptr to key array
        //b ||bne|9,(xl)|22,=b_vct|6,srt02|jump if arblk|27995
        if ((*(xl_it.wp)-(word)(b_vct)) != 0) C_GOTO(srt02);				// jump if arblk
        //b ||beq|7,xr|21,=nulls|6,srt01|jump if null second arg|27996
        if ((xr-(word)(&c.nulls)) == 0) C_GOTO(srt01);				// jump if null second arg
        //b ||err|1,257|26,erroneous 2nd arg in sort/rsort of vector|||27998
        C_JSR_1(gtnvr,(C_ERR(257)));
        //b ||mov|3,srtdf|7,xr||store datatype field name vrblk|27999
        v.srtdf= xr;				// store datatype field name vrblk
//      compute n and offset to item a(0) in vector case
// srt01:
        //b |srt01|mov|8,wc|19,*vclen||offset to a(0)|28003
        C_GOTO(srt01);
        } /* _l0719 */
        

        void srt01() {
        wc= CFP_B*VCLEN;				// offset to a(0)
        //b ||mov|8,wb|19,*vcvls||offset to first item|28004
        wb= CFP_B*VCVLS;				// offset to first item
        //b ||mov|8,wa|13,vclen(xl)||get block length|28005
        wa= *((word *)(CFP_B*VCLEN + xl));				// get block length
        //b ||sub|8,wa|19,*vcsi_||get no. of entries, n (in bytes)|28006
        wa -= CFP_B*VCSI_;				// get no. of entries, n (in bytes)
        //b ||brn|6,srt04|||merge|28007
         C_GOTO(srt04);				// merge
//      here for array
// srt02:
        //b |srt02|ldi|13,ardim(xl)|||get possible dimension|28011
        } /* srt01 */
        

        void srt02() {
        ia = *((word *)(CFP_B*ARDIM + xl));				// get possible dimension
        //b ||mfi|8,wa|||convert to short integer|28012
        wa = ia;				// convert to short integer
        //b ||wtb|8,wa|||further convert to baus|28013
        wa <<= LOG_CFP_B;				// further convert to baus
        //b ||mov|8,wb|19,*arvls||offset to first value if one|28014
        wb= CFP_B*ARVLS;				// offset to first value if one
        //b ||mov|8,wc|19,*arpro||offset before values if one dim.|28015
        wc= CFP_B*ARPRO;				// offset before values if one dim.
        //b ||beq|13,arndm(xl)|18,=num01|6,srt04|jump in fact if one dim.|28016
        if ((*((word *)(CFP_B*ARNDM + xl))-NUM01) == 0) C_GOTO(srt04);				// jump in fact if one dim.
        //b ||bne|13,arndm(xl)|18,=num02|6,srt16|fail unless two dimens|28017
        if ((*((word *)(CFP_B*ARNDM + xl))-NUM02) != 0) C_GOTO(srt16);				// fail unless two dimens
        //b ||ldi|13,arlb2(xl)|||get lower bound 2 as default|28018
        ia = *((word *)(CFP_B*ARLB2 + xl));				// get lower bound 2 as default
        //b ||beq|7,xr|21,=nulls|6,srt03|jump if default second arg|28019
        if ((xr-(word)(&c.nulls)) == 0) C_GOTO(srt03);				// jump if default second arg
        //b ||ppm|6,srt17|||fail|28021
        C_JSR_1(gtint,C_GOTO(srt17));				// fail
        //b ||ldi|13,icval(xr)|||get actual integer value|28022
        ia = *((word *)(CFP_B*ICVAL + xr));				// get actual integer value
        //b ||ejc|||||28023
        
//      sorta (continued)
//      here with sort column index in ia in array case
// srt03:
        //b |srt03|sbi|13,arlb2(xl)|||subtract low bound|28029
        C_GOTO(srt03);
        } /* srt02 */
        

        void srt03() {
        ia-=*((word *)(CFP_B*ARLB2 + xl));				// subtract low bound
        //b ||iov|6,srt17|||fail if overflow|28030
        /*g.ino g.iov is a noop, but could be done like g.aov*/				// fail if overflow
        //b ||ilt|6,srt17|||fail if below low bound|28031
        if (ia < 0)  C_GOTO(srt17);				// fail if below low bound
        //b ||sbi|13,ardm2(xl)|||check against dimension|28032
        ia-=*((word *)(CFP_B*ARDM2 + xl));				// check against dimension
        //b ||ige|6,srt17|||fail if too large|28033
        if (ia >= 0)  C_GOTO(srt17);				// fail if too large
        //b ||adi|13,ardm2(xl)|||restore value|28034
        ia+=*((word *)(CFP_B*ARDM2 + xl));				// restore value
        //b ||mfi|8,wa|||get as small integer|28035
        wa = ia;				// get as small integer
        //b ||wtb|8,wa|||offset within row to key|28036
        wa <<= LOG_CFP_B;				// offset within row to key
        //b ||mov|3,srtof|8,wa||keep offset|28037
        v.srtof= wa;				// keep offset
        //b ||ldi|13,ardm2(xl)|||second dimension is row length|28038
        ia = *((word *)(CFP_B*ARDM2 + xl));				// second dimension is row length
        //b ||mfi|8,wa|||convert to short integer|28039
        wa = ia;				// convert to short integer
        //b ||mov|7,xr|8,wa||copy row length|28040
        xr= wa;				// copy row length
        //b ||wtb|8,wa|||convert to bytes|28041
        wa <<= LOG_CFP_B;				// convert to bytes
        //b ||mov|3,srtst|8,wa||store as stride|28042
        v.srtst= wa;				// store as stride
        //b ||ldi|13,ardim(xl)|||get number of rows|28043
        ia = *((word *)(CFP_B*ARDIM + xl));				// get number of rows
        //b ||mfi|8,wa|||as a short integer|28044
        wa = ia;				// as a short integer
        //b ||wtb|8,wa|||convert n to baus|28045
        wa <<= LOG_CFP_B;				// convert n to baus
        //b ||mov|8,wc|13,arlen(xl)||offset past array end|28046
        wc= *((word *)(CFP_B*ARLEN + xl));				// offset past array end
        //b ||sub|8,wc|8,wa||adjust, giving space for n offsets|28047
        wc -= wa;				// adjust, giving space for n offsets
        //b ||dca|8,wc|||point to a(0)|28048
        wc -= CFP_B;				// point to a(0)
        //b ||mov|8,wb|13,arofs(xl)||offset to word before first item|28049
        wb= *((word *)(CFP_B*AROFS + xl));				// offset to word before first item
        //b ||ica|8,wb|||offset to first item|28050
        wb += CFP_B;				// offset to first item
//      separate pre-processing for arrays and vectors done.
//      to simplify later key comparisons, removal of any trblk
//      trap blocks from entries in key array is effected.
//      (xl) = 1(xs) = pointer to key array
//      (xs) = pointer to sort array
//      wa = number of items, n (converted to bytes).
//      wb = offset to first item of arrays.
//      wc = offset to a(0)
// srt04:
        //b |srt04|ble|8,wa|19,*num01|6,srt15|return if only a single item|28062
        C_GOTO(srt04);
        } /* srt03 */
        

        void srt04() {
        if ((wa-CFP_B*NUM01) <= 0) C_GOTO(srt15);				// return if only a single item
        //b ||mov|3,srtsn|8,wa||store number of items (in baus)|28063
        v.srtsn= wa;				// store number of items (in baus)
        //b ||mov|3,srtso|8,wc||store offset to a(0)|28064
        v.srtso= wc;				// store offset to a(0)
        //b ||mov|8,wc|13,arlen(xl)||length of array or vec (=vclen)|28065
        wc= *((word *)(CFP_B*ARLEN + xl));				// length of array or vec (=vclen)
        //b ||add|8,wc|7,xl||point past end of array or vector|28066
        wc += xl;				// point past end of array or vector
        //b ||mov|3,srtsf|8,wb||store offset to first row|28067
        v.srtsf= wb;				// store offset to first row
        //b ||add|7,xl|8,wb||point to first item in key array|28068
        xl += wb;				// point to first item in key array
//      loop through array
// srt05:
        //b |srt05|mov|7,xr|9,(xl)||get an entry|28072
        C_GOTO(srt05);
        } /* srt04 */
        

        void srt05() {
        xr= *(xl_it.wp);				// get an entry
//      hunt along trblk chain
// srt06:
        //b |srt06|bne|9,(xr)|22,=b_trt|6,srt07|jump out if not trblk|28076
        C_GOTO(srt06);
        } /* srt05 */
        

        void srt06() {
        if ((*(xr_it.wp)-(word)(b_trt)) != 0) C_GOTO(srt07);				// jump out if not trblk
        //b ||mov|7,xr|13,trval(xr)||get value field|28077
        xr= *((word *)(CFP_B*TRVAL + xr));				// get value field
        //b ||brn|6,srt06|||loop|28078
         C_GOTO(srt06);				// loop
        //b ||ejc|||||28079
        
//      sorta (continued)
//      xr is value from end of chain
// srt07:
        //b |srt07|mov|10,(xl)+|7,xr||store as array entry|28085
        } /* srt06 */
        

        void srt07() {
        *(xl_it.wp++)= xr;				// store as array entry
        //b ||blt|7,xl|8,wc|6,srt05|loop if not done|28086
        if ((xl-wc) < 0) C_GOTO(srt05);				// loop if not done
        //b ||mov|7,xl|9,(xs)||get adrs of sort array|28087
        xl= *(xs_it.wp);				// get adrs of sort array
        //b ||mov|7,xr|3,srtsf||initial offset to first key|28088
        xr= v.srtsf;				// initial offset to first key
        //b ||mov|8,wb|3,srtst||get stride|28089
        wb= v.srtst;				// get stride
        //b ||add|7,xl|3,srtso||offset to a(0)|28090
        xl += v.srtso;				// offset to a(0)
        //b ||ica|7,xl|||point to a(1)|28091
        xl += CFP_B;				// point to a(1)
        //b ||mov|8,wc|3,srtsn||get n|28092
        wc= v.srtsn;				// get n
        //b ||btw|8,wc|||convert from bytes|28093
        wc >>= LOG_CFP_B;				// convert from bytes
        //b ||mov|3,srtnr|8,wc||store as row count|28094
        v.srtnr= wc;				// store as row count
        //b ||lct|8,wc|8,wc||loop counter|28095
        wc= wc;				// loop counter
//      store key offsets at top of sort array
// srt08:
        //b |srt08|mov|10,(xl)+|7,xr||store an offset|28099
        C_GOTO(srt08);
        } /* srt07 */
        

        void srt08() {
        *(xl_it.wp++)= xr;				// store an offset
        //b ||add|7,xr|8,wb||bump offset by stride|28100
        xr += wb;				// bump offset by stride
        //b ||bct|8,wc|6,srt08||loop through rows|28101
        if ((--wc))  C_GOTO(srt08);				// loop through rows
//      perform the sort on offsets in sort array.
//      (srtsn)               number of items to sort, n (bytes)
//      (srtso)               offset to a(0)
// srt09:
        //b |srt09|mov|8,wa|3,srtsn||get n|28108
        C_GOTO(srt09);
        } /* srt08 */
        

        void srt09() {
        wa= v.srtsn;				// get n
        //b ||mov|8,wc|3,srtnr||get number of rows|28109
        wc= v.srtnr;				// get number of rows
        //b ||rsh|8,wc|1,1||i = n / 2 (wc=i, index into array)|28110
        wc >>= 1;				// i = n / 2 (wc=i, index into array)
        //b ||wtb|8,wc|||convert back to bytes|28111
        wc <<= LOG_CFP_B;				// convert back to bytes
//      loop to form initial heap
// srt10:
        //b |srt10|jsr|6,sorth|||sorth(i,n)|28115
        C_GOTO(srt10);
        } /* srt09 */
        

        void srt10() {
        extern void _l0724();
        C_JMS(sorth,P_PRC_SORTH,_l0724);
        } /* srt10 */
        

        void _l0724() {
        //b ||dca|8,wc|||i = i - 1|28116
        wc -= CFP_B;				// i = i - 1
        //b ||bnz|8,wc|6,srt10||loop if i gt 0|28117
        if (wc) C_GOTO(srt10);				// loop if i gt 0
        //b ||mov|8,wc|8,wa||i = n|28118
        wc= wa;				// i = n
//      sorting loop. at this point, a(1) is the largest
//      item, since algorithm initialises it as, and then maintains
//      it as, root of tree.
// srt11:
        //b |srt11|dca|8,wc|||i = i - 1 (n - 1 initially)|28124
        C_GOTO(srt11);
        } /* _l0724 */
        

        void srt11() {
        wc -= CFP_B;				// i = i - 1 (n - 1 initially)
        //b ||bze|8,wc|6,srt12||jump if done|28125
        if ( !( wc) ) C_GOTO(srt12);				// jump if done
        //b ||mov|7,xr|9,(xs)||get sort array address|28126
        xr= *(xs_it.wp);				// get sort array address
        //b ||add|7,xr|3,srtso||point to a(0)|28127
        xr += v.srtso;				// point to a(0)
        //b ||mov|7,xl|7,xr||a(0) address|28128
        xl= xr;				// a(0) address
        //b ||add|7,xl|8,wc||a(i) address|28129
        xl += wc;				// a(i) address
        //b ||mov|8,wb|13,num01(xl)||copy a(i+1)|28130
        wb= *((word *)(CFP_B*NUM01 + xl));				// copy a(i+1)
        //b ||mov|13,num01(xl)|13,num01(xr)||move a(1) to a(i+1)|28131
        *((word *)(CFP_B*NUM01 + xl))= *((word *)(CFP_B*NUM01 + xr));				// move a(1) to a(i+1)
        //b ||mov|13,num01(xr)|8,wb||complete exchange of a(1), a(i+1)|28132
        *((word *)(CFP_B*NUM01 + xr))= wb;				// complete exchange of a(1), a(i+1)
        //b ||mov|8,wa|8,wc||n = i for sorth|28133
        wa= wc;				// n = i for sorth
        //b ||mov|8,wc|19,*num01||i = 1 for sorth|28134
        wc= CFP_B*NUM01;				// i = 1 for sorth
        //b ||jsr|6,sorth|||sorth(1,n)|28135
        extern void _l0725();
        C_JMS(sorth,P_PRC_SORTH,_l0725);
        } /* srt11 */
        

        void _l0725() {
        //b ||mov|8,wc|8,wa||restore wc|28136
        wc= wa;				// restore wc
        //b ||brn|6,srt11|||loop|28137
         C_GOTO(srt11);				// loop
        //b ||ejc|||||28138
        
//      sorta (continued)
//      offsets have been permuted into required order by sort.
//      copy array elements over them.
// srt12:
        //b |srt12|mov|7,xr|9,(xs)||base adrs of key array|28145
        } /* _l0725 */
        

        void srt12() {
        xr= *(xs_it.wp);				// base adrs of key array
        //b ||mov|8,wc|7,xr||copy it|28146
        wc= xr;				// copy it
        //b ||add|8,wc|3,srtso||offset of a(0)|28147
        wc += v.srtso;				// offset of a(0)
        //b ||add|7,xr|3,srtsf||adrs of first row of sort array|28148
        xr += v.srtsf;				// adrs of first row of sort array
        //b ||mov|8,wb|3,srtst||get stride|28149
        wb= v.srtst;				// get stride
//      copying loop for successive items. sorted offsets are
//      held at end of sort array.
// srt13:
        //b |srt13|ica|8,wc|||adrs of next of sorted offsets|28154
        C_GOTO(srt13);
        } /* srt12 */
        

        void srt13() {
        wc += CFP_B;				// adrs of next of sorted offsets
        //b ||mov|7,xl|8,wc||copy it for access|28155
        xl= wc;				// copy it for access
        //b ||mov|7,xl|9,(xl)||get offset|28156
        xl= *(xl_it.wp);				// get offset
        //b ||add|7,xl|13,num01(xs)||add key array base adrs|28157
        xl += *((word *)(CFP_B*NUM01 + xs));				// add key array base adrs
        //b ||mov|8,wa|8,wb||get count of characters in row|28158
        wa= wb;				// get count of characters in row
        //b ||mvw||||copy a complete row|28159
        wa = wa >> LOG_CFP_B; do { *(xr_it.wp++)= *(xl_it.wp++); } while (--wa);				// copy a complete row
        //b ||dcv|3,srtnr|||decrement row count|28160
        (v.srtnr)--;				// decrement row count
        //b ||bnz|3,srtnr|6,srt13||repeat till all rows done|28161
        if (v.srtnr) C_GOTO(srt13);				// repeat till all rows done
//      return point
// srt15:
        //b |srt15|mov|7,xr|10,(xs)+||pop result array ptr|28165
        C_GOTO(srt15);
        } /* srt13 */
        

        void srt15() {
        xr= C_POP();				// pop result array ptr
        //b ||ica|7,xs|||pop key array ptr|28166
        xs += CFP_B;				// pop key array ptr
        //b ||zer|3,r_sxl|||clear junk|28167
        v.r_sxl=0;				// clear junk
        //b ||zer|3,r_sxr|||clear junk|28168
        v.r_sxr=0;				// clear junk
        //b ||exi||||return|28169
        C_NEXIT(P_PRC_SORTA,0);				// return
//      error point
// srt16:
        //b |srt16|erb|1,256|26,sort/rsort 1st arg not suitable array or table|||28173
        } /* srt15 */
        

        void srt16() {
        C_ERB(256)
// srt17:
        //b |srt17|erb|1,258|26,sort/rsort 2nd arg out of range or non-integer|||28174
        } /* srt16 */
        

        void srt17() {
        C_ERB(258)
//      return point if input table is empty
// srt18:
        //b |srt18|exi|1,1|||return indication of null table|28178
        } /* srt17 */
        

        void srt18() {
        C_NEXIT(P_PRC_SORTA,1);				// return indication of null table
        //b ||ejc|||||28180
        
//      sortc --  compare sort keys
//      compare two sort keys given their offsets. if
//      equal, compare key offsets to give stable sort.
//      note that if srtsr is non-zero (request for reverse
//      sort), the quoted returns are inverted.
//      for objects of differing datatypes, the entry point
//      identifications are compared.
//      (xl)                  base adrs for keys
//      (wa)                  offset to key 1 item
//      (wb)                  offset to key 2 item
//      (srtsr)               zero/non-zero for sort/rsort
//      (srtof)               offset within row to comparands
//      jsr  sortc            call to compare keys
//      ppm  loc              key1 less than key2
//                            normal return, key1 gt than key2
//      (xl,xr,wa,wb)         destroyed
// sortc:
        //b |sortc|prc|25,e|1,1||entry point|28201
        } /* srt18 */
        

        void sortc() {
        //b ||mov|3,srts1|8,wa||save offset 1|28202
        v.srts1= wa;				// save offset 1
        //b ||mov|3,srts2|8,wb||save offset 2|28203
        v.srts2= wb;				// save offset 2
        //b ||mov|3,srtsc|8,wc||save wc|28204
        v.srtsc= wc;				// save wc
        //b ||add|7,xl|3,srtof||add offset to comparand field|28205
        xl += v.srtof;				// add offset to comparand field
        //b ||mov|7,xr|7,xl||copy base + offset|28206
        xr= xl;				// copy base + offset
        //b ||add|7,xl|8,wa||add key1 offset|28207
        xl += wa;				// add key1 offset
        //b ||add|7,xr|8,wb||add key2 offset|28208
        xr += wb;				// add key2 offset
        //b ||mov|7,xl|9,(xl)||get key1|28209
        xl= *(xl_it.wp);				// get key1
        //b ||mov|7,xr|9,(xr)||get key2|28210
        xr= *(xr_it.wp);				// get key2
        //b ||bne|3,srtdf|21,=nulls|6,src12|jump if datatype field name used|28211
        if ((v.srtdf-(word)(&c.nulls)) != 0) C_GOTO(src12);				// jump if datatype field name used
        //b ||ejc|||||28212
        
//      sortc (continued)
//      merge after dealing with field name. try for strings.
// src01:
        //b |src01|mov|8,wc|9,(xl)||get type code|28218
        C_GOTO(src01);
        } /* sortc */
        

        void src01() {
        wc= *(xl_it.wp);				// get type code
        //b ||bne|8,wc|9,(xr)|6,src02|skip if not same datatype|28219
        if ((wc-*(xr_it.wp)) != 0) C_GOTO(src02);				// skip if not same datatype
        //b ||beq|8,wc|22,=b_scl|6,src09|jump if both strings|28220
        if ((wc-(word)(b_scl)) == 0) C_GOTO(src09);				// jump if both strings
        //b ||beq|8,wc|22,=b_icl|6,src14|jump if both integers|28221
        if ((wc-(word)(b_icl)) == 0) C_GOTO(src14);				// jump if both integers
//      datatypes different.  now try for numeric
// src02:
        //b |src02|mov|3,r_sxl|7,xl||keep arg1|28229
        C_GOTO(src02);
        } /* src01 */
        

        void src02() {
        v.r_sxl= xl;				// keep arg1
        //b ||mov|3,r_sxr|7,xr||keep arg2|28230
        v.r_sxr= xr;				// keep arg2
        //b ||beq|8,wc|22,=b_scl|6,src11|do not allow conversion to number|28233
        if ((wc-(word)(b_scl)) == 0) C_GOTO(src11);				// do not allow conversion to number
        //b ||beq|9,(xr)|22,=b_scl|6,src11|if either arg is a string|28234
        if ((*(xr_it.wp)-(word)(b_scl)) == 0) C_GOTO(src11);				// if either arg is a string
// src14:
        //b |src14|mov|11,-(xs)|7,xl||stack|28277
        C_GOTO(src14);
        } /* src02 */
        

        void src14() {
        C_PUSH(xl);				// stack
        //b ||mov|11,-(xs)|7,xr||args|28278
        C_PUSH(xr);				// args
        //b ||ppm|6,src05|||key1 greater|28284
        extern void _l0726();
        C_JMS(acomp,P_PRC_ACOMP,_l0726);
        } /* src14 */
        

        void _l0726() {
        C_JMS_HANDLE_5(acomp,C_GOTO(src10),C_GOTO(src10),C_GOTO(src03),C_GOTO(src08),C_GOTO(src05));				// key1 greater
//      return if key1 smaller (sort), greater (rsort)
// src03:
        //b |src03|bnz|3,srtsr|6,src06||jump if rsort|28288
        C_GOTO(src03);
        } /* _l0726 */
        

        void src03() {
        if (v.srtsr) C_GOTO(src06);				// jump if rsort
// src04:
        //b |src04|mov|8,wc|3,srtsc||restore wc|28290
        C_GOTO(src04);
        } /* src03 */
        

        void src04() {
        wc= v.srtsc;				// restore wc
        //b ||exi|1,1|||return|28291
        C_EXIT(1);				// return
//      return if key1 greater (sort), smaller (rsort)
// src05:
        //b |src05|bnz|3,srtsr|6,src04||jump if rsort|28295
        } /* src04 */
        

        void src05() {
        if (v.srtsr) C_GOTO(src04);				// jump if rsort
// src06:
        //b |src06|mov|8,wc|3,srtsc||restore wc|28297
        C_GOTO(src06);
        } /* src05 */
        

        void src06() {
        wc= v.srtsc;				// restore wc
        //b ||exi||||return|28298
        C_EXIT(0);				// return
//      keys are of same datatype
// src07:
        //b |src07|blt|7,xl|7,xr|6,src03|item first created is less|28302
        } /* src06 */
        

        void src07() {
        if ((xl-xr) < 0) C_GOTO(src03);				// item first created is less
        //b ||bgt|7,xl|7,xr|6,src05|addresses rise in order of creation|28303
        if ((xl-xr) > 0) C_GOTO(src05);				// addresses rise in order of creation
//      drop through or merge for identical or equal objects
// src08:
        //b |src08|blt|3,srts1|3,srts2|6,src04|test offsets or key addrss instead|28307
        C_GOTO(src08);
        } /* src07 */
        

        void src08() {
        if ((v.srts1-v.srts2) < 0) C_GOTO(src04);				// test offsets or key addrss instead
        //b ||brn|6,src06|||offset 1 greater|28308
         C_GOTO(src06);				// offset 1 greater
        //b ||ejc|||||28309
        
//      sortc (continued)
//      strings
// src09:
        //b |src09|mov|11,-(xs)|7,xl||stack|28319
        } /* src08 */
        

        void src09() {
        C_PUSH(xl);				// stack
        //b ||mov|11,-(xs)|7,xr||args|28320
        C_PUSH(xr);				// args
        //b ||ppm|6,src05|||key1 greater|28326
        extern void _l0727();
        C_JMS(lcomp,P_PRC_LCOMP,_l0727);
        } /* src09 */
        

        void _l0727() {
        C_JMS_HANDLE_5(lcomp,(C_ERR(299)),(C_ERR(299)),C_GOTO(src03),C_GOTO(src08),C_GOTO(src05));				// key1 greater
//      arithmetic comparison failed - recover args
// src10:
        //b |src10|mov|7,xl|3,r_sxl||get arg1|28330
        C_GOTO(src10);
        } /* _l0727 */
        

        void src10() {
        xl= v.r_sxl;				// get arg1
        //b ||mov|7,xr|3,r_sxr||get arg2|28331
        xr= v.r_sxr;				// get arg2
        //b ||mov|8,wc|9,(xl)||get type of key1|28332
        wc= *(xl_it.wp);				// get type of key1
        //b ||beq|8,wc|9,(xr)|6,src07|jump if keys of same type|28333
        if ((wc-*(xr_it.wp)) == 0) C_GOTO(src07);				// jump if keys of same type
//      here to compare datatype ids
// src11:
        //b |src11|mov|7,xl|8,wc||get block type word|28337
        C_GOTO(src11);
        } /* src10 */
        

        void src11() {
        xl= wc;				// get block type word
        //b ||mov|7,xr|9,(xr)||get block type word|28338
        xr= *(xr_it.wp);				// get block type word
        //b ||lei|7,xl|||entry point id for key1|28339
        xl = find_elab(xl);    /* get entry code */				// entry point id for key1
        //b ||lei|7,xr|||entry point id for key2|28340
        xr = find_elab(xr);    /* get entry code */				// entry point id for key2
        //b ||bgt|7,xl|7,xr|6,src05|jump if key1 gt key2|28341
        if ((xl-xr) > 0) C_GOTO(src05);				// jump if key1 gt key2
        //b ||brn|6,src03|||key1 lt key2|28342
         C_GOTO(src03);				// key1 lt key2
//      datatype field name used
// src12:
        //b |src12|jsr|6,sortf|||call routine to find field 1|28346
        } /* src11 */
        

        void src12() {
        C_JSR(sortf);				// call routine to find field 1
        //b ||mov|11,-(xs)|7,xl||stack item pointer|28347
        C_PUSH(xl);				// stack item pointer
        //b ||mov|7,xl|7,xr||get key2|28348
        xl= xr;				// get key2
        //b ||jsr|6,sortf|||find field 2|28349
        C_JSR(sortf);				// find field 2
        //b ||mov|7,xr|7,xl||place as key2|28350
        xr= xl;				// place as key2
        //b ||mov|7,xl|10,(xs)+||recover key1|28351
        xl= C_POP();				// recover key1
        //b ||brn|6,src01|||merge|28352
         C_GOTO(src01);				// merge
        //b ||ejc|||||28354
        
//      sortf -- find field for sortc
//      routine used by sortc to obtain item corresponding
//      to a given field name, if this exists, in a programmer
//      defined object passed as argument.
//      if such a match occurs, record is kept of datatype
//      name, field name and offset to field in order to
//      short-circuit later searches on same type. note that
//      dfblks are stored in static and hence cannot be moved.
//      (srtdf)               vrblk pointer of field name
//      (xl)                  possible pdblk pointer
//      jsr  sortf            call to search for field name
//      (xl)                  item found or original pdblk ptr
//      (wc)                  destroyed
// sortf:
        //b |sortf|prc|25,e|1,0||entry point|28372
        } /* src12 */
        

        void sortf() {
        //b ||bne|9,(xl)|22,=b_pdt|6,srtf3|return if not pdblk|28373
        if ((*(xl_it.wp)-(word)(b_pdt)) != 0) C_GOTO(srtf3);				// return if not pdblk
        //b ||mov|11,-(xs)|7,xr||keep xr|28374
        C_PUSH(xr);				// keep xr
        //b ||mov|7,xr|3,srtfd||get possible former dfblk ptr|28375
        xr= v.srtfd;				// get possible former dfblk ptr
        //b ||bze|7,xr|6,srtf4||jump if not|28376
        if ( !( xr) ) C_GOTO(srtf4);				// jump if not
        //b ||bne|7,xr|13,pddfp(xl)|6,srtf4|jump if not right datatype|28377
        if ((xr-*((word *)(CFP_B*PDDFP + xl))) != 0) C_GOTO(srtf4);				// jump if not right datatype
        //b ||bne|3,srtdf|3,srtff|6,srtf4|jump if not right field name|28378
        if ((v.srtdf-v.srtff) != 0) C_GOTO(srtf4);				// jump if not right field name
        //b ||add|7,xl|3,srtfo||add offset to required field|28379
        xl += v.srtfo;				// add offset to required field
//      here with xl pointing to found field
// srtf1:
        //b |srtf1|mov|7,xl|9,(xl)||get item from field|28383
        C_GOTO(srtf1);
        } /* sortf */
        

        void srtf1() {
        xl= *(xl_it.wp);				// get item from field
//      return point
// srtf2:
        //b |srtf2|mov|7,xr|10,(xs)+||restore xr|28387
        C_GOTO(srtf2);
        } /* srtf1 */
        

        void srtf2() {
        xr= C_POP();				// restore xr
// srtf3:
        //b |srtf3|exi||||return|28389
        C_GOTO(srtf3);
        } /* srtf2 */
        

        void srtf3() {
        C_EXIT(0);				// return
        //b ||ejc|||||28390
        
//      sortf (continued)
//      conduct a search
// srtf4:
        //b |srtf4|mov|7,xr|7,xl||copy original pointer|28396
        } /* srtf3 */
        

        void srtf4() {
        xr= xl;				// copy original pointer
        //b ||mov|7,xr|13,pddfp(xr)||point to dfblk|28397
        xr= *((word *)(CFP_B*PDDFP + xr));				// point to dfblk
        //b ||mov|3,srtfd|7,xr||keep a copy|28398
        v.srtfd= xr;				// keep a copy
        //b ||mov|8,wc|13,fargs(xr)||get number of fields|28399
        wc= *((word *)(CFP_B*FARGS + xr));				// get number of fields
        //b ||wtb|8,wc|||convert to bytes|28400
        wc <<= LOG_CFP_B;				// convert to bytes
        //b ||add|7,xr|13,dflen(xr)||point past last field|28401
        xr += *((word *)(CFP_B*DFLEN + xr));				// point past last field
//      loop to find name in pdfblk
// srtf5:
        //b |srtf5|dca|8,wc|||count down|28405
        C_GOTO(srtf5);
        } /* srtf4 */
        

        void srtf5() {
        wc -= CFP_B;				// count down
        //b ||dca|7,xr|||point in front|28406
        xr -= CFP_B;				// point in front
        //b ||beq|9,(xr)|3,srtdf|6,srtf6|skip out if found|28407
        if ((*(xr_it.wp)-v.srtdf) == 0) C_GOTO(srtf6);				// skip out if found
        //b ||bnz|8,wc|6,srtf5||loop|28408
        if (wc) C_GOTO(srtf5);				// loop
        //b ||brn|6,srtf2|||return - not found|28409
         C_GOTO(srtf2);				// return - not found
//      found
// srtf6:
        //b |srtf6|mov|3,srtff|9,(xr)||keep field name ptr|28413
        } /* srtf5 */
        

        void srtf6() {
        v.srtff= *(xr_it.wp);				// keep field name ptr
        //b ||add|8,wc|19,*pdfld||add offset to first field|28414
        wc += CFP_B*PDFLD;				// add offset to first field
        //b ||mov|3,srtfo|8,wc||store as field offset|28415
        v.srtfo= wc;				// store as field offset
        //b ||add|7,xl|8,wc||point to field|28416
        xl += wc;				// point to field
        //b ||brn|6,srtf1|||return|28417
         C_GOTO(srtf1);				// return
        //b ||ejc|||||28419
        
//      sorth -- heap routine for sorta
//      this routine constructs a heap from elements of array, a.
//      in this application, the elements are offsets to keys in
//      a key array.
//      (xs)                  pointer to sort array base
//      1(xs)                 pointer to key array base
//      (wa)                  max array index, n (in bytes)
//      (wc)                  offset j in a to root (in *1 to *n)
//      jsr  sorth            call sorth(j,n) to make heap
//      (xl,xr,wb)            destroyed
// sorth:
        //b |sorth|prc|25,n|1,0||entry point|28434
        } /* srtf6 */
        

        void sorth() {
        //b ||mov|3,srtsn|8,wa||save n|28435
        v.srtsn= wa;				// save n
        //b ||mov|3,srtwc|8,wc||keep wc|28436
        v.srtwc= wc;				// keep wc
        //b ||mov|7,xl|9,(xs)||sort array base adrs|28437
        xl= *(xs_it.wp);				// sort array base adrs
        //b ||add|7,xl|3,srtso||add offset to a(0)|28438
        xl += v.srtso;				// add offset to a(0)
        //b ||add|7,xl|8,wc||point to a(j)|28439
        xl += wc;				// point to a(j)
        //b ||mov|3,srtrt|9,(xl)||get offset to root|28440
        v.srtrt= *(xl_it.wp);				// get offset to root
        //b ||add|8,wc|8,wc||double j - cant exceed n|28441
        wc += wc;				// double j - cant exceed n
//      loop to move down tree using doubled index j
// srh01:
        //b |srh01|bgt|8,wc|3,srtsn|6,srh03|done if j gt n|28445
        C_GOTO(srh01);
        } /* sorth */
        

        void srh01() {
        if ((wc-v.srtsn) > 0) C_GOTO(srh03);				// done if j gt n
        //b ||beq|8,wc|3,srtsn|6,srh02|skip if j equals n|28446
        if ((wc-v.srtsn) == 0) C_GOTO(srh02);				// skip if j equals n
        //b ||mov|7,xr|9,(xs)||sort array base adrs|28447
        xr= *(xs_it.wp);				// sort array base adrs
        //b ||mov|7,xl|13,num01(xs)||key array base adrs|28448
        xl= *((word *)(CFP_B*NUM01 + xs));				// key array base adrs
        //b ||add|7,xr|3,srtso||point to a(0)|28449
        xr += v.srtso;				// point to a(0)
        //b ||add|7,xr|8,wc||adrs of a(j)|28450
        xr += wc;				// adrs of a(j)
        //b ||mov|8,wa|13,num01(xr)||get a(j+1)|28451
        wa= *((word *)(CFP_B*NUM01 + xr));				// get a(j+1)
        //b ||mov|8,wb|9,(xr)||get a(j)|28452
        wb= *(xr_it.wp);				// get a(j)
//      compare sons. (wa) right son, (wb) left son
        //b ||ppm|6,srh02|||a(j+1) lt a(j)|28457
        C_JSR_1(sortc,C_GOTO(srh02));				// a(j+1) lt a(j)
        //b ||ica|8,wc|||point to greater son, a(j+1)|28458
        wc += CFP_B;				// point to greater son, a(j+1)
        //b ||ejc|||||28459
        
//      sorth (continued)
//      compare root with greater son
// srh02:
        //b |srh02|mov|7,xl|13,num01(xs)||key array base adrs|28465
        C_GOTO(srh02);
        } /* srh01 */
        

        void srh02() {
        xl= *((word *)(CFP_B*NUM01 + xs));				// key array base adrs
        //b ||mov|7,xr|9,(xs)||get sort array address|28466
        xr= *(xs_it.wp);				// get sort array address
        //b ||add|7,xr|3,srtso||adrs of a(0)|28467
        xr += v.srtso;				// adrs of a(0)
        //b ||mov|8,wb|7,xr||copy this adrs|28468
        wb= xr;				// copy this adrs
        //b ||add|7,xr|8,wc||adrs of greater son, a(j)|28469
        xr += wc;				// adrs of greater son, a(j)
        //b ||mov|8,wa|9,(xr)||get a(j)|28470
        wa= *(xr_it.wp);				// get a(j)
        //b ||mov|7,xr|8,wb||point back to a(0)|28471
        xr= wb;				// point back to a(0)
        //b ||mov|8,wb|3,srtrt||get root|28472
        wb= v.srtrt;				// get root
        //b ||ppm|6,srh03|||father exceeds sons - done|28474
        C_JSR_1(sortc,C_GOTO(srh03));				// father exceeds sons - done
        //b ||mov|7,xr|9,(xs)||get sort array adrs|28475
        xr= *(xs_it.wp);				// get sort array adrs
        //b ||add|7,xr|3,srtso||point to a(0)|28476
        xr += v.srtso;				// point to a(0)
        //b ||mov|7,xl|7,xr||copy it|28477
        xl= xr;				// copy it
        //b ||mov|8,wa|8,wc||copy j|28478
        wa= wc;				// copy j
        //b ||btw|8,wc|||convert to words|28479
        wc >>= LOG_CFP_B;				// convert to words
        //b ||rsh|8,wc|1,1||get j/2|28480
        wc >>= 1;				// get j/2
        //b ||wtb|8,wc|||convert back to bytes|28481
        wc <<= LOG_CFP_B;				// convert back to bytes
        //b ||add|7,xl|8,wa||point to a(j)|28482
        xl += wa;				// point to a(j)
        //b ||add|7,xr|8,wc||adrs of a(j/2)|28483
        xr += wc;				// adrs of a(j/2)
        //b ||mov|9,(xr)|9,(xl)||a(j/2) = a(j)|28484
        *(xr_it.wp)= *(xl_it.wp);				// a(j/2) = a(j)
        //b ||mov|8,wc|8,wa||recover j|28485
        wc= wa;				// recover j
        //b ||aov|8,wc|8,wc|6,srh03|j = j*2. done if too big|28486
        wc+=wc;				// j = j*2. done if too big
        //b ||brn|6,srh01|||loop|28487
         C_GOTO(srh01);				// loop
//      finish by copying root offset back into array
// srh03:
        //b |srh03|btw|8,wc|||convert to words|28491
        } /* srh02 */
        

        void srh03() {
        wc >>= LOG_CFP_B;				// convert to words
        //b ||rsh|8,wc|1,1||j = j/2|28492
        wc >>= 1;				// j = j/2
        //b ||wtb|8,wc|||convert back to bytes|28493
        wc <<= LOG_CFP_B;				// convert back to bytes
        //b ||mov|7,xr|9,(xs)||sort array adrs|28494
        xr= *(xs_it.wp);				// sort array adrs
        //b ||add|7,xr|3,srtso||adrs of a(0)|28495
        xr += v.srtso;				// adrs of a(0)
        //b ||add|7,xr|8,wc||adrs of a(j/2)|28496
        xr += wc;				// adrs of a(j/2)
        //b ||mov|9,(xr)|3,srtrt||a(j/2) = root|28497
        *(xr_it.wp)= v.srtrt;				// a(j/2) = root
        //b ||mov|8,wa|3,srtsn||restore wa|28498
        wa= v.srtsn;				// restore wa
        //b ||mov|8,wc|3,srtwc||restore wc|28499
        wc= v.srtwc;				// restore wc
        //b ||exi||||return|28500
        C_NEXIT(P_PRC_SORTH,0);				// return
        //b ||ejc|||||28503
        
//      trace -- set/reset a trace association
//      this procedure is shared by trace and stoptr to
//      either initiate or stop a trace respectively.
//      (xl)                  trblk ptr (trace) or zero (stoptr)
//      1(xs)                 first argument (name)
//      0(xs)                 second argument (trace type)
//      jsr  trace            call to set/reset trace
//      ppm  loc              transfer loc if 1st arg is bad name
//      ppm  loc              transfer loc if 2nd arg is bad type
//      (xs)                  popped
//      (xl,xr,wa,wb,wc,ia)   destroyed
// trace:
        //b |trace|prc|25,n|1,2||entry point|28519
        } /* srh03 */
        

        void trace() {
        //b ||ppm|6,trc15|||jump if not string|28521
        extern void _l0728();
        C_JMS(gtstg,P_PRC_GTSTG,_l0728);
        } /* trace */
        

        void _l0728() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(trc15));				// jump if not string
        //b ||plc|7,xr|||else point to string|28522
        xr += CFP_F;				// else point to string
        //b ||lch|8,wa|9,(xr)||load first character|28523
        wa = *(xr_it.chp);				// load first character
        //b ||mov|7,xr|9,(xs)||load name argument|28527
        xr= *(xs_it.wp);				// load name argument
        //b ||mov|9,(xs)|7,xl||stack trblk ptr or zero|28528
        *(xs_it.wp)= xl;				// stack trblk ptr or zero
        //b ||mov|8,wc|18,=trtac||set trtyp for access trace|28529
        wc= TRTAC;				// set trtyp for access trace
        //b ||beq|8,wa|18,=ch_la|6,trc10|jump if a (access)|28530
        if ((wa-CH_LA) == 0) C_GOTO(trc10);				// jump if a (access)
        //b ||mov|8,wc|18,=trtvl||set trtyp for value trace|28531
        wc= TRTVL;				// set trtyp for value trace
        //b ||beq|8,wa|18,=ch_lv|6,trc10|jump if v (value)|28532
        if ((wa-CH_LV) == 0) C_GOTO(trc10);				// jump if v (value)
        //b ||beq|8,wa|18,=ch_bl|6,trc10|jump if blank (value)|28533
        if ((wa-CH_BL) == 0) C_GOTO(trc10);				// jump if blank (value)
//      here for l,k,f,c,r
        //b ||beq|8,wa|18,=ch_lf|6,trc01|jump if f (function)|28537
        if ((wa-CH_LF) == 0) C_GOTO(trc01);				// jump if f (function)
        //b ||beq|8,wa|18,=ch_lr|6,trc01|jump if r (return)|28538
        if ((wa-CH_LR) == 0) C_GOTO(trc01);				// jump if r (return)
        //b ||beq|8,wa|18,=ch_ll|6,trc03|jump if l (label)|28539
        if ((wa-CH_LL) == 0) C_GOTO(trc03);				// jump if l (label)
        //b ||beq|8,wa|18,=ch_lk|6,trc06|jump if k (keyword)|28540
        if ((wa-CH_LK) == 0) C_GOTO(trc06);				// jump if k (keyword)
        //b ||bne|8,wa|18,=ch_lc|6,trc15|else error if not c (call)|28541
        if ((wa-CH_LC) != 0) C_GOTO(trc15);				// else error if not c (call)
//      here for f,c,r
// trc01:
        //b |trc01|jsr|6,gtnvr|||point to vrblk for name|28545
        C_GOTO(trc01);
        } /* _l0728 */
        

        void trc01() {
        //b ||ppm|6,trc16|||jump if bad name|28546
        C_JSR_1(gtnvr,C_GOTO(trc16));				// jump if bad name
        //b ||ica|7,xs|||pop stack|28547
        xs += CFP_B;				// pop stack
        //b ||mov|7,xr|13,vrfnc(xr)||point to function block|28548
        xr= *((word *)(CFP_B*VRFNC + xr));				// point to function block
        //b ||bne|9,(xr)|22,=b_pfc|6,trc17|error if not program function|28549
        if ((*(xr_it.wp)-(word)(b_pfc)) != 0) C_GOTO(trc17);				// error if not program function
        //b ||beq|8,wa|18,=ch_lr|6,trc02|jump if r (return)|28550
        if ((wa-CH_LR) == 0) C_GOTO(trc02);				// jump if r (return)
        //b ||ejc|||||28551
        
//      trace (continued)
//      here for f,c to set/reset call trace
        //b ||mov|13,pfctr(xr)|7,xl||set/reset call trace|28557
        *((word *)(CFP_B*PFCTR + xr))= xl;				// set/reset call trace
        //b ||beq|8,wa|18,=ch_lc|6,exnul|exit with null if c (call)|28558
        if ((wa-CH_LC) == 0) C_GOTO(exnul);				// exit with null if c (call)
//      here for f,r to set/reset return trace
// trc02:
        //b |trc02|mov|13,pfrtr(xr)|7,xl||set/reset return trace|28562
        C_GOTO(trc02);
        } /* trc01 */
        

        void trc02() {
        *((word *)(CFP_B*PFRTR + xr))= xl;				// set/reset return trace
        //b ||exi||||return|28563
        C_NEXIT(P_PRC_TRACE,0);				// return
//      here for l to set/reset label trace
// trc03:
        //b |trc03|jsr|6,gtnvr|||point to vrblk|28567
        } /* trc02 */
        

        void trc03() {
        //b ||ppm|6,trc16|||jump if bad name|28568
        C_JSR_1(gtnvr,C_GOTO(trc16));				// jump if bad name
        //b ||mov|7,xl|13,vrlbl(xr)||load label pointer|28569
        xl= *((word *)(CFP_B*VRLBL + xr));				// load label pointer
        //b ||bne|9,(xl)|22,=b_trt|6,trc04|jump if no old trace|28570
        if ((*(xl_it.wp)-(word)(b_trt)) != 0) C_GOTO(trc04);				// jump if no old trace
        //b ||mov|7,xl|13,trlbl(xl)||else delete old trace association|28571
        xl= *((word *)(CFP_B*TRLBL + xl));				// else delete old trace association
//      here with old label trace association deleted
// trc04:
        //b |trc04|beq|7,xl|21,=stndl|6,trc16|error if undefined label|28575
        C_GOTO(trc04);
        } /* trc03 */
        

        void trc04() {
        if ((xl-(word)(&c.stndl)) == 0) C_GOTO(trc16);				// error if undefined label
        //b ||mov|8,wb|10,(xs)+||get trblk ptr again|28576
        wb= C_POP();				// get trblk ptr again
        //b ||bze|8,wb|6,trc05||jump if stoptr case|28577
        if ( !( wb) ) C_GOTO(trc05);				// jump if stoptr case
        //b ||mov|13,vrlbl(xr)|8,wb||else set new trblk pointer|28578
        *((word *)(CFP_B*VRLBL + xr))= wb;				// else set new trblk pointer
        //b ||mov|13,vrtra(xr)|22,=b_vrt||set label trace routine address|28579
        *((word *)(CFP_B*VRTRA + xr))= (word)(b_vrt);				// set label trace routine address
        //b ||mov|7,xr|8,wb||copy trblk pointer|28580
        xr= wb;				// copy trblk pointer
        //b ||mov|13,trlbl(xr)|7,xl||store real label in trblk|28581
        *((word *)(CFP_B*TRLBL + xr))= xl;				// store real label in trblk
        //b ||exi||||return|28582
        C_NEXIT(P_PRC_TRACE,0);				// return
//      here for stoptr case for label
// trc05:
        //b |trc05|mov|13,vrlbl(xr)|7,xl||store label ptr back in vrblk|28586
        } /* trc04 */
        

        void trc05() {
        *((word *)(CFP_B*VRLBL + xr))= xl;				// store label ptr back in vrblk
        //b ||mov|13,vrtra(xr)|22,=b_vrg||store normal transfer address|28587
        *((word *)(CFP_B*VRTRA + xr))= (word)(b_vrg);				// store normal transfer address
        //b ||exi||||return|28588
        C_NEXIT(P_PRC_TRACE,0);				// return
        //b ||ejc|||||28589
        
//      trace (continued)
//      here for k (keyword)
// trc06:
        //b |trc06|jsr|6,gtnvr|||point to vrblk|28595
        } /* trc05 */
        

        void trc06() {
        //b ||ppm|6,trc16|||error if not natural var|28596
        C_JSR_1(gtnvr,C_GOTO(trc16));				// error if not natural var
        //b ||bnz|13,vrlen(xr)|6,trc16||error if not system var|28597
        if (*((word *)(CFP_B*VRLEN + xr))) C_GOTO(trc16);				// error if not system var
        //b ||ica|7,xs|||pop stack|28598
        xs += CFP_B;				// pop stack
        //b ||bze|7,xl|6,trc07||jump if stoptr case|28599
        if ( !( xl) ) C_GOTO(trc07);				// jump if stoptr case
        //b ||mov|13,trkvr(xl)|7,xr||store vrblk ptr in trblk for ktrex|28600
        *((word *)(CFP_B*TRKVR + xl))= xr;				// store vrblk ptr in trblk for ktrex
//      merge here with trblk set up in wb (or zero)
// trc07:
        //b |trc07|mov|7,xr|13,vrsvp(xr)||point to svblk|28604
        C_GOTO(trc07);
        } /* trc06 */
        

        void trc07() {
        xr= *((word *)(CFP_B*VRSVP + xr));				// point to svblk
        //b ||beq|7,xr|21,=v_ert|6,trc08|jump if errtype|28605
        if ((xr-(word)(&c.v_ert)) == 0) C_GOTO(trc08);				// jump if errtype
        //b ||beq|7,xr|21,=v_stc|6,trc09|jump if stcount|28606
        if ((xr-(word)(&c.v_stc)) == 0) C_GOTO(trc09);				// jump if stcount
        //b ||bne|7,xr|21,=v_fnc|6,trc17|else error if not fnclevel|28607
        if ((xr-(word)(&c.v_fnc)) != 0) C_GOTO(trc17);				// else error if not fnclevel
//      fnclevel
        //b ||mov|3,r_fnc|7,xl||set/reset fnclevel trace|28611
        v.r_fnc= xl;				// set/reset fnclevel trace
        //b ||exi||||return|28612
        C_NEXIT(P_PRC_TRACE,0);				// return
//      errtype
// trc08:
        //b |trc08|mov|3,r_ert|7,xl||set/reset errtype trace|28616
        } /* trc07 */
        

        void trc08() {
        v.r_ert= xl;				// set/reset errtype trace
        //b ||exi||||return|28617
        C_NEXIT(P_PRC_TRACE,0);				// return
//      stcount
// trc09:
        //b |trc09|mov|3,r_stc|7,xl||set/reset stcount trace|28621
        } /* trc08 */
        

        void trc09() {
        v.r_stc= xl;				// set/reset stcount trace
        //b ||jsr|6,stgcc|||update countdown counters|28622
        C_JSR(stgcc);				// update countdown counters
        //b ||exi||||return|28623
        C_NEXIT(P_PRC_TRACE,0);				// return
        //b ||ejc|||||28624
        
//      trace (continued)
//      a,v merge here with trtyp value in wc
// trc10:
        //b |trc10|jsr|6,gtvar|||locate variable|28630
        } /* trc09 */
        

        void trc10() {
        //b ||ppm|6,trc16|||error if not appropriate name|28631
        C_JSR_1(gtvar,C_GOTO(trc16));				// error if not appropriate name
        //b ||mov|8,wb|10,(xs)+||get new trblk ptr again|28632
        wb= C_POP();				// get new trblk ptr again
        //b ||add|8,wa|7,xl||point to variable location|28633
        wa += xl;				// point to variable location
        //b ||mov|7,xr|8,wa||copy variable pointer|28634
        xr= wa;				// copy variable pointer
//      loop to search trblk chain
// trc11:
        //b |trc11|mov|7,xl|9,(xr)||point to next entry|28638
        C_GOTO(trc11);
        } /* trc10 */
        

        void trc11() {
        xl= *(xr_it.wp);				// point to next entry
        //b ||bne|9,(xl)|22,=b_trt|6,trc13|jump if not trblk|28639
        if ((*(xl_it.wp)-(word)(b_trt)) != 0) C_GOTO(trc13);				// jump if not trblk
        //b ||blt|8,wc|13,trtyp(xl)|6,trc13|jump if too far out on chain|28640
        if ((wc-*((word *)(CFP_B*TRTYP + xl))) < 0) C_GOTO(trc13);				// jump if too far out on chain
        //b ||beq|8,wc|13,trtyp(xl)|6,trc12|jump if this matches our type|28641
        if ((wc-*((word *)(CFP_B*TRTYP + xl))) == 0) C_GOTO(trc12);				// jump if this matches our type
        //b ||add|7,xl|19,*trnxt||else point to link field|28642
        xl += CFP_B*TRNXT;				// else point to link field
        //b ||mov|7,xr|7,xl||copy pointer|28643
        xr= xl;				// copy pointer
        //b ||brn|6,trc11|||and loop back|28644
         C_GOTO(trc11);				// and loop back
//      here to delete an old trblk of the type we were given
// trc12:
        //b |trc12|mov|7,xl|13,trnxt(xl)||get ptr to next block or value|28648
        } /* trc11 */
        

        void trc12() {
        xl= *((word *)(CFP_B*TRNXT + xl));				// get ptr to next block or value
        //b ||mov|9,(xr)|7,xl||store to delete this trblk|28649
        *(xr_it.wp)= xl;				// store to delete this trblk
//      here after deleting any old association of this type
// trc13:
        //b |trc13|bze|8,wb|6,trc14||jump if stoptr case|28653
        C_GOTO(trc13);
        } /* trc12 */
        

        void trc13() {
        if ( !( wb) ) C_GOTO(trc14);				// jump if stoptr case
        //b ||mov|9,(xr)|8,wb||else link new trblk in|28654
        *(xr_it.wp)= wb;				// else link new trblk in
        //b ||mov|7,xr|8,wb||copy trblk pointer|28655
        xr= wb;				// copy trblk pointer
        //b ||mov|13,trnxt(xr)|7,xl||store forward pointer|28656
        *((word *)(CFP_B*TRNXT + xr))= xl;				// store forward pointer
        //b ||mov|13,trtyp(xr)|8,wc||store appropriate trap type code|28657
        *((word *)(CFP_B*TRTYP + xr))= wc;				// store appropriate trap type code
//      here to make sure vrget,vrsto are set properly
// trc14:
        //b |trc14|mov|7,xr|8,wa||recall possible vrblk pointer|28661
        C_GOTO(trc14);
        } /* trc13 */
        

        void trc14() {
        xr= wa;				// recall possible vrblk pointer
        //b ||sub|7,xr|19,*vrval||point back to vrblk|28662
        xr -= CFP_B*VRVAL;				// point back to vrblk
        //b ||jsr|6,setvr|||set fields if vrblk|28663
        C_JSR(setvr);				// set fields if vrblk
        //b ||exi||||return|28664
        C_NEXIT(P_PRC_TRACE,0);				// return
//      here for bad trace type
// trc15:
        //b |trc15|exi|1,2|||take bad trace type error exit|28668
        } /* trc14 */
        

        void trc15() {
        C_NEXIT(P_PRC_TRACE,2);				// take bad trace type error exit
//      pop stack before failing
// trc16:
        //b |trc16|ica|7,xs|||pop stack|28672
        } /* trc15 */
        

        void trc16() {
        xs += CFP_B;				// pop stack
//      here for bad name argument
// trc17:
        //b |trc17|exi|1,1|||take bad name error exit|28676
        C_GOTO(trc17);
        } /* trc16 */
        

        void trc17() {
        C_NEXIT(P_PRC_TRACE,1);				// take bad name error exit
        //b ||ejc|||||28678
        
//      trbld -- build trblk
//      trblk is used by the input, output and trace functions
//      to construct a trblk (trap block)
//      (xr)                  trtag or trter
//      (xl)                  trfnc or trfpt
//      (wb)                  trtyp
//      jsr  trbld            call to build trblk
//      (xr)                  pointer to trblk
//      (wa)                  destroyed
// trbld:
        //b |trbld|prc|25,e|1,0||entry point|28692
        } /* trc17 */
        

        void trbld() {
        //b ||mov|11,-(xs)|7,xr||stack trtag (or trfnm)|28693
        C_PUSH(xr);				// stack trtag (or trfnm)
        //b ||mov|8,wa|19,*trsi_||set size of trblk|28694
        wa= CFP_B*TRSI_;				// set size of trblk
        //b ||jsr|6,alloc|||allocate trblk|28695
        C_JSR(alloc);				// allocate trblk
        //b ||mov|9,(xr)|22,=b_trt||store first word|28696
        *(xr_it.wp)= (word)(b_trt);				// store first word
        //b ||mov|13,trfnc(xr)|7,xl||store trfnc (or trfpt)|28697
        *((word *)(CFP_B*TRFNC + xr))= xl;				// store trfnc (or trfpt)
        //b ||mov|13,trtag(xr)|10,(xs)+||store trtag (or trfnm)|28698
        *((word *)(CFP_B*TRTAG + xr))= C_POP();				// store trtag (or trfnm)
        //b ||mov|13,trtyp(xr)|8,wb||store type|28699
        *((word *)(CFP_B*TRTYP + xr))= wb;				// store type
        //b ||mov|13,trval(xr)|21,=nulls||for now, a null value|28700
        *((word *)(CFP_B*TRVAL + xr))= (word)(&c.nulls);				// for now, a null value
        //b ||exi||||return to caller|28701
        C_EXIT(0);				// return to caller
        //b ||ejc|||||28703
        
//      trimr -- trim trailing blanks
//      trimr is passed a pointer to an scblk which must be the
//      last block in dynamic storage. trailing blanks are
//      trimmed off and the dynamic storage pointer reset to
//      the end of the (possibly) shortened block.
//      (wb)                  non-zero to trim trailing blanks
//      (xr)                  pointer to string to trim
//      jsr  trimr            call to trim string
//      (xr)                  pointer to trimmed string
//      (xl,wa,wb,wc)         destroyed
//      the call with wb zero still performs the end zero pad
//      and dnamp readjustment. it is used from acess if kvtrm=0.
// trimr:
        //b |trimr|prc|25,e|1,0||entry point|28721
        } /* trbld */
        

        void trimr() {
        //b ||mov|7,xl|7,xr||copy string pointer|28722
        xl= xr;				// copy string pointer
        //b ||mov|8,wa|13,sclen(xr)||load string length|28723
        wa= *((word *)(CFP_B*SCLEN + xr));				// load string length
        //b ||bze|8,wa|6,trim2||jump if null input|28724
        if ( !( wa) ) C_GOTO(trim2);				// jump if null input
        //b ||plc|7,xl|8,wa||else point past last character|28725
        xl_it.chp += CFP_F + wa;				// else point past last character
        //b ||bze|8,wb|6,trim3||jump if no trim|28726
        if ( !( wb) ) C_GOTO(trim3);				// jump if no trim
        //b ||mov|8,wc|18,=ch_bl||load blank character|28727
        wc= CH_BL;				// load blank character
//      loop through characters from right to left
// trim0:
        //b |trim0|lch|8,wb|11,-(xl)||load next character|28731
        C_GOTO(trim0);
        } /* trimr */
        

        void trim0() {
        wb = *(--xl_it.chp);				// load next character
        //b ||beq|8,wb|18,=ch_ht|6,trim1|jump if horizontal tab|28733
        if ((wb-CH_HT) == 0) C_GOTO(trim1);				// jump if horizontal tab
        //b ||bne|8,wb|8,wc|6,trim3|jump if non-blank found|28735
        if ((wb-wc) != 0) C_GOTO(trim3);				// jump if non-blank found
// trim1:
        //b |trim1|dcv|8,wa|||else decrement character count|28736
        C_GOTO(trim1);
        } /* trim0 */
        

        void trim1() {
        (wa)--;				// else decrement character count
        //b ||bnz|8,wa|6,trim0||loop back if more to check|28737
        if (wa) C_GOTO(trim0);				// loop back if more to check
//      here if result is null (null or all-blank input)
// trim2:
        //b |trim2|mov|3,dnamp|7,xr||wipe out input string block|28741
        C_GOTO(trim2);
        } /* trim1 */
        

        void trim2() {
        v.dnamp= xr;				// wipe out input string block
        //b ||mov|7,xr|21,=nulls||load null result|28742
        xr= (word)(&c.nulls);				// load null result
        //b ||brn|6,trim5|||merge to exit|28743
         C_GOTO(trim5);				// merge to exit
        //b ||ejc|||||28744
        
//      trimr (continued)
//      here with non-blank found (merge for no trim)
// trim3:
        //b |trim3|mov|13,sclen(xr)|8,wa||set new length|28750
        } /* trim2 */
        

        void trim3() {
        *((word *)(CFP_B*SCLEN + xr))= wa;				// set new length
        //b ||mov|7,xl|7,xr||copy string pointer|28751
        xl= xr;				// copy string pointer
        //b ||psc|7,xl|8,wa||ready for storing blanks|28752
        xl_it.chp += CFP_F + wa;				// ready for storing blanks
        //b ||ctb|8,wa|2,schar||get length of block in bytes|28753
        wa += (CFP_B-1)+CFP_B*SCHAR;				// get length of block in bytes
        wa &= 0xfffffffffffffff8;
        //b ||add|8,wa|7,xr||point past new block|28754
        wa += xr;				// point past new block
        //b ||mov|3,dnamp|8,wa||set new top of storage pointer|28755
        v.dnamp= wa;				// set new top of storage pointer
        //b ||lct|8,wa|18,=cfp_c||get count of chars in word|28756
        wa= CFP_C;				// get count of chars in word
        //b ||zer|8,wc|||set zero char|28757
        wc=0;				// set zero char
//      loop to zero pad last word of characters
// trim4:
        //b |trim4|sch|8,wc|10,(xl)+||store zero character|28761
        C_GOTO(trim4);
        } /* trim3 */
        

        void trim4() {
        *(xl_it.chp++) = wc;				// store zero character
        //b ||bct|8,wa|6,trim4||loop back till all stored|28762
        if ((--wa))  C_GOTO(trim4);				// loop back till all stored
//      common exit point
// trim5:
        //b ||csc|7,xl|||complete store characters|28763
        //b |trim5|zer|7,xl|||clear garbage xl pointer|28767
        C_GOTO(trim5);
        } /* trim4 */
        

        void trim5() {
        xl=0;				// clear garbage xl pointer
        //b ||exi||||return to caller|28768
        C_EXIT(0);				// return to caller
        //b ||ejc|||||28770
        
//      trxeq -- execute function type trace
//      trxeq is used to execute a trace when a fourth argument
//      has been supplied. trace has already been decremented.
//      (xr)                  pointer to trblk
//      (xl,wa)               name base,offset for variable
//      jsr  trxeq            call to execute trace
//      (wb,wc,ra)            destroyed
//      the following stack entries are made before passing
//      control to the trace function using the cfunc routine.
//                            trxeq return point word(s)
//                            saved value of trace keyword
//                            trblk pointer
//                            name base
//                            name offset
//                            saved value of r_cod
//                            saved code ptr (-r_cod)
//                            saved value of flptr
//      flptr --------------- zero (dummy fail offset)
//                            nmblk for variable name
//      xs ------------------ trace tag
//      r_cod and the code ptr are set to dummy values which
//      cause control to return to the trxeq procedure on success
//      or failure (trxeq ignores a failure condition).
// trxeq:
        //b |trxeq|prc|25,r|1,0||entry point (recursive)|28801
        } /* trim5 */
        

        void trxeq() {
        //b ||mov|8,wc|3,r_cod||load code block pointer|28802
        wc= v.r_cod;				// load code block pointer
        //b ||scp|8,wb|||get current code pointer|28803
        wb= reg_cp;				// get current code pointer
        //b ||sub|8,wb|8,wc||make code pointer into offset|28804
        wb -= wc;				// make code pointer into offset
        //b ||mov|11,-(xs)|3,kvtra||stack trace keyword value|28805
        C_PUSH(v.kvtra);				// stack trace keyword value
        //b ||mov|11,-(xs)|7,xr||stack trblk pointer|28806
        C_PUSH(xr);				// stack trblk pointer
        //b ||mov|11,-(xs)|7,xl||stack name base|28807
        C_PUSH(xl);				// stack name base
        //b ||mov|11,-(xs)|8,wa||stack name offset|28808
        C_PUSH(wa);				// stack name offset
        //b ||mov|11,-(xs)|8,wc||stack code block pointer|28809
        C_PUSH(wc);				// stack code block pointer
        //b ||mov|11,-(xs)|8,wb||stack code pointer offset|28810
        C_PUSH(wb);				// stack code pointer offset
        //b ||mov|11,-(xs)|3,flptr||stack old failure pointer|28811
        C_PUSH(v.flptr);				// stack old failure pointer
        //b ||zer|11,-(xs)|||set dummy fail offset|28812
        *(--xs_it.wp)=0;				// set dummy fail offset
        //b ||mov|3,flptr|7,xs||set new failure pointer|28813
        v.flptr= xs;				// set new failure pointer
        //b ||zer|3,kvtra|||reset trace keyword to zero|28814
        v.kvtra=0;				// reset trace keyword to zero
        //b ||mov|8,wc|21,=trxdc||load new (dummy) code blk pointer|28815
        wc= (word)(&c.trxdc);				// load new (dummy) code blk pointer
        //b ||mov|3,r_cod|8,wc||set as code block pointer|28816
        v.r_cod= wc;				// set as code block pointer
        //b ||lcp|8,wc|||and new code pointer|28817
        reg_cp = wc;				// and new code pointer
        //b ||ejc|||||28818
        
//      trxeq (continued)
//      now prepare arguments for function
        //b ||mov|8,wb|8,wa||save name offset|28824
        wb= wa;				// save name offset
        //b ||mov|8,wa|19,*nmsi_||load nmblk size|28825
        wa= CFP_B*NMSI_;				// load nmblk size
        //b ||jsr|6,alloc|||allocate space for nmblk|28826
        C_JSR(alloc);				// allocate space for nmblk
        //b ||mov|9,(xr)|22,=b_nml||set type word|28827
        *(xr_it.wp)= (word)(b_nml);				// set type word
        //b ||mov|13,nmbas(xr)|7,xl||store name base|28828
        *((word *)(CFP_B*NMBAS + xr))= xl;				// store name base
        //b ||mov|13,nmofs(xr)|8,wb||store name offset|28829
        *((word *)(CFP_B*NMOFS + xr))= wb;				// store name offset
        //b ||mov|7,xl|12,6(xs)||reload pointer to trblk|28830
        xl= *((word *)(CFP_B*6 + xs));				// reload pointer to trblk
        //b ||mov|11,-(xs)|7,xr||stack nmblk pointer (1st argument)|28831
        C_PUSH(xr);				// stack nmblk pointer (1st argument)
        //b ||mov|11,-(xs)|13,trtag(xl)||stack trace tag (2nd argument)|28832
        C_PUSH(*((word *)(CFP_B*TRTAG + xl)));				// stack trace tag (2nd argument)
        //b ||mov|7,xl|13,trfnc(xl)||load trace vrblk pointer|28833
        xl= *((word *)(CFP_B*TRFNC + xl));				// load trace vrblk pointer
        //b ||mov|7,xl|13,vrfnc(xl)||load trace function pointer|28834
        xl= *((word *)(CFP_B*VRFNC + xl));				// load trace function pointer
        //b ||beq|7,xl|21,=stndf|6,trxq2|jump if not a defined function|28835
        if ((xl-(word)(&c.stndf)) == 0) C_GOTO(trxq2);				// jump if not a defined function
        //b ||mov|8,wa|18,=num02||set number of arguments to two|28836
        wa= NUM02;				// set number of arguments to two
        //b ||brn|6,cfunc|||jump to call function|28837
         C_GOTO(cfunc);				// jump to call function
//      see o_txr for details of return to this point
// trxq1:
        //b |trxq1|mov|7,xs|3,flptr||point back to our stack entries|28841
        } /* trxeq */
        

        void trxq1() {
        xs= v.flptr;				// point back to our stack entries
        //b ||ica|7,xs|||pop off garbage fail offset|28842
        xs += CFP_B;				// pop off garbage fail offset
        //b ||mov|3,flptr|10,(xs)+||restore old failure pointer|28843
        v.flptr= C_POP();				// restore old failure pointer
        //b ||mov|8,wb|10,(xs)+||reload code offset|28844
        wb= C_POP();				// reload code offset
        //b ||mov|8,wc|10,(xs)+||load old code base pointer|28845
        wc= C_POP();				// load old code base pointer
        //b ||mov|7,xr|8,wc||copy cdblk pointer|28846
        xr= wc;				// copy cdblk pointer
        //b ||mov|3,kvstn|13,cdstm(xr)||restore stmnt no|28847
        v.kvstn= *((word *)(CFP_B*CDSTM + xr));				// restore stmnt no
        //b ||mov|8,wa|10,(xs)+||reload name offset|28848
        wa= C_POP();				// reload name offset
        //b ||mov|7,xl|10,(xs)+||reload name base|28849
        xl= C_POP();				// reload name base
        //b ||mov|7,xr|10,(xs)+||reload trblk pointer|28850
        xr= C_POP();				// reload trblk pointer
        //b ||mov|3,kvtra|10,(xs)+||restore trace keyword value|28851
        v.kvtra= C_POP();				// restore trace keyword value
        //b ||add|8,wb|8,wc||recompute absolute code pointer|28852
        wb += wc;				// recompute absolute code pointer
        //b ||lcp|8,wb|||restore code pointer|28853
        reg_cp = wb;				// restore code pointer
        //b ||mov|3,r_cod|8,wc||and code block pointer|28854
        v.r_cod= wc;				// and code block pointer
        //b ||exi||||return to trxeq caller|28855
        C_EXIT(0);				// return to trxeq caller
//      here if the target function is not defined
// trxq2:
        //b |trxq2|erb|1,197|26,trace fourth arg is not function name or null|||28859
        } /* trxq1 */
        

        void trxq2() {
        C_ERB(197)
        //b ||ejc|||||28862
        
//      xscan -- execution function argument scan
//      xscan scans out one token in a prototype argument in
//      array,clear,data,define,load function calls. xscan
//      calls must be preceded by a call to the initialization
//      procedure xscni. the following variables are used.
//      r_xsc                 pointer to scblk for function arg
//      xsofs                 offset (num chars scanned so far)
//      (wa)                  non-zero to skip and trim blanks
//      (wc)                  delimiter one (ch_xx)
//      (xl)                  delimiter two (ch_xx)
//      jsr  xscan            call to scan next item
//      (xr)                  pointer to scblk for token scanned
//      (wa)                  completion code (see below)
//      (wc,xl)               destroyed
//      the scan starts from the current position and continues
//      until one of the following three conditions occurs.
//      1)   delimiter one is encountered  (wa set to 1)
//      2)   delimiter two encountered  (wa set to 2)
//      3)   end of string encountered  (wa set to 0)
//      the result is a string containing all characters scanned
//      up to but not including any delimiter character.
//      the pointer is left pointing past the delimiter.
//      if only one delimiter is to be detected, delimiter one
//      and delimiter two should be set to the same value.
//      in the case where the end of string is encountered, the
//      string includes all the characters to the end of the
//      string. no further calls can be made to xscan until
//      xscni is called to initialize a new argument scan
        //b ||ejc|||||28902
        
//      xscan (continued)
// xscan:
        //b |xscan|prc|25,e|1,0||entry point|28906
        } /* trxq2 */
        

        void xscan() {
        //b ||mov|3,xscwb|8,wb||preserve wb|28907
        v.xscwb= wb;				// preserve wb
        //b ||mov|11,-(xs)|8,wa||record blank skip flag|28908
        C_PUSH(wa);				// record blank skip flag
        //b ||mov|11,-(xs)|8,wa||and second copy|28909
        C_PUSH(wa);				// and second copy
        //b ||mov|7,xr|3,r_xsc||point to argument string|28910
        xr= v.r_xsc;				// point to argument string
        //b ||mov|8,wa|13,sclen(xr)||load string length|28911
        wa= *((word *)(CFP_B*SCLEN + xr));				// load string length
        //b ||mov|8,wb|3,xsofs||load current offset|28912
        wb= v.xsofs;				// load current offset
        //b ||sub|8,wa|8,wb||get number of remaining characters|28913
        wa -= wb;				// get number of remaining characters
        //b ||bze|8,wa|6,xscn3||jump if no characters left|28914
        if ( !( wa) ) C_GOTO(xscn3);				// jump if no characters left
        //b ||plc|7,xr|8,wb||point to current character|28915
        xr_it.chp += CFP_F + wb;				// point to current character
//      loop to search for delimiter
// xscn1:
        //b |xscn1|lch|8,wb|10,(xr)+||load next character|28919
        C_GOTO(xscn1);
        } /* xscan */
        

        void xscn1() {
        wb = *(xr_it.chp++);				// load next character
        //b ||beq|8,wb|8,wc|6,xscn4|jump if delimiter one found|28920
        if ((wb-wc) == 0) C_GOTO(xscn4);				// jump if delimiter one found
        //b ||beq|8,wb|7,xl|6,xscn5|jump if delimiter two found|28921
        if ((wb-xl) == 0) C_GOTO(xscn5);				// jump if delimiter two found
        //b ||bze|9,(xs)|6,xscn2||jump if not skipping blanks|28922
        if ( !( *(xs_it.wp)) ) C_GOTO(xscn2);				// jump if not skipping blanks
        //b ||icv|3,xsofs|||assume blank and delete it|28923
        (v.xsofs)++;				// assume blank and delete it
        //b ||beq|8,wb|18,=ch_ht|6,xscn2|jump if horizontal tab|28925
        if ((wb-CH_HT) == 0) C_GOTO(xscn2);				// jump if horizontal tab
        //b ||beq|8,wb|18,=ch_bl|6,xscn2|jump if blank|28930
        if ((wb-CH_BL) == 0) C_GOTO(xscn2);				// jump if blank
        //b ||dcv|3,xsofs|||undelete non-blank character|28931
        (v.xsofs)--;				// undelete non-blank character
        //b ||zer|9,(xs)|||and discontinue blank checking|28932
        *(xs_it.wp)=0;				// and discontinue blank checking
//      here after performing any leading blank trimming.
// xscn2:
        //b |xscn2|dcv|8,wa|||decrement count of chars left|28936
        C_GOTO(xscn2);
        } /* xscn1 */
        

        void xscn2() {
        (wa)--;				// decrement count of chars left
        //b ||bnz|8,wa|6,xscn1||loop back if more chars to go|28937
        if (wa) C_GOTO(xscn1);				// loop back if more chars to go
//      here for runout
// xscn3:
        //b |xscn3|mov|7,xl|3,r_xsc||point to string block|28941
        C_GOTO(xscn3);
        } /* xscn2 */
        

        void xscn3() {
        xl= v.r_xsc;				// point to string block
        //b ||mov|8,wa|13,sclen(xl)||get string length|28942
        wa= *((word *)(CFP_B*SCLEN + xl));				// get string length
        //b ||mov|8,wb|3,xsofs||load offset|28943
        wb= v.xsofs;				// load offset
        //b ||sub|8,wa|8,wb||get substring length|28944
        wa -= wb;				// get substring length
        //b ||zer|3,r_xsc|||clear string ptr for collector|28945
        v.r_xsc=0;				// clear string ptr for collector
        //b ||zer|3,xscrt|||set zero (runout) return code|28946
        v.xscrt=0;				// set zero (runout) return code
        //b ||brn|6,xscn7|||jump to exit|28947
         C_GOTO(xscn7);				// jump to exit
        //b ||ejc|||||28948
        
//      xscan (continued)
//      here if delimiter one found
// xscn4:
        //b |xscn4|mov|3,xscrt|18,=num01||set return code|28954
        } /* xscn3 */
        

        void xscn4() {
        v.xscrt= NUM01;				// set return code
        //b ||brn|6,xscn6|||jump to merge|28955
         C_GOTO(xscn6);				// jump to merge
//      here if delimiter two found
// xscn5:
        //b |xscn5|mov|3,xscrt|18,=num02||set return code|28959
        } /* xscn4 */
        

        void xscn5() {
        v.xscrt= NUM02;				// set return code
//      merge here after detecting a delimiter
// xscn6:
        //b |xscn6|mov|7,xl|3,r_xsc||reload pointer to string|28963
        C_GOTO(xscn6);
        } /* xscn5 */
        

        void xscn6() {
        xl= v.r_xsc;				// reload pointer to string
        //b ||mov|8,wc|13,sclen(xl)||get original length of string|28964
        wc= *((word *)(CFP_B*SCLEN + xl));				// get original length of string
        //b ||sub|8,wc|8,wa||minus chars left = chars scanned|28965
        wc -= wa;				// minus chars left = chars scanned
        //b ||mov|8,wa|8,wc||move to reg for sbstr|28966
        wa= wc;				// move to reg for sbstr
        //b ||mov|8,wb|3,xsofs||set offset|28967
        wb= v.xsofs;				// set offset
        //b ||sub|8,wa|8,wb||compute length for sbstr|28968
        wa -= wb;				// compute length for sbstr
        //b ||icv|8,wc|||adjust new cursor past delimiter|28969
        (wc)++;				// adjust new cursor past delimiter
        //b ||mov|3,xsofs|8,wc||store new offset|28970
        v.xsofs= wc;				// store new offset
//      common exit point
// xscn7:
        //b |xscn7|zer|7,xr|||clear garbage character ptr in xr|28974
        C_GOTO(xscn7);
        } /* xscn6 */
        

        void xscn7() {
        xr=0;				// clear garbage character ptr in xr
        //b ||jsr|6,sbstr|||build sub-string|28975
        C_JSR(sbstr);				// build sub-string
        //b ||ica|7,xs|||remove copy of blank flag|28976
        xs += CFP_B;				// remove copy of blank flag
        //b ||mov|8,wb|10,(xs)+||original blank skip/trim flag|28977
        wb= C_POP();				// original blank skip/trim flag
        //b ||bze|13,sclen(xr)|6,xscn8||cannot trim the null string|28978
        if ( !( *((word *)(CFP_B*SCLEN + xr))) ) C_GOTO(xscn8);				// cannot trim the null string
        //b ||jsr|6,trimr|||trim trailing blanks if requested|28979
        C_JSR(trimr);				// trim trailing blanks if requested
//      final exit point
// xscn8:
        //b |xscn8|mov|8,wa|3,xscrt||load return code|28983
        C_GOTO(xscn8);
        } /* xscn7 */
        

        void xscn8() {
        wa= v.xscrt;				// load return code
        //b ||mov|8,wb|3,xscwb||restore wb|28984
        wb= v.xscwb;				// restore wb
        //b ||exi||||return to xscan caller|28985
        C_EXIT(0);				// return to xscan caller
        //b ||ejc|||||28987
        
//      xscni -- execution function argument scan
//      xscni initializes the scan used for prototype arguments
//      in the clear, define, load, data, array functions. see
//      xscan for the procedure which is used after this call.
//      -(xs)                 argument to be scanned (on stack)
//      jsr  xscni            call to scan argument
//      ppm  loc              transfer loc if arg is not string
//      ppm  loc              transfer loc if argument is null
//      (xs)                  popped
//      (xr,r_xsc)            argument (scblk ptr)
//      (wa)                  argument length
//      (ia,ra)               destroyed
// xscni:
        //b |xscni|prc|25,n|1,2||entry point|29004
        } /* xscn8 */
        

        void xscni() {
        //b ||ppm|6,xsci1|||jump if not convertible|29006
        extern void _l0736();
        C_JMS(gtstg,P_PRC_GTSTG,_l0736);
        } /* xscni */
        

        void _l0736() {
        C_JMS_HANDLE_1(gtstg,C_GOTO(xsci1));				// jump if not convertible
        //b ||mov|3,r_xsc|7,xr||else store scblk ptr for xscan|29007
        v.r_xsc= xr;				// else store scblk ptr for xscan
        //b ||zer|3,xsofs|||set offset to zero|29008
        v.xsofs=0;				// set offset to zero
        //b ||bze|8,wa|6,xsci2||jump if null string|29009
        if ( !( wa) ) C_GOTO(xsci2);				// jump if null string
        //b ||exi||||return to xscni caller|29010
        C_NEXIT(P_PRC_XSCNI,0);				// return to xscni caller
//      here if argument is not a string
// xsci1:
        //b |xsci1|exi|1,1|||take not-string error exit|29014
        } /* _l0736 */
        

        void xsci1() {
        C_NEXIT(P_PRC_XSCNI,1);				// take not-string error exit
//      here for null string
// xsci2:
        //b |xsci2|exi|1,2|||take null-string error exit|29018
        } /* xsci1 */
        

        void xsci2() {
        C_NEXIT(P_PRC_XSCNI,2);				// take null-string error exit
        //b ||ttl|27,s p i t b o l -- stack overflow section||||29020
        /* s p i t b o l -- stack overflow section*/
//      control comes here if the main stack overflows
        //b ||sec||||start of stack overflow section|29024
        } /* xsci2 */
        

        /*-------------------------------------------------------------------- sec06 --------*/
        // stack overflow
        void sec06() {
        //b ||add|3,errft|18,=num04||force conclusive fatal error|29026
        v.errft += NUM04;				// force conclusive fatal error
        //b ||mov|7,xs|3,flptr||pop stack to avoid more fails|29027
        xs= v.flptr;				// pop stack to avoid more fails
        //b ||bnz|3,gbcfl|6,stak1||jump if garbage collecting|29028
        if (v.gbcfl) C_GOTO(stak1);				// jump if garbage collecting
        //b ||erb|1,246|26,stack overflow|||29029
        C_ERB(246)
//      no chance of recovery in mid garbage collection
// stak1:
        //b |stak1|mov|7,xr|21,=endso||point to message|29033
        } /* sec06 */
        

        void stak1() {
        xr= (word)(&c.endso);				// point to message
        //b ||zer|3,kvdmp|||memory is undumpable|29034
        v.kvdmp=0;				// memory is undumpable
        //b ||brn|6,stopr|||give up|29035
         C_GOTO(stopr);				// give up
        //b ||ttl|27,s p i t b o l -- error section||||29036
        /* s p i t b o l -- error section*/
//      this section of code is entered whenever a procedure
//      return via an err parameter or an erb opcode is obeyed.
//      (wa)                  is the error code
//      the global variable stage indicates the point at which
//      the error occured as follows.
//      stage=stgic           error during initial compile
//      stage=stgxc           error during compile at execute
//                            time (code, convert function calls)
//      stage=stgev           error during compilation of
//                            expression at execution time
//                            (eval, convert function call).
//      stage=stgxt           error at execute time. compiler
//                            not active.
//      stage=stgce           error during initial compile after
//                            scanning out the end line.
//      stage=stgxe           error during compile at execute
//                            time after scanning end line.
//      stage=stgee           error during expression evaluation
        //b ||sec||||start of error section|29066
        } /* stak1 */
        

        /*-------------------------------------------------------------------- sec07 --------*/
        // errors
        void sec07() {
// error:
        //b |error|beq|3,r_cim|20,=cmlab|6,cmple|jump if error in scanning label|29068
        C_GOTO(ezzor);
        } /* sec07 */
        

        void ezzor() {
        if ((v.r_cim-(word)(&v.cmlab)) == 0) C_GOTO(cmple);				// jump if error in scanning label
        //b ||mov|3,kvert|8,wa||save error code|29069
        v.kvert= wa;				// save error code
        //b ||zer|3,scnrs|||reset rescan switch for scane|29070
        v.scnrs=0;				// reset rescan switch for scane
        //b ||zer|3,scngo|||reset goto switch for scane|29071
        v.scngo=0;				// reset goto switch for scane
        //b ||mov|3,polcs|18,=num01||reset poll count|29073
        v.polcs= NUM01;				// reset poll count
        //b ||mov|3,polct|18,=num01||reset poll count|29074
        v.polct= NUM01;				// reset poll count
        //b ||mov|7,xr|3,stage||load current stage|29076
        xr= v.stage;				// load current stage
        //b ||bsw|7,xr|2,stgno||jump to appropriate error circuit|29077
        extern word _l0737 [];				// jump to appropriate error circuit
        { w0 = ((word *)_l0737)[xr];  C_GOTO(w0_it.callp);}
        }  /* error */
        

        word  _l0737 [] = {
        //b ||iff|2,stgic|6,err01||initial compile|29085
        	(word)(err01),				// initial compile
        //b ||iff|2,stgxc|6,err04||execute time compile|29085
        	(word)(err04),				// execute time compile
        //b ||iff|2,stgev|6,err04||eval compiling expr.|29085
        	(word)(err04),				// eval compiling expr.
        //b ||iff|2,stgxt|6,err05||execute time|29085
        	(word)(err05),				// execute time
        //b ||iff|2,stgce|6,err01||compile - after end|29085
        	(word)(err01),				// compile - after end
        //b ||iff|2,stgxe|6,err04||xeq compile-past end|29085
        	(word)(err04),				// xeq compile-past end
        //b ||iff|2,stgee|6,err04||eval evaluating expr|29085
        	(word)(err04),				// eval evaluating expr
        //b ||esw||||end switch on error type|29085
             }; /* bsw list for _l0737 */				// end switch on error type
        //b ||ejc|||||29086
        
//      error during initial compile
//      the error message is printed as part of the compiler
//      output. this printout includes the offending line (if not
//      printed already) and an error flag under the appropriate
//      column as indicated by scnse unless scnse is set to zero.
//      after printing the message, the generated code is
//      modified to an error call and control is returned to
//      the cmpil procedure after resetting the stack pointer.
//      if the error occurs after the end line, control returns
//      in a slightly different manner to ensure proper cleanup.
// err01:
        //b |err01|mov|7,xs|3,cmpxs||reset stack pointer|29102
        void err01() {
        xs= v.cmpxs;				// reset stack pointer
        //b ||bnz|3,errsp|6,err03||jump if error suppress flag set|29104
        if (v.errsp) C_GOTO(err03);				// jump if error suppress flag set
        //b ||mov|8,wc|3,cmpsn||current statement|29107
        wc= v.cmpsn;				// current statement
        //b ||jsr|6,filnm|||obtain file name for this statement|29108
        C_JSR(filnm);				// obtain file name for this statement
        //b ||mov|8,wb|3,scnse||column number|29110
        wb= v.scnse;				// column number
        //b ||mov|8,wc|3,rdcln||line number|29111
        wc= v.rdcln;				// line number
        //b ||mov|7,xr|3,stage|||29112
        xr= v.stage;
        //b ||ppm|6,erra3|||if system does not want print|29114
        C_JSR_1(sysea,C_GOTO(erra3));				// if system does not want print
        //b ||mov|11,-(xs)|7,xr||save any provided print message|29115
        C_PUSH(xr);				// save any provided print message
        //b ||mov|3,erlst|3,erich||set flag for listr|29117
        v.erlst= v.erich;				// set flag for listr
        //b ||jsr|6,listr|||list line|29118
        C_JSR(listr);				// list line
        //b ||jsr|6,prtis|||terminate listing|29119
        C_JSR(prtis);				// terminate listing
        //b ||zer|3,erlst|||clear listr flag|29120
        v.erlst=0;				// clear listr flag
        //b ||mov|8,wa|3,scnse||load scan element offset|29121
        wa= v.scnse;				// load scan element offset
        //b ||bze|8,wa|6,err02||skip if not set|29122
        if ( !( wa) ) C_GOTO(err02);				// skip if not set
        //b ||lct|8,wb|8,wa||loop counter|29124
        wb= wa;				// loop counter
        //b ||icv|8,wa|||increase for ch_ex|29125
        (wa)++;				// increase for ch_ex
        //b ||mov|7,xl|3,r_cim||point to bad statement|29126
        xl= v.r_cim;				// point to bad statement
        //b ||jsr|6,alocs|||string block for error flag|29127
        C_JSR(alocs);				// string block for error flag
        //b ||mov|8,wa|7,xr||remember string ptr|29128
        wa= xr;				// remember string ptr
        //b ||psc|7,xr|||ready for character storing|29129
        xr += CFP_F;				// ready for character storing
        //b ||plc|7,xl|||ready to get chars|29130
        xl += CFP_F;				// ready to get chars
//      loop to replace all chars but tabs by blanks
// erra1:
        //b |erra1|lch|8,wc|10,(xl)+||get next char|29134
        C_GOTO(erra1);
        } /* err01 */
        

        void erra1() {
        wc = *(xl_it.chp++);				// get next char
        //b ||beq|8,wc|18,=ch_ht|6,erra2|skip if tab|29135
        if ((wc-CH_HT) == 0) C_GOTO(erra2);				// skip if tab
        //b ||mov|8,wc|18,=ch_bl||get a blank|29136
        wc= CH_BL;				// get a blank
        //b ||ejc|||||29137
        
//      merge to store blank or tab in error line
// erra2:
        //b |erra2|sch|8,wc|10,(xr)+||store char|29141
        C_GOTO(erra2);
        } /* erra1 */
        

        void erra2() {
        *(xr_it.chp++) = wc;				// store char
        //b ||bct|8,wb|6,erra1||loop|29142
        if ((--wb))  C_GOTO(erra1);				// loop
        //b ||mov|7,xl|18,=ch_ex||exclamation mark|29143
        xl= CH_EX;				// exclamation mark
        //b ||sch|7,xl|9,(xr)||store at end of error line|29144
        *(xr_it.chp) = xl;				// store at end of error line
        //b ||csc|7,xr|||end of sch loop|29145
        //b ||mov|3,profs|18,=stnpd||allow for statement number|29146
        v.profs= STNPD;				// allow for statement number
        //b ||mov|7,xr|8,wa||point to error line|29147
        xr= wa;				// point to error line
        //b ||jsr|6,prtst|||print error line|29148
        C_JSR(prtst);				// print error line
//      here after placing error flag as required
// err02:
        //b |err02|jsr|6,prtis|||print blank line|29162
        C_GOTO(err02);
        } /* erra2 */
        

        void err02() {
        C_JSR(prtis);				// print blank line
        //b ||mov|7,xr|10,(xs)+||restore any sysea message|29164
        xr= C_POP();				// restore any sysea message
        //b ||bze|7,xr|6,erra0||did sysea provide message to print|29165
        if ( !( xr) ) C_GOTO(erra0);				// did sysea provide message to print
        //b ||jsr|6,prtst|||print sysea message|29166
        C_JSR(prtst);				// print sysea message
// erra0:
        //b |erra0|jsr|6,ermsg|||generate flag and error message|29168
        C_GOTO(erra0);
        } /* err02 */
        

        void erra0() {
        C_JSR(ermsg);				// generate flag and error message
        //b ||add|3,lstlc|18,=num03||bump page ctr for blank, error, blk|29169
        v.lstlc += NUM03;				// bump page ctr for blank, error, blk
// erra3:
        //b |erra3|zer|7,xr|||in case of fatal error|29170
        C_GOTO(erra3);
        } /* erra0 */
        

        void erra3() {
        xr=0;				// in case of fatal error
        //b ||bhi|3,errft|18,=num03|6,stopr|pack up if several fatals|29171
        if ((v.errft-NUM03) > 0) C_GOTO(stopr);				// pack up if several fatals
//      count error, inhibit execution if required
        //b ||icv|3,cmerc|||bump error count|29175
        (v.cmerc)++;				// bump error count
        //b ||add|3,noxeq|3,cswer||inhibit xeq if -noerrors|29176
        v.noxeq += v.cswer;				// inhibit xeq if -noerrors
        //b ||bne|3,stage|18,=stgic|6,cmp10|special return if after end line|29177
        if ((v.stage-STGIC) != 0) C_GOTO(cmp10);				// special return if after end line
        //b ||ejc|||||29178
        
//      loop to scan to end of statement
// err03:
        //b |err03|mov|7,xr|3,r_cim||point to start of image|29182
        C_GOTO(err03);
        } /* erra3 */
        

        void err03() {
        xr= v.r_cim;				// point to start of image
        //b ||plc|7,xr|||point to first char|29183
        xr += CFP_F;				// point to first char
        //b ||lch|7,xr|9,(xr)||get first char|29184
        xr = *(xr_it.chp);				// get first char
        //b ||beq|7,xr|18,=ch_mn|6,cmpce|jump if error in control card|29185
        if ((xr-CH_MN) == 0) C_GOTO(cmpce);				// jump if error in control card
        //b ||zer|3,scnrs|||clear rescan flag|29186
        v.scnrs=0;				// clear rescan flag
        //b ||mnz|3,errsp|||set error suppress flag|29187
        v.errsp = 0xffffffffffffffff;				// set error suppress flag
        //b ||jsr|6,scane|||scan next element|29188
        C_JSR(scane);				// scan next element
        //b ||bne|7,xl|18,=t_smc|6,err03|loop back if not statement end|29189
        if ((xl-T_SMC) != 0) C_GOTO(err03);				// loop back if not statement end
        //b ||zer|3,errsp|||clear error suppress flag|29190
        v.errsp=0;				// clear error suppress flag
//      generate error call in code and return to cmpil
        //b ||mov|3,cwcof|19,*cdcod||reset offset in ccblk|29194
        v.cwcof= CFP_B*CDCOD;				// reset offset in ccblk
        //b ||mov|8,wa|21,=ocer_||load compile error call|29195
        wa= (word)(&c.ocer_);				// load compile error call
        //b ||jsr|6,cdwrd|||generate it|29196
        C_JSR(cdwrd);				// generate it
        //b ||mov|13,cmsoc(xs)|3,cwcof||set success fill in offset|29197
        *((word *)(CFP_B*CMSOC + xs))= v.cwcof;				// set success fill in offset
        //b ||mnz|13,cmffc(xs)|||set failure fill in flag|29198
        *((word *)(CFP_B*CMFFC + xs)) = 0xffffffffffffffff;				// set failure fill in flag
        //b ||jsr|6,cdwrd|||generate succ. fill in word|29199
        C_JSR(cdwrd);				// generate succ. fill in word
        //b ||brn|6,cmpse|||merge to generate error as cdfal|29200
         C_GOTO(cmpse);				// merge to generate error as cdfal
//      error during execute time compile or expression evaluatio
//      execute time compilation is initiated through gtcod or
//      gtexp which are called by compile, code or eval.
//      before causing statement failure through exfal it is
//      helpful to set keyword errtext and for generality
//      these errors may be handled by the setexit mechanism.
// err04:
        //b |err04|bge|3,errft|18,=num03|6,labo1|abort if too many fatal errors|29210
        } /* err03 */
        

        void err04() {
        if ((v.errft-NUM03) >= 0) C_GOTO(labo1);				// abort if too many fatal errors
        //b ||beq|3,kvert|18,=nm320|6,err06|treat user interrupt specially|29212
        if ((v.kvert-NM320) == 0) C_GOTO(err06);				// treat user interrupt specially
        //b ||zer|3,r_ccb|||forget garbage code block|29214
        v.r_ccb=0;				// forget garbage code block
        //b ||mov|3,cwcof|19,*cccod||set initial offset (mbe catspaw)|29215
        v.cwcof= CFP_B*CCCOD;				// set initial offset (mbe catspaw)
        //b ||jsr|6,ertex|||get fail message text|29217
        C_JSR(ertex);				// get fail message text
        //b ||dca|7,xs|||ensure stack ok on loop start|29218
        xs -= CFP_B;				// ensure stack ok on loop start
//      pop stack until find flptr for most deeply nested prog.
//      defined function call or call of eval / code.
// erra4:
        //b |erra4|ica|7,xs|||pop stack|29223
        C_GOTO(erra4);
        } /* err04 */
        

        void erra4() {
        xs += CFP_B;				// pop stack
        //b ||beq|7,xs|3,flprt|6,errc4|jump if prog defined fn call found|29224
        if ((xs-v.flprt) == 0) C_GOTO(errc4);				// jump if prog defined fn call found
        //b ||bne|7,xs|3,gtcef|6,erra4|loop if not eval or code call yet|29225
        if ((xs-v.gtcef) != 0) C_GOTO(erra4);				// loop if not eval or code call yet
        //b ||mov|3,stage|18,=stgxt||re-set stage for execute|29226
        v.stage= STGXT;				// re-set stage for execute
        //b ||mov|3,r_cod|3,r_gtc||recover code ptr|29227
        v.r_cod= v.r_gtc;				// recover code ptr
        //b ||mov|3,flptr|7,xs||restore fail pointer|29228
        v.flptr= xs;				// restore fail pointer
        //b ||zer|3,r_cim|||forget possible image|29229
        v.r_cim=0;				// forget possible image
        //b ||zer|3,cnind|||forget possible include|29231
        v.cnind=0;				// forget possible include
//      test errlimit
// errb4:
        //b |errb4|bnz|3,kverl|6,err07||jump if errlimit non-zero|29236
        C_GOTO(errb4);
        } /* erra4 */
        

        void errb4() {
        if (v.kverl) C_GOTO(err07);				// jump if errlimit non-zero
        //b ||brn|6,exfal|||fail|29237
         C_GOTO(exfal);				// fail
//      return from prog. defined function is outstanding
// errc4:
        //b |errc4|mov|7,xs|3,flptr||restore stack from flptr|29241
        } /* errb4 */
        

        void errc4() {
        xs= v.flptr;				// restore stack from flptr
        //b ||brn|6,errb4|||merge|29242
         C_GOTO(errb4);				// merge
        //b ||ejc|||||29243
        
//      error at execute time.
//      the action taken on an error is as follows.
//      if errlimit keyword is zero, an abort is signalled,
//      see coding for system label abort at l_abo.
//      otherwise, errlimit is decremented and an errtype trace
//      generated if required. control returns either via a jump
//      to continue (to take the failure exit) or a specified
//      setexit trap is executed and control passes to the trap.
//      if 3 or more fatal errors occur an abort is signalled
//      regardless of errlimit and setexit - looping is all too
//      probable otherwise. fatal errors include stack overflow
//      and exceeding stlimit.
// err05:
        //b |err05|ssl|3,iniss|||restore main prog s-r stack ptr|29261
        } /* errc4 */
        

        void err05() {
        //b ||bnz|3,dmvch|6,err08||jump if in mid-dump|29262
        if (v.dmvch) C_GOTO(err08);				// jump if in mid-dump
//      merge here from err08 and err04 (error 320)
// err06:
        //b |err06|bze|3,kverl|6,labo1||abort if errlimit is zero|29266
        C_GOTO(err06);
        } /* err05 */
        

        void err06() {
        if ( !( v.kverl) ) C_GOTO(labo1);				// abort if errlimit is zero
        //b ||jsr|6,ertex|||get fail message text|29267
        C_JSR(ertex);				// get fail message text
//      merge from err04
// err07:
        //b |err07|bge|3,errft|18,=num03|6,labo1|abort if too many fatal errors|29271
        C_GOTO(err07);
        } /* err06 */
        

        void err07() {
        if ((v.errft-NUM03) >= 0) C_GOTO(labo1);				// abort if too many fatal errors
        //b ||dcv|3,kverl|||decrement errlimit|29272
        (v.kverl)--;				// decrement errlimit
        //b ||mov|7,xl|3,r_ert||load errtype trace pointer|29273
        xl= v.r_ert;				// load errtype trace pointer
        //b ||jsr|6,ktrex|||generate errtype trace if required|29274
        C_JSR(ktrex);				// generate errtype trace if required
        //b ||mov|8,wa|3,r_cod||get current code block|29275
        wa= v.r_cod;				// get current code block
        //b ||mov|3,r_cnt|8,wa||set cdblk ptr for continuation|29276
        v.r_cnt= wa;				// set cdblk ptr for continuation
        //b ||scp|8,wb|||current code pointer|29277
        wb= reg_cp;				// current code pointer
        //b ||sub|8,wb|8,wa||offset within code block|29278
        wb -= wa;				// offset within code block
        //b ||mov|3,stxoc|8,wb||save code ptr offset for scontinue|29279
        v.stxoc= wb;				// save code ptr offset for scontinue
        //b ||mov|7,xr|3,flptr||set ptr to failure offset|29280
        xr= v.flptr;				// set ptr to failure offset
        //b ||mov|3,stxof|9,(xr)||save failure offset for continue|29281
        v.stxof= *(xr_it.wp);				// save failure offset for continue
        //b ||mov|7,xr|3,r_sxc||load setexit cdblk pointer|29282
        xr= v.r_sxc;				// load setexit cdblk pointer
        //b ||bze|7,xr|6,lcnt1||continue if no setexit trap|29283
        if ( !( xr) ) C_GOTO(lcnt1);				// continue if no setexit trap
        //b ||zer|3,r_sxc|||else reset trap|29284
        v.r_sxc=0;				// else reset trap
        //b ||mov|3,stxvr|21,=nulls||reset setexit arg to null|29285
        v.stxvr= (word)(&c.nulls);				// reset setexit arg to null
        //b ||mov|7,xl|9,(xr)||load ptr to code block routine|29286
        xl= *(xr_it.wp);				// load ptr to code block routine
        //b ||bri|7,xl|||execute first trap statement|29287
        C_GOTO(xl_it.callp);				// execute first trap statement
//      interrupted partly through a dump whilst store is in a
//      mess so do a tidy up operation. see dumpr for details.
// err08:
        //b |err08|mov|7,xr|3,dmvch||chain head for affected vrblks|29292
        } /* err07 */
        

        void err08() {
        xr= v.dmvch;				// chain head for affected vrblks
        //b ||bze|7,xr|6,err06||done if zero|29293
        if ( !( xr) ) C_GOTO(err06);				// done if zero
        //b ||mov|3,dmvch|9,(xr)||set next link as chain head|29294
        v.dmvch= *(xr_it.wp);				// set next link as chain head
        //b ||jsr|6,setvr|||restore vrget field|29295
        C_JSR(setvr);				// restore vrget field
//      label to mark end of code
// s_yyy:
        //b |s_yyy|brn|6,err08|||loop through chain|29299
        C_GOTO(s_yyy);
        } /* err08 */
        

        void s_yyy() {
         C_GOTO(err08);				// loop through chain
        //b ||ttl|27,s p i t b o l -- here endeth the code||||29300
        /* s p i t b o l -- here endeth the code*/
//      end of assembly
        //b ||end||||end macro-spitbol assembly|29304
        } /* s_yyy */
        

